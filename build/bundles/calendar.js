webpackJsonp([183],{

/***/ 123:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(181).then((function(require) {
	data = __webpack_require__(592);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 124:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(180).then((function(require) {
	data = __webpack_require__(593);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 125:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(179).then((function(require) {
	data = __webpack_require__(594);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 126:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(178).then((function(require) {
	data = __webpack_require__(595);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 127:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(177).then((function(require) {
	data = __webpack_require__(596);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 128:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(176).then((function(require) {
	data = __webpack_require__(597);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 129:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(175).then((function(require) {
	data = __webpack_require__(598);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 130:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(174).then((function(require) {
	data = __webpack_require__(599);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 131:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(173).then((function(require) {
	data = __webpack_require__(600);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 132:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(172).then((function(require) {
	data = __webpack_require__(601);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 133:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(171).then((function(require) {
	data = __webpack_require__(602);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 134:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(170).then((function(require) {
	data = __webpack_require__(603);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 135:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(169).then((function(require) {
	data = __webpack_require__(604);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 136:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(168).then((function(require) {
	data = __webpack_require__(605);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 137:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(167).then((function(require) {
	data = __webpack_require__(606);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 138:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(166).then((function(require) {
	data = __webpack_require__(607);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 139:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(165).then((function(require) {
	data = __webpack_require__(608);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 140:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(164).then((function(require) {
	data = __webpack_require__(609);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 141:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(163).then((function(require) {
	data = __webpack_require__(610);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 142:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(162).then((function(require) {
	data = __webpack_require__(611);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 143:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(161).then((function(require) {
	data = __webpack_require__(612);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 144:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(160).then((function(require) {
	data = __webpack_require__(613);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 145:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(159).then((function(require) {
	data = __webpack_require__(614);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 146:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(158).then((function(require) {
	data = __webpack_require__(615);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 147:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(2).then((function(require) {
	data = __webpack_require__(616);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 148:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(157).then((function(require) {
	data = __webpack_require__(617);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 149:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(156).then((function(require) {
	data = __webpack_require__(618);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 150:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(155).then((function(require) {
	data = __webpack_require__(619);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 151:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(154).then((function(require) {
	data = __webpack_require__(620);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 152:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(153).then((function(require) {
	data = __webpack_require__(621);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 153:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(152).then((function(require) {
	data = __webpack_require__(622);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 154:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(151).then((function(require) {
	data = __webpack_require__(623);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 155:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(150).then((function(require) {
	data = __webpack_require__(624);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 156:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(149).then((function(require) {
	data = __webpack_require__(625);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 157:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(148).then((function(require) {
	data = __webpack_require__(626);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 158:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(147).then((function(require) {
	data = __webpack_require__(627);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 159:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(146).then((function(require) {
	data = __webpack_require__(628);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 160:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(145).then((function(require) {
	data = __webpack_require__(629);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 161:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(144).then((function(require) {
	data = __webpack_require__(630);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 162:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(143).then((function(require) {
	data = __webpack_require__(631);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 163:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(142).then((function(require) {
	data = __webpack_require__(632);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 164:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(141).then((function(require) {
	data = __webpack_require__(633);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 165:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(140).then((function(require) {
	data = __webpack_require__(634);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 166:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(139).then((function(require) {
	data = __webpack_require__(635);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 167:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(138).then((function(require) {
	data = __webpack_require__(636);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 168:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(137).then((function(require) {
	data = __webpack_require__(637);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 169:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(136).then((function(require) {
	data = __webpack_require__(638);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 170:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(135).then((function(require) {
	data = __webpack_require__(639);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 171:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(134).then((function(require) {
	data = __webpack_require__(640);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 172:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(133).then((function(require) {
	data = __webpack_require__(641);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 173:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(132).then((function(require) {
	data = __webpack_require__(642);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 174:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(131).then((function(require) {
	data = __webpack_require__(643);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 175:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(130).then((function(require) {
	data = __webpack_require__(644);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 176:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(129).then((function(require) {
	data = __webpack_require__(645);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 177:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(128).then((function(require) {
	data = __webpack_require__(646);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 178:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(127).then((function(require) {
	data = __webpack_require__(647);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 179:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(126).then((function(require) {
	data = __webpack_require__(648);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 180:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(125).then((function(require) {
	data = __webpack_require__(649);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 181:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(124).then((function(require) {
	data = __webpack_require__(650);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 182:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(123).then((function(require) {
	data = __webpack_require__(651);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 183:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(122).then((function(require) {
	data = __webpack_require__(652);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 184:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(121).then((function(require) {
	data = __webpack_require__(653);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 185:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(1).then((function(require) {
	data = __webpack_require__(654);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 186:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(120).then((function(require) {
	data = __webpack_require__(655);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 187:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(0).then((function(require) {
	data = __webpack_require__(656);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 188:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(119).then((function(require) {
	data = __webpack_require__(657);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 189:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(118).then((function(require) {
	data = __webpack_require__(658);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 305:
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 123,
	"./af.js": 123,
	"./ar": 130,
	"./ar-dz": 124,
	"./ar-dz.js": 124,
	"./ar-kw": 125,
	"./ar-kw.js": 125,
	"./ar-ly": 126,
	"./ar-ly.js": 126,
	"./ar-ma": 127,
	"./ar-ma.js": 127,
	"./ar-sa": 128,
	"./ar-sa.js": 128,
	"./ar-tn": 129,
	"./ar-tn.js": 129,
	"./ar.js": 130,
	"./bg": 131,
	"./bg.js": 131,
	"./ca": 132,
	"./ca.js": 132,
	"./cs": 133,
	"./cs.js": 133,
	"./da": 134,
	"./da.js": 134,
	"./de": 137,
	"./de-at": 135,
	"./de-at.js": 135,
	"./de-ch": 136,
	"./de-ch.js": 136,
	"./de.js": 137,
	"./el": 138,
	"./el.js": 138,
	"./en-au": 139,
	"./en-au.js": 139,
	"./en-ca": 140,
	"./en-ca.js": 140,
	"./en-gb": 141,
	"./en-gb.js": 141,
	"./en-ie": 142,
	"./en-ie.js": 142,
	"./en-nz": 143,
	"./en-nz.js": 143,
	"./es": 145,
	"./es-do": 144,
	"./es-do.js": 144,
	"./es.js": 145,
	"./et": 146,
	"./et.js": 146,
	"./eu": 147,
	"./eu.js": 147,
	"./fa": 148,
	"./fa.js": 148,
	"./fi": 149,
	"./fi.js": 149,
	"./fr": 152,
	"./fr-ca": 150,
	"./fr-ca.js": 150,
	"./fr-ch": 151,
	"./fr-ch.js": 151,
	"./fr.js": 152,
	"./gl": 153,
	"./gl.js": 153,
	"./he": 154,
	"./he.js": 154,
	"./hi": 155,
	"./hi.js": 155,
	"./hr": 156,
	"./hr.js": 156,
	"./hu": 157,
	"./hu.js": 157,
	"./id": 158,
	"./id.js": 158,
	"./is": 159,
	"./is.js": 159,
	"./it": 160,
	"./it.js": 160,
	"./ja": 161,
	"./ja.js": 161,
	"./kk": 162,
	"./kk.js": 162,
	"./ko": 163,
	"./ko.js": 163,
	"./lb": 164,
	"./lb.js": 164,
	"./lt": 165,
	"./lt.js": 165,
	"./lv": 166,
	"./lv.js": 166,
	"./mk": 167,
	"./mk.js": 167,
	"./ms": 169,
	"./ms-my": 168,
	"./ms-my.js": 168,
	"./ms.js": 169,
	"./nb": 170,
	"./nb.js": 170,
	"./nl": 172,
	"./nl-be": 171,
	"./nl-be.js": 171,
	"./nl.js": 172,
	"./nn": 173,
	"./nn.js": 173,
	"./pl": 174,
	"./pl.js": 174,
	"./pt": 176,
	"./pt-br": 175,
	"./pt-br.js": 175,
	"./pt.js": 176,
	"./ro": 177,
	"./ro.js": 177,
	"./ru": 178,
	"./ru.js": 178,
	"./sk": 179,
	"./sk.js": 179,
	"./sl": 180,
	"./sl.js": 180,
	"./sr": 182,
	"./sr-cyrl": 181,
	"./sr-cyrl.js": 181,
	"./sr.js": 182,
	"./sv": 183,
	"./sv.js": 183,
	"./th": 184,
	"./th.js": 184,
	"./tr": 185,
	"./tr.js": 185,
	"./uk": 186,
	"./uk.js": 186,
	"./vi": 187,
	"./vi.js": 187,
	"./zh-cn": 188,
	"./zh-cn.js": 188,
	"./zh-tw": 189,
	"./zh-tw.js": 189
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 305;

/***/ }),

/***/ 351:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(588);

var _convertToFC = __webpack_require__(353);

var _convertToFC2 = _interopRequireDefault(_convertToFC);

var _displayEvent = __webpack_require__(354);

var _displayEvent2 = _interopRequireDefault(_displayEvent);

var _locationHistory = __webpack_require__(121);

var _locationHistory2 = _interopRequireDefault(_locationHistory);

var _responses = __webpack_require__(79);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var queryRegExp = /calendar\/?(?:\/*event\/+([0-9]+))?/;

var begin = function begin(momentLang) {
  var calendarOptions = {
    editable: false,
    header: {
      left: 'prev,next today',
      center: 'title',
      right: 'month,agendaWeek,agendaDay'
    },
    lang: momentLang,
    events: function events(start, end, timezone, callback) {
      socket.emit('plugins.calendar.getEventsByDate', {
        startDate: start.valueOf(),
        endDate: end.valueOf()
      }, function (err, events) {
        if (err) {
          if (err.message) {
            app.alertError(err);
          }
          throw err;
        }

        callback((0, _convertToFC2.default)(events));
      });
    },
    eventClick: function eventClick(_ref, e) {
      var original = _ref.original,
          pid = _ref.id;

      e.preventDefault();
      e.stopPropagation();
      (0, _displayEvent2.default)(original);
      if (original.external) {
        // TODO
      } else {
        if (original.repeats) {
          ajaxify.updateHistory('calendar/event/' + pid + '/' + original.day);
        } else {
          ajaxify.updateHistory('calendar/event/' + pid);
        }
      }
    },
    timezone: 'local'
  };

  var shouldHandle = false;

  _locationHistory2.default.listen(function (state, data) {
    if (state.prev.startsWith('calendar') && state.current.startsWith('calendar')) {
      data.url = null; // eslint-disable-line no-param-reassign
      shouldHandle = true;
    } else {
      shouldHandle = false;
    }
  });

  var init = function init() {
    var $calendar = $('#calendar');

    if ($calendar && !shouldHandle) {
      $calendar.fullCalendar(calendarOptions);
      var btn = $('#plugin-calendar-cal-only-yes');
      btn.on('click', function (e) {
        e.preventDefault();
        $calendar.toggleClass('plugin-calendar-cal-only-yes');
        btn.toggleClass('active');
      }).detach().appendTo($calendar.find('.fc-toolbar .fc-right'));
    }

    var $display = $('#plugin-calendar-cal-event-display');
    if ($display) {
      $display.on('click', '.dismiss', function () {
        $display.modal('hide');
        ajaxify.updateHistory('calendar');
      });
    }

    var matches = location.pathname.match(queryRegExp);
    var pid = matches && parseInt(matches[1], 10);
    if (pid) {
      var el = $calendar.data('fullCalendar').getEventCache().find(function (x) {
        return x.id === pid;
      });

      if (shouldHandle) {
        var event = el && el.original;
        if (event) {
          (0, _displayEvent2.default)(event);
        } else {
          history.replaceState({}, '', RELATIVE_PATH + '/calendar');
        }
      } else {
        (0, _responses.setupDTP)($display.find('[data-day]'), window.calendarEventData.day);
      }
      $calendar.fullCalendar('gotoDate', el ? el.start : window.calendarEventData.day || window.calendarEventData.startDate);
    } else if (shouldHandle) {
      $display.modal('hide');
    }
  };

  $(document).ready(init);
  $(window).on('action:ajaxify.end', init);
};

__webpack_require__.p = RELATIVE_PATH + '/plugins/nodebb-plugin-calendar/bundles/'; // eslint-disable-line

var lang = config.userLang || config.defaultLang;
var momentLang = lang.toLowerCase().replace(/_/g, '-');

try {
  if (momentLang === 'en-us') {
    begin('en-us');
  } else {
    __webpack_require__(305)("./" + momentLang)(function () {
      // eslint-disable-line
      begin(momentLang);
    });
  }
} catch (e) {
  try {
    __webpack_require__(305)("./" + momentLang.split('-')[0])(function () {
      // eslint-disable-line
      begin(momentLang);
    });
  } catch (er) {
    begin('en-us');
    throw Error('Could not load locale data (' + momentLang + ') for fullcalendar');
  }
}

/***/ }),

/***/ 353:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var mapper = function mapper(event) {
  var newEvent = {
    id: event.pid,
    title: event.name,
    allDay: event.allday,
    start: event.startDate,
    end: event.endDate + 1,
    className: [],
    original: event
  };

  if (event.external) {
    newEvent.className = ['plugin-calendar-cal-event-external'];
  } else {
    newEvent.className = ['plugin-calendar-cal-event-category-' + event.cid, 'plugin-calendar-cal-event-response-' + (event.responses[app.user.uid] || 'no'), event.topicDeleted ? 'plugin-calendar-cal-event-topic-deleted' : ''];
  }

  return newEvent;
};

var convertToFC = function convertToFC(events) {
  return events.map(mapper);
};

exports.default = convertToFC;

/***/ }),

/***/ 354:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _templates = __webpack_require__(361);

var _responses = __webpack_require__(79);

var displayEvent = function displayEvent(event, cb) {
  var content = (0, _templates.eventTemplate)({ event: event, uid: app.user.uid });
  var pid = event.pid;

  var div = $(content);
  var $display = $('#plugin-calendar-cal-event-display');
  var $goToPost = $display.find('.modal-footer a.btn-primary.gotopost');
  var $goToUrl = $display.find('.modal-footer a.btn-primary.gotourl');
  $display.modal('hide').find('.modal-body .posts').empty().append(div);
  if (event.external) {
    $goToPost.hide();

    if (event.url) {
      $goToUrl.show().attr('href', event.url);
    } else {
      $goToUrl.hide();
    }
  } else {
    $goToUrl.hide();
    $goToPost.show().attr('href', RELATIVE_PATH + '/post/' + pid);
  }
  $display.find('.modal-body').attr('data-pid', pid);
  if (!event.external && event.repeats) {
    $display.find('[data-day]').attr('data-day', event.day);
  }
  $display.modal('show');

  (0, _responses.setupPost)({ pid: pid }, function () {
    $(window).trigger('action:calendar.event.display', { pid: pid, day: event.day, modal: $display });

    if (typeof cb === 'function') {
      cb({ content: content, parsed: event });
    }
  });
};

exports.default = displayEvent;

/***/ }),

/***/ 361:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.eventTemplate = undefined;

var _defineProperty2 = __webpack_require__(308);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var makeListElement = function makeListElement(n) {
  var li = '<li data-value="' + n + '">[[moment:time-duration, ' + n + ']]</li>';
  return li;
};

var eventTemplate = function eventTemplate(_ref) {
  var event = _ref.event,
      isEmail = _ref.isEmail,
      uid = _ref.uid;
  var startDate = event.startDate,
      endDate = event.endDate,
      allday = event.allday;


  var response = 'no';
  if (uid && event.responses && event.responses[uid]) {
    response = event.responses[uid];
  }
  var responsesTemplate = function responsesTemplate() {
    return '\n<div class="plugin-calendar-event-responses" data-day="' + (event.day || '') + '">\n  <i class="fa fa-reply" aria-hidden="true"></i>\n  <div class="col-xs-12 col-sm-6">\n    ' + (event.repeats ? '\n    <div class="input-group plugin-calendar-event-responses-day">\n      <input class="form-control" title="[[calendar:select_day]]" type="text">\n      <span class="input-group-addon">\n        <i class="fa fa-calendar-check-o"></i>\n      </span>\n    </div>\n    ' : '') + '\n    ' + (uid === 0 ? '' : '\n    <div class="plugin-calendar-event-responses-user btn-group">\n      ' + function () {
      var active = (0, _defineProperty3.default)({
        no: '',
        maybe: '',
        yes: ''
      }, response, 'active');

      return '\n      <button data-value="no" type="button" class="btn btn-sm btn-danger ' + active.no + '">\n        [[calendar:response_no]]\n      </button>\n      <button data-value="maybe" type="button" class="btn btn-sm btn-default ' + active.maybe + '">\n        [[calendar:response_maybe]]\n      </button>\n      <button data-value="yes" type="button" class="btn btn-sm btn-success ' + active.yes + '">\n        [[calendar:response_yes]]\n      </button>\n        ';
    }() + '\n    </div>\n    ') + '\n    <div class="panel-group plugin-calendar-event-responses-lists" data-loaded="false">\n      <div class="panel panel-default closed">\n        <div class="panel-heading">\n          <a role="button" data-toggle="collapse" href="#"\n          class="btn btn-sm btn-info" aria-expanded="true">\n            <i class="fa fa-chevron-down pull-right"></i>\n            [[calendar:response_yes]]\n          </a>\n        </div>\n        <div class="panel-collapse">\n          <div class="panel-body">\n            <ul class="plugin-calendar-event-responses-list-yes">\n              <!-- yes responses go here -->\n            </ul>\n          </div>\n        </div>\n      </div>\n      <div class="panel panel-default closed">\n        <div class="panel-heading">\n          <a role="button" data-toggle="collapse" href="#"\n          class="btn btn-sm btn-link" aria-expanded="true">\n            <i class="fa fa-chevron-down pull-right"></i>\n            [[calendar:response_maybe]]\n          </a>\n        </div>\n        <div class="panel-collapse">\n          <div class="panel-body">\n            <ul class="plugin-calendar-event-responses-list-maybe">\n              <!-- maybe responses go here -->\n            </ul>\n          </div>\n        </div>\n      </div>\n      <div class="panel panel-default closed">\n        <div class="panel-heading">\n          <a role="button" data-toggle="collapse" href="#"\n          class="btn btn-sm btn-warning" aria-expanded="true">\n            <i class="fa fa-chevron-down pull-right"></i>\n            [[calendar:response_no]]\n          </a>\n        </div>\n        <div class="panel-collapse">\n          <div class="panel-body">\n            <ul class="plugin-calendar-event-responses-list-no">\n              <!-- no responses go here -->\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>';
  };
  var responses = isEmail ? '\n  <div class="plugin-calendar-event-responses">\n    <i class="fa fa-reply" aria-hidden="true"></i>\n    [[calendar:you_responded, [[calendar:response_' + response + ']]]]\n  </div>\n  ' : responsesTemplate();

  if (event.external) {
    responses = '';
  }

  var html = '\n<div class="plugin-calendar-event panel panel-success" data-translated="false">\n  <div class="plugin-calendar-event-name panel-heading">\n    ' + event.name + '\n  </div>\n  <div class="panel-body">\n    <div class="plugin-calendar-event-date">\n      <i class="fa fa-clock-o" aria-hidden="true"></i>\n      <a\n        title="[[moment:time-date-view, utc, ' + startDate + ', ' + endDate + ', ' + allday + ']] UTC"\n        class="plugin-calendar-time-date-view"\n      >[[moment:time-date-view, local, ' + startDate + ', ' + endDate + ', ' + allday + ']]</a>\n    </div>\n    ' + (event.external ? '\n    <div class="plugin-calendar-event-location">\n      <i class="fa fa-location-arrow" aria-hidden="true"></i>\n      <span>External: ' + event.source + '<span>\n    </div>\n    ' : '') + '\n    ' + (event.location ? '\n    <div class="plugin-calendar-event-location">\n      <i class="fa fa-location-arrow" aria-hidden="true"></i>\n      <span>' + event.location + '<span>\n    </div>\n    ' : '') + '\n    ' + (event.description ? '\n    <div class="plugin-calendar-event-description">\n      <i class="fa fa-info-circle" aria-hidden="true"></i>\n      <div>' + event.description + '</div>\n    </div>\n    ' : '') + '\n    ' + (!event.external && event.reminders ? '\n    <div class="plugin-calendar-event-reminders">\n      <i class="fa fa-bell" aria-hidden="true"></i>\n      <ul>\n        ' + event.reminders.sort(function (a, b) {
    return a - b;
  }).map(makeListElement).join('\n') + '\n      </ul>\n    </div>\n    ' : '') + '\n    ' + function () {
    if (event.repeats) {
      var key = ['day', 'week', 'month', 'year'].find(function (x) {
        return event.repeats.every[x];
      });
      if (key) {
        return '<div class="plugin-calendar-event-repeats">\n            <i class="fa fa-repeat" aria-hidden="true"></i>\n            <span>[[calendar:every_' + key + ']]</span>\n          </div>';
      }
      if (event.repeats.every.daysOfWeek) {
        var days = event.repeats.every.daysOfWeek.map(function (day) {
          return '[[moment:locale-data, _weekdaysShort, ' + day + ']]';
        }).join(', ');
        var endDateText = '[[moment:time-date-view, utc, ' + event.repeats.endDate + ', ' + (event.repeats.endDate + ', true]]');
        return '<div class="plugin-calendar-event-repeats">\n            <i class="fa fa-repeat" aria-hidden="true"></i>\n            <span>\n              ' + (Number.isFinite(event.repeats.endDate) ? '\n              [[calendar:repeats_weekly_on_until, ' + endDateText + ']] ' + days + '\n              ' : '\n              [[calendar:repeats_weekly_on_forever]] ' + days + '\n              ') + '\n            </span>\n          </div>';
      }
    }
    return '';
  }() + '\n    ' + (event.mandatory ? '\n    <div class="plugin-calendar-event-mandatory">\n      <i class="fa fa-exclamation-circle" aria-hidden="true"></i>\n      <span>[[calendar:mandatory]]</span>\n    </div>\n    ' : responses) + '\n  </div>\n</div>';

  return html;
};

exports.eventTemplate = eventTemplate;

/***/ }),

/***/ 588:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_moment__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_moment__);
/*!
 * FullCalendar v3.4.0
 * Docs & License: https://fullcalendar.io/
 * (c) 2017 Adam Shaw
 */


(function(factory) {
  factory(jQuery, __WEBPACK_IMPORTED_MODULE_0_moment___default.a);
})(function($, moment) {

;;

var FC = $.fullCalendar = {
	version: "3.4.0",
	// When introducing internal API incompatibilities (where fullcalendar plugins would break),
	// the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)
	// and the below integer should be incremented.
	internalApiVersion: 9
};
var fcViews = FC.views = {};


$.fn.fullCalendar = function(options) {
	var args = Array.prototype.slice.call(arguments, 1); // for a possible method call
	var res = this; // what this function will return (this jQuery object by default)

	this.each(function(i, _element) { // loop each DOM element involved
		var element = $(_element);
		var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)
		var singleRes; // the returned value of this single method call

		// a method call
		if (typeof options === 'string') {
			if (calendar && $.isFunction(calendar[options])) {
				singleRes = calendar[options].apply(calendar, args);
				if (!i) {
					res = singleRes; // record the first method call result
				}
				if (options === 'destroy') { // for the destroy method, must remove Calendar object data
					element.removeData('fullCalendar');
				}
			}
		}
		// a new calendar initialization
		else if (!calendar) { // don't initialize twice
			calendar = new Calendar(element, options);
			element.data('fullCalendar', calendar);
			calendar.render();
		}
	});

	return res;
};


var complexOptions = [ // names of options that are objects whose properties should be combined
	'header',
	'footer',
	'buttonText',
	'buttonIcons',
	'themeButtonIcons'
];


// Merges an array of option objects into a single object
function mergeOptions(optionObjs) {
	return mergeProps(optionObjs, complexOptions);
}

;;

// exports
FC.intersectRanges = intersectRanges;
FC.applyAll = applyAll;
FC.debounce = debounce;
FC.isInt = isInt;
FC.htmlEscape = htmlEscape;
FC.cssToStr = cssToStr;
FC.proxy = proxy;
FC.capitaliseFirstLetter = capitaliseFirstLetter;


/* FullCalendar-specific DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/


// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
function compensateScroll(rowEls, scrollbarWidths) {
	if (scrollbarWidths.left) {
		rowEls.css({
			'border-left-width': 1,
			'margin-left': scrollbarWidths.left - 1
		});
	}
	if (scrollbarWidths.right) {
		rowEls.css({
			'border-right-width': 1,
			'margin-right': scrollbarWidths.right - 1
		});
	}
}


// Undoes compensateScroll and restores all borders/margins
function uncompensateScroll(rowEls) {
	rowEls.css({
		'margin-left': '',
		'margin-right': '',
		'border-left-width': '',
		'border-right-width': ''
	});
}


// Make the mouse cursor express that an event is not allowed in the current area
function disableCursor() {
	$('body').addClass('fc-not-allowed');
}


// Returns the mouse cursor to its original look
function enableCursor() {
	$('body').removeClass('fc-not-allowed');
}


// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and 
// reduces the available height.
function distributeHeight(els, availableHeight, shouldRedistribute) {

	// *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
	// and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.

	var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
	var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
	var flexEls = []; // elements that are allowed to expand. array of DOM nodes
	var flexOffsets = []; // amount of vertical space it takes up
	var flexHeights = []; // actual css height
	var usedHeight = 0;

	undistributeHeight(els); // give all elements their natural height

	// find elements that are below the recommended height (expandable).
	// important to query for heights in a single first pass (to avoid reflow oscillation).
	els.each(function(i, el) {
		var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
		var naturalOffset = $(el).outerHeight(true);

		if (naturalOffset < minOffset) {
			flexEls.push(el);
			flexOffsets.push(naturalOffset);
			flexHeights.push($(el).height());
		}
		else {
			// this element stretches past recommended height (non-expandable). mark the space as occupied.
			usedHeight += naturalOffset;
		}
	});

	// readjust the recommended height to only consider the height available to non-maxed-out rows.
	if (shouldRedistribute) {
		availableHeight -= usedHeight;
		minOffset1 = Math.floor(availableHeight / flexEls.length);
		minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
	}

	// assign heights to all expandable elements
	$(flexEls).each(function(i, el) {
		var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
		var naturalOffset = flexOffsets[i];
		var naturalHeight = flexHeights[i];
		var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding

		if (naturalOffset < minOffset) { // we check this again because redistribution might have changed things
			$(el).height(newHeight);
		}
	});
}


// Undoes distrubuteHeight, restoring all els to their natural height
function undistributeHeight(els) {
	els.height('');
}


// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
function matchCellWidths(els) {
	var maxInnerWidth = 0;

	els.find('> *').each(function(i, innerEl) {
		var innerWidth = $(innerEl).outerWidth();
		if (innerWidth > maxInnerWidth) {
			maxInnerWidth = innerWidth;
		}
	});

	maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance

	els.width(maxInnerWidth);

	return maxInnerWidth;
}


// Given one element that resides inside another,
// Subtracts the height of the inner element from the outer element.
function subtractInnerElHeight(outerEl, innerEl) {
	var both = outerEl.add(innerEl);
	var diff;

	// effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
	both.css({
		position: 'relative', // cause a reflow, which will force fresh dimension recalculation
		left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
	});
	diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions
	both.css({ position: '', left: '' }); // undo hack

	return diff;
}


/* Element Geom Utilities
----------------------------------------------------------------------------------------------------------------------*/

FC.getOuterRect = getOuterRect;
FC.getClientRect = getClientRect;
FC.getContentRect = getContentRect;
FC.getScrollbarWidths = getScrollbarWidths;


// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51
function getScrollParent(el) {
	var position = el.css('position'),
		scrollParent = el.parents().filter(function() {
			var parent = $(this);
			return (/(auto|scroll)/).test(
				parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x')
			);
		}).eq(0);

	return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
}


// Queries the outer bounding area of a jQuery element.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getOuterRect(el, origin) {
	var offset = el.offset();
	var left = offset.left - (origin ? origin.left : 0);
	var top = offset.top - (origin ? origin.top : 0);

	return {
		left: left,
		right: left + el.outerWidth(),
		top: top,
		bottom: top + el.outerHeight()
	};
}


// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
// WARNING: given element can't have borders
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getClientRect(el, origin) {
	var offset = el.offset();
	var scrollbarWidths = getScrollbarWidths(el);
	var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);
	var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);

	return {
		left: left,
		right: left + el[0].clientWidth, // clientWidth includes padding but NOT scrollbars
		top: top,
		bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars
	};
}


// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getContentRect(el, origin) {
	var offset = el.offset(); // just outside of border, margin not included
	var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -
		(origin ? origin.left : 0);
	var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -
		(origin ? origin.top : 0);

	return {
		left: left,
		right: left + el.width(),
		top: top,
		bottom: top + el.height()
	};
}


// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.
// WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getScrollbarWidths(el) {
	var leftRightWidth = el[0].offsetWidth - el[0].clientWidth;
	var bottomWidth = el[0].offsetHeight - el[0].clientHeight;
	var widths;

	leftRightWidth = sanitizeScrollbarWidth(leftRightWidth);
	bottomWidth = sanitizeScrollbarWidth(bottomWidth);

	widths = { left: 0, right: 0, top: 0, bottom: bottomWidth };

	if (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') { // is the scrollbar on the left side?
		widths.left = leftRightWidth;
	}
	else {
		widths.right = leftRightWidth;
	}

	return widths;
}


// The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to
// retina displays, rounding, and IE11. Massage them into a usable value.
function sanitizeScrollbarWidth(width) {
	width = Math.max(0, width); // no negatives
	width = Math.round(width);
	return width;
}


// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side

var _isLeftRtlScrollbars = null;

function getIsLeftRtlScrollbars() { // responsible for caching the computation
	if (_isLeftRtlScrollbars === null) {
		_isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
	}
	return _isLeftRtlScrollbars;
}

function computeIsLeftRtlScrollbars() { // creates an offscreen test element, then removes it
	var el = $('<div><div/></div>')
		.css({
			position: 'absolute',
			top: -1000,
			left: 0,
			border: 0,
			padding: 0,
			overflow: 'scroll',
			direction: 'rtl'
		})
		.appendTo('body');
	var innerEl = el.children();
	var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?
	el.remove();
	return res;
}


// Retrieves a jQuery element's computed CSS value as a floating-point number.
// If the queried value is non-numeric (ex: IE can return "medium" for border width), will just return zero.
function getCssFloat(el, prop) {
	return parseFloat(el.css(prop)) || 0;
}


/* Mouse / Touch Utilities
----------------------------------------------------------------------------------------------------------------------*/

FC.preventDefault = preventDefault;


// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
function isPrimaryMouseButton(ev) {
	return ev.which == 1 && !ev.ctrlKey;
}


function getEvX(ev) {
	var touches = ev.originalEvent.touches;

	// on mobile FF, pageX for touch events is present, but incorrect,
	// so, look at touch coordinates first.
	if (touches && touches.length) {
		return touches[0].pageX;
	}

	return ev.pageX;
}


function getEvY(ev) {
	var touches = ev.originalEvent.touches;

	// on mobile FF, pageX for touch events is present, but incorrect,
	// so, look at touch coordinates first.
	if (touches && touches.length) {
		return touches[0].pageY;
	}

	return ev.pageY;
}


function getEvIsTouch(ev) {
	return /^touch/.test(ev.type);
}


function preventSelection(el) {
	el.addClass('fc-unselectable')
		.on('selectstart', preventDefault);
}


function allowSelection(el) {
	el.removeClass('fc-unselectable')
		.off('selectstart', preventDefault);
}


// Stops a mouse/touch event from doing it's native browser action
function preventDefault(ev) {
	ev.preventDefault();
}


/* General Geometry Utils
----------------------------------------------------------------------------------------------------------------------*/

FC.intersectRects = intersectRects;

// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
function intersectRects(rect1, rect2) {
	var res = {
		left: Math.max(rect1.left, rect2.left),
		right: Math.min(rect1.right, rect2.right),
		top: Math.max(rect1.top, rect2.top),
		bottom: Math.min(rect1.bottom, rect2.bottom)
	};

	if (res.left < res.right && res.top < res.bottom) {
		return res;
	}
	return false;
}


// Returns a new point that will have been moved to reside within the given rectangle
function constrainPoint(point, rect) {
	return {
		left: Math.min(Math.max(point.left, rect.left), rect.right),
		top: Math.min(Math.max(point.top, rect.top), rect.bottom)
	};
}


// Returns a point that is the center of the given rectangle
function getRectCenter(rect) {
	return {
		left: (rect.left + rect.right) / 2,
		top: (rect.top + rect.bottom) / 2
	};
}


// Subtracts point2's coordinates from point1's coordinates, returning a delta
function diffPoints(point1, point2) {
	return {
		left: point1.left - point2.left,
		top: point1.top - point2.top
	};
}


/* Object Ordering by Field
----------------------------------------------------------------------------------------------------------------------*/

FC.parseFieldSpecs = parseFieldSpecs;
FC.compareByFieldSpecs = compareByFieldSpecs;
FC.compareByFieldSpec = compareByFieldSpec;
FC.flexibleCompare = flexibleCompare;


function parseFieldSpecs(input) {
	var specs = [];
	var tokens = [];
	var i, token;

	if (typeof input === 'string') {
		tokens = input.split(/\s*,\s*/);
	}
	else if (typeof input === 'function') {
		tokens = [ input ];
	}
	else if ($.isArray(input)) {
		tokens = input;
	}

	for (i = 0; i < tokens.length; i++) {
		token = tokens[i];

		if (typeof token === 'string') {
			specs.push(
				token.charAt(0) == '-' ?
					{ field: token.substring(1), order: -1 } :
					{ field: token, order: 1 }
			);
		}
		else if (typeof token === 'function') {
			specs.push({ func: token });
		}
	}

	return specs;
}


function compareByFieldSpecs(obj1, obj2, fieldSpecs) {
	var i;
	var cmp;

	for (i = 0; i < fieldSpecs.length; i++) {
		cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);
		if (cmp) {
			return cmp;
		}
	}

	return 0;
}


function compareByFieldSpec(obj1, obj2, fieldSpec) {
	if (fieldSpec.func) {
		return fieldSpec.func(obj1, obj2);
	}
	return flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) *
		(fieldSpec.order || 1);
}


function flexibleCompare(a, b) {
	if (!a && !b) {
		return 0;
	}
	if (b == null) {
		return -1;
	}
	if (a == null) {
		return 1;
	}
	if ($.type(a) === 'string' || $.type(b) === 'string') {
		return String(a).localeCompare(String(b));
	}
	return a - b;
}


/* FullCalendar-specific Misc Utilities
----------------------------------------------------------------------------------------------------------------------*/


// Computes the intersection of the two ranges. Will return fresh date clones in a range.
// Returns undefined if no intersection.
// Expects all dates to be normalized to the same timezone beforehand.
// TODO: move to date section?
function intersectRanges(subjectRange, constraintRange) {
	var subjectStart = subjectRange.start;
	var subjectEnd = subjectRange.end;
	var constraintStart = constraintRange.start;
	var constraintEnd = constraintRange.end;
	var segStart, segEnd;
	var isStart, isEnd;

	if (subjectEnd > constraintStart && subjectStart < constraintEnd) { // in bounds at all?

		if (subjectStart >= constraintStart) {
			segStart = subjectStart.clone();
			isStart = true;
		}
		else {
			segStart = constraintStart.clone();
			isStart =  false;
		}

		if (subjectEnd <= constraintEnd) {
			segEnd = subjectEnd.clone();
			isEnd = true;
		}
		else {
			segEnd = constraintEnd.clone();
			isEnd = false;
		}

		return {
			start: segStart,
			end: segEnd,
			isStart: isStart,
			isEnd: isEnd
		};
	}
}


/* Date Utilities
----------------------------------------------------------------------------------------------------------------------*/

FC.computeGreatestUnit = computeGreatestUnit;
FC.divideRangeByDuration = divideRangeByDuration;
FC.divideDurationByDuration = divideDurationByDuration;
FC.multiplyDuration = multiplyDuration;
FC.durationHasTime = durationHasTime;

var dayIDs = [ 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat' ];
var unitsDesc = [ 'year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond' ]; // descending


// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
function diffDayTime(a, b) {
	return moment.duration({
		days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),
		ms: a.time() - b.time() // time-of-day from day start. disregards timezone
	});
}


// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.
function diffDay(a, b) {
	return moment.duration({
		days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')
	});
}


// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.
function diffByUnit(a, b, unit) {
	return moment.duration(
		Math.round(a.diff(b, unit, true)), // returnFloat=true
		unit
	);
}


// Computes the unit name of the largest whole-unit period of time.
// For example, 48 hours will be "days" whereas 49 hours will be "hours".
// Accepts start/end, a range object, or an original duration object.
function computeGreatestUnit(start, end) {
	var i, unit;
	var val;

	for (i = 0; i < unitsDesc.length; i++) {
		unit = unitsDesc[i];
		val = computeRangeAs(unit, start, end);

		if (val >= 1 && isInt(val)) {
			break;
		}
	}

	return unit; // will be "milliseconds" if nothing else matches
}


// like computeGreatestUnit, but has special abilities to interpret the source input for clues
function computeDurationGreatestUnit(duration, durationInput) {
	var unit = computeGreatestUnit(duration);

	// prevent days:7 from being interpreted as a week
	if (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {
		unit = 'day';
	}

	return unit;
}


// Computes the number of units (like "hours") in the given range.
// Range can be a {start,end} object, separate start/end args, or a Duration.
// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling
// of month-diffing logic (which tends to vary from version to version).
function computeRangeAs(unit, start, end) {

	if (end != null) { // given start, end
		return end.diff(start, unit, true);
	}
	else if (moment.isDuration(start)) { // given duration
		return start.as(unit);
	}
	else { // given { start, end } range object
		return start.end.diff(start.start, unit, true);
	}
}


// Intelligently divides a range (specified by a start/end params) by a duration
function divideRangeByDuration(start, end, dur) {
	var months;

	if (durationHasTime(dur)) {
		return (end - start) / dur;
	}
	months = dur.asMonths();
	if (Math.abs(months) >= 1 && isInt(months)) {
		return end.diff(start, 'months', true) / months;
	}
	return end.diff(start, 'days', true) / dur.asDays();
}


// Intelligently divides one duration by another
function divideDurationByDuration(dur1, dur2) {
	var months1, months2;

	if (durationHasTime(dur1) || durationHasTime(dur2)) {
		return dur1 / dur2;
	}
	months1 = dur1.asMonths();
	months2 = dur2.asMonths();
	if (
		Math.abs(months1) >= 1 && isInt(months1) &&
		Math.abs(months2) >= 1 && isInt(months2)
	) {
		return months1 / months2;
	}
	return dur1.asDays() / dur2.asDays();
}


// Intelligently multiplies a duration by a number
function multiplyDuration(dur, n) {
	var months;

	if (durationHasTime(dur)) {
		return moment.duration(dur * n);
	}
	months = dur.asMonths();
	if (Math.abs(months) >= 1 && isInt(months)) {
		return moment.duration({ months: months * n });
	}
	return moment.duration({ days: dur.asDays() * n });
}


function cloneRange(range) {
	return {
		start: range.start.clone(),
		end: range.end.clone()
	};
}


// Trims the beginning and end of inner range to be completely within outerRange.
// Returns a new range object.
function constrainRange(innerRange, outerRange) {
	innerRange = cloneRange(innerRange);

	if (outerRange.start) {
		// needs to be inclusively before outerRange's end
		innerRange.start = constrainDate(innerRange.start, outerRange);
	}

	if (outerRange.end) {
		innerRange.end = minMoment(innerRange.end, outerRange.end);
	}

	return innerRange;
}


// If the given date is not within the given range, move it inside.
// (If it's past the end, make it one millisecond before the end).
// Always returns a new moment.
function constrainDate(date, range) {
	date = date.clone();

	if (range.start) {
		date = maxMoment(date, range.start);
	}

	if (range.end && date >= range.end) {
		date = range.end.clone().subtract(1);
	}

	return date;
}


function isDateWithinRange(date, range) {
	return (!range.start || date >= range.start) &&
		(!range.end || date < range.end);
}


// TODO: deal with repeat code in intersectRanges
// constraintRange can have unspecified start/end, an open-ended range.
function doRangesIntersect(subjectRange, constraintRange) {
	return (!constraintRange.start || subjectRange.end >= constraintRange.start) &&
		(!constraintRange.end || subjectRange.start < constraintRange.end);
}


function isRangeWithinRange(innerRange, outerRange) {
	return (!outerRange.start || innerRange.start >= outerRange.start) &&
		(!outerRange.end || innerRange.end <= outerRange.end);
}


function isRangesEqual(range0, range1) {
	return ((range0.start && range1.start && range0.start.isSame(range1.start)) || (!range0.start && !range1.start)) &&
		((range0.end && range1.end && range0.end.isSame(range1.end)) || (!range0.end && !range1.end));
}


// Returns the moment that's earlier in time. Always a copy.
function minMoment(mom1, mom2) {
	return (mom1.isBefore(mom2) ? mom1 : mom2).clone();
}


// Returns the moment that's later in time. Always a copy.
function maxMoment(mom1, mom2) {
	return (mom1.isAfter(mom2) ? mom1 : mom2).clone();
}


// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)
function durationHasTime(dur) {
	return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
}


function isNativeDate(input) {
	return  Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
}


// Returns a boolean about whether the given input is a time string, like "06:40:00" or "06:00"
function isTimeString(str) {
	return /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
}


/* Logging and Debug
----------------------------------------------------------------------------------------------------------------------*/

FC.log = function() {
	var console = window.console;

	if (console && console.log) {
		return console.log.apply(console, arguments);
	}
};

FC.warn = function() {
	var console = window.console;

	if (console && console.warn) {
		return console.warn.apply(console, arguments);
	}
	else {
		return FC.log.apply(FC, arguments);
	}
};


/* General Utilities
----------------------------------------------------------------------------------------------------------------------*/

var hasOwnPropMethod = {}.hasOwnProperty;


// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
function mergeProps(propObjs, complexProps) {
	var dest = {};
	var i, name;
	var complexObjs;
	var j, val;
	var props;

	if (complexProps) {
		for (i = 0; i < complexProps.length; i++) {
			name = complexProps[i];
			complexObjs = [];

			// collect the trailing object values, stopping when a non-object is discovered
			for (j = propObjs.length - 1; j >= 0; j--) {
				val = propObjs[j][name];

				if (typeof val === 'object') {
					complexObjs.unshift(val);
				}
				else if (val !== undefined) {
					dest[name] = val; // if there were no objects, this value will be used
					break;
				}
			}

			// if the trailing values were objects, use the merged value
			if (complexObjs.length) {
				dest[name] = mergeProps(complexObjs);
			}
		}
	}

	// copy values into the destination, going from last to first
	for (i = propObjs.length - 1; i >= 0; i--) {
		props = propObjs[i];

		for (name in props) {
			if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign
				dest[name] = props[name];
			}
		}
	}

	return dest;
}


// Create an object that has the given prototype. Just like Object.create
function createObject(proto) {
	var f = function() {};
	f.prototype = proto;
	return new f();
}
FC.createObject = createObject;


function copyOwnProps(src, dest) {
	for (var name in src) {
		if (hasOwnProp(src, name)) {
			dest[name] = src[name];
		}
	}
}


function hasOwnProp(obj, name) {
	return hasOwnPropMethod.call(obj, name);
}


// Is the given value a non-object non-function value?
function isAtomic(val) {
	return /undefined|null|boolean|number|string/.test($.type(val));
}


function applyAll(functions, thisObj, args) {
	if ($.isFunction(functions)) {
		functions = [ functions ];
	}
	if (functions) {
		var i;
		var ret;
		for (i=0; i<functions.length; i++) {
			ret = functions[i].apply(thisObj, args) || ret;
		}
		return ret;
	}
}


function firstDefined() {
	for (var i=0; i<arguments.length; i++) {
		if (arguments[i] !== undefined) {
			return arguments[i];
		}
	}
}


function htmlEscape(s) {
	return (s + '').replace(/&/g, '&amp;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/'/g, '&#039;')
		.replace(/"/g, '&quot;')
		.replace(/\n/g, '<br />');
}


function stripHtmlEntities(text) {
	return text.replace(/&.*?;/g, '');
}


// Given a hash of CSS properties, returns a string of CSS.
// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
function cssToStr(cssProps) {
	var statements = [];

	$.each(cssProps, function(name, val) {
		if (val != null) {
			statements.push(name + ':' + val);
		}
	});

	return statements.join(';');
}


// Given an object hash of HTML attribute names to values,
// generates a string that can be injected between < > in HTML
function attrsToStr(attrs) {
	var parts = [];

	$.each(attrs, function(name, val) {
		if (val != null) {
			parts.push(name + '="' + htmlEscape(val) + '"');
		}
	});

	return parts.join(' ');
}


function capitaliseFirstLetter(str) {
	return str.charAt(0).toUpperCase() + str.slice(1);
}


function compareNumbers(a, b) { // for .sort()
	return a - b;
}


function isInt(n) {
	return n % 1 === 0;
}


// Returns a method bound to the given object context.
// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with
// different contexts as identical when binding/unbinding events.
function proxy(obj, methodName) {
	var method = obj[methodName];

	return function() {
		return method.apply(obj, arguments);
	};
}


// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
function debounce(func, wait, immediate) {
	var timeout, args, context, timestamp, result;

	var later = function() {
		var last = +new Date() - timestamp;
		if (last < wait) {
			timeout = setTimeout(later, wait - last);
		}
		else {
			timeout = null;
			if (!immediate) {
				result = func.apply(context, args);
				context = args = null;
			}
		}
	};

	return function() {
		context = this;
		args = arguments;
		timestamp = +new Date();
		var callNow = immediate && !timeout;
		if (!timeout) {
			timeout = setTimeout(later, wait);
		}
		if (callNow) {
			result = func.apply(context, args);
			context = args = null;
		}
		return result;
	};
}

;;

/*
GENERAL NOTE on moments throughout the *entire rest* of the codebase:
All moments are assumed to be ambiguously-zoned unless otherwise noted,
with the NOTABLE EXCEOPTION of start/end dates that live on *Event Objects*.
Ambiguously-TIMED moments are assumed to be ambiguously-zoned by nature.
*/

var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
var ambigTimeOrZoneRegex =
	/^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
var newMomentProto = moment.fn; // where we will attach our new methods
var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods

// tell momentjs to transfer these properties upon clone
var momentProperties = moment.momentProperties;
momentProperties.push('_fullCalendar');
momentProperties.push('_ambigTime');
momentProperties.push('_ambigZone');


// Creating
// -------------------------------------------------------------------------------------------------

// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
FC.moment = function() {
	return makeMoment(arguments);
};

// Sames as FC.moment, but forces the resulting moment to be in the UTC timezone.
FC.moment.utc = function() {
	var mom = makeMoment(arguments, true);

	// Force it into UTC because makeMoment doesn't guarantee it
	// (if given a pre-existing moment for example)
	if (mom.hasTime()) { // don't give ambiguously-timed moments a UTC zone
		mom.utc();
	}

	return mom;
};

// Same as FC.moment, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
FC.moment.parseZone = function() {
	return makeMoment(arguments, true, true);
};

// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
function makeMoment(args, parseAsUTC, parseZone) {
	var input = args[0];
	var isSingleString = args.length == 1 && typeof input === 'string';
	var isAmbigTime;
	var isAmbigZone;
	var ambigMatch;
	var mom;

	if (moment.isMoment(input) || isNativeDate(input) || input === undefined) {
		mom = moment.apply(null, args);
	}
	else { // "parsing" is required
		isAmbigTime = false;
		isAmbigZone = false;

		if (isSingleString) {
			if (ambigDateOfMonthRegex.test(input)) {
				// accept strings like '2014-05', but convert to the first of the month
				input += '-01';
				args = [ input ]; // for when we pass it on to moment's constructor
				isAmbigTime = true;
				isAmbigZone = true;
			}
			else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
				isAmbigTime = !ambigMatch[5]; // no time part?
				isAmbigZone = true;
			}
		}
		else if ($.isArray(input)) {
			// arrays have no timezone information, so assume ambiguous zone
			isAmbigZone = true;
		}
		// otherwise, probably a string with a format

		if (parseAsUTC || isAmbigTime) {
			mom = moment.utc.apply(moment, args);
		}
		else {
			mom = moment.apply(null, args);
		}

		if (isAmbigTime) {
			mom._ambigTime = true;
			mom._ambigZone = true; // ambiguous time always means ambiguous zone
		}
		else if (parseZone) { // let's record the inputted zone somehow
			if (isAmbigZone) {
				mom._ambigZone = true;
			}
			else if (isSingleString) {
				mom.utcOffset(input); // if not a valid zone, will assign UTC
			}
		}
	}

	mom._fullCalendar = true; // flag for extended functionality

	return mom;
}


// Week Number
// -------------------------------------------------------------------------------------------------


// Returns the week number, considering the locale's custom week number calcuation
// `weeks` is an alias for `week`
newMomentProto.week = newMomentProto.weeks = function(input) {
	var weekCalc = this._locale._fullCalendar_weekCalc;

	if (input == null && typeof weekCalc === 'function') { // custom function only works for getter
		return weekCalc(this);
	}
	else if (weekCalc === 'ISO') {
		return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter
	}

	return oldMomentProto.week.apply(this, arguments); // local getter/setter
};


// Time-of-day
// -------------------------------------------------------------------------------------------------

// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
newMomentProto.time = function(time) {

	// Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
	// `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
	if (!this._fullCalendar) {
		return oldMomentProto.time.apply(this, arguments);
	}

	if (time == null) { // getter
		return moment.duration({
			hours: this.hours(),
			minutes: this.minutes(),
			seconds: this.seconds(),
			milliseconds: this.milliseconds()
		});
	}
	else { // setter

		this._ambigTime = false; // mark that the moment now has a time

		if (!moment.isDuration(time) && !moment.isMoment(time)) {
			time = moment.duration(time);
		}

		// The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
		// Only for Duration times, not Moment times.
		var dayHours = 0;
		if (moment.isDuration(time)) {
			dayHours = Math.floor(time.asDays()) * 24;
		}

		// We need to set the individual fields.
		// Can't use startOf('day') then add duration. In case of DST at start of day.
		return this.hours(dayHours + time.hours())
			.minutes(time.minutes())
			.seconds(time.seconds())
			.milliseconds(time.milliseconds());
	}
};

// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
newMomentProto.stripTime = function() {

	if (!this._ambigTime) {

		this.utc(true); // keepLocalTime=true (for keeping *date* value)

		// set time to zero
		this.set({
			hours: 0,
			minutes: 0,
			seconds: 0,
			ms: 0
		});

		// Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
		// which clears all ambig flags.
		this._ambigTime = true;
		this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset
	}

	return this; // for chaining
};

// Returns if the moment has a non-ambiguous time (boolean)
newMomentProto.hasTime = function() {
	return !this._ambigTime;
};


// Timezone
// -------------------------------------------------------------------------------------------------

// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
newMomentProto.stripZone = function() {
	var wasAmbigTime;

	if (!this._ambigZone) {

		wasAmbigTime = this._ambigTime;

		this.utc(true); // keepLocalTime=true (for keeping date and time values)

		// the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
		this._ambigTime = wasAmbigTime || false;

		// Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
		// which clears the ambig flags.
		this._ambigZone = true;
	}

	return this; // for chaining
};

// Returns of the moment has a non-ambiguous timezone offset (boolean)
newMomentProto.hasZone = function() {
	return !this._ambigZone;
};


// implicitly marks a zone
newMomentProto.local = function(keepLocalTime) {

	// for when converting from ambiguously-zoned to local,
	// keep the time values when converting from UTC -> local
	oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);

	// ensure non-ambiguous
	// this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals
	this._ambigTime = false;
	this._ambigZone = false;

	return this; // for chaining
};


// implicitly marks a zone
newMomentProto.utc = function(keepLocalTime) {

	oldMomentProto.utc.call(this, keepLocalTime);

	// ensure non-ambiguous
	// this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals
	this._ambigTime = false;
	this._ambigZone = false;

	return this;
};


// implicitly marks a zone (will probably get called upon .utc() and .local())
newMomentProto.utcOffset = function(tzo) {

	if (tzo != null) { // setter
		// these assignments needs to happen before the original zone method is called.
		// I forget why, something to do with a browser crash.
		this._ambigTime = false;
		this._ambigZone = false;
	}

	return oldMomentProto.utcOffset.apply(this, arguments);
};


// Formatting
// -------------------------------------------------------------------------------------------------

newMomentProto.format = function() {

	if (this._fullCalendar && arguments[0]) { // an enhanced moment? and a format string provided?
		return formatDate(this, arguments[0]); // our extended formatting
	}
	if (this._ambigTime) {
		return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
	}
	if (this._ambigZone) {
		return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
	}
	if (this._fullCalendar) { // enhanced non-ambig moment?
		// moment.format() doesn't ensure english, but we want to.
		return oldMomentFormat(englishMoment(this));
	}

	return oldMomentProto.format.apply(this, arguments);
};

newMomentProto.toISOString = function() {

	if (this._ambigTime) {
		return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
	}
	if (this._ambigZone) {
		return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
	}
	if (this._fullCalendar) { // enhanced non-ambig moment?
		// depending on browser, moment might not output english. ensure english.
		// https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22
		return oldMomentProto.toISOString.apply(englishMoment(this), arguments);
	}

	return oldMomentProto.toISOString.apply(this, arguments);
};

function englishMoment(mom) {
	if (mom.locale() !== 'en') {
		return mom.clone().locale('en');
	}
	return mom;
}

;;
(function() {

// exports
FC.formatDate = formatDate;
FC.formatRange = formatRange;
FC.oldMomentFormat = oldMomentFormat;
FC.queryMostGranularFormatUnit = queryMostGranularFormatUnit;


// Config
// ---------------------------------------------------------------------------------------------------------------------

/*
Inserted between chunks in the fake ("intermediate") formatting string.
Important that it passes as whitespace (\s) because moment often identifies non-standalone months
via a regexp with an \s.
*/
var PART_SEPARATOR = '\u000b'; // vertical tab

/*
Inserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,
but rather, a "special" token that has custom rendering (see specialTokens map).
*/
var SPECIAL_TOKEN_MARKER = '\u001f'; // information separator 1

/*
Inserted at the beginning and end of a span of text that must have non-zero numeric characters.
Handling of these markers is done in a post-processing step at the very end of text rendering.
*/
var MAYBE_MARKER = '\u001e'; // information separator 2
var MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global

/*
Addition formatting tokens we want recognized
*/
var specialTokens = {
	t: function(date) { // "a" or "p"
		return oldMomentFormat(date, 'a').charAt(0);
	},
	T: function(date) { // "A" or "P"
		return oldMomentFormat(date, 'A').charAt(0);
	}
};

/*
The first characters of formatting tokens for units that are 1 day or larger.
`value` is for ranking relative size (lower means bigger).
`unit` is a normalized unit, used for comparing moments.
*/
var largeTokenMap = {
	Y: { value: 1, unit: 'year' },
	M: { value: 2, unit: 'month' },
	W: { value: 3, unit: 'week' }, // ISO week
	w: { value: 3, unit: 'week' }, // local week
	D: { value: 4, unit: 'day' }, // day of month
	d: { value: 4, unit: 'day' } // day of week
};


// Single Date Formatting
// ---------------------------------------------------------------------------------------------------------------------

/*
Formats `date` with a Moment formatting string, but allow our non-zero areas and special token
*/
function formatDate(date, formatStr) {
	return renderFakeFormatString(
		getParsedFormatString(formatStr).fakeFormatString,
		date
	);
}

/*
Call this if you want Moment's original format method to be used
*/
function oldMomentFormat(mom, formatStr) {
	return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js
}


// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset

/*
Using a formatting string meant for a single date, generate a range string, like
"Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
If the dates are the same as far as the format string is concerned, just return a single
rendering of one date, without any separator.
*/
function formatRange(date1, date2, formatStr, separator, isRTL) {
	var localeData;

	date1 = FC.moment.parseZone(date1);
	date2 = FC.moment.parseZone(date2);

	localeData = date1.localeData();

	// Expand localized format strings, like "LL" -> "MMMM D YYYY".
	// BTW, this is not important for `formatDate` because it is impossible to put custom tokens
	// or non-zero areas in Moment's localized format strings.
	formatStr = localeData.longDateFormat(formatStr) || formatStr;

	return renderParsedFormat(
		getParsedFormatString(formatStr),
		date1,
		date2,
		separator || ' - ',
		isRTL
	);
}

/*
Renders a range with an already-parsed format string.
*/
function renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {
	var sameUnits = parsedFormat.sameUnits;
	var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons
	var unzonedDate2 = date2.clone().stripZone(); // "

	var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);
	var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);

	var leftI;
	var leftStr = '';
	var rightI;
	var rightStr = '';
	var middleI;
	var middleStr1 = '';
	var middleStr2 = '';
	var middleStr = '';

	// Start at the leftmost side of the formatting string and continue until you hit a token
	// that is not the same between dates.
	for (
		leftI = 0;
		leftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI]));
		leftI++
	) {
		leftStr += renderedParts1[leftI];
	}

	// Similarly, start at the rightmost side of the formatting string and move left
	for (
		rightI = sameUnits.length - 1;
		rightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI]));
		rightI--
	) {
		// If current chunk is on the boundary of unique date-content, and is a special-case
		// date-formatting postfix character, then don't consume it. Consider it unique date-content.
		// TODO: make configurable
		if (rightI - 1 === leftI && renderedParts1[rightI] === '.') {
			break;
		}

		rightStr = renderedParts1[rightI] + rightStr;
	}

	// The area in the middle is different for both of the dates.
	// Collect them distinctly so we can jam them together later.
	for (middleI = leftI; middleI <= rightI; middleI++) {
		middleStr1 += renderedParts1[middleI];
		middleStr2 += renderedParts2[middleI];
	}

	if (middleStr1 || middleStr2) {
		if (isRTL) {
			middleStr = middleStr2 + separator + middleStr1;
		}
		else {
			middleStr = middleStr1 + separator + middleStr2;
		}
	}

	return processMaybeMarkers(
		leftStr + middleStr + rightStr
	);
}


// Format String Parsing
// ---------------------------------------------------------------------------------------------------------------------

var parsedFormatStrCache = {};

/*
Returns a parsed format string, leveraging a cache.
*/
function getParsedFormatString(formatStr) {
	return parsedFormatStrCache[formatStr] ||
		(parsedFormatStrCache[formatStr] = parseFormatString(formatStr));
}

/*
Parses a format string into the following:
- fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.
- sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like "day"),
  that indicates how similar a range's start & end must be in order to share the same formatted text.
  If not a token, then the value is null.
  Always a flat array (not nested liked "chunks").
*/
function parseFormatString(formatStr) {
	var chunks = chunkFormatString(formatStr);
	
	return {
		fakeFormatString: buildFakeFormatString(chunks),
		sameUnits: buildSameUnits(chunks)
	};
}

/*
Break the formatting string into an array of chunks.
A 'maybe' chunk will have nested chunks.
*/
function chunkFormatString(formatStr) {
	var chunks = [];
	var match;

	// TODO: more descrimination
	// \4 is a backreference to the first character of a multi-character set.
	var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g;

	while ((match = chunker.exec(formatStr))) {
		if (match[1]) { // a literal string inside [ ... ]
			chunks.push.apply(chunks, // append
				splitStringLiteral(match[1])
			);
		}
		else if (match[2]) { // non-zero formatting inside ( ... )
			chunks.push({ maybe: chunkFormatString(match[2]) });
		}
		else if (match[3]) { // a formatting token
			chunks.push({ token: match[3] });
		}
		else if (match[5]) { // an unenclosed literal string
			chunks.push.apply(chunks, // append
				splitStringLiteral(match[5])
			);
		}
	}

	return chunks;
}

/*
Potentially splits a literal-text string into multiple parts. For special cases.
*/
function splitStringLiteral(s) {
	if (s === '. ') {
		return [ '.', ' ' ]; // for locales with periods bound to the end of each year/month/date
	}
	else {
		return [ s ];
	}
}

/*
Given chunks parsed from a real format string, generate a fake (aka "intermediate") format string with special control
characters that will eventually be given to moment for formatting, and then post-processed.
*/
function buildFakeFormatString(chunks) {
	var parts = [];
	var i, chunk;

	for (i = 0; i < chunks.length; i++) {
		chunk = chunks[i];

		if (typeof chunk === 'string') {
			parts.push('[' + chunk + ']');
		}
		else if (chunk.token) {
			if (chunk.token in specialTokens) {
				parts.push(
					SPECIAL_TOKEN_MARKER + // useful during post-processing
					'[' + chunk.token + ']' // preserve as literal text
				);
			}
			else {
				parts.push(chunk.token); // unprotected text implies a format string
			}
		}
		else if (chunk.maybe) {
			parts.push(
				MAYBE_MARKER + // useful during post-processing
				buildFakeFormatString(chunk.maybe) +
				MAYBE_MARKER
			);
		}
	}

	return parts.join(PART_SEPARATOR);
}

/*
Given parsed chunks from a real formatting string, generates an array of unit strings (like "day") that indicate
in which regard two dates must be similar in order to share range formatting text.
The `chunks` can be nested (because of "maybe" chunks), however, the returned array will be flat.
*/
function buildSameUnits(chunks) {
	var units = [];
	var i, chunk;
	var tokenInfo;

	for (i = 0; i < chunks.length; i++) {
		chunk = chunks[i];

		if (chunk.token) {
			tokenInfo = largeTokenMap[chunk.token.charAt(0)];
			units.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second
		}
		else if (chunk.maybe) {
			units.push.apply(units, // append
				buildSameUnits(chunk.maybe)
			);
		}
		else {
			units.push(null);
		}
	}

	return units;
}


// Rendering to text
// ---------------------------------------------------------------------------------------------------------------------

/*
Formats a date with a fake format string, post-processes the control characters, then returns.
*/
function renderFakeFormatString(fakeFormatString, date) {
	return processMaybeMarkers(
		renderFakeFormatStringParts(fakeFormatString, date).join('')
	);
}

/*
Formats a date into parts that will have been post-processed, EXCEPT for the "maybe" markers.
*/
function renderFakeFormatStringParts(fakeFormatString, date) {
	var parts = [];
	var fakeRender = oldMomentFormat(date, fakeFormatString);
	var fakeParts = fakeRender.split(PART_SEPARATOR);
	var i, fakePart;

	for (i = 0; i < fakeParts.length; i++) {
		fakePart = fakeParts[i];

		if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {
			parts.push(
				// the literal string IS the token's name.
				// call special token's registered function.
				specialTokens[fakePart.substring(1)](date)
			);
		}
		else {
			parts.push(fakePart);
		}
	}

	return parts;
}

/*
Accepts an almost-finally-formatted string and processes the "maybe" control characters, returning a new string.
*/
function processMaybeMarkers(s) {
	return s.replace(MAYBE_REGEXP, function(m0, m1) { // regex assumed to have 'g' flag
		if (m1.match(/[1-9]/)) { // any non-zero numeric characters?
			return m1;
		}
		else {
			return '';
		}
	});
}


// Misc Utils
// -------------------------------------------------------------------------------------------------

/*
Returns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.
*/
function queryMostGranularFormatUnit(formatStr) {
	var chunks = chunkFormatString(formatStr);
	var i, chunk;
	var candidate;
	var best;

	for (i = 0; i < chunks.length; i++) {
		chunk = chunks[i];

		if (chunk.token) {
			candidate = largeTokenMap[chunk.token.charAt(0)];
			if (candidate) {
				if (!best || candidate.value > best.value) {
					best = candidate;
				}
			}
		}
	}

	if (best) {
		return best.unit;
	}

	return null;
};

})();

// quick local references
var formatDate = FC.formatDate;
var formatRange = FC.formatRange;
var oldMomentFormat = FC.oldMomentFormat;

;;

FC.Class = Class; // export

// Class that all other classes will inherit from
function Class() { }


// Called on a class to create a subclass.
// Last argument contains instance methods. Any argument before the last are considered mixins.
Class.extend = function() {
	var len = arguments.length;
	var i;
	var members;

	for (i = 0; i < len; i++) {
		members = arguments[i];
		if (i < len - 1) { // not the last argument?
			mixIntoClass(this, members);
		}
	}

	return extendClass(this, members || {}); // members will be undefined if no arguments
};


// Adds new member variables/methods to the class's prototype.
// Can be called with another class, or a plain object hash containing new members.
Class.mixin = function(members) {
	mixIntoClass(this, members);
};


function extendClass(superClass, members) {
	var subClass;

	// ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist
	if (hasOwnProp(members, 'constructor')) {
		subClass = members.constructor;
	}
	if (typeof subClass !== 'function') {
		subClass = members.constructor = function() {
			superClass.apply(this, arguments);
		};
	}

	// build the base prototype for the subclass, which is an new object chained to the superclass's prototype
	subClass.prototype = createObject(superClass.prototype);

	// copy each member variable/method onto the the subclass's prototype
	copyOwnProps(members, subClass.prototype);

	// copy over all class variables/methods to the subclass, such as `extend` and `mixin`
	copyOwnProps(superClass, subClass);

	return subClass;
}


function mixIntoClass(theClass, members) {
	copyOwnProps(members, theClass.prototype);
}
;;

var Model = Class.extend(EmitterMixin, ListenerMixin, {

	_props: null,
	_watchers: null,
	_globalWatchArgs: null,

	constructor: function() {
		this._watchers = {};
		this._props = {};
		this.applyGlobalWatchers();
	},

	applyGlobalWatchers: function() {
		var argSets = this._globalWatchArgs || [];
		var i;

		for (i = 0; i < argSets.length; i++) {
			this.watch.apply(this, argSets[i]);
		}
	},

	has: function(name) {
		return name in this._props;
	},

	get: function(name) {
		if (name === undefined) {
			return this._props;
		}

		return this._props[name];
	},

	set: function(name, val) {
		var newProps;

		if (typeof name === 'string') {
			newProps = {};
			newProps[name] = val === undefined ? null : val;
		}
		else {
			newProps = name;
		}

		this.setProps(newProps);
	},

	reset: function(newProps) {
		var oldProps = this._props;
		var changeset = {}; // will have undefined's to signal unsets
		var name;

		for (name in oldProps) {
			changeset[name] = undefined;
		}

		for (name in newProps) {
			changeset[name] = newProps[name];
		}

		this.setProps(changeset);
	},

	unset: function(name) { // accepts a string or array of strings
		var newProps = {};
		var names;
		var i;

		if (typeof name === 'string') {
			names = [ name ];
		}
		else {
			names = name;
		}

		for (i = 0; i < names.length; i++) {
			newProps[names[i]] = undefined;
		}

		this.setProps(newProps);
	},

	setProps: function(newProps) {
		var changedProps = {};
		var changedCnt = 0;
		var name, val;

		for (name in newProps) {
			val = newProps[name];

			// a change in value?
			// if an object, don't check equality, because might have been mutated internally.
			// TODO: eventually enforce immutability.
			if (
				typeof val === 'object' ||
				val !== this._props[name]
			) {
				changedProps[name] = val;
				changedCnt++;
			}
		}

		if (changedCnt) {

			this.trigger('before:batchChange', changedProps);

			for (name in changedProps) {
				val = changedProps[name];

				this.trigger('before:change', name, val);
				this.trigger('before:change:' + name, val);
			}

			for (name in changedProps) {
				val = changedProps[name];

				if (val === undefined) {
					delete this._props[name];
				}
				else {
					this._props[name] = val;
				}

				this.trigger('change:' + name, val);
				this.trigger('change', name, val);
			}

			this.trigger('batchChange', changedProps);
		}
	},

	watch: function(name, depList, startFunc, stopFunc) {
		var _this = this;

		this.unwatch(name);

		this._watchers[name] = this._watchDeps(depList, function(deps) {
			var res = startFunc.call(_this, deps);

			if (res && res.then) {
				_this.unset(name); // put in an unset state while resolving
				res.then(function(val) {
					_this.set(name, val);
				});
			}
			else {
				_this.set(name, res);
			}
		}, function() {
			_this.unset(name);

			if (stopFunc) {
				stopFunc.call(_this);
			}
		});
	},

	unwatch: function(name) {
		var watcher = this._watchers[name];

		if (watcher) {
			delete this._watchers[name];
			watcher.teardown();
		}
	},

	_watchDeps: function(depList, startFunc, stopFunc) {
		var _this = this;
		var queuedChangeCnt = 0;
		var depCnt = depList.length;
		var satisfyCnt = 0;
		var values = {}; // what's passed as the `deps` arguments
		var bindTuples = []; // array of [ eventName, handlerFunc ] arrays
		var isCallingStop = false;

		function onBeforeDepChange(depName, val, isOptional) {
			queuedChangeCnt++;
			if (queuedChangeCnt === 1) { // first change to cause a "stop" ?
				if (satisfyCnt === depCnt) { // all deps previously satisfied?
					isCallingStop = true;
					stopFunc();
					isCallingStop = false;
				}
			}
		}

		function onDepChange(depName, val, isOptional) {

			if (val === undefined) { // unsetting a value?

				// required dependency that was previously set?
				if (!isOptional && values[depName] !== undefined) {
					satisfyCnt--;
				}

				delete values[depName];
			}
			else { // setting a value?

				// required dependency that was previously unset?
				if (!isOptional && values[depName] === undefined) {
					satisfyCnt++;
				}

				values[depName] = val;
			}

			queuedChangeCnt--;
			if (!queuedChangeCnt) { // last change to cause a "start"?

				// now finally satisfied or satisfied all along?
				if (satisfyCnt === depCnt) {

					// if the stopFunc initiated another value change, ignore it.
					// it will be processed by another change event anyway.
					if (!isCallingStop) {
						startFunc(values);
					}
				}
			}
		}

		// intercept for .on() that remembers handlers
		function bind(eventName, handler) {
			_this.on(eventName, handler);
			bindTuples.push([ eventName, handler ]);
		}

		// listen to dependency changes
		depList.forEach(function(depName) {
			var isOptional = false;

			if (depName.charAt(0) === '?') { // TODO: more DRY
				depName = depName.substring(1);
				isOptional = true;
			}

			bind('before:change:' + depName, function(val) {
				onBeforeDepChange(depName, val, isOptional);
			});

			bind('change:' + depName, function(val) {
				onDepChange(depName, val, isOptional);
			});
		});

		// process current dependency values
		depList.forEach(function(depName) {
			var isOptional = false;

			if (depName.charAt(0) === '?') { // TODO: more DRY
				depName = depName.substring(1);
				isOptional = true;
			}

			if (_this.has(depName)) {
				values[depName] = _this.get(depName);
				satisfyCnt++;
			}
			else if (isOptional) {
				satisfyCnt++;
			}
		});

		// initially satisfied
		if (satisfyCnt === depCnt) {
			startFunc(values);
		}

		return {
			teardown: function() {
				// remove all handlers
				for (var i = 0; i < bindTuples.length; i++) {
					_this.off(bindTuples[i][0], bindTuples[i][1]);
				}
				bindTuples = null;

				// was satisfied, so call stopFunc
				if (satisfyCnt === depCnt) {
					stopFunc();
				}
			},
			flash: function() {
				if (satisfyCnt === depCnt) {
					stopFunc();
					startFunc(values);
				}
			}
		};
	},

	flash: function(name) {
		var watcher = this._watchers[name];

		if (watcher) {
			watcher.flash();
		}
	}

});


Model.watch = function(/* same arguments as this.watch() */) {
	var proto = this.prototype;

	if (!proto._globalWatchArgs) {
		proto._globalWatchArgs = [];
	}

	proto._globalWatchArgs.push(arguments);
};


FC.Model = Model;


;;

var Promise = {

	construct: function(executor) {
		var deferred = $.Deferred();
		var promise = deferred.promise();

		if (typeof executor === 'function') {
			executor(
				function(val) { // resolve
					deferred.resolve(val);
					attachImmediatelyResolvingThen(promise, val);
				},
				function() { // reject
					deferred.reject();
					attachImmediatelyRejectingThen(promise);
				}
			);
		}

		return promise;
	},

	resolve: function(val) {
		var deferred = $.Deferred().resolve(val);
		var promise = deferred.promise();

		attachImmediatelyResolvingThen(promise, val);

		return promise;
	},

	reject: function() {
		var deferred = $.Deferred().reject();
		var promise = deferred.promise();

		attachImmediatelyRejectingThen(promise);

		return promise;
	}

};


function attachImmediatelyResolvingThen(promise, val) {
	promise.then = function(onResolve) {
		if (typeof onResolve === 'function') {
			onResolve(val);
		}
		return promise; // for chaining
	};
}


function attachImmediatelyRejectingThen(promise) {
	promise.then = function(onResolve, onReject) {
		if (typeof onReject === 'function') {
			onReject();
		}
		return promise; // for chaining
	};
}


FC.Promise = Promise;

;;

var TaskQueue = Class.extend(EmitterMixin, {

	q: null,
	isPaused: false,
	isRunning: false,


	constructor: function() {
		this.q = [];
	},


	queue: function(/* taskFunc, taskFunc... */) {
		this.q.push.apply(this.q, arguments); // append
		this.tryStart();
	},


	pause: function() {
		this.isPaused = true;
	},


	resume: function() {
		this.isPaused = false;
		this.tryStart();
	},


	tryStart: function() {
		if (!this.isRunning && this.canRunNext()) {
			this.isRunning = true;
			this.trigger('start');
			this.runNext();
		}
	},


	canRunNext: function() {
		return !this.isPaused && this.q.length;
	},


	runNext: function() { // does not check canRunNext
		this.runTask(this.q.shift());
	},


	runTask: function(task) {
		this.runTaskFunc(task);
	},


	runTaskFunc: function(taskFunc) {
		var _this = this;
		var res = taskFunc();

		if (res && res.then) {
			res.then(done);
		}
		else {
			done();
		}

		function done() {
			if (_this.canRunNext()) {
				_this.runNext();
			}
			else {
				_this.isRunning = false;
				_this.trigger('stop');
			}
		}
	}

});

FC.TaskQueue = TaskQueue;

;;

var RenderQueue = TaskQueue.extend({

	waitsByNamespace: null,
	waitNamespace: null,
	waitId: null,


	constructor: function(waitsByNamespace) {
		TaskQueue.call(this); // super-constructor

		this.waitsByNamespace = waitsByNamespace || {};
	},


	queue: function(taskFunc, namespace, type) {
		var task = {
			func: taskFunc,
			namespace: namespace,
			type: type
		};
		var waitMs;

		if (namespace) {
			waitMs = this.waitsByNamespace[namespace];
		}

		if (this.waitNamespace) {
			if (namespace === this.waitNamespace && waitMs != null) {
				this.delayWait(waitMs);
			}
			else {
				this.clearWait();
				this.tryStart();
			}
		}

		if (this.compoundTask(task)) { // appended to queue?

			if (!this.waitNamespace && waitMs != null) {
				this.startWait(namespace, waitMs);
			}
			else {
				this.tryStart();
			}
		}
	},


	startWait: function(namespace, waitMs) {
		this.waitNamespace = namespace;
		this.spawnWait(waitMs);
	},


	delayWait: function(waitMs) {
		clearTimeout(this.waitId);
		this.spawnWait(waitMs);
	},


	spawnWait: function(waitMs) {
		var _this = this;

		this.waitId = setTimeout(function() {
			_this.waitNamespace = null;
			_this.tryStart();
		}, waitMs);
	},


	clearWait: function() {
		if (this.waitNamespace) {
			clearTimeout(this.waitId);
			this.waitId = null;
			this.waitNamespace = null;
		}
	},


	canRunNext: function() {
		if (!TaskQueue.prototype.canRunNext.apply(this, arguments)) {
			return false;
		}

		// waiting for a certain namespace to stop receiving tasks?
		if (this.waitNamespace) {

			// if there was a different namespace task in the meantime,
			// that forces all previously-waiting tasks to suddenly execute.
			// TODO: find a way to do this in constant time.
			for (var q = this.q, i = 0; i < q.length; i++) {
				if (q[i].namespace !== this.waitNamespace) {
					return true; // allow execution
				}
			}

			return false;
		}

		return true;
	},


	runTask: function(task) {
		this.runTaskFunc(task.func);
	},


	compoundTask: function(newTask) {
		var q = this.q;
		var shouldAppend = true;
		var i, task;

		if (newTask.namespace) {

			if (newTask.type === 'destroy' || newTask.type === 'init') {

				// remove all add/remove ops with same namespace, regardless of order
				for (i = q.length - 1; i >= 0; i--) {
					task = q[i];

					if (
						task.namespace === newTask.namespace &&
						(task.type === 'add' || task.type === 'remove')
					) {
						q.splice(i, 1); // remove task
					}
				}

				if (newTask.type === 'destroy') {
					// eat away final init/destroy operation
					if (q.length) {
						task = q[q.length - 1]; // last task

						if (task.namespace === newTask.namespace) {

							// the init and our destroy cancel each other out
							if (task.type === 'init') {
								shouldAppend = false;
								q.pop();
							}
							// prefer to use the destroy operation that's already present
							else if (task.type === 'destroy') {
								shouldAppend = false;
							}
						}
					}
				}
				else if (newTask.type === 'init') {
					// eat away final init operation
					if (q.length) {
						task = q[q.length - 1]; // last task

						if (
							task.namespace === newTask.namespace &&
							task.type === 'init'
						) {
							// our init operation takes precedence
							q.pop();
						}
					}
				}
			}
		}

		if (shouldAppend) {
			q.push(newTask);
		}

		return shouldAppend;
	}

});

FC.RenderQueue = RenderQueue;

;;

var EmitterMixin = FC.EmitterMixin = {

	// jQuery-ification via $(this) allows a non-DOM object to have
	// the same event handling capabilities (including namespaces).


	on: function(types, handler) {
		$(this).on(types, this._prepareIntercept(handler));
		return this; // for chaining
	},


	one: function(types, handler) {
		$(this).one(types, this._prepareIntercept(handler));
		return this; // for chaining
	},


	_prepareIntercept: function(handler) {
		// handlers are always called with an "event" object as their first param.
		// sneak the `this` context and arguments into the extra parameter object
		// and forward them on to the original handler.
		var intercept = function(ev, extra) {
			return handler.apply(
				extra.context || this,
				extra.args || []
			);
		};

		// mimick jQuery's internal "proxy" system (risky, I know)
		// causing all functions with the same .guid to appear to be the same.
		// https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448
		// this is needed for calling .off with the original non-intercept handler.
		if (!handler.guid) {
			handler.guid = $.guid++;
		}
		intercept.guid = handler.guid;

		return intercept;
	},


	off: function(types, handler) {
		$(this).off(types, handler);

		return this; // for chaining
	},


	trigger: function(types) {
		var args = Array.prototype.slice.call(arguments, 1); // arguments after the first

		// pass in "extra" info to the intercept
		$(this).triggerHandler(types, { args: args });

		return this; // for chaining
	},


	triggerWith: function(types, context, args) {

		// `triggerHandler` is less reliant on the DOM compared to `trigger`.
		// pass in "extra" info to the intercept.
		$(this).triggerHandler(types, { context: context, args: args });

		return this; // for chaining
	}

};

;;

/*
Utility methods for easily listening to events on another object,
and more importantly, easily unlistening from them.
*/
var ListenerMixin = FC.ListenerMixin = (function() {
	var guid = 0;
	var ListenerMixin = {

		listenerId: null,

		/*
		Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.
		The `callback` will be called with the `this` context of the object that .listenTo is being called on.
		Can be called:
			.listenTo(other, eventName, callback)
		OR
			.listenTo(other, {
				eventName1: callback1,
				eventName2: callback2
			})
		*/
		listenTo: function(other, arg, callback) {
			if (typeof arg === 'object') { // given dictionary of callbacks
				for (var eventName in arg) {
					if (arg.hasOwnProperty(eventName)) {
						this.listenTo(other, eventName, arg[eventName]);
					}
				}
			}
			else if (typeof arg === 'string') {
				other.on(
					arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object
					$.proxy(callback, this) // always use `this` context
						// the usually-undesired jQuery guid behavior doesn't matter,
						// because we always unbind via namespace
				);
			}
		},

		/*
		Causes the current object to stop listening to events on the `other` object.
		`eventName` is optional. If omitted, will stop listening to ALL events on `other`.
		*/
		stopListeningTo: function(other, eventName) {
			other.off((eventName || '') + '.' + this.getListenerNamespace());
		},

		/*
		Returns a string, unique to this object, to be used for event namespacing
		*/
		getListenerNamespace: function() {
			if (this.listenerId == null) {
				this.listenerId = guid++;
			}
			return '_listener' + this.listenerId;
		}

	};
	return ListenerMixin;
})();
;;

/* A rectangular panel that is absolutely positioned over other content
------------------------------------------------------------------------------------------------------------------------
Options:
	- className (string)
	- content (HTML string or jQuery element set)
	- parentEl
	- top
	- left
	- right (the x coord of where the right edge should be. not a "CSS" right)
	- autoHide (boolean)
	- show (callback)
	- hide (callback)
*/

var Popover = Class.extend(ListenerMixin, {

	isHidden: true,
	options: null,
	el: null, // the container element for the popover. generated by this object
	margin: 10, // the space required between the popover and the edges of the scroll container


	constructor: function(options) {
		this.options = options || {};
	},


	// Shows the popover on the specified position. Renders it if not already
	show: function() {
		if (this.isHidden) {
			if (!this.el) {
				this.render();
			}
			this.el.show();
			this.position();
			this.isHidden = false;
			this.trigger('show');
		}
	},


	// Hides the popover, through CSS, but does not remove it from the DOM
	hide: function() {
		if (!this.isHidden) {
			this.el.hide();
			this.isHidden = true;
			this.trigger('hide');
		}
	},


	// Creates `this.el` and renders content inside of it
	render: function() {
		var _this = this;
		var options = this.options;

		this.el = $('<div class="fc-popover"/>')
			.addClass(options.className || '')
			.css({
				// position initially to the top left to avoid creating scrollbars
				top: 0,
				left: 0
			})
			.append(options.content)
			.appendTo(options.parentEl);

		// when a click happens on anything inside with a 'fc-close' className, hide the popover
		this.el.on('click', '.fc-close', function() {
			_this.hide();
		});

		if (options.autoHide) {
			this.listenTo($(document), 'mousedown', this.documentMousedown);
		}
	},


	// Triggered when the user clicks *anywhere* in the document, for the autoHide feature
	documentMousedown: function(ev) {
		// only hide the popover if the click happened outside the popover
		if (this.el && !$(ev.target).closest(this.el).length) {
			this.hide();
		}
	},


	// Hides and unregisters any handlers
	removeElement: function() {
		this.hide();

		if (this.el) {
			this.el.remove();
			this.el = null;
		}

		this.stopListeningTo($(document), 'mousedown');
	},


	// Positions the popover optimally, using the top/left/right options
	position: function() {
		var options = this.options;
		var origin = this.el.offsetParent().offset();
		var width = this.el.outerWidth();
		var height = this.el.outerHeight();
		var windowEl = $(window);
		var viewportEl = getScrollParent(this.el);
		var viewportTop;
		var viewportLeft;
		var viewportOffset;
		var top; // the "position" (not "offset") values for the popover
		var left; //

		// compute top and left
		top = options.top || 0;
		if (options.left !== undefined) {
			left = options.left;
		}
		else if (options.right !== undefined) {
			left = options.right - width; // derive the left value from the right value
		}
		else {
			left = 0;
		}

		if (viewportEl.is(window) || viewportEl.is(document)) { // normalize getScrollParent's result
			viewportEl = windowEl;
			viewportTop = 0; // the window is always at the top left
			viewportLeft = 0; // (and .offset() won't work if called here)
		}
		else {
			viewportOffset = viewportEl.offset();
			viewportTop = viewportOffset.top;
			viewportLeft = viewportOffset.left;
		}

		// if the window is scrolled, it causes the visible area to be further down
		viewportTop += windowEl.scrollTop();
		viewportLeft += windowEl.scrollLeft();

		// constrain to the view port. if constrained by two edges, give precedence to top/left
		if (options.viewportConstrain !== false) {
			top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
			top = Math.max(top, viewportTop + this.margin);
			left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
			left = Math.max(left, viewportLeft + this.margin);
		}

		this.el.css({
			top: top - origin.top,
			left: left - origin.left
		});
	},


	// Triggers a callback. Calls a function in the option hash of the same name.
	// Arguments beyond the first `name` are forwarded on.
	// TODO: better code reuse for this. Repeat code
	trigger: function(name) {
		if (this.options[name]) {
			this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
	}

});

;;

/*
A cache for the left/right/top/bottom/width/height values for one or more elements.
Works with both offset (from topleft document) and position (from offsetParent).

options:
- els
- isHorizontal
- isVertical
*/
var CoordCache = FC.CoordCache = Class.extend({

	els: null, // jQuery set (assumed to be siblings)
	forcedOffsetParentEl: null, // options can override the natural offsetParent
	origin: null, // {left,top} position of offsetParent of els
	boundingRect: null, // constrain cordinates to this rectangle. {left,right,top,bottom} or null
	isHorizontal: false, // whether to query for left/right/width
	isVertical: false, // whether to query for top/bottom/height

	// arrays of coordinates (offsets from topleft of document)
	lefts: null,
	rights: null,
	tops: null,
	bottoms: null,


	constructor: function(options) {
		this.els = $(options.els);
		this.isHorizontal = options.isHorizontal;
		this.isVertical = options.isVertical;
		this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;
	},


	// Queries the els for coordinates and stores them.
	// Call this method before using and of the get* methods below.
	build: function() {
		var offsetParentEl = this.forcedOffsetParentEl;
		if (!offsetParentEl && this.els.length > 0) {
			offsetParentEl = this.els.eq(0).offsetParent();
		}

		this.origin = offsetParentEl ?
			offsetParentEl.offset() :
			null;

		this.boundingRect = this.queryBoundingRect();

		if (this.isHorizontal) {
			this.buildElHorizontals();
		}
		if (this.isVertical) {
			this.buildElVerticals();
		}
	},


	// Destroys all internal data about coordinates, freeing memory
	clear: function() {
		this.origin = null;
		this.boundingRect = null;
		this.lefts = null;
		this.rights = null;
		this.tops = null;
		this.bottoms = null;
	},


	// When called, if coord caches aren't built, builds them
	ensureBuilt: function() {
		if (!this.origin) {
			this.build();
		}
	},


	// Populates the left/right internal coordinate arrays
	buildElHorizontals: function() {
		var lefts = [];
		var rights = [];

		this.els.each(function(i, node) {
			var el = $(node);
			var left = el.offset().left;
			var width = el.outerWidth();

			lefts.push(left);
			rights.push(left + width);
		});

		this.lefts = lefts;
		this.rights = rights;
	},


	// Populates the top/bottom internal coordinate arrays
	buildElVerticals: function() {
		var tops = [];
		var bottoms = [];

		this.els.each(function(i, node) {
			var el = $(node);
			var top = el.offset().top;
			var height = el.outerHeight();

			tops.push(top);
			bottoms.push(top + height);
		});

		this.tops = tops;
		this.bottoms = bottoms;
	},


	// Given a left offset (from document left), returns the index of the el that it horizontally intersects.
	// If no intersection is made, returns undefined.
	getHorizontalIndex: function(leftOffset) {
		this.ensureBuilt();

		var lefts = this.lefts;
		var rights = this.rights;
		var len = lefts.length;
		var i;

		for (i = 0; i < len; i++) {
			if (leftOffset >= lefts[i] && leftOffset < rights[i]) {
				return i;
			}
		}
	},


	// Given a top offset (from document top), returns the index of the el that it vertically intersects.
	// If no intersection is made, returns undefined.
	getVerticalIndex: function(topOffset) {
		this.ensureBuilt();

		var tops = this.tops;
		var bottoms = this.bottoms;
		var len = tops.length;
		var i;

		for (i = 0; i < len; i++) {
			if (topOffset >= tops[i] && topOffset < bottoms[i]) {
				return i;
			}
		}
	},


	// Gets the left offset (from document left) of the element at the given index
	getLeftOffset: function(leftIndex) {
		this.ensureBuilt();
		return this.lefts[leftIndex];
	},


	// Gets the left position (from offsetParent left) of the element at the given index
	getLeftPosition: function(leftIndex) {
		this.ensureBuilt();
		return this.lefts[leftIndex] - this.origin.left;
	},


	// Gets the right offset (from document left) of the element at the given index.
	// This value is NOT relative to the document's right edge, like the CSS concept of "right" would be.
	getRightOffset: function(leftIndex) {
		this.ensureBuilt();
		return this.rights[leftIndex];
	},


	// Gets the right position (from offsetParent left) of the element at the given index.
	// This value is NOT relative to the offsetParent's right edge, like the CSS concept of "right" would be.
	getRightPosition: function(leftIndex) {
		this.ensureBuilt();
		return this.rights[leftIndex] - this.origin.left;
	},


	// Gets the width of the element at the given index
	getWidth: function(leftIndex) {
		this.ensureBuilt();
		return this.rights[leftIndex] - this.lefts[leftIndex];
	},


	// Gets the top offset (from document top) of the element at the given index
	getTopOffset: function(topIndex) {
		this.ensureBuilt();
		return this.tops[topIndex];
	},


	// Gets the top position (from offsetParent top) of the element at the given position
	getTopPosition: function(topIndex) {
		this.ensureBuilt();
		return this.tops[topIndex] - this.origin.top;
	},

	// Gets the bottom offset (from the document top) of the element at the given index.
	// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
	getBottomOffset: function(topIndex) {
		this.ensureBuilt();
		return this.bottoms[topIndex];
	},


	// Gets the bottom position (from the offsetParent top) of the element at the given index.
	// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
	getBottomPosition: function(topIndex) {
		this.ensureBuilt();
		return this.bottoms[topIndex] - this.origin.top;
	},


	// Gets the height of the element at the given index
	getHeight: function(topIndex) {
		this.ensureBuilt();
		return this.bottoms[topIndex] - this.tops[topIndex];
	},


	// Bounding Rect
	// TODO: decouple this from CoordCache

	// Compute and return what the elements' bounding rectangle is, from the user's perspective.
	// Right now, only returns a rectangle if constrained by an overflow:scroll element.
	// Returns null if there are no elements
	queryBoundingRect: function() {
		var scrollParentEl;

		if (this.els.length > 0) {
			scrollParentEl = getScrollParent(this.els.eq(0));

			if (!scrollParentEl.is(document)) {
				return getClientRect(scrollParentEl);
			}
		}

		return null;
	},

	isPointInBounds: function(leftOffset, topOffset) {
		return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);
	},

	isLeftInBounds: function(leftOffset) {
		return !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);
	},

	isTopInBounds: function(topOffset) {
		return !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);
	}

});

;;

/* Tracks a drag's mouse movement, firing various handlers
----------------------------------------------------------------------------------------------------------------------*/
// TODO: use Emitter

var DragListener = FC.DragListener = Class.extend(ListenerMixin, {

	options: null,
	subjectEl: null,

	// coordinates of the initial mousedown
	originX: null,
	originY: null,

	// the wrapping element that scrolls, or MIGHT scroll if there's overflow.
	// TODO: do this for wrappers that have overflow:hidden as well.
	scrollEl: null,

	isInteracting: false,
	isDistanceSurpassed: false,
	isDelayEnded: false,
	isDragging: false,
	isTouch: false,
	isGeneric: false, // initiated by 'dragstart' (jqui)

	delay: null,
	delayTimeoutId: null,
	minDistance: null,

	shouldCancelTouchScroll: true,
	scrollAlwaysKills: false,


	constructor: function(options) {
		this.options = options || {};
	},


	// Interaction (high-level)
	// -----------------------------------------------------------------------------------------------------------------


	startInteraction: function(ev, extraOptions) {

		if (ev.type === 'mousedown') {
			if (GlobalEmitter.get().shouldIgnoreMouse()) {
				return;
			}
			else if (!isPrimaryMouseButton(ev)) {
				return;
			}
			else {
				ev.preventDefault(); // prevents native selection in most browsers
			}
		}

		if (!this.isInteracting) {

			// process options
			extraOptions = extraOptions || {};
			this.delay = firstDefined(extraOptions.delay, this.options.delay, 0);
			this.minDistance = firstDefined(extraOptions.distance, this.options.distance, 0);
			this.subjectEl = this.options.subjectEl;

			preventSelection($('body'));

			this.isInteracting = true;
			this.isTouch = getEvIsTouch(ev);
			this.isGeneric = ev.type === 'dragstart';
			this.isDelayEnded = false;
			this.isDistanceSurpassed = false;

			this.originX = getEvX(ev);
			this.originY = getEvY(ev);
			this.scrollEl = getScrollParent($(ev.target));

			this.bindHandlers();
			this.initAutoScroll();
			this.handleInteractionStart(ev);
			this.startDelay(ev);

			if (!this.minDistance) {
				this.handleDistanceSurpassed(ev);
			}
		}
	},


	handleInteractionStart: function(ev) {
		this.trigger('interactionStart', ev);
	},


	endInteraction: function(ev, isCancelled) {
		if (this.isInteracting) {
			this.endDrag(ev);

			if (this.delayTimeoutId) {
				clearTimeout(this.delayTimeoutId);
				this.delayTimeoutId = null;
			}

			this.destroyAutoScroll();
			this.unbindHandlers();

			this.isInteracting = false;
			this.handleInteractionEnd(ev, isCancelled);

			allowSelection($('body'));
		}
	},


	handleInteractionEnd: function(ev, isCancelled) {
		this.trigger('interactionEnd', ev, isCancelled || false);
	},


	// Binding To DOM
	// -----------------------------------------------------------------------------------------------------------------


	bindHandlers: function() {
		// some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,
		// so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.
		var globalEmitter = GlobalEmitter.get();

		if (this.isGeneric) {
			this.listenTo($(document), { // might only work on iOS because of GlobalEmitter's bind :(
				drag: this.handleMove,
				dragstop: this.endInteraction
			});
		}
		else if (this.isTouch) {
			this.listenTo(globalEmitter, {
				touchmove: this.handleTouchMove,
				touchend: this.endInteraction,
				scroll: this.handleTouchScroll
			});
		}
		else {
			this.listenTo(globalEmitter, {
				mousemove: this.handleMouseMove,
				mouseup: this.endInteraction
			});
		}

		this.listenTo(globalEmitter, {
			selectstart: preventDefault, // don't allow selection while dragging
			contextmenu: preventDefault // long taps would open menu on Chrome dev tools
		});
	},


	unbindHandlers: function() {
		this.stopListeningTo(GlobalEmitter.get());
		this.stopListeningTo($(document)); // for isGeneric
	},


	// Drag (high-level)
	// -----------------------------------------------------------------------------------------------------------------


	// extraOptions ignored if drag already started
	startDrag: function(ev, extraOptions) {
		this.startInteraction(ev, extraOptions); // ensure interaction began

		if (!this.isDragging) {
			this.isDragging = true;
			this.handleDragStart(ev);
		}
	},


	handleDragStart: function(ev) {
		this.trigger('dragStart', ev);
	},


	handleMove: function(ev) {
		var dx = getEvX(ev) - this.originX;
		var dy = getEvY(ev) - this.originY;
		var minDistance = this.minDistance;
		var distanceSq; // current distance from the origin, squared

		if (!this.isDistanceSurpassed) {
			distanceSq = dx * dx + dy * dy;
			if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem
				this.handleDistanceSurpassed(ev);
			}
		}

		if (this.isDragging) {
			this.handleDrag(dx, dy, ev);
		}
	},


	// Called while the mouse is being moved and when we know a legitimate drag is taking place
	handleDrag: function(dx, dy, ev) {
		this.trigger('drag', dx, dy, ev);
		this.updateAutoScroll(ev); // will possibly cause scrolling
	},


	endDrag: function(ev) {
		if (this.isDragging) {
			this.isDragging = false;
			this.handleDragEnd(ev);
		}
	},


	handleDragEnd: function(ev) {
		this.trigger('dragEnd', ev);
	},


	// Delay
	// -----------------------------------------------------------------------------------------------------------------


	startDelay: function(initialEv) {
		var _this = this;

		if (this.delay) {
			this.delayTimeoutId = setTimeout(function() {
				_this.handleDelayEnd(initialEv);
			}, this.delay);
		}
		else {
			this.handleDelayEnd(initialEv);
		}
	},


	handleDelayEnd: function(initialEv) {
		this.isDelayEnded = true;

		if (this.isDistanceSurpassed) {
			this.startDrag(initialEv);
		}
	},


	// Distance
	// -----------------------------------------------------------------------------------------------------------------


	handleDistanceSurpassed: function(ev) {
		this.isDistanceSurpassed = true;

		if (this.isDelayEnded) {
			this.startDrag(ev);
		}
	},


	// Mouse / Touch
	// -----------------------------------------------------------------------------------------------------------------


	handleTouchMove: function(ev) {

		// prevent inertia and touchmove-scrolling while dragging
		if (this.isDragging && this.shouldCancelTouchScroll) {
			ev.preventDefault();
		}

		this.handleMove(ev);
	},


	handleMouseMove: function(ev) {
		this.handleMove(ev);
	},


	// Scrolling (unrelated to auto-scroll)
	// -----------------------------------------------------------------------------------------------------------------


	handleTouchScroll: function(ev) {
		// if the drag is being initiated by touch, but a scroll happens before
		// the drag-initiating delay is over, cancel the drag
		if (!this.isDragging || this.scrollAlwaysKills) {
			this.endInteraction(ev, true); // isCancelled=true
		}
	},


	// Utils
	// -----------------------------------------------------------------------------------------------------------------


	// Triggers a callback. Calls a function in the option hash of the same name.
	// Arguments beyond the first `name` are forwarded on.
	trigger: function(name) {
		if (this.options[name]) {
			this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
		// makes _methods callable by event name. TODO: kill this
		if (this['_' + name]) {
			this['_' + name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
	}


});

;;
/*
this.scrollEl is set in DragListener
*/
DragListener.mixin({

	isAutoScroll: false,

	scrollBounds: null, // { top, bottom, left, right }
	scrollTopVel: null, // pixels per second
	scrollLeftVel: null, // pixels per second
	scrollIntervalId: null, // ID of setTimeout for scrolling animation loop

	// defaults
	scrollSensitivity: 30, // pixels from edge for scrolling to start
	scrollSpeed: 200, // pixels per second, at maximum speed
	scrollIntervalMs: 50, // millisecond wait between scroll increment


	initAutoScroll: function() {
		var scrollEl = this.scrollEl;

		this.isAutoScroll =
			this.options.scroll &&
			scrollEl &&
			!scrollEl.is(window) &&
			!scrollEl.is(document);

		if (this.isAutoScroll) {
			// debounce makes sure rapid calls don't happen
			this.listenTo(scrollEl, 'scroll', debounce(this.handleDebouncedScroll, 100));
		}
	},


	destroyAutoScroll: function() {
		this.endAutoScroll(); // kill any animation loop

		// remove the scroll handler if there is a scrollEl
		if (this.isAutoScroll) {
			this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(
		}
	},


	// Computes and stores the bounding rectangle of scrollEl
	computeScrollBounds: function() {
		if (this.isAutoScroll) {
			this.scrollBounds = getOuterRect(this.scrollEl);
			// TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
		}
	},


	// Called when the dragging is in progress and scrolling should be updated
	updateAutoScroll: function(ev) {
		var sensitivity = this.scrollSensitivity;
		var bounds = this.scrollBounds;
		var topCloseness, bottomCloseness;
		var leftCloseness, rightCloseness;
		var topVel = 0;
		var leftVel = 0;

		if (bounds) { // only scroll if scrollEl exists

			// compute closeness to edges. valid range is from 0.0 - 1.0
			topCloseness = (sensitivity - (getEvY(ev) - bounds.top)) / sensitivity;
			bottomCloseness = (sensitivity - (bounds.bottom - getEvY(ev))) / sensitivity;
			leftCloseness = (sensitivity - (getEvX(ev) - bounds.left)) / sensitivity;
			rightCloseness = (sensitivity - (bounds.right - getEvX(ev))) / sensitivity;

			// translate vertical closeness into velocity.
			// mouse must be completely in bounds for velocity to happen.
			if (topCloseness >= 0 && topCloseness <= 1) {
				topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up
			}
			else if (bottomCloseness >= 0 && bottomCloseness <= 1) {
				topVel = bottomCloseness * this.scrollSpeed;
			}

			// translate horizontal closeness into velocity
			if (leftCloseness >= 0 && leftCloseness <= 1) {
				leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left
			}
			else if (rightCloseness >= 0 && rightCloseness <= 1) {
				leftVel = rightCloseness * this.scrollSpeed;
			}
		}

		this.setScrollVel(topVel, leftVel);
	},


	// Sets the speed-of-scrolling for the scrollEl
	setScrollVel: function(topVel, leftVel) {

		this.scrollTopVel = topVel;
		this.scrollLeftVel = leftVel;

		this.constrainScrollVel(); // massages into realistic values

		// if there is non-zero velocity, and an animation loop hasn't already started, then START
		if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {
			this.scrollIntervalId = setInterval(
				proxy(this, 'scrollIntervalFunc'), // scope to `this`
				this.scrollIntervalMs
			);
		}
	},


	// Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
	constrainScrollVel: function() {
		var el = this.scrollEl;

		if (this.scrollTopVel < 0) { // scrolling up?
			if (el.scrollTop() <= 0) { // already scrolled all the way up?
				this.scrollTopVel = 0;
			}
		}
		else if (this.scrollTopVel > 0) { // scrolling down?
			if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) { // already scrolled all the way down?
				this.scrollTopVel = 0;
			}
		}

		if (this.scrollLeftVel < 0) { // scrolling left?
			if (el.scrollLeft() <= 0) { // already scrolled all the left?
				this.scrollLeftVel = 0;
			}
		}
		else if (this.scrollLeftVel > 0) { // scrolling right?
			if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) { // already scrolled all the way right?
				this.scrollLeftVel = 0;
			}
		}
	},


	// This function gets called during every iteration of the scrolling animation loop
	scrollIntervalFunc: function() {
		var el = this.scrollEl;
		var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by

		// change the value of scrollEl's scroll
		if (this.scrollTopVel) {
			el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
		}
		if (this.scrollLeftVel) {
			el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
		}

		this.constrainScrollVel(); // since the scroll values changed, recompute the velocities

		// if scrolled all the way, which causes the vels to be zero, stop the animation loop
		if (!this.scrollTopVel && !this.scrollLeftVel) {
			this.endAutoScroll();
		}
	},


	// Kills any existing scrolling animation loop
	endAutoScroll: function() {
		if (this.scrollIntervalId) {
			clearInterval(this.scrollIntervalId);
			this.scrollIntervalId = null;

			this.handleScrollEnd();
		}
	},


	// Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
	handleDebouncedScroll: function() {
		// recompute all coordinates, but *only* if this is *not* part of our scrolling animation
		if (!this.scrollIntervalId) {
			this.handleScrollEnd();
		}
	},


	// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
	handleScrollEnd: function() {
	}

});
;;

/* Tracks mouse movements over a component and raises events about which hit the mouse is over.
------------------------------------------------------------------------------------------------------------------------
options:
- subjectEl
- subjectCenter
*/

var HitDragListener = DragListener.extend({

	component: null, // converts coordinates to hits
		// methods: hitsNeeded, hitsNotNeeded, queryHit

	origHit: null, // the hit the mouse was over when listening started
	hit: null, // the hit the mouse is over
	coordAdjust: null, // delta that will be added to the mouse coordinates when computing collisions


	constructor: function(component, options) {
		DragListener.call(this, options); // call the super-constructor

		this.component = component;
	},


	// Called when drag listening starts (but a real drag has not necessarily began).
	// ev might be undefined if dragging was started manually.
	handleInteractionStart: function(ev) {
		var subjectEl = this.subjectEl;
		var subjectRect;
		var origPoint;
		var point;

		this.component.hitsNeeded();
		this.computeScrollBounds(); // for autoscroll

		if (ev) {
			origPoint = { left: getEvX(ev), top: getEvY(ev) };
			point = origPoint;

			// constrain the point to bounds of the element being dragged
			if (subjectEl) {
				subjectRect = getOuterRect(subjectEl); // used for centering as well
				point = constrainPoint(point, subjectRect);
			}

			this.origHit = this.queryHit(point.left, point.top);

			// treat the center of the subject as the collision point?
			if (subjectEl && this.options.subjectCenter) {

				// only consider the area the subject overlaps the hit. best for large subjects.
				// TODO: skip this if hit didn't supply left/right/top/bottom
				if (this.origHit) {
					subjectRect = intersectRects(this.origHit, subjectRect) ||
						subjectRect; // in case there is no intersection
				}

				point = getRectCenter(subjectRect);
			}

			this.coordAdjust = diffPoints(point, origPoint); // point - origPoint
		}
		else {
			this.origHit = null;
			this.coordAdjust = null;
		}

		// call the super-method. do it after origHit has been computed
		DragListener.prototype.handleInteractionStart.apply(this, arguments);
	},


	// Called when the actual drag has started
	handleDragStart: function(ev) {
		var hit;

		DragListener.prototype.handleDragStart.apply(this, arguments); // call the super-method

		// might be different from this.origHit if the min-distance is large
		hit = this.queryHit(getEvX(ev), getEvY(ev));

		// report the initial hit the mouse is over
		// especially important if no min-distance and drag starts immediately
		if (hit) {
			this.handleHitOver(hit);
		}
	},


	// Called when the drag moves
	handleDrag: function(dx, dy, ev) {
		var hit;

		DragListener.prototype.handleDrag.apply(this, arguments); // call the super-method

		hit = this.queryHit(getEvX(ev), getEvY(ev));

		if (!isHitsEqual(hit, this.hit)) { // a different hit than before?
			if (this.hit) {
				this.handleHitOut();
			}
			if (hit) {
				this.handleHitOver(hit);
			}
		}
	},


	// Called when dragging has been stopped
	handleDragEnd: function() {
		this.handleHitDone();
		DragListener.prototype.handleDragEnd.apply(this, arguments); // call the super-method
	},


	// Called when a the mouse has just moved over a new hit
	handleHitOver: function(hit) {
		var isOrig = isHitsEqual(hit, this.origHit);

		this.hit = hit;

		this.trigger('hitOver', this.hit, isOrig, this.origHit);
	},


	// Called when the mouse has just moved out of a hit
	handleHitOut: function() {
		if (this.hit) {
			this.trigger('hitOut', this.hit);
			this.handleHitDone();
			this.hit = null;
		}
	},


	// Called after a hitOut. Also called before a dragStop
	handleHitDone: function() {
		if (this.hit) {
			this.trigger('hitDone', this.hit);
		}
	},


	// Called when the interaction ends, whether there was a real drag or not
	handleInteractionEnd: function() {
		DragListener.prototype.handleInteractionEnd.apply(this, arguments); // call the super-method

		this.origHit = null;
		this.hit = null;

		this.component.hitsNotNeeded();
	},


	// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
	handleScrollEnd: function() {
		DragListener.prototype.handleScrollEnd.apply(this, arguments); // call the super-method

		// hits' absolute positions will be in new places after a user's scroll.
		// HACK for recomputing.
		if (this.isDragging) {
			this.component.releaseHits();
			this.component.prepareHits();
		}
	},


	// Gets the hit underneath the coordinates for the given mouse event
	queryHit: function(left, top) {

		if (this.coordAdjust) {
			left += this.coordAdjust.left;
			top += this.coordAdjust.top;
		}

		return this.component.queryHit(left, top);
	}

});


// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.
// Two null values will be considered equal, as two "out of the component" states are the same.
function isHitsEqual(hit0, hit1) {

	if (!hit0 && !hit1) {
		return true;
	}

	if (hit0 && hit1) {
		return hit0.component === hit1.component &&
			isHitPropsWithin(hit0, hit1) &&
			isHitPropsWithin(hit1, hit0); // ensures all props are identical
	}

	return false;
}


// Returns true if all of subHit's non-standard properties are within superHit
function isHitPropsWithin(subHit, superHit) {
	for (var propName in subHit) {
		if (!/^(component|left|right|top|bottom)$/.test(propName)) {
			if (subHit[propName] !== superHit[propName]) {
				return false;
			}
		}
	}
	return true;
}

;;

/*
Listens to document and window-level user-interaction events, like touch events and mouse events,
and fires these events as-is to whoever is observing a GlobalEmitter.
Best when used as a singleton via GlobalEmitter.get()

Normalizes mouse/touch events. For examples:
- ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click
- compensates for various buggy scenarios where a touchend does not fire
*/

FC.touchMouseIgnoreWait = 500;

var GlobalEmitter = Class.extend(ListenerMixin, EmitterMixin, {

	isTouching: false,
	mouseIgnoreDepth: 0,
	handleScrollProxy: null,


	bind: function() {
		var _this = this;

		this.listenTo($(document), {
			touchstart: this.handleTouchStart,
			touchcancel: this.handleTouchCancel,
			touchend: this.handleTouchEnd,
			mousedown: this.handleMouseDown,
			mousemove: this.handleMouseMove,
			mouseup: this.handleMouseUp,
			click: this.handleClick,
			selectstart: this.handleSelectStart,
			contextmenu: this.handleContextMenu
		});

		// because we need to call preventDefault
		// because https://www.chromestatus.com/features/5093566007214080
		// TODO: investigate performance because this is a global handler
		window.addEventListener(
			'touchmove',
			this.handleTouchMoveProxy = function(ev) {
				_this.handleTouchMove($.Event(ev));
			},
			{ passive: false } // allows preventDefault()
		);

		// attach a handler to get called when ANY scroll action happens on the page.
		// this was impossible to do with normal on/off because 'scroll' doesn't bubble.
		// http://stackoverflow.com/a/32954565/96342
		window.addEventListener(
			'scroll',
			this.handleScrollProxy = function(ev) {
				_this.handleScroll($.Event(ev));
			},
			true // useCapture
		);
	},

	unbind: function() {
		this.stopListeningTo($(document));

		window.removeEventListener(
			'touchmove',
			this.handleTouchMoveProxy
		);

		window.removeEventListener(
			'scroll',
			this.handleScrollProxy,
			true // useCapture
		);
	},


	// Touch Handlers
	// -----------------------------------------------------------------------------------------------------------------

	handleTouchStart: function(ev) {

		// if a previous touch interaction never ended with a touchend, then implicitly end it,
		// but since a new touch interaction is about to begin, don't start the mouse ignore period.
		this.stopTouch(ev, true); // skipMouseIgnore=true

		this.isTouching = true;
		this.trigger('touchstart', ev);
	},

	handleTouchMove: function(ev) {
		if (this.isTouching) {
			this.trigger('touchmove', ev);
		}
	},

	handleTouchCancel: function(ev) {
		if (this.isTouching) {
			this.trigger('touchcancel', ev);

			// Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.
			// If touchend fires later, it won't have any effect b/c isTouching will be false.
			this.stopTouch(ev);
		}
	},

	handleTouchEnd: function(ev) {
		this.stopTouch(ev);
	},


	// Mouse Handlers
	// -----------------------------------------------------------------------------------------------------------------

	handleMouseDown: function(ev) {
		if (!this.shouldIgnoreMouse()) {
			this.trigger('mousedown', ev);
		}
	},

	handleMouseMove: function(ev) {
		if (!this.shouldIgnoreMouse()) {
			this.trigger('mousemove', ev);
		}
	},

	handleMouseUp: function(ev) {
		if (!this.shouldIgnoreMouse()) {
			this.trigger('mouseup', ev);
		}
	},

	handleClick: function(ev) {
		if (!this.shouldIgnoreMouse()) {
			this.trigger('click', ev);
		}
	},


	// Misc Handlers
	// -----------------------------------------------------------------------------------------------------------------

	handleSelectStart: function(ev) {
		this.trigger('selectstart', ev);
	},

	handleContextMenu: function(ev) {
		this.trigger('contextmenu', ev);
	},

	handleScroll: function(ev) {
		this.trigger('scroll', ev);
	},


	// Utils
	// -----------------------------------------------------------------------------------------------------------------

	stopTouch: function(ev, skipMouseIgnore) {
		if (this.isTouching) {
			this.isTouching = false;
			this.trigger('touchend', ev);

			if (!skipMouseIgnore) {
				this.startTouchMouseIgnore();
			}
		}
	},

	startTouchMouseIgnore: function() {
		var _this = this;
		var wait = FC.touchMouseIgnoreWait;

		if (wait) {
			this.mouseIgnoreDepth++;
			setTimeout(function() {
				_this.mouseIgnoreDepth--;
			}, wait);
		}
	},

	shouldIgnoreMouse: function() {
		return this.isTouching || Boolean(this.mouseIgnoreDepth);
	}

});


// Singleton
// ---------------------------------------------------------------------------------------------------------------------

(function() {
	var globalEmitter = null;
	var neededCount = 0;


	// gets the singleton
	GlobalEmitter.get = function() {

		if (!globalEmitter) {
			globalEmitter = new GlobalEmitter();
			globalEmitter.bind();
		}

		return globalEmitter;
	};


	// called when an object knows it will need a GlobalEmitter in the near future.
	GlobalEmitter.needed = function() {
		GlobalEmitter.get(); // ensures globalEmitter
		neededCount++;
	};


	// called when the object that originally called needed() doesn't need a GlobalEmitter anymore.
	GlobalEmitter.unneeded = function() {
		neededCount--;

		if (!neededCount) { // nobody else needs it
			globalEmitter.unbind();
			globalEmitter = null;
		}
	};

})();

;;

/* Creates a clone of an element and lets it track the mouse as it moves
----------------------------------------------------------------------------------------------------------------------*/

var MouseFollower = Class.extend(ListenerMixin, {

	options: null,

	sourceEl: null, // the element that will be cloned and made to look like it is dragging
	el: null, // the clone of `sourceEl` that will track the mouse
	parentEl: null, // the element that `el` (the clone) will be attached to

	// the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl
	top0: null,
	left0: null,

	// the absolute coordinates of the initiating touch/mouse action
	y0: null,
	x0: null,

	// the number of pixels the mouse has moved from its initial position
	topDelta: null,
	leftDelta: null,

	isFollowing: false,
	isHidden: false,
	isAnimating: false, // doing the revert animation?

	constructor: function(sourceEl, options) {
		this.options = options = options || {};
		this.sourceEl = sourceEl;
		this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent
	},


	// Causes the element to start following the mouse
	start: function(ev) {
		if (!this.isFollowing) {
			this.isFollowing = true;

			this.y0 = getEvY(ev);
			this.x0 = getEvX(ev);
			this.topDelta = 0;
			this.leftDelta = 0;

			if (!this.isHidden) {
				this.updatePosition();
			}

			if (getEvIsTouch(ev)) {
				this.listenTo($(document), 'touchmove', this.handleMove);
			}
			else {
				this.listenTo($(document), 'mousemove', this.handleMove);
			}
		}
	},


	// Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
	// `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
	stop: function(shouldRevert, callback) {
		var _this = this;
		var revertDuration = this.options.revertDuration;

		function complete() { // might be called by .animate(), which might change `this` context
			_this.isAnimating = false;
			_this.removeElement();

			_this.top0 = _this.left0 = null; // reset state for future updatePosition calls

			if (callback) {
				callback();
			}
		}

		if (this.isFollowing && !this.isAnimating) { // disallow more than one stop animation at a time
			this.isFollowing = false;

			this.stopListeningTo($(document));

			if (shouldRevert && revertDuration && !this.isHidden) { // do a revert animation?
				this.isAnimating = true;
				this.el.animate({
					top: this.top0,
					left: this.left0
				}, {
					duration: revertDuration,
					complete: complete
				});
			}
			else {
				complete();
			}
		}
	},


	// Gets the tracking element. Create it if necessary
	getEl: function() {
		var el = this.el;

		if (!el) {
			el = this.el = this.sourceEl.clone()
				.addClass(this.options.additionalClass || '')
				.css({
					position: 'absolute',
					visibility: '', // in case original element was hidden (commonly through hideEvents())
					display: this.isHidden ? 'none' : '', // for when initially hidden
					margin: 0,
					right: 'auto', // erase and set width instead
					bottom: 'auto', // erase and set height instead
					width: this.sourceEl.width(), // explicit height in case there was a 'right' value
					height: this.sourceEl.height(), // explicit width in case there was a 'bottom' value
					opacity: this.options.opacity || '',
					zIndex: this.options.zIndex
				});

			// we don't want long taps or any mouse interaction causing selection/menus.
			// would use preventSelection(), but that prevents selectstart, causing problems.
			el.addClass('fc-unselectable');

			el.appendTo(this.parentEl);
		}

		return el;
	},


	// Removes the tracking element if it has already been created
	removeElement: function() {
		if (this.el) {
			this.el.remove();
			this.el = null;
		}
	},


	// Update the CSS position of the tracking element
	updatePosition: function() {
		var sourceOffset;
		var origin;

		this.getEl(); // ensure this.el

		// make sure origin info was computed
		if (this.top0 === null) {
			sourceOffset = this.sourceEl.offset();
			origin = this.el.offsetParent().offset();
			this.top0 = sourceOffset.top - origin.top;
			this.left0 = sourceOffset.left - origin.left;
		}

		this.el.css({
			top: this.top0 + this.topDelta,
			left: this.left0 + this.leftDelta
		});
	},


	// Gets called when the user moves the mouse
	handleMove: function(ev) {
		this.topDelta = getEvY(ev) - this.y0;
		this.leftDelta = getEvX(ev) - this.x0;

		if (!this.isHidden) {
			this.updatePosition();
		}
	},


	// Temporarily makes the tracking element invisible. Can be called before following starts
	hide: function() {
		if (!this.isHidden) {
			this.isHidden = true;
			if (this.el) {
				this.el.hide();
			}
		}
	},


	// Show the tracking element after it has been temporarily hidden
	show: function() {
		if (this.isHidden) {
			this.isHidden = false;
			this.updatePosition();
			this.getEl().show();
		}
	}

});

;;

/* An abstract class comprised of a "grid" of areas that each represent a specific datetime
----------------------------------------------------------------------------------------------------------------------*/

var Grid = FC.Grid = Class.extend(ListenerMixin, {

	// self-config, overridable by subclasses
	hasDayInteractions: true, // can user click/select ranges of time?

	view: null, // a View object
	isRTL: null, // shortcut to the view's isRTL option

	start: null,
	end: null,

	el: null, // the containing element
	elsByFill: null, // a hash of jQuery element sets used for rendering each fill. Keyed by fill name.

	// derived from options
	eventTimeFormat: null,
	displayEventTime: null,
	displayEventEnd: null,

	minResizeDuration: null, // TODO: hack. set by subclasses. minumum event resize duration

	// if defined, holds the unit identified (ex: "year" or "month") that determines the level of granularity
	// of the date areas. if not defined, assumes to be day and time granularity.
	// TODO: port isTimeScale into same system?
	largeUnit: null,

	dayClickListener: null,
	daySelectListener: null,
	segDragListener: null,
	segResizeListener: null,
	externalDragListener: null,


	constructor: function(view) {
		this.view = view;
		this.isRTL = view.opt('isRTL');
		this.elsByFill = {};

		this.dayClickListener = this.buildDayClickListener();
		this.daySelectListener = this.buildDaySelectListener();
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Generates the format string used for event time text, if not explicitly defined by 'timeFormat'
	computeEventTimeFormat: function() {
		return this.view.opt('smallTimeFormat');
	},


	// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventTime'.
	// Only applies to non-all-day events.
	computeDisplayEventTime: function() {
		return true;
	},


	// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventEnd'
	computeDisplayEventEnd: function() {
		return true;
	},


	/* Dates
	------------------------------------------------------------------------------------------------------------------*/


	// Tells the grid about what period of time to display.
	// Any date-related internal data should be generated.
	setRange: function(range) {
		this.start = range.start.clone();
		this.end = range.end.clone();

		this.rangeUpdated();
		this.processRangeOptions();
	},


	// Called when internal variables that rely on the range should be updated
	rangeUpdated: function() {
	},


	// Updates values that rely on options and also relate to range
	processRangeOptions: function() {
		var view = this.view;
		var displayEventTime;
		var displayEventEnd;

		this.eventTimeFormat =
			view.opt('eventTimeFormat') ||
			view.opt('timeFormat') || // deprecated
			this.computeEventTimeFormat();

		displayEventTime = view.opt('displayEventTime');
		if (displayEventTime == null) {
			displayEventTime = this.computeDisplayEventTime(); // might be based off of range
		}

		displayEventEnd = view.opt('displayEventEnd');
		if (displayEventEnd == null) {
			displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
		}

		this.displayEventTime = displayEventTime;
		this.displayEventEnd = displayEventEnd;
	},


	// Converts a span (has unzoned start/end and any other grid-specific location information)
	// into an array of segments (pieces of events whose format is decided by the grid).
	spanToSegs: function(span) {
		// subclasses must implement
	},


	// Diffs the two dates, returning a duration, based on granularity of the grid
	// TODO: port isTimeScale into this system?
	diffDates: function(a, b) {
		if (this.largeUnit) {
			return diffByUnit(a, b, this.largeUnit);
		}
		else {
			return diffDayTime(a, b);
		}
	},


	/* Hit Area
	------------------------------------------------------------------------------------------------------------------*/

	hitsNeededDepth: 0, // necessary because multiple callers might need the same hits

	hitsNeeded: function() {
		if (!(this.hitsNeededDepth++)) {
			this.prepareHits();
		}
	},

	hitsNotNeeded: function() {
		if (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {
			this.releaseHits();
		}
	},


	// Called before one or more queryHit calls might happen. Should prepare any cached coordinates for queryHit
	prepareHits: function() {
	},


	// Called when queryHit calls have subsided. Good place to clear any coordinate caches.
	releaseHits: function() {
	},


	// Given coordinates from the topleft of the document, return data about the date-related area underneath.
	// Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).
	// Must have a `grid` property, a reference to this current grid. TODO: avoid this
	// The returned object will be processed by getHitSpan and getHitEl.
	queryHit: function(leftOffset, topOffset) {
	},


	// like getHitSpan, but returns null if the resulting span's range is invalid
	getSafeHitSpan: function(hit) {
		var hitSpan = this.getHitSpan(hit);

		if (!isRangeWithinRange(hitSpan, this.view.activeRange)) {
			return null;
		}

		return hitSpan;
	},


	// Given position-level information about a date-related area within the grid,
	// should return an object with at least a start/end date. Can provide other information as well.
	getHitSpan: function(hit) {
	},


	// Given position-level information about a date-related area within the grid,
	// should return a jQuery element that best represents it. passed to dayClick callback.
	getHitEl: function(hit) {
	},


	/* Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Sets the container element that the grid should render inside of.
	// Does other DOM-related initializations.
	setElement: function(el) {
		this.el = el;

		if (this.hasDayInteractions) {
			preventSelection(el);

			this.bindDayHandler('touchstart', this.dayTouchStart);
			this.bindDayHandler('mousedown', this.dayMousedown);
		}

		// attach event-element-related handlers. in Grid.events
		// same garbage collection note as above.
		this.bindSegHandlers();

		this.bindGlobalHandlers();
	},


	bindDayHandler: function(name, handler) {
		var _this = this;

		// attach a handler to the grid's root element.
		// jQuery will take care of unregistering them when removeElement gets called.
		this.el.on(name, function(ev) {
			if (
				!$(ev.target).is(
					_this.segSelector + ',' + // directly on an event element
					_this.segSelector + ' *,' + // within an event element
					'.fc-more,' + // a "more.." link
					'a[data-goto]' // a clickable nav link
				)
			) {
				return handler.call(_this, ev);
			}
		});
	},


	// Removes the grid's container element from the DOM. Undoes any other DOM-related attachments.
	// DOES NOT remove any content beforehand (doesn't clear events or call unrenderDates), unlike View
	removeElement: function() {
		this.unbindGlobalHandlers();
		this.clearDragListeners();

		this.el.remove();

		// NOTE: we don't null-out this.el for the same reasons we don't do it within View::removeElement
	},


	// Renders the basic structure of grid view before any content is rendered
	renderSkeleton: function() {
		// subclasses should implement
	},


	// Renders the grid's date-related content (like areas that represent days/times).
	// Assumes setRange has already been called and the skeleton has already been rendered.
	renderDates: function() {
		// subclasses should implement
	},


	// Unrenders the grid's date-related content
	unrenderDates: function() {
		// subclasses should implement
	},


	/* Handlers
	------------------------------------------------------------------------------------------------------------------*/


	// Binds DOM handlers to elements that reside outside the grid, such as the document
	bindGlobalHandlers: function() {
		this.listenTo($(document), {
			dragstart: this.externalDragStart, // jqui
			sortstart: this.externalDragStart // jqui
		});
	},


	// Unbinds DOM handlers from elements that reside outside the grid
	unbindGlobalHandlers: function() {
		this.stopListeningTo($(document));
	},


	// Process a mousedown on an element that represents a day. For day clicking and selecting.
	dayMousedown: function(ev) {
		var view = this.view;

		// HACK
		// This will still work even though bindDayHandler doesn't use GlobalEmitter.
		if (GlobalEmitter.get().shouldIgnoreMouse()) {
			return;
		}

		this.dayClickListener.startInteraction(ev);

		if (view.opt('selectable')) {
			this.daySelectListener.startInteraction(ev, {
				distance: view.opt('selectMinDistance')
			});
		}
	},


	dayTouchStart: function(ev) {
		var view = this.view;
		var selectLongPressDelay;

		// On iOS (and Android?) when a new selection is initiated overtop another selection,
		// the touchend never fires because the elements gets removed mid-touch-interaction (my theory).
		// HACK: simply don't allow this to happen.
		// ALSO: prevent selection when an *event* is already raised.
		if (view.isSelected || view.selectedEvent) {
			return;
		}

		selectLongPressDelay = view.opt('selectLongPressDelay');
		if (selectLongPressDelay == null) {
			selectLongPressDelay = view.opt('longPressDelay'); // fallback
		}

		this.dayClickListener.startInteraction(ev);

		if (view.opt('selectable')) {
			this.daySelectListener.startInteraction(ev, {
				delay: selectLongPressDelay
			});
		}
	},


	// Creates a listener that tracks the user's drag across day elements, for day clicking.
	buildDayClickListener: function() {
		var _this = this;
		var view = this.view;
		var dayClickHit; // null if invalid dayClick

		var dragListener = new HitDragListener(this, {
			scroll: view.opt('dragScroll'),
			interactionStart: function() {
				dayClickHit = dragListener.origHit;
			},
			hitOver: function(hit, isOrig, origHit) {
				// if user dragged to another cell at any point, it can no longer be a dayClick
				if (!isOrig) {
					dayClickHit = null;
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				dayClickHit = null;
			},
			interactionEnd: function(ev, isCancelled) {
				var hitSpan;

				if (!isCancelled && dayClickHit) {
					hitSpan = _this.getSafeHitSpan(dayClickHit);

					if (hitSpan) {
						view.triggerDayClick(hitSpan, _this.getHitEl(dayClickHit), ev);
					}
				}
			}
		});

		// because dayClickListener won't be called with any time delay, "dragging" will begin immediately,
		// which will kill any touchmoving/scrolling. Prevent this.
		dragListener.shouldCancelTouchScroll = false;

		dragListener.scrollAlwaysKills = true;

		return dragListener;
	},


	// Creates a listener that tracks the user's drag across day elements, for day selecting.
	buildDaySelectListener: function() {
		var _this = this;
		var view = this.view;
		var selectionSpan; // null if invalid selection

		var dragListener = new HitDragListener(this, {
			scroll: view.opt('dragScroll'),
			interactionStart: function() {
				selectionSpan = null;
			},
			dragStart: function() {
				view.unselect(); // since we could be rendering a new selection, we want to clear any old one
			},
			hitOver: function(hit, isOrig, origHit) {
				var origHitSpan;
				var hitSpan;

				if (origHit) { // click needs to have started on a hit

					origHitSpan = _this.getSafeHitSpan(origHit);
					hitSpan = _this.getSafeHitSpan(hit);

					if (origHitSpan && hitSpan) {
						selectionSpan = _this.computeSelection(origHitSpan, hitSpan);
					}
					else {
						selectionSpan = null;
					}

					if (selectionSpan) {
						_this.renderSelection(selectionSpan);
					}
					else if (selectionSpan === false) {
						disableCursor();
					}
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				selectionSpan = null;
				_this.unrenderSelection();
			},
			hitDone: function() { // called after a hitOut OR before a dragEnd
				enableCursor();
			},
			interactionEnd: function(ev, isCancelled) {
				if (!isCancelled && selectionSpan) {
					// the selection will already have been rendered. just report it
					view.reportSelection(selectionSpan, ev);
				}
			}
		});

		return dragListener;
	},


	// Kills all in-progress dragging.
	// Useful for when public API methods that result in re-rendering are invoked during a drag.
	// Also useful for when touch devices misbehave and don't fire their touchend.
	clearDragListeners: function() {
		this.dayClickListener.endInteraction();
		this.daySelectListener.endInteraction();

		if (this.segDragListener) {
			this.segDragListener.endInteraction(); // will clear this.segDragListener
		}
		if (this.segResizeListener) {
			this.segResizeListener.endInteraction(); // will clear this.segResizeListener
		}
		if (this.externalDragListener) {
			this.externalDragListener.endInteraction(); // will clear this.externalDragListener
		}
	},


	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: should probably move this to Grid.events, like we did event dragging / resizing


	// Renders a mock event at the given event location, which contains zoned start/end properties.
	// Returns all mock event elements.
	renderEventLocationHelper: function(eventLocation, sourceSeg) {
		var fakeEvent = this.fabricateHelperEvent(eventLocation, sourceSeg);

		return this.renderHelper(fakeEvent, sourceSeg); // do the actual rendering
	},


	// Builds a fake event given zoned event date properties and a segment is should be inspired from.
	// The range's end can be null, in which case the mock event that is rendered will have a null end time.
	// `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.
	fabricateHelperEvent: function(eventLocation, sourceSeg) {
		var fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {}; // mask the original event object if possible

		fakeEvent.start = eventLocation.start.clone();
		fakeEvent.end = eventLocation.end ? eventLocation.end.clone() : null;
		fakeEvent.allDay = null; // force it to be freshly computed by normalizeEventDates
		this.view.calendar.normalizeEventDates(fakeEvent);

		// this extra className will be useful for differentiating real events from mock events in CSS
		fakeEvent.className = (fakeEvent.className || []).concat('fc-helper');

		// if something external is being dragged in, don't render a resizer
		if (!sourceSeg) {
			fakeEvent.editable = false;
		}

		return fakeEvent;
	},


	// Renders a mock event. Given zoned event date properties.
	// Must return all mock event elements.
	renderHelper: function(eventLocation, sourceSeg) {
		// subclasses must implement
	},


	// Unrenders a mock event
	unrenderHelper: function() {
		// subclasses must implement
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.
	// Given a span (unzoned start/end and other misc data)
	renderSelection: function(span) {
		this.renderHighlight(span);
	},


	// Unrenders any visual indications of a selection. Will unrender a highlight by default.
	unrenderSelection: function() {
		this.unrenderHighlight();
	},


	// Given the first and last date-spans of a selection, returns another date-span object.
	// Subclasses can override and provide additional data in the span object. Will be passed to renderSelection().
	// Will return false if the selection is invalid and this should be indicated to the user.
	// Will return null/undefined if a selection invalid but no error should be reported.
	computeSelection: function(span0, span1) {
		var span = this.computeSelectionSpan(span0, span1);

		if (span && !this.view.calendar.isSelectionSpanAllowed(span)) {
			return false;
		}

		return span;
	},


	// Given two spans, must return the combination of the two.
	// TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.
	computeSelectionSpan: function(span0, span1) {
		var dates = [ span0.start, span0.end, span1.start, span1.end ];

		dates.sort(compareNumbers); // sorts chronologically. works with Moments

		return { start: dates[0].clone(), end: dates[3].clone() };
	},


	/* Highlight
	------------------------------------------------------------------------------------------------------------------*/


	// Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)
	renderHighlight: function(span) {
		this.renderFill('highlight', this.spanToSegs(span));
	},


	// Unrenders the emphasis on a date range
	unrenderHighlight: function() {
		this.unrenderFill('highlight');
	},


	// Generates an array of classNames for rendering the highlight. Used by the fill system.
	highlightSegClasses: function() {
		return [ 'fc-highlight' ];
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessHours: function() {
	},


	unrenderBusinessHours: function() {
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	getNowIndicatorUnit: function() {
	},


	renderNowIndicator: function(date) {
	},


	unrenderNowIndicator: function() {
	},


	/* Fill System (highlight, background events, business hours)
	--------------------------------------------------------------------------------------------------------------------
	TODO: remove this system. like we did in TimeGrid
	*/


	// Renders a set of rectangles over the given segments of time.
	// MUST RETURN a subset of segs, the segs that were actually rendered.
	// Responsible for populating this.elsByFill. TODO: better API for expressing this requirement
	renderFill: function(type, segs) {
		// subclasses must implement
	},


	// Unrenders a specific type of fill that is currently rendered on the grid
	unrenderFill: function(type) {
		var el = this.elsByFill[type];

		if (el) {
			el.remove();
			delete this.elsByFill[type];
		}
	},


	// Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
	// Only returns segments that successfully rendered.
	// To be harnessed by renderFill (implemented by subclasses).
	// Analagous to renderFgSegEls.
	renderFillSegEls: function(type, segs) {
		var _this = this;
		var segElMethod = this[type + 'SegEl'];
		var html = '';
		var renderedSegs = [];
		var i;

		if (segs.length) {

			// build a large concatenation of segment HTML
			for (i = 0; i < segs.length; i++) {
				html += this.fillSegHtml(type, segs[i]);
			}

			// Grab individual elements from the combined HTML string. Use each as the default rendering.
			// Then, compute the 'el' for each segment.
			$(html).each(function(i, node) {
				var seg = segs[i];
				var el = $(node);

				// allow custom filter methods per-type
				if (segElMethod) {
					el = segElMethod.call(_this, seg, el);
				}

				if (el) { // custom filters did not cancel the render
					el = $(el); // allow custom filter to return raw DOM node

					// correct element type? (would be bad if a non-TD were inserted into a table for example)
					if (el.is(_this.fillSegTag)) {
						seg.el = el;
						renderedSegs.push(seg);
					}
				}
			});
		}

		return renderedSegs;
	},


	fillSegTag: 'div', // subclasses can override


	// Builds the HTML needed for one fill segment. Generic enough to work with different types.
	fillSegHtml: function(type, seg) {

		// custom hooks per-type
		var classesMethod = this[type + 'SegClasses'];
		var cssMethod = this[type + 'SegCss'];

		var classes = classesMethod ? classesMethod.call(this, seg) : [];
		var css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});

		return '<' + this.fillSegTag +
			(classes.length ? ' class="' + classes.join(' ') + '"' : '') +
			(css ? ' style="' + css + '"' : '') +
			' />';
	},



	/* Generic rendering utilities for subclasses
	------------------------------------------------------------------------------------------------------------------*/


	// Computes HTML classNames for a single-day element
	getDayClasses: function(date, noThemeHighlight) {
		var view = this.view;
		var classes = [];
		var today;

		if (!isDateWithinRange(date, view.activeRange)) {
			classes.push('fc-disabled-day'); // TODO: jQuery UI theme?
		}
		else {
			classes.push('fc-' + dayIDs[date.day()]);

			if (
				view.currentRangeAs('months') == 1 && // TODO: somehow get into MonthView
				date.month() != view.currentRange.start.month()
			) {
				classes.push('fc-other-month');
			}

			today = view.calendar.getNow();

			if (date.isSame(today, 'day')) {
				classes.push('fc-today');

				if (noThemeHighlight !== true) {
					classes.push(view.highlightStateClass);
				}
			}
			else if (date < today) {
				classes.push('fc-past');
			}
			else {
				classes.push('fc-future');
			}
		}

		return classes;
	}

});

;;

/* Event-rendering and event-interaction methods for the abstract Grid class
----------------------------------------------------------------------------------------------------------------------

Data Types:
	event - { title, id, start, (end), whatever }
	location - { start, (end), allDay }
	rawEventRange - { start, end }
	eventRange - { start, end, isStart, isEnd }
	eventSpan - { start, end, isStart, isEnd, whatever }
	eventSeg - { event, whatever }
	seg - { whatever }
*/

Grid.mixin({

	// self-config, overridable by subclasses
	segSelector: '.fc-event-container > *', // what constitutes an event element?

	mousedOverSeg: null, // the segment object the user's mouse is over. null if over nothing
	isDraggingSeg: false, // is a segment being dragged? boolean
	isResizingSeg: false, // is a segment being resized? boolean
	isDraggingExternal: false, // jqui-dragging an external element? boolean
	segs: null, // the *event* segments currently rendered in the grid. TODO: rename to `eventSegs`


	// Renders the given events onto the grid
	renderEvents: function(events) {
		var bgEvents = [];
		var fgEvents = [];
		var i;

		for (i = 0; i < events.length; i++) {
			(isBgEvent(events[i]) ? bgEvents : fgEvents).push(events[i]);
		}

		this.segs = [].concat( // record all segs
			this.renderBgEvents(bgEvents),
			this.renderFgEvents(fgEvents)
		);
	},


	renderBgEvents: function(events) {
		var segs = this.eventsToSegs(events);

		// renderBgSegs might return a subset of segs, segs that were actually rendered
		return this.renderBgSegs(segs) || segs;
	},


	renderFgEvents: function(events) {
		var segs = this.eventsToSegs(events);

		// renderFgSegs might return a subset of segs, segs that were actually rendered
		return this.renderFgSegs(segs) || segs;
	},


	// Unrenders all events currently rendered on the grid
	unrenderEvents: function() {
		this.handleSegMouseout(); // trigger an eventMouseout if user's mouse is over an event
		this.clearDragListeners();

		this.unrenderFgSegs();
		this.unrenderBgSegs();

		this.segs = null;
	},


	// Retrieves all rendered segment objects currently rendered on the grid
	getEventSegs: function() {
		return this.segs || [];
	},


	/* Foreground Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Renders foreground event segments onto the grid. May return a subset of segs that were rendered.
	renderFgSegs: function(segs) {
		// subclasses must implement
	},


	// Unrenders all currently rendered foreground segments
	unrenderFgSegs: function() {
		// subclasses must implement
	},


	// Renders and assigns an `el` property for each foreground event segment.
	// Only returns segments that successfully rendered.
	// A utility that subclasses may use.
	renderFgSegEls: function(segs, disableResizing) {
		var view = this.view;
		var html = '';
		var renderedSegs = [];
		var i;

		if (segs.length) { // don't build an empty html string

			// build a large concatenation of event segment HTML
			for (i = 0; i < segs.length; i++) {
				html += this.fgSegHtml(segs[i], disableResizing);
			}

			// Grab individual elements from the combined HTML string. Use each as the default rendering.
			// Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
			$(html).each(function(i, node) {
				var seg = segs[i];
				var el = view.resolveEventEl(seg.event, $(node));

				if (el) {
					el.data('fc-seg', seg); // used by handlers
					seg.el = el;
					renderedSegs.push(seg);
				}
			});
		}

		return renderedSegs;
	},


	// Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
	fgSegHtml: function(seg, disableResizing) {
		// subclasses should implement
	},


	/* Background Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Renders the given background event segments onto the grid.
	// Returns a subset of the segs that were actually rendered.
	renderBgSegs: function(segs) {
		return this.renderFill('bgEvent', segs);
	},


	// Unrenders all the currently rendered background event segments
	unrenderBgSegs: function() {
		this.unrenderFill('bgEvent');
	},


	// Renders a background event element, given the default rendering. Called by the fill system.
	bgEventSegEl: function(seg, el) {
		return this.view.resolveEventEl(seg.event, el); // will filter through eventRender
	},


	// Generates an array of classNames to be used for the default rendering of a background event.
	// Called by fillSegHtml.
	bgEventSegClasses: function(seg) {
		var event = seg.event;
		var source = event.source || {};

		return [ 'fc-bgevent' ].concat(
			event.className,
			source.className || []
		);
	},


	// Generates a semicolon-separated CSS string to be used for the default rendering of a background event.
	// Called by fillSegHtml.
	bgEventSegCss: function(seg) {
		return {
			'background-color': this.getSegSkinCss(seg)['background-color']
		};
	},


	// Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.
	// Called by fillSegHtml.
	businessHoursSegClasses: function(seg) {
		return [ 'fc-nonbusiness', 'fc-bgevent' ];
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	// Compute business hour segs for the grid's current date range.
	// Caller must ask if whole-day business hours are needed.
	// If no `businessHours` configuration value is specified, assumes the calendar default.
	buildBusinessHourSegs: function(wholeDay, businessHours) {
		return this.eventsToSegs(
			this.buildBusinessHourEvents(wholeDay, businessHours)
		);
	},


	// Compute business hour *events* for the grid's current date range.
	// Caller must ask if whole-day business hours are needed.
	// If no `businessHours` configuration value is specified, assumes the calendar default.
	buildBusinessHourEvents: function(wholeDay, businessHours) {
		var calendar = this.view.calendar;
		var events;

		if (businessHours == null) {
			// fallback
			// access from calendawr. don't access from view. doesn't update with dynamic options.
			businessHours = calendar.opt('businessHours');
		}

		events = calendar.computeBusinessHourEvents(wholeDay, businessHours);

		// HACK. Eventually refactor business hours "events" system.
		// If no events are given, but businessHours is activated, this means the entire visible range should be
		// marked as *not* business-hours, via inverse-background rendering.
		if (!events.length && businessHours) {
			events = [
				$.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, {
					start: this.view.activeRange.end, // guaranteed out-of-range
					end: this.view.activeRange.end,   // "
					dow: null
				})
			];
		}

		return events;
	},


	/* Handlers
	------------------------------------------------------------------------------------------------------------------*/


	// Attaches event-element-related handlers for *all* rendered event segments of the view.
	bindSegHandlers: function() {
		this.bindSegHandlersToEl(this.el);
	},


	// Attaches event-element-related handlers to an arbitrary container element. leverages bubbling.
	bindSegHandlersToEl: function(el) {
		this.bindSegHandlerToEl(el, 'touchstart', this.handleSegTouchStart);
		this.bindSegHandlerToEl(el, 'mouseenter', this.handleSegMouseover);
		this.bindSegHandlerToEl(el, 'mouseleave', this.handleSegMouseout);
		this.bindSegHandlerToEl(el, 'mousedown', this.handleSegMousedown);
		this.bindSegHandlerToEl(el, 'click', this.handleSegClick);
	},


	// Executes a handler for any a user-interaction on a segment.
	// Handler gets called with (seg, ev), and with the `this` context of the Grid
	bindSegHandlerToEl: function(el, name, handler) {
		var _this = this;

		el.on(name, this.segSelector, function(ev) {
			var seg = $(this).data('fc-seg'); // grab segment data. put there by View::renderEvents

			// only call the handlers if there is not a drag/resize in progress
			if (seg && !_this.isDraggingSeg && !_this.isResizingSeg) {
				return handler.call(_this, seg, ev); // context will be the Grid
			}
		});
	},


	handleSegClick: function(seg, ev) {
		var res = this.view.publiclyTrigger('eventClick', seg.el[0], seg.event, ev); // can return `false` to cancel
		if (res === false) {
			ev.preventDefault();
		}
	},


	// Updates internal state and triggers handlers for when an event element is moused over
	handleSegMouseover: function(seg, ev) {
		if (
			!GlobalEmitter.get().shouldIgnoreMouse() &&
			!this.mousedOverSeg
		) {
			this.mousedOverSeg = seg;
			if (this.view.isEventResizable(seg.event)) {
				seg.el.addClass('fc-allow-mouse-resize');
			}
			this.view.publiclyTrigger('eventMouseover', seg.el[0], seg.event, ev);
		}
	},


	// Updates internal state and triggers handlers for when an event element is moused out.
	// Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
	handleSegMouseout: function(seg, ev) {
		ev = ev || {}; // if given no args, make a mock mouse event

		if (this.mousedOverSeg) {
			seg = seg || this.mousedOverSeg; // if given no args, use the currently moused-over segment
			this.mousedOverSeg = null;
			if (this.view.isEventResizable(seg.event)) {
				seg.el.removeClass('fc-allow-mouse-resize');
			}
			this.view.publiclyTrigger('eventMouseout', seg.el[0], seg.event, ev);
		}
	},


	handleSegMousedown: function(seg, ev) {
		var isResizing = this.startSegResize(seg, ev, { distance: 5 });

		if (!isResizing && this.view.isEventDraggable(seg.event)) {
			this.buildSegDragListener(seg)
				.startInteraction(ev, {
					distance: 5
				});
		}
	},


	handleSegTouchStart: function(seg, ev) {
		var view = this.view;
		var event = seg.event;
		var isSelected = view.isEventSelected(event);
		var isDraggable = view.isEventDraggable(event);
		var isResizable = view.isEventResizable(event);
		var isResizing = false;
		var dragListener;
		var eventLongPressDelay;

		if (isSelected && isResizable) {
			// only allow resizing of the event is selected
			isResizing = this.startSegResize(seg, ev);
		}

		if (!isResizing && (isDraggable || isResizable)) { // allowed to be selected?

			eventLongPressDelay = view.opt('eventLongPressDelay');
			if (eventLongPressDelay == null) {
				eventLongPressDelay = view.opt('longPressDelay'); // fallback
			}

			dragListener = isDraggable ?
				this.buildSegDragListener(seg) :
				this.buildSegSelectListener(seg); // seg isn't draggable, but still needs to be selected

			dragListener.startInteraction(ev, { // won't start if already started
				delay: isSelected ? 0 : eventLongPressDelay // do delay if not already selected
			});
		}
	},


	// returns boolean whether resizing actually started or not.
	// assumes the seg allows resizing.
	// `dragOptions` are optional.
	startSegResize: function(seg, ev, dragOptions) {
		if ($(ev.target).is('.fc-resizer')) {
			this.buildSegResizeListener(seg, $(ev.target).is('.fc-start-resizer'))
				.startInteraction(ev, dragOptions);
			return true;
		}
		return false;
	},



	/* Event Dragging
	------------------------------------------------------------------------------------------------------------------*/


	// Builds a listener that will track user-dragging on an event segment.
	// Generic enough to work with any type of Grid.
	// Has side effect of setting/unsetting `segDragListener`
	buildSegDragListener: function(seg) {
		var _this = this;
		var view = this.view;
		var el = seg.el;
		var event = seg.event;
		var isDragging;
		var mouseFollower; // A clone of the original element that will move with the mouse
		var dropLocation; // zoned event date properties

		if (this.segDragListener) {
			return this.segDragListener;
		}

		// Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents
		// of the view.
		var dragListener = this.segDragListener = new HitDragListener(view, {
			scroll: view.opt('dragScroll'),
			subjectEl: el,
			subjectCenter: true,
			interactionStart: function(ev) {
				seg.component = _this; // for renderDrag
				isDragging = false;
				mouseFollower = new MouseFollower(seg.el, {
					additionalClass: 'fc-dragging',
					parentEl: view.el,
					opacity: dragListener.isTouch ? null : view.opt('dragOpacity'),
					revertDuration: view.opt('dragRevertDuration'),
					zIndex: 2 // one above the .fc-view
				});
				mouseFollower.hide(); // don't show until we know this is a real drag
				mouseFollower.start(ev);
			},
			dragStart: function(ev) {
				if (dragListener.isTouch && !view.isEventSelected(event)) {
					// if not previously selected, will fire after a delay. then, select the event
					view.selectEvent(event);
				}
				isDragging = true;
				_this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
				_this.segDragStart(seg, ev);
				view.hideEvent(event); // hide all event segments. our mouseFollower will take over
			},
			hitOver: function(hit, isOrig, origHit) {
				var isAllowed = true;
				var origHitSpan;
				var hitSpan;
				var dragHelperEls;

				// starting hit could be forced (DayGrid.limit)
				if (seg.hit) {
					origHit = seg.hit;
				}

				// hit might not belong to this grid, so query origin grid
				origHitSpan = origHit.component.getSafeHitSpan(origHit);
				hitSpan = hit.component.getSafeHitSpan(hit);

				if (origHitSpan && hitSpan) {
					dropLocation = _this.computeEventDrop(origHitSpan, hitSpan, event);
					isAllowed = dropLocation && _this.isEventLocationAllowed(dropLocation, event);
				}
				else {
					isAllowed = false;
				}

				if (!isAllowed) {
					dropLocation = null;
					disableCursor();
				}

				// if a valid drop location, have the subclass render a visual indication
				if (dropLocation && (dragHelperEls = view.renderDrag(dropLocation, seg))) {

					dragHelperEls.addClass('fc-dragging');
					if (!dragListener.isTouch) {
						_this.applyDragOpacity(dragHelperEls);
					}

					mouseFollower.hide(); // if the subclass is already using a mock event "helper", hide our own
				}
				else {
					mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)
				}

				if (isOrig) {
					dropLocation = null; // needs to have moved hits to be a valid drop
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				view.unrenderDrag(); // unrender whatever was done in renderDrag
				mouseFollower.show(); // show in case we are moving out of all hits
				dropLocation = null;
			},
			hitDone: function() { // Called after a hitOut OR before a dragEnd
				enableCursor();
			},
			interactionEnd: function(ev) {
				delete seg.component; // prevent side effects

				// do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
				mouseFollower.stop(!dropLocation, function() {
					if (isDragging) {
						view.unrenderDrag();
						_this.segDragStop(seg, ev);
					}

					if (dropLocation) {
						// no need to re-show original, will rerender all anyways. esp important if eventRenderWait
						view.reportSegDrop(seg, dropLocation, _this.largeUnit, el, ev);
					}
					else {
						view.showEvent(event);
					}
				});
				_this.segDragListener = null;
			}
		});

		return dragListener;
	},


	// seg isn't draggable, but let's use a generic DragListener
	// simply for the delay, so it can be selected.
	// Has side effect of setting/unsetting `segDragListener`
	buildSegSelectListener: function(seg) {
		var _this = this;
		var view = this.view;
		var event = seg.event;

		if (this.segDragListener) {
			return this.segDragListener;
		}

		var dragListener = this.segDragListener = new DragListener({
			dragStart: function(ev) {
				if (dragListener.isTouch && !view.isEventSelected(event)) {
					// if not previously selected, will fire after a delay. then, select the event
					view.selectEvent(event);
				}
			},
			interactionEnd: function(ev) {
				_this.segDragListener = null;
			}
		});

		return dragListener;
	},


	// Called before event segment dragging starts
	segDragStart: function(seg, ev) {
		this.isDraggingSeg = true;
		this.view.publiclyTrigger('eventDragStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Called after event segment dragging stops
	segDragStop: function(seg, ev) {
		this.isDraggingSeg = false;
		this.view.publiclyTrigger('eventDragStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Given the spans an event drag began, and the span event was dropped, calculates the new zoned start/end/allDay
	// values for the event. Subclasses may override and set additional properties to be used by renderDrag.
	// A falsy returned value indicates an invalid drop.
	// DOES NOT consider overlap/constraint.
	computeEventDrop: function(startSpan, endSpan, event) {
		var calendar = this.view.calendar;
		var dragStart = startSpan.start;
		var dragEnd = endSpan.start;
		var delta;
		var dropLocation; // zoned event date properties

		if (dragStart.hasTime() === dragEnd.hasTime()) {
			delta = this.diffDates(dragEnd, dragStart);

			// if an all-day event was in a timed area and it was dragged to a different time,
			// guarantee an end and adjust start/end to have times
			if (event.allDay && durationHasTime(delta)) {
				dropLocation = {
					start: event.start.clone(),
					end: calendar.getEventEnd(event), // will be an ambig day
					allDay: false // for normalizeEventTimes
				};
				calendar.normalizeEventTimes(dropLocation);
			}
			// othewise, work off existing values
			else {
				dropLocation = pluckEventDateProps(event);
			}

			dropLocation.start.add(delta);
			if (dropLocation.end) {
				dropLocation.end.add(delta);
			}
		}
		else {
			// if switching from day <-> timed, start should be reset to the dropped date, and the end cleared
			dropLocation = {
				start: dragEnd.clone(),
				end: null, // end should be cleared
				allDay: !dragEnd.hasTime()
			};
		}

		return dropLocation;
	},


	// Utility for apply dragOpacity to a jQuery set
	applyDragOpacity: function(els) {
		var opacity = this.view.opt('dragOpacity');

		if (opacity != null) {
			els.css('opacity', opacity);
		}
	},


	/* External Element Dragging
	------------------------------------------------------------------------------------------------------------------*/


	// Called when a jQuery UI drag is initiated anywhere in the DOM
	externalDragStart: function(ev, ui) {
		var view = this.view;
		var el;
		var accept;

		if (view.opt('droppable')) { // only listen if this setting is on
			el = $((ui ? ui.item : null) || ev.target);

			// Test that the dragged element passes the dropAccept selector or filter function.
			// FYI, the default is "*" (matches all)
			accept = view.opt('dropAccept');
			if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
				if (!this.isDraggingExternal) { // prevent double-listening if fired twice
					this.listenToExternalDrag(el, ev, ui);
				}
			}
		}
	},


	// Called when a jQuery UI drag starts and it needs to be monitored for dropping
	listenToExternalDrag: function(el, ev, ui) {
		var _this = this;
		var view = this.view;
		var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create
		var dropLocation; // a null value signals an unsuccessful drag

		// listener that tracks mouse movement over date-associated pixel regions
		var dragListener = _this.externalDragListener = new HitDragListener(this, {
			interactionStart: function() {
				_this.isDraggingExternal = true;
			},
			hitOver: function(hit) {
				var isAllowed = true;
				var hitSpan = hit.component.getSafeHitSpan(hit); // hit might not belong to this grid

				if (hitSpan) {
					dropLocation = _this.computeExternalDrop(hitSpan, meta);
					isAllowed = dropLocation && _this.isExternalLocationAllowed(dropLocation, meta.eventProps);
				}
				else {
					isAllowed = false;
				}

				if (!isAllowed) {
					dropLocation = null;
					disableCursor();
				}

				if (dropLocation) {
					_this.renderDrag(dropLocation); // called without a seg parameter
				}
			},
			hitOut: function() {
				dropLocation = null; // signal unsuccessful
			},
			hitDone: function() { // Called after a hitOut OR before a dragEnd
				enableCursor();
				_this.unrenderDrag();
			},
			interactionEnd: function(ev) {
				if (dropLocation) { // element was dropped on a valid hit
					view.reportExternalDrop(meta, dropLocation, el, ev, ui);
				}
				_this.isDraggingExternal = false;
				_this.externalDragListener = null;
			}
		});

		dragListener.startDrag(ev); // start listening immediately
	},


	// Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
	// returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.
	// Returning a null value signals an invalid drop hit.
	// DOES NOT consider overlap/constraint.
	computeExternalDrop: function(span, meta) {
		var calendar = this.view.calendar;
		var dropLocation = {
			start: calendar.applyTimezone(span.start), // simulate a zoned event start date
			end: null
		};

		// if dropped on an all-day span, and element's metadata specified a time, set it
		if (meta.startTime && !dropLocation.start.hasTime()) {
			dropLocation.start.time(meta.startTime);
		}

		if (meta.duration) {
			dropLocation.end = dropLocation.start.clone().add(meta.duration);
		}

		return dropLocation;
	},



	/* Drag Rendering (for both events and an external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event or external element being dragged.
	// `dropLocation` contains hypothetical start/end/allDay values the event would have if dropped. end can be null.
	// `seg` is the internal segment object that is being dragged. If dragging an external element, `seg` is null.
	// A truthy returned value indicates this method has rendered a helper element.
	// Must return elements used for any mock events.
	renderDrag: function(dropLocation, seg) {
		// subclasses must implement
	},


	// Unrenders a visual indication of an event or external element being dragged
	unrenderDrag: function() {
		// subclasses must implement
	},


	/* Resizing
	------------------------------------------------------------------------------------------------------------------*/


	// Creates a listener that tracks the user as they resize an event segment.
	// Generic enough to work with any type of Grid.
	buildSegResizeListener: function(seg, isStart) {
		var _this = this;
		var view = this.view;
		var calendar = view.calendar;
		var el = seg.el;
		var event = seg.event;
		var eventEnd = calendar.getEventEnd(event);
		var isDragging;
		var resizeLocation; // zoned event date properties. falsy if invalid resize

		// Tracks mouse movement over the *grid's* coordinate map
		var dragListener = this.segResizeListener = new HitDragListener(this, {
			scroll: view.opt('dragScroll'),
			subjectEl: el,
			interactionStart: function() {
				isDragging = false;
			},
			dragStart: function(ev) {
				isDragging = true;
				_this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
				_this.segResizeStart(seg, ev);
			},
			hitOver: function(hit, isOrig, origHit) {
				var isAllowed = true;
				var origHitSpan = _this.getSafeHitSpan(origHit);
				var hitSpan = _this.getSafeHitSpan(hit);

				if (origHitSpan && hitSpan) {
					resizeLocation = isStart ?
						_this.computeEventStartResize(origHitSpan, hitSpan, event) :
						_this.computeEventEndResize(origHitSpan, hitSpan, event);

					isAllowed = resizeLocation && _this.isEventLocationAllowed(resizeLocation, event);
				}
				else {
					isAllowed = false;
				}

				if (!isAllowed) {
					resizeLocation = null;
					disableCursor();
				}
				else {
					if (
						resizeLocation.start.isSame(event.start.clone().stripZone()) &&
						resizeLocation.end.isSame(eventEnd.clone().stripZone())
					) {
						// no change. (FYI, event dates might have zones)
						resizeLocation = null;
					}
				}

				if (resizeLocation) {
					view.hideEvent(event);
					_this.renderEventResize(resizeLocation, seg);
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				resizeLocation = null;
				view.showEvent(event); // for when out-of-bounds. show original
			},
			hitDone: function() { // resets the rendering to show the original event
				_this.unrenderEventResize();
				enableCursor();
			},
			interactionEnd: function(ev) {
				if (isDragging) {
					_this.segResizeStop(seg, ev);
				}

				if (resizeLocation) { // valid date to resize to?
					// no need to re-show original, will rerender all anyways. esp important if eventRenderWait
					view.reportSegResize(seg, resizeLocation, _this.largeUnit, el, ev);
				}
				else {
					view.showEvent(event);
				}
				_this.segResizeListener = null;
			}
		});

		return dragListener;
	},


	// Called before event segment resizing starts
	segResizeStart: function(seg, ev) {
		this.isResizingSeg = true;
		this.view.publiclyTrigger('eventResizeStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Called after event segment resizing stops
	segResizeStop: function(seg, ev) {
		this.isResizingSeg = false;
		this.view.publiclyTrigger('eventResizeStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Returns new date-information for an event segment being resized from its start
	computeEventStartResize: function(startSpan, endSpan, event) {
		return this.computeEventResize('start', startSpan, endSpan, event);
	},


	// Returns new date-information for an event segment being resized from its end
	computeEventEndResize: function(startSpan, endSpan, event) {
		return this.computeEventResize('end', startSpan, endSpan, event);
	},


	// Returns new zoned date information for an event segment being resized from its start OR end
	// `type` is either 'start' or 'end'.
	// DOES NOT consider overlap/constraint.
	computeEventResize: function(type, startSpan, endSpan, event) {
		var calendar = this.view.calendar;
		var delta = this.diffDates(endSpan[type], startSpan[type]);
		var resizeLocation; // zoned event date properties
		var defaultDuration;

		// build original values to work from, guaranteeing a start and end
		resizeLocation = {
			start: event.start.clone(),
			end: calendar.getEventEnd(event),
			allDay: event.allDay
		};

		// if an all-day event was in a timed area and was resized to a time, adjust start/end to have times
		if (resizeLocation.allDay && durationHasTime(delta)) {
			resizeLocation.allDay = false;
			calendar.normalizeEventTimes(resizeLocation);
		}

		resizeLocation[type].add(delta); // apply delta to start or end

		// if the event was compressed too small, find a new reasonable duration for it
		if (!resizeLocation.start.isBefore(resizeLocation.end)) {

			defaultDuration =
				this.minResizeDuration || // TODO: hack
				(event.allDay ?
					calendar.defaultAllDayEventDuration :
					calendar.defaultTimedEventDuration);

			if (type == 'start') { // resizing the start?
				resizeLocation.start = resizeLocation.end.clone().subtract(defaultDuration);
			}
			else { // resizing the end?
				resizeLocation.end = resizeLocation.start.clone().add(defaultDuration);
			}
		}

		return resizeLocation;
	},


	// Renders a visual indication of an event being resized.
	// `range` has the updated dates of the event. `seg` is the original segment object involved in the drag.
	// Must return elements used for any mock events.
	renderEventResize: function(range, seg) {
		// subclasses must implement
	},


	// Unrenders a visual indication of an event being resized.
	unrenderEventResize: function() {
		// subclasses must implement
	},


	/* Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Compute the text that should be displayed on an event's element.
	// `range` can be the Event object itself, or something range-like, with at least a `start`.
	// If event times are disabled, or the event has no time, will return a blank string.
	// If not specified, formatStr will default to the eventTimeFormat setting,
	// and displayEnd will default to the displayEventEnd setting.
	getEventTimeText: function(range, formatStr, displayEnd) {

		if (formatStr == null) {
			formatStr = this.eventTimeFormat;
		}

		if (displayEnd == null) {
			displayEnd = this.displayEventEnd;
		}

		if (this.displayEventTime && range.start.hasTime()) {
			if (displayEnd && range.end) {
				return this.view.formatRange(range, formatStr);
			}
			else {
				return range.start.format(formatStr);
			}
		}

		return '';
	},


	// Generic utility for generating the HTML classNames for an event segment's element
	getSegClasses: function(seg, isDraggable, isResizable) {
		var view = this.view;
		var classes = [
			'fc-event',
			seg.isStart ? 'fc-start' : 'fc-not-start',
			seg.isEnd ? 'fc-end' : 'fc-not-end'
		].concat(this.getSegCustomClasses(seg));

		if (isDraggable) {
			classes.push('fc-draggable');
		}
		if (isResizable) {
			classes.push('fc-resizable');
		}

		// event is currently selected? attach a className.
		if (view.isEventSelected(seg.event)) {
			classes.push('fc-selected');
		}

		return classes;
	},


	// List of classes that were defined by the caller of the API in some way
	getSegCustomClasses: function(seg) {
		var event = seg.event;

		return [].concat(
			event.className, // guaranteed to be an array
			event.source ? event.source.className : []
		);
	},


	// Utility for generating event skin-related CSS properties
	getSegSkinCss: function(seg) {
		return {
			'background-color': this.getSegBackgroundColor(seg),
			'border-color': this.getSegBorderColor(seg),
			color: this.getSegTextColor(seg)
		};
	},


	// Queries for caller-specified color, then falls back to default
	getSegBackgroundColor: function(seg) {
		return seg.event.backgroundColor ||
			seg.event.color ||
			this.getSegDefaultBackgroundColor(seg);
	},


	getSegDefaultBackgroundColor: function(seg) {
		var source = seg.event.source || {};

		return source.backgroundColor ||
			source.color ||
			this.view.opt('eventBackgroundColor') ||
			this.view.opt('eventColor');
	},


	// Queries for caller-specified color, then falls back to default
	getSegBorderColor: function(seg) {
		return seg.event.borderColor ||
			seg.event.color ||
			this.getSegDefaultBorderColor(seg);
	},


	getSegDefaultBorderColor: function(seg) {
		var source = seg.event.source || {};

		return source.borderColor ||
			source.color ||
			this.view.opt('eventBorderColor') ||
			this.view.opt('eventColor');
	},


	// Queries for caller-specified color, then falls back to default
	getSegTextColor: function(seg) {
		return seg.event.textColor ||
			this.getSegDefaultTextColor(seg);
	},


	getSegDefaultTextColor: function(seg) {
		var source = seg.event.source || {};

		return source.textColor ||
			this.view.opt('eventTextColor');
	},


	/* Event Location Validation
	------------------------------------------------------------------------------------------------------------------*/


	isEventLocationAllowed: function(eventLocation, event) {
		if (this.isEventLocationInRange(eventLocation)) {
			var calendar = this.view.calendar;
			var eventSpans = this.eventToSpans(eventLocation);
			var i;

			if (eventSpans.length) {
				for (i = 0; i < eventSpans.length; i++) {
					if (!calendar.isEventSpanAllowed(eventSpans[i], event)) {
						return false;
					}
				}

				return true;
			}
		}

		return false;
	},


	isExternalLocationAllowed: function(eventLocation, metaProps) { // FOR the external element
		if (this.isEventLocationInRange(eventLocation)) {
			var calendar = this.view.calendar;
			var eventSpans = this.eventToSpans(eventLocation);
			var i;

			if (eventSpans.length) {
				for (i = 0; i < eventSpans.length; i++) {
					if (!calendar.isExternalSpanAllowed(eventSpans[i], eventLocation, metaProps)) {
						return false;
					}
				}

				return true;
			}
		}

		return false;
	},


	isEventLocationInRange: function(eventLocation) {
		return isRangeWithinRange(
			this.eventToRawRange(eventLocation),
			this.view.validRange
		);
	},


	/* Converting events -> eventRange -> eventSpan -> eventSegs
	------------------------------------------------------------------------------------------------------------------*/


	// Generates an array of segments for the given single event
	// Can accept an event "location" as well (which only has start/end and no allDay)
	eventToSegs: function(event) {
		return this.eventsToSegs([ event ]);
	},


	// Generates spans (always unzoned) for the given event.
	// Does not do any inverting for inverse-background events.
	// Can accept an event "location" as well (which only has start/end and no allDay)
	eventToSpans: function(event) {
		var eventRange = this.eventToRange(event); // { start, end, isStart, isEnd }

		if (eventRange) {
			return this.eventRangeToSpans(eventRange, event);
		}
		else { // out of view's valid range
			return [];
		}
	},



	// Converts an array of event objects into an array of event segment objects.
	// A custom `segSliceFunc` may be given for arbitrarily slicing up events.
	// Doesn't guarantee an order for the resulting array.
	eventsToSegs: function(allEvents, segSliceFunc) {
		var _this = this;
		var eventsById = groupEventsById(allEvents);
		var segs = [];

		$.each(eventsById, function(id, events) {
			var visibleEvents = [];
			var eventRanges = [];
			var eventRange; // { start, end, isStart, isEnd }
			var i;

			for (i = 0; i < events.length; i++) {
				eventRange = _this.eventToRange(events[i]); // might be null if completely out of range

				if (eventRange) {
					eventRanges.push(eventRange);
					visibleEvents.push(events[i]);
				}
			}

			// inverse-background events (utilize only the first event in calculations)
			if (isInverseBgEvent(events[0])) {
				eventRanges = _this.invertRanges(eventRanges); // will lose isStart/isEnd

				for (i = 0; i < eventRanges.length; i++) {
					segs.push.apply(segs, // append to
						_this.eventRangeToSegs(eventRanges[i], events[0], segSliceFunc)
					);
				}
			}
			// normal event ranges
			else {
				for (i = 0; i < eventRanges.length; i++) {
					segs.push.apply(segs, // append to
						_this.eventRangeToSegs(eventRanges[i], visibleEvents[i], segSliceFunc)
					);
				}
			}
		});

		return segs;
	},


	// Generates the unzoned start/end dates an event appears to occupy
	// Can accept an event "location" as well (which only has start/end and no allDay)
	// returns { start, end, isStart, isEnd }
	// If the event is completely outside of the grid's valid range, will return undefined.
	eventToRange: function(event) {
		return this.refineRawEventRange(
			this.eventToRawRange(event)
		);
	},


	// Ensures the given range is within the view's activeRange and is correctly localized.
	// Always returns a result
	refineRawEventRange: function(rawRange) {
		var view = this.view;
		var calendar = view.calendar;
		var range = intersectRanges(rawRange, view.activeRange);

		if (range) { // otherwise, event doesn't have valid range

			// hack: dynamic locale change forgets to upate stored event localed
			calendar.localizeMoment(range.start);
			calendar.localizeMoment(range.end);

			return range;
		}
	},


	// not constrained to valid dates
	// not given localizeMoment hack
	eventToRawRange: function(event) {
		var calendar = this.view.calendar;
		var start = event.start.clone().stripZone();
		var end = (
				event.end ?
					event.end.clone() :
					// derive the end from the start and allDay. compute allDay if necessary
					calendar.getDefaultEventEnd(
						event.allDay != null ?
							event.allDay :
							!event.start.hasTime(),
						event.start
					)
			).stripZone();

		return { start: start, end: end };
	},


	// Given an event's range (unzoned start/end), and the event itself,
	// slice into segments (using the segSliceFunc function if specified)
	// eventRange - { start, end, isStart, isEnd }
	eventRangeToSegs: function(eventRange, event, segSliceFunc) {
		var eventSpans = this.eventRangeToSpans(eventRange, event);
		var segs = [];
		var i;

		for (i = 0; i < eventSpans.length; i++) {
			segs.push.apply(segs, // append to
				this.eventSpanToSegs(eventSpans[i], event, segSliceFunc)
			);
		}

		return segs;
	},


	// Given an event's unzoned date range, return an array of eventSpan objects.
	// eventSpan - { start, end, isStart, isEnd, otherthings... }
	// Subclasses can override.
	// Subclasses are obligated to forward eventRange.isStart/isEnd to the resulting spans.
	eventRangeToSpans: function(eventRange, event) {
		return [ $.extend({}, eventRange) ]; // copy into a single-item array
	},


	// Given an event's span (unzoned start/end and other misc data), and the event itself,
	// slices into segments and attaches event-derived properties to them.
	// eventSpan - { start, end, isStart, isEnd, otherthings... }
	eventSpanToSegs: function(eventSpan, event, segSliceFunc) {
		var segs = segSliceFunc ? segSliceFunc(eventSpan) : this.spanToSegs(eventSpan);
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];

			// the eventSpan's isStart/isEnd takes precedence over the seg's
			if (!eventSpan.isStart) {
				seg.isStart = false;
			}
			if (!eventSpan.isEnd) {
				seg.isEnd = false;
			}

			seg.event = event;
			seg.eventStartMS = +eventSpan.start; // TODO: not the best name after making spans unzoned
			seg.eventDurationMS = eventSpan.end - eventSpan.start;
		}

		return segs;
	},


	// Produces a new array of range objects that will cover all the time NOT covered by the given ranges.
	// SIDE EFFECT: will mutate the given array and will use its date references.
	invertRanges: function(ranges) {
		var view = this.view;
		var viewStart = view.activeRange.start.clone(); // need a copy
		var viewEnd = view.activeRange.end.clone(); // need a copy
		var inverseRanges = [];
		var start = viewStart; // the end of the previous range. the start of the new range
		var i, range;

		// ranges need to be in order. required for our date-walking algorithm
		ranges.sort(compareRanges);

		for (i = 0; i < ranges.length; i++) {
			range = ranges[i];

			// add the span of time before the event (if there is any)
			if (range.start > start) { // compare millisecond time (skip any ambig logic)
				inverseRanges.push({
					start: start,
					end: range.start
				});
			}

			if (range.end > start) {
				start = range.end;
			}
		}

		// add the span of time after the last event (if there is any)
		if (start < viewEnd) { // compare millisecond time (skip any ambig logic)
			inverseRanges.push({
				start: start,
				end: viewEnd
			});
		}

		return inverseRanges;
	},


	sortEventSegs: function(segs) {
		segs.sort(proxy(this, 'compareEventSegs'));
	},


	// A cmp function for determining which segments should take visual priority
	compareEventSegs: function(seg1, seg2) {
		return seg1.eventStartMS - seg2.eventStartMS || // earlier events go first
			seg2.eventDurationMS - seg1.eventDurationMS || // tie? longer events go first
			seg2.event.allDay - seg1.event.allDay || // tie? put all-day events first (booleans cast to 0/1)
			compareByFieldSpecs(seg1.event, seg2.event, this.view.eventOrderSpecs);
	}

});


/* Utilities
----------------------------------------------------------------------------------------------------------------------*/


function pluckEventDateProps(event) {
	return {
		start: event.start.clone(),
		end: event.end ? event.end.clone() : null,
		allDay: event.allDay // keep it the same
	};
}
FC.pluckEventDateProps = pluckEventDateProps;


function isBgEvent(event) { // returns true if background OR inverse-background
	var rendering = getEventRendering(event);
	return rendering === 'background' || rendering === 'inverse-background';
}
FC.isBgEvent = isBgEvent; // export


function isInverseBgEvent(event) {
	return getEventRendering(event) === 'inverse-background';
}


function getEventRendering(event) {
	return firstDefined((event.source || {}).rendering, event.rendering);
}


function groupEventsById(events) {
	var eventsById = {};
	var i, event;

	for (i = 0; i < events.length; i++) {
		event = events[i];
		(eventsById[event._id] || (eventsById[event._id] = [])).push(event);
	}

	return eventsById;
}


// A cmp function for determining which non-inverted "ranges" (see above) happen earlier
function compareRanges(range1, range2) {
	return range1.start - range2.start; // earlier ranges go first
}


/* External-Dragging-Element Data
----------------------------------------------------------------------------------------------------------------------*/

// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.
FC.dataAttrPrefix = '';

// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
function getDraggedElMeta(el) {
	var prefix = FC.dataAttrPrefix;
	var eventProps; // properties for creating the event, not related to date/time
	var startTime; // a Duration
	var duration;
	var stick;

	if (prefix) { prefix += '-'; }
	eventProps = el.data(prefix + 'event') || null;

	if (eventProps) {
		if (typeof eventProps === 'object') {
			eventProps = $.extend({}, eventProps); // make a copy
		}
		else { // something like 1 or true. still signal event creation
			eventProps = {};
		}

		// pluck special-cased date/time properties
		startTime = eventProps.start;
		if (startTime == null) { startTime = eventProps.time; } // accept 'time' as well
		duration = eventProps.duration;
		stick = eventProps.stick;
		delete eventProps.start;
		delete eventProps.time;
		delete eventProps.duration;
		delete eventProps.stick;
	}

	// fallback to standalone attribute values for each of the date/time properties
	if (startTime == null) { startTime = el.data(prefix + 'start'); }
	if (startTime == null) { startTime = el.data(prefix + 'time'); } // accept 'time' as well
	if (duration == null) { duration = el.data(prefix + 'duration'); }
	if (stick == null) { stick = el.data(prefix + 'stick'); }

	// massage into correct data types
	startTime = startTime != null ? moment.duration(startTime) : null;
	duration = duration != null ? moment.duration(duration) : null;
	stick = Boolean(stick);

	return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };
}


;;

/*
A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.
Prerequisite: the object being mixed into needs to be a *Grid*
*/
var DayTableMixin = FC.DayTableMixin = {

	breakOnWeeks: false, // should create a new row for each week?
	dayDates: null, // whole-day dates for each column. left to right
	dayIndices: null, // for each day from start, the offset
	daysPerRow: null,
	rowCnt: null,
	colCnt: null,
	colHeadFormat: null,


	// Populates internal variables used for date calculation and rendering
	updateDayTable: function() {
		var view = this.view;
		var date = this.start.clone();
		var dayIndex = -1;
		var dayIndices = [];
		var dayDates = [];
		var daysPerRow;
		var firstDay;
		var rowCnt;

		while (date.isBefore(this.end)) { // loop each day from start to end
			if (view.isHiddenDay(date)) {
				dayIndices.push(dayIndex + 0.5); // mark that it's between indices
			}
			else {
				dayIndex++;
				dayIndices.push(dayIndex);
				dayDates.push(date.clone());
			}
			date.add(1, 'days');
		}

		if (this.breakOnWeeks) {
			// count columns until the day-of-week repeats
			firstDay = dayDates[0].day();
			for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {
				if (dayDates[daysPerRow].day() == firstDay) {
					break;
				}
			}
			rowCnt = Math.ceil(dayDates.length / daysPerRow);
		}
		else {
			rowCnt = 1;
			daysPerRow = dayDates.length;
		}

		this.dayDates = dayDates;
		this.dayIndices = dayIndices;
		this.daysPerRow = daysPerRow;
		this.rowCnt = rowCnt;

		this.updateDayTableCols();
	},


	// Computes and assigned the colCnt property and updates any options that may be computed from it
	updateDayTableCols: function() {
		this.colCnt = this.computeColCnt();
		this.colHeadFormat = this.view.opt('columnFormat') || this.computeColHeadFormat();
	},


	// Determines how many columns there should be in the table
	computeColCnt: function() {
		return this.daysPerRow;
	},


	// Computes the ambiguously-timed moment for the given cell
	getCellDate: function(row, col) {
		return this.dayDates[
				this.getCellDayIndex(row, col)
			].clone();
	},


	// Computes the ambiguously-timed date range for the given cell
	getCellRange: function(row, col) {
		var start = this.getCellDate(row, col);
		var end = start.clone().add(1, 'days');

		return { start: start, end: end };
	},


	// Returns the number of day cells, chronologically, from the first of the grid (0-based)
	getCellDayIndex: function(row, col) {
		return row * this.daysPerRow + this.getColDayIndex(col);
	},


	// Returns the numner of day cells, chronologically, from the first cell in *any given row*
	getColDayIndex: function(col) {
		if (this.isRTL) {
			return this.colCnt - 1 - col;
		}
		else {
			return col;
		}
	},


	// Given a date, returns its chronolocial cell-index from the first cell of the grid.
	// If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
	// If before the first offset, returns a negative number.
	// If after the last offset, returns an offset past the last cell offset.
	// Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
	getDateDayIndex: function(date) {
		var dayIndices = this.dayIndices;
		var dayOffset = date.diff(this.start, 'days');

		if (dayOffset < 0) {
			return dayIndices[0] - 1;
		}
		else if (dayOffset >= dayIndices.length) {
			return dayIndices[dayIndices.length - 1] + 1;
		}
		else {
			return dayIndices[dayOffset];
		}
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Computes a default column header formatting string if `colFormat` is not explicitly defined
	computeColHeadFormat: function() {
		// if more than one week row, or if there are a lot of columns with not much space,
		// put just the day numbers will be in each cell
		if (this.rowCnt > 1 || this.colCnt > 10) {
			return 'ddd'; // "Sat"
		}
		// multiple days, so full single date string WON'T be in title text
		else if (this.colCnt > 1) {
			return this.view.opt('dayOfMonthFormat'); // "Sat 12/10"
		}
		// single day, so full single date string will probably be in title text
		else {
			return 'dddd'; // "Saturday"
		}
	},


	/* Slicing
	------------------------------------------------------------------------------------------------------------------*/


	// Slices up a date range into a segment for every week-row it intersects with
	sliceRangeByRow: function(range) {
		var daysPerRow = this.daysPerRow;
		var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
		var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
		var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
		var segs = [];
		var row;
		var rowFirst, rowLast; // inclusive day-index range for current row
		var segFirst, segLast; // inclusive day-index range for segment

		for (row = 0; row < this.rowCnt; row++) {
			rowFirst = row * daysPerRow;
			rowLast = rowFirst + daysPerRow - 1;

			// intersect segment's offset range with the row's
			segFirst = Math.max(rangeFirst, rowFirst);
			segLast = Math.min(rangeLast, rowLast);

			// deal with in-between indices
			segFirst = Math.ceil(segFirst); // in-between starts round to next cell
			segLast = Math.floor(segLast); // in-between ends round to prev cell

			if (segFirst <= segLast) { // was there any intersection with the current row?
				segs.push({
					row: row,

					// normalize to start of row
					firstRowDayIndex: segFirst - rowFirst,
					lastRowDayIndex: segLast - rowFirst,

					// must be matching integers to be the segment's start/end
					isStart: segFirst === rangeFirst,
					isEnd: segLast === rangeLast
				});
			}
		}

		return segs;
	},


	// Slices up a date range into a segment for every day-cell it intersects with.
	// TODO: make more DRY with sliceRangeByRow somehow.
	sliceRangeByDay: function(range) {
		var daysPerRow = this.daysPerRow;
		var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
		var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
		var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
		var segs = [];
		var row;
		var rowFirst, rowLast; // inclusive day-index range for current row
		var i;
		var segFirst, segLast; // inclusive day-index range for segment

		for (row = 0; row < this.rowCnt; row++) {
			rowFirst = row * daysPerRow;
			rowLast = rowFirst + daysPerRow - 1;

			for (i = rowFirst; i <= rowLast; i++) {

				// intersect segment's offset range with the row's
				segFirst = Math.max(rangeFirst, i);
				segLast = Math.min(rangeLast, i);

				// deal with in-between indices
				segFirst = Math.ceil(segFirst); // in-between starts round to next cell
				segLast = Math.floor(segLast); // in-between ends round to prev cell

				if (segFirst <= segLast) { // was there any intersection with the current row?
					segs.push({
						row: row,

						// normalize to start of row
						firstRowDayIndex: segFirst - rowFirst,
						lastRowDayIndex: segLast - rowFirst,

						// must be matching integers to be the segment's start/end
						isStart: segFirst === rangeFirst,
						isEnd: segLast === rangeLast
					});
				}
			}
		}

		return segs;
	},


	/* Header Rendering
	------------------------------------------------------------------------------------------------------------------*/


	renderHeadHtml: function() {
		var view = this.view;

		return '' +
			'<div class="fc-row ' + view.widgetHeaderClass + '">' +
				'<table>' +
					'<thead>' +
						this.renderHeadTrHtml() +
					'</thead>' +
				'</table>' +
			'</div>';
	},


	renderHeadIntroHtml: function() {
		return this.renderIntroHtml(); // fall back to generic
	},


	renderHeadTrHtml: function() {
		return '' +
			'<tr>' +
				(this.isRTL ? '' : this.renderHeadIntroHtml()) +
				this.renderHeadDateCellsHtml() +
				(this.isRTL ? this.renderHeadIntroHtml() : '') +
			'</tr>';
	},


	renderHeadDateCellsHtml: function() {
		var htmls = [];
		var col, date;

		for (col = 0; col < this.colCnt; col++) {
			date = this.getCellDate(0, col);
			htmls.push(this.renderHeadDateCellHtml(date));
		}

		return htmls.join('');
	},


	// TODO: when internalApiVersion, accept an object for HTML attributes
	// (colspan should be no different)
	renderHeadDateCellHtml: function(date, colspan, otherAttrs) {
		var view = this.view;
		var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.
		var classNames = [
			'fc-day-header',
			view.widgetHeaderClass
		];
		var innerHtml = htmlEscape(date.format(this.colHeadFormat));

		// if only one row of days, the classNames on the header can represent the specific days beneath
		if (this.rowCnt === 1) {
			classNames = classNames.concat(
				// includes the day-of-week class
				// noThemeHighlight=true (don't highlight the header)
				this.getDayClasses(date, true)
			);
		}
		else {
			classNames.push('fc-' + dayIDs[date.day()]); // only add the day-of-week class
		}

		return '' +
            '<th class="' + classNames.join(' ') + '"' +
				((isDateValid && this.rowCnt) === 1 ?
					' data-date="' + date.format('YYYY-MM-DD') + '"' :
					'') +
				(colspan > 1 ?
					' colspan="' + colspan + '"' :
					'') +
				(otherAttrs ?
					' ' + otherAttrs :
					'') +
				'>' +
				(isDateValid ?
					// don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)
					view.buildGotoAnchorHtml(
						{ date: date, forceOff: this.rowCnt > 1 || this.colCnt === 1 },
						innerHtml
					) :
					// if not valid, display text, but no link
					innerHtml
				) +
			'</th>';
	},


	/* Background Rendering
	------------------------------------------------------------------------------------------------------------------*/


	renderBgTrHtml: function(row) {
		return '' +
			'<tr>' +
				(this.isRTL ? '' : this.renderBgIntroHtml(row)) +
				this.renderBgCellsHtml(row) +
				(this.isRTL ? this.renderBgIntroHtml(row) : '') +
			'</tr>';
	},


	renderBgIntroHtml: function(row) {
		return this.renderIntroHtml(); // fall back to generic
	},


	renderBgCellsHtml: function(row) {
		var htmls = [];
		var col, date;

		for (col = 0; col < this.colCnt; col++) {
			date = this.getCellDate(row, col);
			htmls.push(this.renderBgCellHtml(date));
		}

		return htmls.join('');
	},


	renderBgCellHtml: function(date, otherAttrs) {
		var view = this.view;
		var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.
		var classes = this.getDayClasses(date);

		classes.unshift('fc-day', view.widgetContentClass);

		return '<td class="' + classes.join(' ') + '"' +
			(isDateValid ?
				' data-date="' + date.format('YYYY-MM-DD') + '"' : // if date has a time, won't format it
				'') +
			(otherAttrs ?
				' ' + otherAttrs :
				'') +
			'></td>';
	},


	/* Generic
	------------------------------------------------------------------------------------------------------------------*/


	// Generates the default HTML intro for any row. User classes should override
	renderIntroHtml: function() {
	},


	// TODO: a generic method for dealing with <tr>, RTL, intro
	// when increment internalApiVersion
	// wrapTr (scheduler)


	/* Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Applies the generic "intro" and "outro" HTML to the given cells.
	// Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
	bookendCells: function(trEl) {
		var introHtml = this.renderIntroHtml();

		if (introHtml) {
			if (this.isRTL) {
				trEl.append(introHtml);
			}
			else {
				trEl.prepend(introHtml);
			}
		}
	}

};

;;

/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
----------------------------------------------------------------------------------------------------------------------*/

var DayGrid = FC.DayGrid = Grid.extend(DayTableMixin, {

	numbersVisible: false, // should render a row for day/week numbers? set by outside view. TODO: make internal
	bottomCoordPadding: 0, // hack for extending the hit area for the last row of the coordinate grid

	rowEls: null, // set of fake row elements
	cellEls: null, // set of whole-day elements comprising the row's background
	helperEls: null, // set of cell skeleton elements for rendering the mock event "helper"

	rowCoordCache: null,
	colCoordCache: null,


	// Renders the rows and columns into the component's `this.el`, which should already be assigned.
	// isRigid determins whether the individual rows should ignore the contents and be a constant height.
	// Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
	renderDates: function(isRigid) {
		var view = this.view;
		var rowCnt = this.rowCnt;
		var colCnt = this.colCnt;
		var html = '';
		var row;
		var col;

		for (row = 0; row < rowCnt; row++) {
			html += this.renderDayRowHtml(row, isRigid);
		}
		this.el.html(html);

		this.rowEls = this.el.find('.fc-row');
		this.cellEls = this.el.find('.fc-day, .fc-disabled-day');

		this.rowCoordCache = new CoordCache({
			els: this.rowEls,
			isVertical: true
		});
		this.colCoordCache = new CoordCache({
			els: this.cellEls.slice(0, this.colCnt), // only the first row
			isHorizontal: true
		});

		// trigger dayRender with each cell's element
		for (row = 0; row < rowCnt; row++) {
			for (col = 0; col < colCnt; col++) {
				view.publiclyTrigger(
					'dayRender',
					null,
					this.getCellDate(row, col),
					this.getCellEl(row, col)
				);
			}
		}
	},


	unrenderDates: function() {
		this.removeSegPopover();
	},


	renderBusinessHours: function() {
		var segs = this.buildBusinessHourSegs(true); // wholeDay=true
		this.renderFill('businessHours', segs, 'bgevent');
	},


	unrenderBusinessHours: function() {
		this.unrenderFill('businessHours');
	},


	// Generates the HTML for a single row, which is a div that wraps a table.
	// `row` is the row number.
	renderDayRowHtml: function(row, isRigid) {
		var view = this.view;
		var classes = [ 'fc-row', 'fc-week', view.widgetContentClass ];

		if (isRigid) {
			classes.push('fc-rigid');
		}

		return '' +
			'<div class="' + classes.join(' ') + '">' +
				'<div class="fc-bg">' +
					'<table>' +
						this.renderBgTrHtml(row) +
					'</table>' +
				'</div>' +
				'<div class="fc-content-skeleton">' +
					'<table>' +
						(this.numbersVisible ?
							'<thead>' +
								this.renderNumberTrHtml(row) +
							'</thead>' :
							''
							) +
					'</table>' +
				'</div>' +
			'</div>';
	},


	/* Grid Number Rendering
	------------------------------------------------------------------------------------------------------------------*/


	renderNumberTrHtml: function(row) {
		return '' +
			'<tr>' +
				(this.isRTL ? '' : this.renderNumberIntroHtml(row)) +
				this.renderNumberCellsHtml(row) +
				(this.isRTL ? this.renderNumberIntroHtml(row) : '') +
			'</tr>';
	},


	renderNumberIntroHtml: function(row) {
		return this.renderIntroHtml();
	},


	renderNumberCellsHtml: function(row) {
		var htmls = [];
		var col, date;

		for (col = 0; col < this.colCnt; col++) {
			date = this.getCellDate(row, col);
			htmls.push(this.renderNumberCellHtml(date));
		}

		return htmls.join('');
	},


	// Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
	// The number row will only exist if either day numbers or week numbers are turned on.
	renderNumberCellHtml: function(date) {
		var view = this.view;
		var html = '';
		var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.
		var isDayNumberVisible = view.dayNumbersVisible && isDateValid;
		var classes;
		var weekCalcFirstDoW;

		if (!isDayNumberVisible && !view.cellWeekNumbersVisible) {
			// no numbers in day cell (week number must be along the side)
			return '<td/>'; //  will create an empty space above events :(
		}

		classes = this.getDayClasses(date);
		classes.unshift('fc-day-top');

		if (view.cellWeekNumbersVisible) {
			// To determine the day of week number change under ISO, we cannot
			// rely on moment.js methods such as firstDayOfWeek() or weekday(),
			// because they rely on the locale's dow (possibly overridden by
			// our firstDay option), which may not be Monday. We cannot change
			// dow, because that would affect the calendar start day as well.
			if (date._locale._fullCalendar_weekCalc === 'ISO') {
				weekCalcFirstDoW = 1;  // Monday by ISO 8601 definition
			}
			else {
				weekCalcFirstDoW = date._locale.firstDayOfWeek();
			}
		}

		html += '<td class="' + classes.join(' ') + '"' +
			(isDateValid ?
				' data-date="' + date.format() + '"' :
				''
				) +
			'>';

		if (view.cellWeekNumbersVisible && (date.day() == weekCalcFirstDoW)) {
			html += view.buildGotoAnchorHtml(
				{ date: date, type: 'week' },
				{ 'class': 'fc-week-number' },
				date.format('w') // inner HTML
			);
		}

		if (isDayNumberVisible) {
			html += view.buildGotoAnchorHtml(
				date,
				{ 'class': 'fc-day-number' },
				date.date() // inner HTML
			);
		}

		html += '</td>';

		return html;
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Computes a default event time formatting string if `timeFormat` is not explicitly defined
	computeEventTimeFormat: function() {
		return this.view.opt('extraSmallTimeFormat'); // like "6p" or "6:30p"
	},


	// Computes a default `displayEventEnd` value if one is not expliclty defined
	computeDisplayEventEnd: function() {
		return this.colCnt == 1; // we'll likely have space if there's only one day
	},


	/* Dates
	------------------------------------------------------------------------------------------------------------------*/


	rangeUpdated: function() {
		this.updateDayTable();
	},


	// Slices up the given span (unzoned start/end with other misc data) into an array of segments
	spanToSegs: function(span) {
		var segs = this.sliceRangeByRow(span);
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			if (this.isRTL) {
				seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;
				seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;
			}
			else {
				seg.leftCol = seg.firstRowDayIndex;
				seg.rightCol = seg.lastRowDayIndex;
			}
		}

		return segs;
	},


	/* Hit System
	------------------------------------------------------------------------------------------------------------------*/


	prepareHits: function() {
		this.colCoordCache.build();
		this.rowCoordCache.build();
		this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
	},


	releaseHits: function() {
		this.colCoordCache.clear();
		this.rowCoordCache.clear();
	},


	queryHit: function(leftOffset, topOffset) {
		if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {
			var col = this.colCoordCache.getHorizontalIndex(leftOffset);
			var row = this.rowCoordCache.getVerticalIndex(topOffset);

			if (row != null && col != null) {
				return this.getCellHit(row, col);
			}
		}
	},


	getHitSpan: function(hit) {
		return this.getCellRange(hit.row, hit.col);
	},


	getHitEl: function(hit) {
		return this.getCellEl(hit.row, hit.col);
	},


	/* Cell System
	------------------------------------------------------------------------------------------------------------------*/
	// FYI: the first column is the leftmost column, regardless of date


	getCellHit: function(row, col) {
		return {
			row: row,
			col: col,
			component: this, // needed unfortunately :(
			left: this.colCoordCache.getLeftOffset(col),
			right: this.colCoordCache.getRightOffset(col),
			top: this.rowCoordCache.getTopOffset(row),
			bottom: this.rowCoordCache.getBottomOffset(row)
		};
	},


	getCellEl: function(row, col) {
		return this.cellEls.eq(row * this.colCnt + col);
	},


	/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: move to DayGrid.event, similar to what we did with Grid's drag methods


	// Renders a visual indication of an event or external element being dragged.
	// `eventLocation` has zoned start and end (optional)
	renderDrag: function(eventLocation, seg) {
		var eventSpans = this.eventToSpans(eventLocation);
		var i;

		// always render a highlight underneath
		for (i = 0; i < eventSpans.length; i++) {
			this.renderHighlight(eventSpans[i]);
		}

		// if a segment from the same calendar but another component is being dragged, render a helper event
		if (seg && seg.component !== this) {
			return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
		}
	},


	// Unrenders any visual indication of a hovering event
	unrenderDrag: function() {
		this.unrenderHighlight();
		this.unrenderHelper();
	},


	/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event being resized
	renderEventResize: function(eventLocation, seg) {
		var eventSpans = this.eventToSpans(eventLocation);
		var i;

		for (i = 0; i < eventSpans.length; i++) {
			this.renderHighlight(eventSpans[i]);
		}

		return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
	},


	// Unrenders a visual indication of an event being resized
	unrenderEventResize: function() {
		this.unrenderHighlight();
		this.unrenderHelper();
	},


	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a mock "helper" event. `sourceSeg` is the associated internal segment object. It can be null.
	renderHelper: function(event, sourceSeg) {
		var helperNodes = [];
		var segs = this.eventToSegs(event);
		var rowStructs;

		segs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered
		rowStructs = this.renderSegRows(segs);

		// inject each new event skeleton into each associated row
		this.rowEls.each(function(row, rowNode) {
			var rowEl = $(rowNode); // the .fc-row
			var skeletonEl = $('<div class="fc-helper-skeleton"><table/></div>'); // will be absolutely positioned
			var skeletonTop;

			// If there is an original segment, match the top position. Otherwise, put it at the row's top level
			if (sourceSeg && sourceSeg.row === row) {
				skeletonTop = sourceSeg.el.position().top;
			}
			else {
				skeletonTop = rowEl.find('.fc-content-skeleton tbody').position().top;
			}

			skeletonEl.css('top', skeletonTop)
				.find('table')
					.append(rowStructs[row].tbodyEl);

			rowEl.append(skeletonEl);
			helperNodes.push(skeletonEl[0]);
		});

		return ( // must return the elements rendered
			this.helperEls = $(helperNodes) // array -> jQuery set
		);
	},


	// Unrenders any visual indication of a mock helper event
	unrenderHelper: function() {
		if (this.helperEls) {
			this.helperEls.remove();
			this.helperEls = null;
		}
	},


	/* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/


	fillSegTag: 'td', // override the default tag name


	// Renders a set of rectangles over the given segments of days.
	// Only returns segments that successfully rendered.
	renderFill: function(type, segs, className) {
		var nodes = [];
		var i, seg;
		var skeletonEl;

		segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			skeletonEl = this.renderFillRow(type, seg, className);
			this.rowEls.eq(seg.row).append(skeletonEl);
			nodes.push(skeletonEl[0]);
		}

		this.elsByFill[type] = $(nodes);

		return segs;
	},


	// Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
	renderFillRow: function(type, seg, className) {
		var colCnt = this.colCnt;
		var startCol = seg.leftCol;
		var endCol = seg.rightCol + 1;
		var skeletonEl;
		var trEl;

		className = className || type.toLowerCase();

		skeletonEl = $(
			'<div class="fc-' + className + '-skeleton">' +
				'<table><tr/></table>' +
			'</div>'
		);
		trEl = skeletonEl.find('tr');

		if (startCol > 0) {
			trEl.append('<td colspan="' + startCol + '"/>');
		}

		trEl.append(
			seg.el.attr('colspan', endCol - startCol)
		);

		if (endCol < colCnt) {
			trEl.append('<td colspan="' + (colCnt - endCol) + '"/>');
		}

		this.bookendCells(trEl);

		return skeletonEl;
	}

});

;;

/* Event-rendering methods for the DayGrid class
----------------------------------------------------------------------------------------------------------------------*/

DayGrid.mixin({

	rowStructs: null, // an array of objects, each holding information about a row's foreground event-rendering


	// Unrenders all events currently rendered on the grid
	unrenderEvents: function() {
		this.removeSegPopover(); // removes the "more.." events popover
		Grid.prototype.unrenderEvents.apply(this, arguments); // calls the super-method
	},


	// Retrieves all rendered segment objects currently rendered on the grid
	getEventSegs: function() {
		return Grid.prototype.getEventSegs.call(this) // get the segments from the super-method
			.concat(this.popoverSegs || []); // append the segments from the "more..." popover
	},


	// Renders the given background event segments onto the grid
	renderBgSegs: function(segs) {

		// don't render timed background events
		var allDaySegs = $.grep(segs, function(seg) {
			return seg.event.allDay;
		});

		return Grid.prototype.renderBgSegs.call(this, allDaySegs); // call the super-method
	},


	// Renders the given foreground event segments onto the grid
	renderFgSegs: function(segs) {
		var rowStructs;

		// render an `.el` on each seg
		// returns a subset of the segs. segs that were actually rendered
		segs = this.renderFgSegEls(segs);

		rowStructs = this.rowStructs = this.renderSegRows(segs);

		// append to each row's content skeleton
		this.rowEls.each(function(i, rowNode) {
			$(rowNode).find('.fc-content-skeleton > table').append(
				rowStructs[i].tbodyEl
			);
		});

		return segs; // return only the segs that were actually rendered
	},


	// Unrenders all currently rendered foreground event segments
	unrenderFgSegs: function() {
		var rowStructs = this.rowStructs || [];
		var rowStruct;

		while ((rowStruct = rowStructs.pop())) {
			rowStruct.tbodyEl.remove();
		}

		this.rowStructs = null;
	},


	// Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
	// Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
	// PRECONDITION: each segment shoud already have a rendered and assigned `.el`
	renderSegRows: function(segs) {
		var rowStructs = [];
		var segRows;
		var row;

		segRows = this.groupSegRows(segs); // group into nested arrays

		// iterate each row of segment groupings
		for (row = 0; row < segRows.length; row++) {
			rowStructs.push(
				this.renderSegRow(row, segRows[row])
			);
		}

		return rowStructs;
	},


	// Builds the HTML to be used for the default element for an individual segment
	fgSegHtml: function(seg, disableResizing) {
		var view = this.view;
		var event = seg.event;
		var isDraggable = view.isEventDraggable(event);
		var isResizableFromStart = !disableResizing && event.allDay &&
			seg.isStart && view.isEventResizableFromStart(event);
		var isResizableFromEnd = !disableResizing && event.allDay &&
			seg.isEnd && view.isEventResizableFromEnd(event);
		var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
		var skinCss = cssToStr(this.getSegSkinCss(seg));
		var timeHtml = '';
		var timeText;
		var titleHtml;

		classes.unshift('fc-day-grid-event', 'fc-h-event');

		// Only display a timed events time if it is the starting segment
		if (seg.isStart) {
			timeText = this.getEventTimeText(event);
			if (timeText) {
				timeHtml = '<span class="fc-time">' + htmlEscape(timeText) + '</span>';
			}
		}

		titleHtml =
			'<span class="fc-title">' +
				(htmlEscape(event.title || '') || '&nbsp;') + // we always want one line of height
			'</span>';
		
		return '<a class="' + classes.join(' ') + '"' +
				(event.url ?
					' href="' + htmlEscape(event.url) + '"' :
					''
					) +
				(skinCss ?
					' style="' + skinCss + '"' :
					''
					) +
			'>' +
				'<div class="fc-content">' +
					(this.isRTL ?
						titleHtml + ' ' + timeHtml : // put a natural space in between
						timeHtml + ' ' + titleHtml   //
						) +
				'</div>' +
				(isResizableFromStart ?
					'<div class="fc-resizer fc-start-resizer" />' :
					''
					) +
				(isResizableFromEnd ?
					'<div class="fc-resizer fc-end-resizer" />' :
					''
					) +
			'</a>';
	},


	// Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
	// the segments. Returns object with a bunch of internal data about how the render was calculated.
	// NOTE: modifies rowSegs
	renderSegRow: function(row, rowSegs) {
		var colCnt = this.colCnt;
		var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
		var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
		var tbody = $('<tbody/>');
		var segMatrix = []; // lookup for which segments are rendered into which level+col cells
		var cellMatrix = []; // lookup for all <td> elements of the level+col matrix
		var loneCellMatrix = []; // lookup for <td> elements that only take up a single column
		var i, levelSegs;
		var col;
		var tr;
		var j, seg;
		var td;

		// populates empty cells from the current column (`col`) to `endCol`
		function emptyCellsUntil(endCol) {
			while (col < endCol) {
				// try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
				td = (loneCellMatrix[i - 1] || [])[col];
				if (td) {
					td.attr(
						'rowspan',
						parseInt(td.attr('rowspan') || 1, 10) + 1
					);
				}
				else {
					td = $('<td/>');
					tr.append(td);
				}
				cellMatrix[i][col] = td;
				loneCellMatrix[i][col] = td;
				col++;
			}
		}

		for (i = 0; i < levelCnt; i++) { // iterate through all levels
			levelSegs = segLevels[i];
			col = 0;
			tr = $('<tr/>');

			segMatrix.push([]);
			cellMatrix.push([]);
			loneCellMatrix.push([]);

			// levelCnt might be 1 even though there are no actual levels. protect against this.
			// this single empty row is useful for styling.
			if (levelSegs) {
				for (j = 0; j < levelSegs.length; j++) { // iterate through segments in level
					seg = levelSegs[j];

					emptyCellsUntil(seg.leftCol);

					// create a container that occupies or more columns. append the event element.
					td = $('<td class="fc-event-container"/>').append(seg.el);
					if (seg.leftCol != seg.rightCol) {
						td.attr('colspan', seg.rightCol - seg.leftCol + 1);
					}
					else { // a single-column segment
						loneCellMatrix[i][col] = td;
					}

					while (col <= seg.rightCol) {
						cellMatrix[i][col] = td;
						segMatrix[i][col] = seg;
						col++;
					}

					tr.append(td);
				}
			}

			emptyCellsUntil(colCnt); // finish off the row
			this.bookendCells(tr);
			tbody.append(tr);
		}

		return { // a "rowStruct"
			row: row, // the row number
			tbodyEl: tbody,
			cellMatrix: cellMatrix,
			segMatrix: segMatrix,
			segLevels: segLevels,
			segs: rowSegs
		};
	},


	// Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
	// NOTE: modifies segs
	buildSegLevels: function(segs) {
		var levels = [];
		var i, seg;
		var j;

		// Give preference to elements with certain criteria, so they have
		// a chance to be closer to the top.
		this.sortEventSegs(segs);
		
		for (i = 0; i < segs.length; i++) {
			seg = segs[i];

			// loop through levels, starting with the topmost, until the segment doesn't collide with other segments
			for (j = 0; j < levels.length; j++) {
				if (!isDaySegCollision(seg, levels[j])) {
					break;
				}
			}
			// `j` now holds the desired subrow index
			seg.level = j;

			// create new level array if needed and append segment
			(levels[j] || (levels[j] = [])).push(seg);
		}

		// order segments left-to-right. very important if calendar is RTL
		for (j = 0; j < levels.length; j++) {
			levels[j].sort(compareDaySegCols);
		}

		return levels;
	},


	// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
	groupSegRows: function(segs) {
		var segRows = [];
		var i;

		for (i = 0; i < this.rowCnt; i++) {
			segRows.push([]);
		}

		for (i = 0; i < segs.length; i++) {
			segRows[segs[i].row].push(segs[i]);
		}

		return segRows;
	}

});


// Computes whether two segments' columns collide. They are assumed to be in the same row.
function isDaySegCollision(seg, otherSegs) {
	var i, otherSeg;

	for (i = 0; i < otherSegs.length; i++) {
		otherSeg = otherSegs[i];

		if (
			otherSeg.leftCol <= seg.rightCol &&
			otherSeg.rightCol >= seg.leftCol
		) {
			return true;
		}
	}

	return false;
}


// A cmp function for determining the leftmost event
function compareDaySegCols(a, b) {
	return a.leftCol - b.leftCol;
}

;;

/* Methods relate to limiting the number events for a given day on a DayGrid
----------------------------------------------------------------------------------------------------------------------*/
// NOTE: all the segs being passed around in here are foreground segs

DayGrid.mixin({

	segPopover: null, // the Popover that holds events that can't fit in a cell. null when not visible
	popoverSegs: null, // an array of segment objects that the segPopover holds. null when not visible


	removeSegPopover: function() {
		if (this.segPopover) {
			this.segPopover.hide(); // in handler, will call segPopover's removeElement
		}
	},


	// Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
	// `levelLimit` can be false (don't limit), a number, or true (should be computed).
	limitRows: function(levelLimit) {
		var rowStructs = this.rowStructs || [];
		var row; // row #
		var rowLevelLimit;

		for (row = 0; row < rowStructs.length; row++) {
			this.unlimitRow(row);

			if (!levelLimit) {
				rowLevelLimit = false;
			}
			else if (typeof levelLimit === 'number') {
				rowLevelLimit = levelLimit;
			}
			else {
				rowLevelLimit = this.computeRowLevelLimit(row);
			}

			if (rowLevelLimit !== false) {
				this.limitRow(row, rowLevelLimit);
			}
		}
	},


	// Computes the number of levels a row will accomodate without going outside its bounds.
	// Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
	// `row` is the row number.
	computeRowLevelLimit: function(row) {
		var rowEl = this.rowEls.eq(row); // the containing "fake" row div
		var rowHeight = rowEl.height(); // TODO: cache somehow?
		var trEls = this.rowStructs[row].tbodyEl.children();
		var i, trEl;
		var trHeight;

		function iterInnerHeights(i, childNode) {
			trHeight = Math.max(trHeight, $(childNode).outerHeight());
		}

		// Reveal one level <tr> at a time and stop when we find one out of bounds
		for (i = 0; i < trEls.length; i++) {
			trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)

			// with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,
			// so instead, find the tallest inner content element.
			trHeight = 0;
			trEl.find('> td > :first-child').each(iterInnerHeights);

			if (trEl.position().top + trHeight > rowHeight) {
				return i;
			}
		}

		return false; // should not limit at all
	},


	// Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
	// `row` is the row number.
	// `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
	limitRow: function(row, levelLimit) {
		var _this = this;
		var rowStruct = this.rowStructs[row];
		var moreNodes = []; // array of "more" <a> links and <td> DOM nodes
		var col = 0; // col #, left-to-right (not chronologically)
		var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
		var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row
		var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes
		var i, seg;
		var segsBelow; // array of segment objects below `seg` in the current `col`
		var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
		var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)
		var td, rowspan;
		var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell
		var j;
		var moreTd, moreWrap, moreLink;

		// Iterates through empty level cells and places "more" links inside if need be
		function emptyCellsUntil(endCol) { // goes from current `col` to `endCol`
			while (col < endCol) {
				segsBelow = _this.getCellSegs(row, col, levelLimit);
				if (segsBelow.length) {
					td = cellMatrix[levelLimit - 1][col];
					moreLink = _this.renderMoreLink(row, col, segsBelow);
					moreWrap = $('<div/>').append(moreLink);
					td.append(moreWrap);
					moreNodes.push(moreWrap[0]);
				}
				col++;
			}
		}

		if (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?
			levelSegs = rowStruct.segLevels[levelLimit - 1];
			cellMatrix = rowStruct.cellMatrix;

			limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit
				.addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array

			// iterate though segments in the last allowable level
			for (i = 0; i < levelSegs.length; i++) {
				seg = levelSegs[i];
				emptyCellsUntil(seg.leftCol); // process empty cells before the segment

				// determine *all* segments below `seg` that occupy the same columns
				colSegsBelow = [];
				totalSegsBelow = 0;
				while (col <= seg.rightCol) {
					segsBelow = this.getCellSegs(row, col, levelLimit);
					colSegsBelow.push(segsBelow);
					totalSegsBelow += segsBelow.length;
					col++;
				}

				if (totalSegsBelow) { // do we need to replace this segment with one or many "more" links?
					td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell
					rowspan = td.attr('rowspan') || 1;
					segMoreNodes = [];

					// make a replacement <td> for each column the segment occupies. will be one for each colspan
					for (j = 0; j < colSegsBelow.length; j++) {
						moreTd = $('<td class="fc-more-cell"/>').attr('rowspan', rowspan);
						segsBelow = colSegsBelow[j];
						moreLink = this.renderMoreLink(
							row,
							seg.leftCol + j,
							[ seg ].concat(segsBelow) // count seg as hidden too
						);
						moreWrap = $('<div/>').append(moreLink);
						moreTd.append(moreWrap);
						segMoreNodes.push(moreTd[0]);
						moreNodes.push(moreTd[0]);
					}

					td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements
					limitedNodes.push(td[0]);
				}
			}

			emptyCellsUntil(this.colCnt); // finish off the level
			rowStruct.moreEls = $(moreNodes); // for easy undoing later
			rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
		}
	},


	// Reveals all levels and removes all "more"-related elements for a grid's row.
	// `row` is a row number.
	unlimitRow: function(row) {
		var rowStruct = this.rowStructs[row];

		if (rowStruct.moreEls) {
			rowStruct.moreEls.remove();
			rowStruct.moreEls = null;
		}

		if (rowStruct.limitedEls) {
			rowStruct.limitedEls.removeClass('fc-limited');
			rowStruct.limitedEls = null;
		}
	},


	// Renders an <a> element that represents hidden event element for a cell.
	// Responsible for attaching click handler as well.
	renderMoreLink: function(row, col, hiddenSegs) {
		var _this = this;
		var view = this.view;

		return $('<a class="fc-more"/>')
			.text(
				this.getMoreLinkText(hiddenSegs.length)
			)
			.on('click', function(ev) {
				var clickOption = view.opt('eventLimitClick');
				var date = _this.getCellDate(row, col);
				var moreEl = $(this);
				var dayEl = _this.getCellEl(row, col);
				var allSegs = _this.getCellSegs(row, col);

				// rescope the segments to be within the cell's date
				var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
				var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);

				if (typeof clickOption === 'function') {
					// the returned value can be an atomic option
					clickOption = view.publiclyTrigger('eventLimitClick', null, {
						date: date,
						dayEl: dayEl,
						moreEl: moreEl,
						segs: reslicedAllSegs,
						hiddenSegs: reslicedHiddenSegs
					}, ev);
				}

				if (clickOption === 'popover') {
					_this.showSegPopover(row, col, moreEl, reslicedAllSegs);
				}
				else if (typeof clickOption === 'string') { // a view name
					view.calendar.zoomTo(date, clickOption);
				}
			});
	},


	// Reveals the popover that displays all events within a cell
	showSegPopover: function(row, col, moreLink, segs) {
		var _this = this;
		var view = this.view;
		var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>
		var topEl; // the element we want to match the top coordinate of
		var options;

		if (this.rowCnt == 1) {
			topEl = view.el; // will cause the popover to cover any sort of header
		}
		else {
			topEl = this.rowEls.eq(row); // will align with top of row
		}

		options = {
			className: 'fc-more-popover',
			content: this.renderSegPopoverContent(row, col, segs),
			parentEl: this.view.el, // attach to root of view. guarantees outside of scrollbars.
			top: topEl.offset().top,
			autoHide: true, // when the user clicks elsewhere, hide the popover
			viewportConstrain: view.opt('popoverViewportConstrain'),
			hide: function() {
				// kill everything when the popover is hidden
				// notify events to be removed
				if (_this.popoverSegs) {
					var seg;
					for (var i = 0; i < _this.popoverSegs.length; ++i) {
						seg = _this.popoverSegs[i];
						view.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);
					}
				}
				_this.segPopover.removeElement();
				_this.segPopover = null;
				_this.popoverSegs = null;
			}
		};

		// Determine horizontal coordinate.
		// We use the moreWrap instead of the <td> to avoid border confusion.
		if (this.isRTL) {
			options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
		}
		else {
			options.left = moreWrap.offset().left - 1; // -1 to be over cell border
		}

		this.segPopover = new Popover(options);
		this.segPopover.show();

		// the popover doesn't live within the grid's container element, and thus won't get the event
		// delegated-handlers for free. attach event-related handlers to the popover.
		this.bindSegHandlersToEl(this.segPopover.el);
	},


	// Builds the inner DOM contents of the segment popover
	renderSegPopoverContent: function(row, col, segs) {
		var view = this.view;
		var isTheme = view.opt('theme');
		var title = this.getCellDate(row, col).format(view.opt('dayPopoverFormat'));
		var content = $(
			'<div class="fc-header ' + view.widgetHeaderClass + '">' +
				'<span class="fc-close ' +
					(isTheme ? 'ui-icon ui-icon-closethick' : 'fc-icon fc-icon-x') +
				'"></span>' +
				'<span class="fc-title">' +
					htmlEscape(title) +
				'</span>' +
				'<div class="fc-clear"/>' +
			'</div>' +
			'<div class="fc-body ' + view.widgetContentClass + '">' +
				'<div class="fc-event-container"></div>' +
			'</div>'
		);
		var segContainer = content.find('.fc-event-container');
		var i;

		// render each seg's `el` and only return the visible segs
		segs = this.renderFgSegEls(segs, true); // disableResizing=true
		this.popoverSegs = segs;

		for (i = 0; i < segs.length; i++) {

			// because segments in the popover are not part of a grid coordinate system, provide a hint to any
			// grids that want to do drag-n-drop about which cell it came from
			this.hitsNeeded();
			segs[i].hit = this.getCellHit(row, col);
			this.hitsNotNeeded();

			segContainer.append(segs[i].el);
		}

		return content;
	},


	// Given the events within an array of segment objects, reslice them to be in a single day
	resliceDaySegs: function(segs, dayDate) {

		// build an array of the original events
		var events = $.map(segs, function(seg) {
			return seg.event;
		});

		var dayStart = dayDate.clone();
		var dayEnd = dayStart.clone().add(1, 'days');
		var dayRange = { start: dayStart, end: dayEnd };

		// slice the events with a custom slicing function
		segs = this.eventsToSegs(
			events,
			function(range) {
				var seg = intersectRanges(range, dayRange); // undefind if no intersection
				return seg ? [ seg ] : []; // must return an array of segments
			}
		);

		// force an order because eventsToSegs doesn't guarantee one
		this.sortEventSegs(segs);

		return segs;
	},


	// Generates the text that should be inside a "more" link, given the number of events it represents
	getMoreLinkText: function(num) {
		var opt = this.view.opt('eventLimitText');

		if (typeof opt === 'function') {
			return opt(num);
		}
		else {
			return '+' + num + ' ' + opt;
		}
	},


	// Returns segments within a given cell.
	// If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
	getCellSegs: function(row, col, startLevel) {
		var segMatrix = this.rowStructs[row].segMatrix;
		var level = startLevel || 0;
		var segs = [];
		var seg;

		while (level < segMatrix.length) {
			seg = segMatrix[level][col];
			if (seg) {
				segs.push(seg);
			}
			level++;
		}

		return segs;
	}

});

;;

/* A component that renders one or more columns of vertical time slots
----------------------------------------------------------------------------------------------------------------------*/
// We mixin DayTable, even though there is only a single row of days

var TimeGrid = FC.TimeGrid = Grid.extend(DayTableMixin, {

	slotDuration: null, // duration of a "slot", a distinct time segment on given day, visualized by lines
	snapDuration: null, // granularity of time for dragging and selecting
	snapsPerSlot: null,
	labelFormat: null, // formatting string for times running along vertical axis
	labelInterval: null, // duration of how often a label should be displayed for a slot

	colEls: null, // cells elements in the day-row background
	slatContainerEl: null, // div that wraps all the slat rows
	slatEls: null, // elements running horizontally across all columns
	nowIndicatorEls: null,

	colCoordCache: null,
	slatCoordCache: null,


	constructor: function() {
		Grid.apply(this, arguments); // call the super-constructor

		this.processOptions();
	},


	// Renders the time grid into `this.el`, which should already be assigned.
	// Relies on the view's colCnt. In the future, this component should probably be self-sufficient.
	renderDates: function() {
		this.el.html(this.renderHtml());
		this.colEls = this.el.find('.fc-day, .fc-disabled-day');
		this.slatContainerEl = this.el.find('.fc-slats');
		this.slatEls = this.slatContainerEl.find('tr');

		this.colCoordCache = new CoordCache({
			els: this.colEls,
			isHorizontal: true
		});
		this.slatCoordCache = new CoordCache({
			els: this.slatEls,
			isVertical: true
		});

		this.renderContentSkeleton();
	},


	// Renders the basic HTML skeleton for the grid
	renderHtml: function() {
		return '' +
			'<div class="fc-bg">' +
				'<table>' +
					this.renderBgTrHtml(0) + // row=0
				'</table>' +
			'</div>' +
			'<div class="fc-slats">' +
				'<table>' +
					this.renderSlatRowHtml() +
				'</table>' +
			'</div>';
	},


	// Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
	renderSlatRowHtml: function() {
		var view = this.view;
		var isRTL = this.isRTL;
		var html = '';
		var slotTime = moment.duration(+this.view.minTime); // wish there was .clone() for durations
		var slotDate; // will be on the view's first day, but we only care about its time
		var isLabeled;
		var axisHtml;

		// Calculate the time for each slot
		while (slotTime < this.view.maxTime) {
			slotDate = this.start.clone().time(slotTime);
			isLabeled = isInt(divideDurationByDuration(slotTime, this.labelInterval));

			axisHtml =
				'<td class="fc-axis fc-time ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' +
					(isLabeled ?
						'<span>' + // for matchCellWidths
							htmlEscape(slotDate.format(this.labelFormat)) +
						'</span>' :
						''
						) +
				'</td>';

			html +=
				'<tr data-time="' + slotDate.format('HH:mm:ss') + '"' +
					(isLabeled ? '' : ' class="fc-minor"') +
					'>' +
					(!isRTL ? axisHtml : '') +
					'<td class="' + view.widgetContentClass + '"/>' +
					(isRTL ? axisHtml : '') +
				"</tr>";

			slotTime.add(this.slotDuration);
		}

		return html;
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Parses various options into properties of this object
	processOptions: function() {
		var view = this.view;
		var slotDuration = view.opt('slotDuration');
		var snapDuration = view.opt('snapDuration');
		var input;

		slotDuration = moment.duration(slotDuration);
		snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;

		this.slotDuration = slotDuration;
		this.snapDuration = snapDuration;
		this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?

		this.minResizeDuration = snapDuration; // hack

		// might be an array value (for TimelineView).
		// if so, getting the most granular entry (the last one probably).
		input = view.opt('slotLabelFormat');
		if ($.isArray(input)) {
			input = input[input.length - 1];
		}

		this.labelFormat =
			input ||
			view.opt('smallTimeFormat'); // the computed default

		input = view.opt('slotLabelInterval');
		this.labelInterval = input ?
			moment.duration(input) :
			this.computeLabelInterval(slotDuration);
	},


	// Computes an automatic value for slotLabelInterval
	computeLabelInterval: function(slotDuration) {
		var i;
		var labelInterval;
		var slotsPerLabel;

		// find the smallest stock label interval that results in more than one slots-per-label
		for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
			labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
			slotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);
			if (isInt(slotsPerLabel) && slotsPerLabel > 1) {
				return labelInterval;
			}
		}

		return moment.duration(slotDuration); // fall back. clone
	},


	// Computes a default event time formatting string if `timeFormat` is not explicitly defined
	computeEventTimeFormat: function() {
		return this.view.opt('noMeridiemTimeFormat'); // like "6:30" (no AM/PM)
	},


	// Computes a default `displayEventEnd` value if one is not expliclty defined
	computeDisplayEventEnd: function() {
		return true;
	},


	/* Hit System
	------------------------------------------------------------------------------------------------------------------*/


	prepareHits: function() {
		this.colCoordCache.build();
		this.slatCoordCache.build();
	},


	releaseHits: function() {
		this.colCoordCache.clear();
		// NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop
	},


	queryHit: function(leftOffset, topOffset) {
		var snapsPerSlot = this.snapsPerSlot;
		var colCoordCache = this.colCoordCache;
		var slatCoordCache = this.slatCoordCache;

		if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {
			var colIndex = colCoordCache.getHorizontalIndex(leftOffset);
			var slatIndex = slatCoordCache.getVerticalIndex(topOffset);

			if (colIndex != null && slatIndex != null) {
				var slatTop = slatCoordCache.getTopOffset(slatIndex);
				var slatHeight = slatCoordCache.getHeight(slatIndex);
				var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1
				var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
				var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
				var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;
				var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;

				return {
					col: colIndex,
					snap: snapIndex,
					component: this, // needed unfortunately :(
					left: colCoordCache.getLeftOffset(colIndex),
					right: colCoordCache.getRightOffset(colIndex),
					top: snapTop,
					bottom: snapBottom
				};
			}
		}
	},


	getHitSpan: function(hit) {
		var start = this.getCellDate(0, hit.col); // row=0
		var time = this.computeSnapTime(hit.snap); // pass in the snap-index
		var end;

		start.time(time);
		end = start.clone().add(this.snapDuration);

		return { start: start, end: end };
	},


	getHitEl: function(hit) {
		return this.colEls.eq(hit.col);
	},


	/* Dates
	------------------------------------------------------------------------------------------------------------------*/


	rangeUpdated: function() {
		this.updateDayTable();
	},


	// Given a row number of the grid, representing a "snap", returns a time (Duration) from its start-of-day
	computeSnapTime: function(snapIndex) {
		return moment.duration(this.view.minTime + this.snapDuration * snapIndex);
	},


	// Slices up the given span (unzoned start/end with other misc data) into an array of segments
	spanToSegs: function(span) {
		var segs = this.sliceRangeByTimes(span);
		var i;

		for (i = 0; i < segs.length; i++) {
			if (this.isRTL) {
				segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;
			}
			else {
				segs[i].col = segs[i].dayIndex;
			}
		}

		return segs;
	},


	sliceRangeByTimes: function(range) {
		var segs = [];
		var seg;
		var dayIndex;
		var dayDate;
		var dayRange;

		for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {
			dayDate = this.dayDates[dayIndex].clone().time(0); // TODO: better API for this?
			dayRange = {
				start: dayDate.clone().add(this.view.minTime), // don't use .time() because it sux with negatives
				end: dayDate.clone().add(this.view.maxTime)
			};
			seg = intersectRanges(range, dayRange); // both will be ambig timezone
			if (seg) {
				seg.dayIndex = dayIndex;
				segs.push(seg);
			}
		}

		return segs;
	},


	/* Coordinates
	------------------------------------------------------------------------------------------------------------------*/


	updateSize: function(isResize) { // NOT a standard Grid method
		this.slatCoordCache.build();

		if (isResize) {
			this.updateSegVerticals(
				[].concat(this.fgSegs || [], this.bgSegs || [], this.businessSegs || [])
			);
		}
	},


	getTotalSlatHeight: function() {
		return this.slatContainerEl.outerHeight();
	},


	// Computes the top coordinate, relative to the bounds of the grid, of the given date.
	// A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
	computeDateTop: function(date, startOfDayDate) {
		return this.computeTimeTop(
			moment.duration(
				date - startOfDayDate.clone().stripTime()
			)
		);
	},


	// Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
	computeTimeTop: function(time) {
		var len = this.slatEls.length;
		var slatCoverage = (time - this.view.minTime) / this.slotDuration; // floating-point value of # of slots covered
		var slatIndex;
		var slatRemainder;

		// compute a floating-point number for how many slats should be progressed through.
		// from 0 to number of slats (inclusive)
		// constrained because minTime/maxTime might be customized.
		slatCoverage = Math.max(0, slatCoverage);
		slatCoverage = Math.min(len, slatCoverage);

		// an integer index of the furthest whole slat
		// from 0 to number slats (*exclusive*, so len-1)
		slatIndex = Math.floor(slatCoverage);
		slatIndex = Math.min(slatIndex, len - 1);

		// how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
		// could be 1.0 if slatCoverage is covering *all* the slots
		slatRemainder = slatCoverage - slatIndex;

		return this.slatCoordCache.getTopPosition(slatIndex) +
			this.slatCoordCache.getHeight(slatIndex) * slatRemainder;
	},



	/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event being dragged over the specified date(s).
	// A returned value of `true` signals that a mock "helper" event has been rendered.
	renderDrag: function(eventLocation, seg) {
		var eventSpans;
		var i;

		if (seg) { // if there is event information for this drag, render a helper event

			// returns mock event elements
			// signal that a helper has been rendered
			return this.renderEventLocationHelper(eventLocation, seg);
		}
		else { // otherwise, just render a highlight
			eventSpans = this.eventToSpans(eventLocation);

			for (i = 0; i < eventSpans.length; i++) {
				this.renderHighlight(eventSpans[i]);
			}
		}
	},


	// Unrenders any visual indication of an event being dragged
	unrenderDrag: function() {
		this.unrenderHelper();
		this.unrenderHighlight();
	},


	/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event being resized
	renderEventResize: function(eventLocation, seg) {
		return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
	},


	// Unrenders any visual indication of an event being resized
	unrenderEventResize: function() {
		this.unrenderHelper();
	},


	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a mock "helper" event. `sourceSeg` is the original segment object and might be null (an external drag)
	renderHelper: function(event, sourceSeg) {
		return this.renderHelperSegs(this.eventToSegs(event), sourceSeg); // returns mock event elements
	},


	// Unrenders any mock helper event
	unrenderHelper: function() {
		this.unrenderHelperSegs();
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessHours: function() {
		this.renderBusinessSegs(
			this.buildBusinessHourSegs()
		);
	},


	unrenderBusinessHours: function() {
		this.unrenderBusinessSegs();
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	getNowIndicatorUnit: function() {
		return 'minute'; // will refresh on the minute
	},


	renderNowIndicator: function(date) {
		// seg system might be overkill, but it handles scenario where line needs to be rendered
		//  more than once because of columns with the same date (resources columns for example)
		var segs = this.spanToSegs({ start: date, end: date });
		var top = this.computeDateTop(date, date);
		var nodes = [];
		var i;

		// render lines within the columns
		for (i = 0; i < segs.length; i++) {
			nodes.push($('<div class="fc-now-indicator fc-now-indicator-line"></div>')
				.css('top', top)
				.appendTo(this.colContainerEls.eq(segs[i].col))[0]);
		}

		// render an arrow over the axis
		if (segs.length > 0) { // is the current time in view?
			nodes.push($('<div class="fc-now-indicator fc-now-indicator-arrow"></div>')
				.css('top', top)
				.appendTo(this.el.find('.fc-content-skeleton'))[0]);
		}

		this.nowIndicatorEls = $(nodes);
	},


	unrenderNowIndicator: function() {
		if (this.nowIndicatorEls) {
			this.nowIndicatorEls.remove();
			this.nowIndicatorEls = null;
		}
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
	renderSelection: function(span) {
		if (this.view.opt('selectHelper')) { // this setting signals that a mock helper event should be rendered

			// normally acceps an eventLocation, span has a start/end, which is good enough
			this.renderEventLocationHelper(span);
		}
		else {
			this.renderHighlight(span);
		}
	},


	// Unrenders any visual indication of a selection
	unrenderSelection: function() {
		this.unrenderHelper();
		this.unrenderHighlight();
	},


	/* Highlight
	------------------------------------------------------------------------------------------------------------------*/


	renderHighlight: function(span) {
		this.renderHighlightSegs(this.spanToSegs(span));
	},


	unrenderHighlight: function() {
		this.unrenderHighlightSegs();
	}

});

;;

/* Methods for rendering SEGMENTS, pieces of content that live on the view
 ( this file is no longer just for events )
----------------------------------------------------------------------------------------------------------------------*/

TimeGrid.mixin({

	colContainerEls: null, // containers for each column

	// inner-containers for each column where different types of segs live
	fgContainerEls: null,
	bgContainerEls: null,
	helperContainerEls: null,
	highlightContainerEls: null,
	businessContainerEls: null,

	// arrays of different types of displayed segments
	fgSegs: null,
	bgSegs: null,
	helperSegs: null,
	highlightSegs: null,
	businessSegs: null,


	// Renders the DOM that the view's content will live in
	renderContentSkeleton: function() {
		var cellHtml = '';
		var i;
		var skeletonEl;

		for (i = 0; i < this.colCnt; i++) {
			cellHtml +=
				'<td>' +
					'<div class="fc-content-col">' +
						'<div class="fc-event-container fc-helper-container"></div>' +
						'<div class="fc-event-container"></div>' +
						'<div class="fc-highlight-container"></div>' +
						'<div class="fc-bgevent-container"></div>' +
						'<div class="fc-business-container"></div>' +
					'</div>' +
				'</td>';
		}

		skeletonEl = $(
			'<div class="fc-content-skeleton">' +
				'<table>' +
					'<tr>' + cellHtml + '</tr>' +
				'</table>' +
			'</div>'
		);

		this.colContainerEls = skeletonEl.find('.fc-content-col');
		this.helperContainerEls = skeletonEl.find('.fc-helper-container');
		this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');
		this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');
		this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');
		this.businessContainerEls = skeletonEl.find('.fc-business-container');

		this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level
		this.el.append(skeletonEl);
	},


	/* Foreground Events
	------------------------------------------------------------------------------------------------------------------*/


	renderFgSegs: function(segs) {
		segs = this.renderFgSegsIntoContainers(segs, this.fgContainerEls);
		this.fgSegs = segs;
		return segs; // needed for Grid::renderEvents
	},


	unrenderFgSegs: function() {
		this.unrenderNamedSegs('fgSegs');
	},


	/* Foreground Helper Events
	------------------------------------------------------------------------------------------------------------------*/


	renderHelperSegs: function(segs, sourceSeg) {
		var helperEls = [];
		var i, seg;
		var sourceEl;

		segs = this.renderFgSegsIntoContainers(segs, this.helperContainerEls);

		// Try to make the segment that is in the same row as sourceSeg look the same
		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			if (sourceSeg && sourceSeg.col === seg.col) {
				sourceEl = sourceSeg.el;
				seg.el.css({
					left: sourceEl.css('left'),
					right: sourceEl.css('right'),
					'margin-left': sourceEl.css('margin-left'),
					'margin-right': sourceEl.css('margin-right')
				});
			}
			helperEls.push(seg.el[0]);
		}

		this.helperSegs = segs;

		return $(helperEls); // must return rendered helpers
	},


	unrenderHelperSegs: function() {
		this.unrenderNamedSegs('helperSegs');
	},


	/* Background Events
	------------------------------------------------------------------------------------------------------------------*/


	renderBgSegs: function(segs) {
		segs = this.renderFillSegEls('bgEvent', segs); // TODO: old fill system
		this.updateSegVerticals(segs);
		this.attachSegsByCol(this.groupSegsByCol(segs), this.bgContainerEls);
		this.bgSegs = segs;
		return segs; // needed for Grid::renderEvents
	},


	unrenderBgSegs: function() {
		this.unrenderNamedSegs('bgSegs');
	},


	/* Highlight
	------------------------------------------------------------------------------------------------------------------*/


	renderHighlightSegs: function(segs) {
		segs = this.renderFillSegEls('highlight', segs); // TODO: old fill system
		this.updateSegVerticals(segs);
		this.attachSegsByCol(this.groupSegsByCol(segs), this.highlightContainerEls);
		this.highlightSegs = segs;
	},


	unrenderHighlightSegs: function() {
		this.unrenderNamedSegs('highlightSegs');
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessSegs: function(segs) {
		segs = this.renderFillSegEls('businessHours', segs); // TODO: old fill system
		this.updateSegVerticals(segs);
		this.attachSegsByCol(this.groupSegsByCol(segs), this.businessContainerEls);
		this.businessSegs = segs;
	},


	unrenderBusinessSegs: function() {
		this.unrenderNamedSegs('businessSegs');
	},


	/* Seg Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
	groupSegsByCol: function(segs) {
		var segsByCol = [];
		var i;

		for (i = 0; i < this.colCnt; i++) {
			segsByCol.push([]);
		}

		for (i = 0; i < segs.length; i++) {
			segsByCol[segs[i].col].push(segs[i]);
		}

		return segsByCol;
	},


	// Given segments grouped by column, insert the segments' elements into a parallel array of container
	// elements, each living within a column.
	attachSegsByCol: function(segsByCol, containerEls) {
		var col;
		var segs;
		var i;

		for (col = 0; col < this.colCnt; col++) { // iterate each column grouping
			segs = segsByCol[col];

			for (i = 0; i < segs.length; i++) {
				containerEls.eq(col).append(segs[i].el);
			}
		}
	},


	// Given the name of a property of `this` object, assumed to be an array of segments,
	// loops through each segment and removes from DOM. Will null-out the property afterwards.
	unrenderNamedSegs: function(propName) {
		var segs = this[propName];
		var i;

		if (segs) {
			for (i = 0; i < segs.length; i++) {
				segs[i].el.remove();
			}
			this[propName] = null;
		}
	},



	/* Foreground Event Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Given an array of foreground segments, render a DOM element for each, computes position,
	// and attaches to the column inner-container elements.
	renderFgSegsIntoContainers: function(segs, containerEls) {
		var segsByCol;
		var col;

		segs = this.renderFgSegEls(segs); // will call fgSegHtml
		segsByCol = this.groupSegsByCol(segs);

		for (col = 0; col < this.colCnt; col++) {
			this.updateFgSegCoords(segsByCol[col]);
		}

		this.attachSegsByCol(segsByCol, containerEls);

		return segs;
	},


	// Renders the HTML for a single event segment's default rendering
	fgSegHtml: function(seg, disableResizing) {
		var view = this.view;
		var event = seg.event;
		var isDraggable = view.isEventDraggable(event);
		var isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);
		var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);
		var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
		var skinCss = cssToStr(this.getSegSkinCss(seg));
		var timeText;
		var fullTimeText; // more verbose time text. for the print stylesheet
		var startTimeText; // just the start time text

		classes.unshift('fc-time-grid-event', 'fc-v-event');

		if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day...
			// Don't display time text on segments that run entirely through a day.
			// That would appear as midnight-midnight and would look dumb.
			// Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
			if (seg.isStart || seg.isEnd) {
				timeText = this.getEventTimeText(seg);
				fullTimeText = this.getEventTimeText(seg, 'LT');
				startTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false
			}
		} else {
			// Display the normal time text for the *event's* times
			timeText = this.getEventTimeText(event);
			fullTimeText = this.getEventTimeText(event, 'LT');
			startTimeText = this.getEventTimeText(event, null, false); // displayEnd=false
		}

		return '<a class="' + classes.join(' ') + '"' +
			(event.url ?
				' href="' + htmlEscape(event.url) + '"' :
				''
				) +
			(skinCss ?
				' style="' + skinCss + '"' :
				''
				) +
			'>' +
				'<div class="fc-content">' +
					(timeText ?
						'<div class="fc-time"' +
						' data-start="' + htmlEscape(startTimeText) + '"' +
						' data-full="' + htmlEscape(fullTimeText) + '"' +
						'>' +
							'<span>' + htmlEscape(timeText) + '</span>' +
						'</div>' :
						''
						) +
					(event.title ?
						'<div class="fc-title">' +
							htmlEscape(event.title) +
						'</div>' :
						''
						) +
				'</div>' +
				'<div class="fc-bg"/>' +
				/* TODO: write CSS for this
				(isResizableFromStart ?
					'<div class="fc-resizer fc-start-resizer" />' :
					''
					) +
				*/
				(isResizableFromEnd ?
					'<div class="fc-resizer fc-end-resizer" />' :
					''
					) +
			'</a>';
	},


	/* Seg Position Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Refreshes the CSS top/bottom coordinates for each segment element.
	// Works when called after initial render, after a window resize/zoom for example.
	updateSegVerticals: function(segs) {
		this.computeSegVerticals(segs);
		this.assignSegVerticals(segs);
	},


	// For each segment in an array, computes and assigns its top and bottom properties
	computeSegVerticals: function(segs) {
		var i, seg;
		var dayDate;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			dayDate = this.dayDates[seg.dayIndex];

			seg.top = this.computeDateTop(seg.start, dayDate);
			seg.bottom = this.computeDateTop(seg.end, dayDate);
		}
	},


	// Given segments that already have their top/bottom properties computed, applies those values to
	// the segments' elements.
	assignSegVerticals: function(segs) {
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			seg.el.css(this.generateSegVerticalCss(seg));
		}
	},


	// Generates an object with CSS properties for the top/bottom coordinates of a segment element
	generateSegVerticalCss: function(seg) {
		return {
			top: seg.top,
			bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
		};
	},


	/* Foreground Event Positioning Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Given segments that are assumed to all live in the *same column*,
	// compute their verical/horizontal coordinates and assign to their elements.
	updateFgSegCoords: function(segs) {
		this.computeSegVerticals(segs); // horizontals relies on this
		this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array
		this.assignSegVerticals(segs);
		this.assignFgSegHorizontals(segs);
	},


	// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
	// NOTE: Also reorders the given array by date!
	computeFgSegHorizontals: function(segs) {
		var levels;
		var level0;
		var i;

		this.sortEventSegs(segs); // order by certain criteria
		levels = buildSlotSegLevels(segs);
		computeForwardSlotSegs(levels);

		if ((level0 = levels[0])) {

			for (i = 0; i < level0.length; i++) {
				computeSlotSegPressures(level0[i]);
			}

			for (i = 0; i < level0.length; i++) {
				this.computeFgSegForwardBack(level0[i], 0, 0);
			}
		}
	},


	// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
	// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
	// seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
	//
	// The segment might be part of a "series", which means consecutive segments with the same pressure
	// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
	// segments behind this one in the current series, and `seriesBackwardCoord` is the starting
	// coordinate of the first segment in the series.
	computeFgSegForwardBack: function(seg, seriesBackwardPressure, seriesBackwardCoord) {
		var forwardSegs = seg.forwardSegs;
		var i;

		if (seg.forwardCoord === undefined) { // not already computed

			if (!forwardSegs.length) {

				// if there are no forward segments, this segment should butt up against the edge
				seg.forwardCoord = 1;
			}
			else {

				// sort highest pressure first
				this.sortForwardSegs(forwardSegs);

				// this segment's forwardCoord will be calculated from the backwardCoord of the
				// highest-pressure forward segment.
				this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
				seg.forwardCoord = forwardSegs[0].backwardCoord;
			}

			// calculate the backwardCoord from the forwardCoord. consider the series
			seg.backwardCoord = seg.forwardCoord -
				(seg.forwardCoord - seriesBackwardCoord) / // available width for series
				(seriesBackwardPressure + 1); // # of segments in the series

			// use this segment's coordinates to computed the coordinates of the less-pressurized
			// forward segments
			for (i=0; i<forwardSegs.length; i++) {
				this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
			}
		}
	},


	sortForwardSegs: function(forwardSegs) {
		forwardSegs.sort(proxy(this, 'compareForwardSegs'));
	},


	// A cmp function for determining which forward segment to rely on more when computing coordinates.
	compareForwardSegs: function(seg1, seg2) {
		// put higher-pressure first
		return seg2.forwardPressure - seg1.forwardPressure ||
			// put segments that are closer to initial edge first (and favor ones with no coords yet)
			(seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
			// do normal sorting...
			this.compareEventSegs(seg1, seg2);
	},


	// Given foreground event segments that have already had their position coordinates computed,
	// assigns position-related CSS values to their elements.
	assignFgSegHorizontals: function(segs) {
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			seg.el.css(this.generateFgSegHorizontalCss(seg));

			// if the height is short, add a className for alternate styling
			if (seg.bottom - seg.top < 30) {
				seg.el.addClass('fc-short');
			}
		}
	},


	// Generates an object with CSS properties/values that should be applied to an event segment element.
	// Contains important positioning-related properties that should be applied to any event element, customized or not.
	generateFgSegHorizontalCss: function(seg) {
		var shouldOverlap = this.view.opt('slotEventOverlap');
		var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
		var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
		var props = this.generateSegVerticalCss(seg); // get top/bottom first
		var left; // amount of space from left edge, a fraction of the total width
		var right; // amount of space from right edge, a fraction of the total width

		if (shouldOverlap) {
			// double the width, but don't go beyond the maximum forward coordinate (1.0)
			forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
		}

		if (this.isRTL) {
			left = 1 - forwardCoord;
			right = backwardCoord;
		}
		else {
			left = backwardCoord;
			right = 1 - forwardCoord;
		}

		props.zIndex = seg.level + 1; // convert from 0-base to 1-based
		props.left = left * 100 + '%';
		props.right = right * 100 + '%';

		if (shouldOverlap && seg.forwardPressure) {
			// add padding to the edge so that forward stacked events don't cover the resizer's icon
			props[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
		}

		return props;
	}

});


// Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
function buildSlotSegLevels(segs) {
	var levels = [];
	var i, seg;
	var j;

	for (i=0; i<segs.length; i++) {
		seg = segs[i];

		// go through all the levels and stop on the first level where there are no collisions
		for (j=0; j<levels.length; j++) {
			if (!computeSlotSegCollisions(seg, levels[j]).length) {
				break;
			}
		}

		seg.level = j;

		(levels[j] || (levels[j] = [])).push(seg);
	}

	return levels;
}


// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function computeForwardSlotSegs(levels) {
	var i, level;
	var j, seg;
	var k;

	for (i=0; i<levels.length; i++) {
		level = levels[i];

		for (j=0; j<level.length; j++) {
			seg = level[j];

			seg.forwardSegs = [];
			for (k=i+1; k<levels.length; k++) {
				computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
			}
		}
	}
}


// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function computeSlotSegPressures(seg) {
	var forwardSegs = seg.forwardSegs;
	var forwardPressure = 0;
	var i, forwardSeg;

	if (seg.forwardPressure === undefined) { // not already computed

		for (i=0; i<forwardSegs.length; i++) {
			forwardSeg = forwardSegs[i];

			// figure out the child's maximum forward path
			computeSlotSegPressures(forwardSeg);

			// either use the existing maximum, or use the child's forward pressure
			// plus one (for the forwardSeg itself)
			forwardPressure = Math.max(
				forwardPressure,
				1 + forwardSeg.forwardPressure
			);
		}

		seg.forwardPressure = forwardPressure;
	}
}


// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function computeSlotSegCollisions(seg, otherSegs, results) {
	results = results || [];

	for (var i=0; i<otherSegs.length; i++) {
		if (isSlotSegCollision(seg, otherSegs[i])) {
			results.push(otherSegs[i]);
		}
	}

	return results;
}


// Do these segments occupy the same vertical space?
function isSlotSegCollision(seg1, seg2) {
	return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
}

;;

/* An abstract class from which other views inherit from
----------------------------------------------------------------------------------------------------------------------*/

var View = FC.View = Model.extend({

	type: null, // subclass' view name (string)
	name: null, // deprecated. use `type` instead
	title: null, // the text that will be displayed in the header's title

	calendar: null, // owner Calendar object
	viewSpec: null,
	options: null, // hash containing all options. already merged with view-specific-options
	el: null, // the view's containing element. set by Calendar

	renderQueue: null,
	batchRenderDepth: 0,
	isDatesRendered: false,
	isEventsRendered: false,
	isBaseRendered: false, // related to viewRender/viewDestroy triggers

	queuedScroll: null,

	isRTL: false,
	isSelected: false, // boolean whether a range of time is user-selected or not
	selectedEvent: null,

	eventOrderSpecs: null, // criteria for ordering events when they have same date/time

	// classNames styled by jqui themes
	widgetHeaderClass: null,
	widgetContentClass: null,
	highlightStateClass: null,

	// for date utils, computed from options
	nextDayThreshold: null,
	isHiddenDayHash: null,

	// now indicator
	isNowIndicatorRendered: null,
	initialNowDate: null, // result first getNow call
	initialNowQueriedMs: null, // ms time the getNow was called
	nowIndicatorTimeoutID: null, // for refresh timing of now indicator
	nowIndicatorIntervalID: null, // "


	constructor: function(calendar, viewSpec) {
		Model.prototype.constructor.call(this);

		this.calendar = calendar;
		this.viewSpec = viewSpec;

		// shortcuts
		this.type = viewSpec.type;
		this.options = viewSpec.options;

		// .name is deprecated
		this.name = this.type;

		this.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));
		this.initThemingProps();
		this.initHiddenDays();
		this.isRTL = this.opt('isRTL');

		this.eventOrderSpecs = parseFieldSpecs(this.opt('eventOrder'));

		this.renderQueue = this.buildRenderQueue();
		this.initAutoBatchRender();

		this.initialize();
	},


	buildRenderQueue: function() {
		var _this = this;
		var renderQueue = new RenderQueue({
			event: this.opt('eventRenderWait')
		});

		renderQueue.on('start', function() {
			_this.freezeHeight();
			_this.addScroll(_this.queryScroll());
		});

		renderQueue.on('stop', function() {
			_this.thawHeight();
			_this.popScroll();
		});

		return renderQueue;
	},


	initAutoBatchRender: function() {
		var _this = this;

		this.on('before:change', function() {
			_this.startBatchRender();
		});

		this.on('change', function() {
			_this.stopBatchRender();
		});
	},


	startBatchRender: function() {
		if (!(this.batchRenderDepth++)) {
			this.renderQueue.pause();
		}
	},


	stopBatchRender: function() {
		if (!(--this.batchRenderDepth)) {
			this.renderQueue.resume();
		}
	},


	// A good place for subclasses to initialize member variables
	initialize: function() {
		// subclasses can implement
	},


	// Retrieves an option with the given name
	opt: function(name) {
		return this.options[name];
	},


	// Triggers handlers that are view-related. Modifies args before passing to calendar.
	publiclyTrigger: function(name, thisObj) { // arguments beyond thisObj are passed along
		var calendar = this.calendar;

		return calendar.publiclyTrigger.apply(
			calendar,
			[name, thisObj || this].concat(
				Array.prototype.slice.call(arguments, 2), // arguments beyond thisObj
				[ this ] // always make the last argument a reference to the view. TODO: deprecate
			)
		);
	},


	/* Title and Date Formatting
	------------------------------------------------------------------------------------------------------------------*/


	// Sets the view's title property to the most updated computed value
	updateTitle: function() {
		this.title = this.computeTitle();
		this.calendar.setToolbarsTitle(this.title);
	},


	// Computes what the title at the top of the calendar should be for this view
	computeTitle: function() {
		var range;

		// for views that span a large unit of time, show the proper interval, ignoring stray days before and after
		if (/^(year|month)$/.test(this.currentRangeUnit)) {
			range = this.currentRange;
		}
		else { // for day units or smaller, use the actual day range
			range = this.activeRange;
		}

		return this.formatRange(
			{
				// in case currentRange has a time, make sure timezone is correct
				start: this.calendar.applyTimezone(range.start),
				end: this.calendar.applyTimezone(range.end)
			},
			this.opt('titleFormat') || this.computeTitleFormat(),
			this.opt('titleRangeSeparator')
		);
	},


	// Generates the format string that should be used to generate the title for the current date range.
	// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
	computeTitleFormat: function() {
		if (this.currentRangeUnit == 'year') {
			return 'YYYY';
		}
		else if (this.currentRangeUnit == 'month') {
			return this.opt('monthYearFormat'); // like "September 2014"
		}
		else if (this.currentRangeAs('days') > 1) {
			return 'll'; // multi-day range. shorter, like "Sep 9 - 10 2014"
		}
		else {
			return 'LL'; // one day. longer, like "September 9 2014"
		}
	},


	// Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
	// Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
	// The timezones of the dates within `range` will be respected.
	formatRange: function(range, formatStr, separator) {
		var end = range.end;

		if (!end.hasTime()) { // all-day?
			end = end.clone().subtract(1); // convert to inclusive. last ms of previous day
		}

		return formatRange(range.start, end, formatStr, separator, this.opt('isRTL'));
	},


	getAllDayHtml: function() {
		return this.opt('allDayHtml') || htmlEscape(this.opt('allDayText'));
	},


	/* Navigation
	------------------------------------------------------------------------------------------------------------------*/


	// Generates HTML for an anchor to another view into the calendar.
	// Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.
	// `gotoOptions` can either be a moment input, or an object with the form:
	// { date, type, forceOff }
	// `type` is a view-type like "day" or "week". default value is "day".
	// `attrs` and `innerHtml` are use to generate the rest of the HTML tag.
	buildGotoAnchorHtml: function(gotoOptions, attrs, innerHtml) {
		var date, type, forceOff;
		var finalOptions;

		if ($.isPlainObject(gotoOptions)) {
			date = gotoOptions.date;
			type = gotoOptions.type;
			forceOff = gotoOptions.forceOff;
		}
		else {
			date = gotoOptions; // a single moment input
		}
		date = FC.moment(date); // if a string, parse it

		finalOptions = { // for serialization into the link
			date: date.format('YYYY-MM-DD'),
			type: type || 'day'
		};

		if (typeof attrs === 'string') {
			innerHtml = attrs;
			attrs = null;
		}

		attrs = attrs ? ' ' + attrsToStr(attrs) : ''; // will have a leading space
		innerHtml = innerHtml || '';

		if (!forceOff && this.opt('navLinks')) {
			return '<a' + attrs +
				' data-goto="' + htmlEscape(JSON.stringify(finalOptions)) + '">' +
				innerHtml +
				'</a>';
		}
		else {
			return '<span' + attrs + '>' +
				innerHtml +
				'</span>';
		}
	},


	// Rendering Non-date-related Content
	// -----------------------------------------------------------------------------------------------------------------


	// Sets the container element that the view should render inside of, does global DOM-related initializations,
	// and renders all the non-date-related content inside.
	setElement: function(el) {
		this.el = el;
		this.bindGlobalHandlers();
		this.bindBaseRenderHandlers();
		this.renderSkeleton();
	},


	// Removes the view's container element from the DOM, clearing any content beforehand.
	// Undoes any other DOM-related attachments.
	removeElement: function() {
		this.unsetDate();
		this.unrenderSkeleton();

		this.unbindGlobalHandlers();
		this.unbindBaseRenderHandlers();

		this.el.remove();
		// NOTE: don't null-out this.el in case the View was destroyed within an API callback.
		// We don't null-out the View's other jQuery element references upon destroy,
		//  so we shouldn't kill this.el either.
	},


	// Renders the basic structure of the view before any content is rendered
	renderSkeleton: function() {
		// subclasses should implement
	},


	// Unrenders the basic structure of the view
	unrenderSkeleton: function() {
		// subclasses should implement
	},


	// Date Setting/Unsetting
	// -----------------------------------------------------------------------------------------------------------------


	setDate: function(date) {
		var currentDateProfile = this.get('dateProfile');
		var newDateProfile = this.buildDateProfile(date, null, true); // forceToValid=true

		if (
			!currentDateProfile ||
			!isRangesEqual(currentDateProfile.activeRange, newDateProfile.activeRange)
		) {
			this.set('dateProfile', newDateProfile);
		}

		return newDateProfile.date;
	},


	unsetDate: function() {
		this.unset('dateProfile');
	},


	// Date Rendering
	// -----------------------------------------------------------------------------------------------------------------


	requestDateRender: function(dateProfile) {
		var _this = this;

		this.renderQueue.queue(function() {
			_this.executeDateRender(dateProfile);
		}, 'date', 'init');
	},


	requestDateUnrender: function() {
		var _this = this;

		this.renderQueue.queue(function() {
			_this.executeDateUnrender();
		}, 'date', 'destroy');
	},


	// Event Data
	// -----------------------------------------------------------------------------------------------------------------


	fetchInitialEvents: function(dateProfile) {
		return this.calendar.requestEvents(
			dateProfile.activeRange.start,
			dateProfile.activeRange.end
		);
	},


	bindEventChanges: function() {
		this.listenTo(this.calendar, 'eventsReset', this.resetEvents);
	},


	unbindEventChanges: function() {
		this.stopListeningTo(this.calendar, 'eventsReset');
	},


	setEvents: function(events) {
		this.set('currentEvents', events);
		this.set('hasEvents', true);
	},


	unsetEvents: function() {
		this.unset('currentEvents');
		this.unset('hasEvents');
	},


	resetEvents: function(events) {
		this.startBatchRender();
		this.unsetEvents();
		this.setEvents(events);
		this.stopBatchRender();
	},


	// Event Rendering
	// -----------------------------------------------------------------------------------------------------------------


	requestEventsRender: function(events) {
		var _this = this;

		this.renderQueue.queue(function() {
			_this.executeEventsRender(events);
		}, 'event', 'init');
	},


	requestEventsUnrender: function() {
		var _this = this;

		this.renderQueue.queue(function() {
			_this.executeEventsUnrender();
		}, 'event', 'destroy');
	},


	// Date High-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	// if dateProfile not specified, uses current
	executeDateRender: function(dateProfile, skipScroll) {

		this.setDateProfileForRendering(dateProfile);
		this.updateTitle();
		this.calendar.updateToolbarButtons();

		if (this.render) {
			this.render(); // TODO: deprecate
		}

		this.renderDates();
		this.updateSize();
		this.renderBusinessHours(); // might need coordinates, so should go after updateSize()
		this.startNowIndicator();

		if (!skipScroll) {
			this.addScroll(this.computeInitialDateScroll());
		}

		this.isDatesRendered = true;
		this.trigger('datesRendered');
	},


	executeDateUnrender: function() {

		this.unselect();
		this.stopNowIndicator();

		this.trigger('before:datesUnrendered');

		this.unrenderBusinessHours();
		this.unrenderDates();

		if (this.destroy) {
			this.destroy(); // TODO: deprecate
		}

		this.isDatesRendered = false;
	},


	// Date Low-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	// date-cell content only
	renderDates: function() {
		// subclasses should implement
	},


	// date-cell content only
	unrenderDates: function() {
		// subclasses should override
	},


	// Determing when the "meat" of the view is rendered (aka the base)
	// -----------------------------------------------------------------------------------------------------------------


	bindBaseRenderHandlers: function() {
		var _this = this;

		this.on('datesRendered.baseHandler', function() {
			_this.onBaseRender();
		});

		this.on('before:datesUnrendered.baseHandler', function() {
			_this.onBeforeBaseUnrender();
		});
	},


	unbindBaseRenderHandlers: function() {
		this.off('.baseHandler');
	},


	onBaseRender: function() {
		this.applyScreenState();
		this.publiclyTrigger('viewRender', this, this, this.el);
	},


	onBeforeBaseUnrender: function() {
		this.applyScreenState();
		this.publiclyTrigger('viewDestroy', this, this, this.el);
	},


	// Misc view rendering utils
	// -----------------------------------------------------------------------------------------------------------------


	// Binds DOM handlers to elements that reside outside the view container, such as the document
	bindGlobalHandlers: function() {
		this.listenTo(GlobalEmitter.get(), {
			touchstart: this.processUnselect,
			mousedown: this.handleDocumentMousedown
		});
	},


	// Unbinds DOM handlers from elements that reside outside the view container
	unbindGlobalHandlers: function() {
		this.stopListeningTo(GlobalEmitter.get());
	},


	// Initializes internal variables related to theming
	initThemingProps: function() {
		var tm = this.opt('theme') ? 'ui' : 'fc';

		this.widgetHeaderClass = tm + '-widget-header';
		this.widgetContentClass = tm + '-widget-content';
		this.highlightStateClass = tm + '-state-highlight';
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	// Renders business-hours onto the view. Assumes updateSize has already been called.
	renderBusinessHours: function() {
		// subclasses should implement
	},


	// Unrenders previously-rendered business-hours
	unrenderBusinessHours: function() {
		// subclasses should implement
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	// Immediately render the current time indicator and begins re-rendering it at an interval,
	// which is defined by this.getNowIndicatorUnit().
	// TODO: somehow do this for the current whole day's background too
	startNowIndicator: function() {
		var _this = this;
		var unit;
		var update;
		var delay; // ms wait value

		if (this.opt('nowIndicator')) {
			unit = this.getNowIndicatorUnit();
			if (unit) {
				update = proxy(this, 'updateNowIndicator'); // bind to `this`

				this.initialNowDate = this.calendar.getNow();
				this.initialNowQueriedMs = +new Date();
				this.renderNowIndicator(this.initialNowDate);
				this.isNowIndicatorRendered = true;

				// wait until the beginning of the next interval
				delay = this.initialNowDate.clone().startOf(unit).add(1, unit) - this.initialNowDate;
				this.nowIndicatorTimeoutID = setTimeout(function() {
					_this.nowIndicatorTimeoutID = null;
					update();
					delay = +moment.duration(1, unit);
					delay = Math.max(100, delay); // prevent too frequent
					_this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval
				}, delay);
			}
		}
	},


	// rerenders the now indicator, computing the new current time from the amount of time that has passed
	// since the initial getNow call.
	updateNowIndicator: function() {
		if (this.isNowIndicatorRendered) {
			this.unrenderNowIndicator();
			this.renderNowIndicator(
				this.initialNowDate.clone().add(new Date() - this.initialNowQueriedMs) // add ms
			);
		}
	},


	// Immediately unrenders the view's current time indicator and stops any re-rendering timers.
	// Won't cause side effects if indicator isn't rendered.
	stopNowIndicator: function() {
		if (this.isNowIndicatorRendered) {

			if (this.nowIndicatorTimeoutID) {
				clearTimeout(this.nowIndicatorTimeoutID);
				this.nowIndicatorTimeoutID = null;
			}
			if (this.nowIndicatorIntervalID) {
				clearTimeout(this.nowIndicatorIntervalID);
				this.nowIndicatorIntervalID = null;
			}

			this.unrenderNowIndicator();
			this.isNowIndicatorRendered = false;
		}
	},


	// Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator
	// should be refreshed. If something falsy is returned, no time indicator is rendered at all.
	getNowIndicatorUnit: function() {
		// subclasses should implement
	},


	// Renders a current time indicator at the given datetime
	renderNowIndicator: function(date) {
		// subclasses should implement
	},


	// Undoes the rendering actions from renderNowIndicator
	unrenderNowIndicator: function() {
		// subclasses should implement
	},


	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


	// Refreshes anything dependant upon sizing of the container element of the grid
	updateSize: function(isResize) {
		var scroll;

		if (isResize) {
			scroll = this.queryScroll();
		}

		this.updateHeight(isResize);
		this.updateWidth(isResize);
		this.updateNowIndicator();

		if (isResize) {
			this.applyScroll(scroll);
		}
	},


	// Refreshes the horizontal dimensions of the calendar
	updateWidth: function(isResize) {
		// subclasses should implement
	},


	// Refreshes the vertical dimensions of the calendar
	updateHeight: function(isResize) {
		var calendar = this.calendar; // we poll the calendar for height information

		this.setHeight(
			calendar.getSuggestedViewHeight(),
			calendar.isHeightAuto()
		);
	},


	// Updates the vertical dimensions of the calendar to the specified height.
	// if `isAuto` is set to true, height becomes merely a suggestion and the view should use its "natural" height.
	setHeight: function(height, isAuto) {
		// subclasses should implement
	},


	/* Scroller
	------------------------------------------------------------------------------------------------------------------*/


	addForcedScroll: function(scroll) {
		this.addScroll(
			$.extend(scroll, { isForced: true })
		);
	},


	addScroll: function(scroll) {
		var queuedScroll = this.queuedScroll || (this.queuedScroll = {});

		if (!queuedScroll.isForced) {
			$.extend(queuedScroll, scroll);
		}
	},


	popScroll: function() {
		this.applyQueuedScroll();
		this.queuedScroll = null;
	},


	applyQueuedScroll: function() {
		if (this.queuedScroll) {
			this.applyScroll(this.queuedScroll);
		}
	},


	queryScroll: function() {
		var scroll = {};

		if (this.isDatesRendered) {
			$.extend(scroll, this.queryDateScroll());
		}

		return scroll;
	},


	applyScroll: function(scroll) {
		if (this.isDatesRendered) {
			this.applyDateScroll(scroll);
		}
	},


	computeInitialDateScroll: function() {
		return {}; // subclasses must implement
	},


	queryDateScroll: function() {
		return {}; // subclasses must implement
	},


	applyDateScroll: function(scroll) {
		; // subclasses must implement
	},


	/* Height Freezing
	------------------------------------------------------------------------------------------------------------------*/


	freezeHeight: function() {
		this.calendar.freezeContentHeight();
	},


	thawHeight: function() {
		this.calendar.thawContentHeight();
	},


	// Event High-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	executeEventsRender: function(events) {
		this.renderEvents(events);
		this.isEventsRendered = true;

		this.onEventsRender();
	},


	executeEventsUnrender: function() {
		this.onBeforeEventsUnrender();

		if (this.destroyEvents) {
			this.destroyEvents(); // TODO: deprecate
		}

		this.unrenderEvents();
		this.isEventsRendered = false;
	},


	// Event Rendering Triggers
	// -----------------------------------------------------------------------------------------------------------------


	// Signals that all events have been rendered
	onEventsRender: function() {
		this.applyScreenState();

		this.renderedEventSegEach(function(seg) {
			this.publiclyTrigger('eventAfterRender', seg.event, seg.event, seg.el);
		});
		this.publiclyTrigger('eventAfterAllRender');
	},


	// Signals that all event elements are about to be removed
	onBeforeEventsUnrender: function() {
		this.applyScreenState();

		this.renderedEventSegEach(function(seg) {
			this.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);
		});
	},


	applyScreenState: function() {
		this.thawHeight();
		this.freezeHeight();
		this.applyQueuedScroll();
	},


	// Event Low-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	// Renders the events onto the view.
	renderEvents: function(events) {
		// subclasses should implement
	},


	// Removes event elements from the view.
	unrenderEvents: function() {
		// subclasses should implement
	},


	// Event Rendering Utils
	// -----------------------------------------------------------------------------------------------------------------


	// Given an event and the default element used for rendering, returns the element that should actually be used.
	// Basically runs events and elements through the eventRender hook.
	resolveEventEl: function(event, el) {
		var custom = this.publiclyTrigger('eventRender', event, event, el);

		if (custom === false) { // means don't render at all
			el = null;
		}
		else if (custom && custom !== true) {
			el = $(custom);
		}

		return el;
	},


	// Hides all rendered event segments linked to the given event
	showEvent: function(event) {
		this.renderedEventSegEach(function(seg) {
			seg.el.css('visibility', '');
		}, event);
	},


	// Shows all rendered event segments linked to the given event
	hideEvent: function(event) {
		this.renderedEventSegEach(function(seg) {
			seg.el.css('visibility', 'hidden');
		}, event);
	},


	// Iterates through event segments that have been rendered (have an el). Goes through all by default.
	// If the optional `event` argument is specified, only iterates through segments linked to that event.
	// The `this` value of the callback function will be the view.
	renderedEventSegEach: function(func, event) {
		var segs = this.getEventSegs();
		var i;

		for (i = 0; i < segs.length; i++) {
			if (!event || segs[i].event._id === event._id) {
				if (segs[i].el) {
					func.call(this, segs[i]);
				}
			}
		}
	},


	// Retrieves all the rendered segment objects for the view
	getEventSegs: function() {
		// subclasses must implement
		return [];
	},


	/* Event Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/


	// Computes if the given event is allowed to be dragged by the user
	isEventDraggable: function(event) {
		return this.isEventStartEditable(event);
	},


	isEventStartEditable: function(event) {
		return firstDefined(
			event.startEditable,
			(event.source || {}).startEditable,
			this.opt('eventStartEditable'),
			this.isEventGenerallyEditable(event)
		);
	},


	isEventGenerallyEditable: function(event) {
		return firstDefined(
			event.editable,
			(event.source || {}).editable,
			this.opt('editable')
		);
	},


	// Must be called when an event in the view is dropped onto new location.
	// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
	reportSegDrop: function(seg, dropLocation, largeUnit, el, ev) {
		var calendar = this.calendar;
		var mutateResult = calendar.mutateSeg(seg, dropLocation, largeUnit);
		var undoFunc = function() {
			mutateResult.undo();
			calendar.reportEventChange();
		};

		this.triggerEventDrop(seg.event, mutateResult.dateDelta, undoFunc, el, ev);
		calendar.reportEventChange(); // will rerender events
	},


	// Triggers event-drop handlers that have subscribed via the API
	triggerEventDrop: function(event, dateDelta, undoFunc, el, ev) {
		this.publiclyTrigger('eventDrop', el[0], event, dateDelta, undoFunc, ev, {}); // {} = jqui dummy
	},


	/* External Element Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/


	// Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
	// `meta` is the parsed data that has been embedded into the dragging event.
	// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
	reportExternalDrop: function(meta, dropLocation, el, ev, ui) {
		var eventProps = meta.eventProps;
		var eventInput;
		var event;

		// Try to build an event object and render it. TODO: decouple the two
		if (eventProps) {
			eventInput = $.extend({}, eventProps, dropLocation);
			event = this.calendar.renderEvent(eventInput, meta.stick)[0]; // renderEvent returns an array
		}

		this.triggerExternalDrop(event, dropLocation, el, ev, ui);
	},


	// Triggers external-drop handlers that have subscribed via the API
	triggerExternalDrop: function(event, dropLocation, el, ev, ui) {

		// trigger 'drop' regardless of whether element represents an event
		this.publiclyTrigger('drop', el[0], dropLocation.start, ev, ui);

		if (event) {
			this.publiclyTrigger('eventReceive', null, event); // signal an external event landed
		}
	},


	/* Drag-n-Drop Rendering (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a event or external-element drag over the given drop zone.
	// If an external-element, seg will be `null`.
	// Must return elements used for any mock events.
	renderDrag: function(dropLocation, seg) {
		// subclasses must implement
	},


	// Unrenders a visual indication of an event or external-element being dragged.
	unrenderDrag: function() {
		// subclasses must implement
	},


	/* Event Resizing
	------------------------------------------------------------------------------------------------------------------*/


	// Computes if the given event is allowed to be resized from its starting edge
	isEventResizableFromStart: function(event) {
		return this.opt('eventResizableFromStart') && this.isEventResizable(event);
	},


	// Computes if the given event is allowed to be resized from its ending edge
	isEventResizableFromEnd: function(event) {
		return this.isEventResizable(event);
	},


	// Computes if the given event is allowed to be resized by the user at all
	isEventResizable: function(event) {
		var source = event.source || {};

		return firstDefined(
			event.durationEditable,
			source.durationEditable,
			this.opt('eventDurationEditable'),
			event.editable,
			source.editable,
			this.opt('editable')
		);
	},


	// Must be called when an event in the view has been resized to a new length
	reportSegResize: function(seg, resizeLocation, largeUnit, el, ev) {
		var calendar = this.calendar;
		var mutateResult = calendar.mutateSeg(seg, resizeLocation, largeUnit);
		var undoFunc = function() {
			mutateResult.undo();
			calendar.reportEventChange();
		};

		this.triggerEventResize(seg.event, mutateResult.durationDelta, undoFunc, el, ev);
		calendar.reportEventChange(); // will rerender events
	},


	// Triggers event-resize handlers that have subscribed via the API
	triggerEventResize: function(event, durationDelta, undoFunc, el, ev) {
		this.publiclyTrigger('eventResize', el[0], event, durationDelta, undoFunc, ev, {}); // {} = jqui dummy
	},


	/* Selection (time range)
	------------------------------------------------------------------------------------------------------------------*/


	// Selects a date span on the view. `start` and `end` are both Moments.
	// `ev` is the native mouse event that begin the interaction.
	select: function(span, ev) {
		this.unselect(ev);
		this.renderSelection(span);
		this.reportSelection(span, ev);
	},


	// Renders a visual indication of the selection
	renderSelection: function(span) {
		// subclasses should implement
	},


	// Called when a new selection is made. Updates internal state and triggers handlers.
	reportSelection: function(span, ev) {
		this.isSelected = true;
		this.triggerSelect(span, ev);
	},


	// Triggers handlers to 'select'
	triggerSelect: function(span, ev) {
		this.publiclyTrigger(
			'select',
			null,
			this.calendar.applyTimezone(span.start), // convert to calendar's tz for external API
			this.calendar.applyTimezone(span.end), // "
			ev
		);
	},


	// Undoes a selection. updates in the internal state and triggers handlers.
	// `ev` is the native mouse event that began the interaction.
	unselect: function(ev) {
		if (this.isSelected) {
			this.isSelected = false;
			if (this.destroySelection) {
				this.destroySelection(); // TODO: deprecate
			}
			this.unrenderSelection();
			this.publiclyTrigger('unselect', null, ev);
		}
	},


	// Unrenders a visual indication of selection
	unrenderSelection: function() {
		// subclasses should implement
	},


	/* Event Selection
	------------------------------------------------------------------------------------------------------------------*/


	selectEvent: function(event) {
		if (!this.selectedEvent || this.selectedEvent !== event) {
			this.unselectEvent();
			this.renderedEventSegEach(function(seg) {
				seg.el.addClass('fc-selected');
			}, event);
			this.selectedEvent = event;
		}
	},


	unselectEvent: function() {
		if (this.selectedEvent) {
			this.renderedEventSegEach(function(seg) {
				seg.el.removeClass('fc-selected');
			}, this.selectedEvent);
			this.selectedEvent = null;
		}
	},


	isEventSelected: function(event) {
		// event references might change on refetchEvents(), while selectedEvent doesn't,
		// so compare IDs
		return this.selectedEvent && this.selectedEvent._id === event._id;
	},


	/* Mouse / Touch Unselecting (time range & event unselection)
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: move consistently to down/start or up/end?
	// TODO: don't kill previous selection if touch scrolling


	handleDocumentMousedown: function(ev) {
		if (isPrimaryMouseButton(ev)) {
			this.processUnselect(ev);
		}
	},


	processUnselect: function(ev) {
		this.processRangeUnselect(ev);
		this.processEventUnselect(ev);
	},


	processRangeUnselect: function(ev) {
		var ignore;

		// is there a time-range selection?
		if (this.isSelected && this.opt('unselectAuto')) {
			// only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element
			ignore = this.opt('unselectCancel');
			if (!ignore || !$(ev.target).closest(ignore).length) {
				this.unselect(ev);
			}
		}
	},


	processEventUnselect: function(ev) {
		if (this.selectedEvent) {
			if (!$(ev.target).closest('.fc-selected').length) {
				this.unselectEvent();
			}
		}
	},


	/* Day Click
	------------------------------------------------------------------------------------------------------------------*/


	// Triggers handlers to 'dayClick'
	// Span has start/end of the clicked area. Only the start is useful.
	triggerDayClick: function(span, dayEl, ev) {
		this.publiclyTrigger(
			'dayClick',
			dayEl,
			this.calendar.applyTimezone(span.start), // convert to calendar's timezone for external API
			ev
		);
	},


	/* Date Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Returns the date range of the full days the given range visually appears to occupy.
	// Returns a new range object.
	computeDayRange: function(range) {
		var startDay = range.start.clone().stripTime(); // the beginning of the day the range starts
		var end = range.end;
		var endDay = null;
		var endTimeMS;

		if (end) {
			endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends
			endTimeMS = +end.time(); // # of milliseconds into `endDay`

			// If the end time is actually inclusively part of the next day and is equal to or
			// beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
			// Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
			if (endTimeMS && endTimeMS >= this.nextDayThreshold) {
				endDay.add(1, 'days');
			}
		}

		// If no end was specified, or if it is within `startDay` but not past nextDayThreshold,
		// assign the default duration of one day.
		if (!end || endDay <= startDay) {
			endDay = startDay.clone().add(1, 'days');
		}

		return { start: startDay, end: endDay };
	},


	// Does the given event visually appear to occupy more than one day?
	isMultiDayEvent: function(event) {
		var range = this.computeDayRange(event); // event is range-ish

		return range.end.diff(range.start, 'days') > 1;
	}

});


View.watch('displayingDates', [ 'dateProfile' ], function(deps) {
	this.requestDateRender(deps.dateProfile);
}, function() {
	this.requestDateUnrender();
});


View.watch('initialEvents', [ 'dateProfile' ], function(deps) {
	return this.fetchInitialEvents(deps.dateProfile);
});


View.watch('bindingEvents', [ 'initialEvents' ], function(deps) {
	this.setEvents(deps.initialEvents);
	this.bindEventChanges();
}, function() {
	this.unbindEventChanges();
	this.unsetEvents();
});


View.watch('displayingEvents', [ 'displayingDates', 'hasEvents' ], function() {
	this.requestEventsRender(this.get('currentEvents')); // if there were event mutations after initialEvents
}, function() {
	this.requestEventsUnrender();
});

;;

View.mixin({

	// range the view is formally responsible for.
	// for example, a month view might have 1st-31st, excluding padded dates
	currentRange: null,
	currentRangeUnit: null, // name of largest unit being displayed, like "month" or "week"

	// date range with a rendered skeleton
	// includes not-active days that need some sort of DOM
	renderRange: null,

	// dates that display events and accept drag-n-drop
	activeRange: null,

	// constraint for where prev/next operations can go and where events can be dragged/resized to.
	// an object with optional start and end properties.
	validRange: null,

	// how far the current date will move for a prev/next operation
	dateIncrement: null,

	minTime: null, // Duration object that denotes the first visible time of any given day
	maxTime: null, // Duration object that denotes the exclusive visible end time of any given day
	usesMinMaxTime: false, // whether minTime/maxTime will affect the activeRange. Views must opt-in.

	// DEPRECATED
	start: null, // use activeRange.start
	end: null, // use activeRange.end
	intervalStart: null, // use currentRange.start
	intervalEnd: null, // use currentRange.end


	/* Date Range Computation
	------------------------------------------------------------------------------------------------------------------*/


	setDateProfileForRendering: function(dateProfile) {
		this.currentRange = dateProfile.currentRange;
		this.currentRangeUnit = dateProfile.currentRangeUnit;
		this.renderRange = dateProfile.renderRange;
		this.activeRange = dateProfile.activeRange;
		this.validRange = dateProfile.validRange;
		this.dateIncrement = dateProfile.dateIncrement;
		this.minTime = dateProfile.minTime;
		this.maxTime = dateProfile.maxTime;

		// DEPRECATED, but we need to keep it updated
		this.start = dateProfile.activeRange.start;
		this.end = dateProfile.activeRange.end;
		this.intervalStart = dateProfile.currentRange.start;
		this.intervalEnd = dateProfile.currentRange.end;
	},


	// Builds a structure with info about what the dates/ranges will be for the "prev" view.
	buildPrevDateProfile: function(date) {
		var prevDate = date.clone().startOf(this.currentRangeUnit).subtract(this.dateIncrement);

		return this.buildDateProfile(prevDate, -1);
	},


	// Builds a structure with info about what the dates/ranges will be for the "next" view.
	buildNextDateProfile: function(date) {
		var nextDate = date.clone().startOf(this.currentRangeUnit).add(this.dateIncrement);

		return this.buildDateProfile(nextDate, 1);
	},


	// Builds a structure holding dates/ranges for rendering around the given date.
	// Optional direction param indicates whether the date is being incremented/decremented
	// from its previous value. decremented = -1, incremented = 1 (default).
	buildDateProfile: function(date, direction, forceToValid) {
		var validRange = this.buildValidRange();
		var minTime = null;
		var maxTime = null;
		var currentInfo;
		var renderRange;
		var activeRange;
		var isValid;

		if (forceToValid) {
			date = constrainDate(date, validRange);
		}

		currentInfo = this.buildCurrentRangeInfo(date, direction);
		renderRange = this.buildRenderRange(currentInfo.range, currentInfo.unit);
		activeRange = cloneRange(renderRange);

		if (!this.opt('showNonCurrentDates')) {
			activeRange = constrainRange(activeRange, currentInfo.range);
		}

		minTime = moment.duration(this.opt('minTime'));
		maxTime = moment.duration(this.opt('maxTime'));
		this.adjustActiveRange(activeRange, minTime, maxTime);

		activeRange = constrainRange(activeRange, validRange);
		date = constrainDate(date, activeRange);

		// it's invalid if the originally requested date is not contained,
		// or if the range is completely outside of the valid range.
		isValid = doRangesIntersect(currentInfo.range, validRange);

		return {
			validRange: validRange,
			currentRange: currentInfo.range,
			currentRangeUnit: currentInfo.unit,
			activeRange: activeRange,
			renderRange: renderRange,
			minTime: minTime,
			maxTime: maxTime,
			isValid: isValid,
			date: date,
			dateIncrement: this.buildDateIncrement(currentInfo.duration)
				// pass a fallback (might be null) ^
		};
	},


	// Builds an object with optional start/end properties.
	// Indicates the minimum/maximum dates to display.
	buildValidRange: function() {
		return this.getRangeOption('validRange', this.calendar.getNow()) || {};
	},


	// Builds a structure with info about the "current" range, the range that is
	// highlighted as being the current month for example.
	// See buildDateProfile for a description of `direction`.
	// Guaranteed to have `range` and `unit` properties. `duration` is optional.
	buildCurrentRangeInfo: function(date, direction) {
		var duration = null;
		var unit = null;
		var range = null;
		var dayCount;

		if (this.viewSpec.duration) {
			duration = this.viewSpec.duration;
			unit = this.viewSpec.durationUnit;
			range = this.buildRangeFromDuration(date, direction, duration, unit);
		}
		else if ((dayCount = this.opt('dayCount'))) {
			unit = 'day';
			range = this.buildRangeFromDayCount(date, direction, dayCount);
		}
		else if ((range = this.buildCustomVisibleRange(date))) {
			unit = computeGreatestUnit(range.start, range.end);
		}
		else {
			duration = this.getFallbackDuration();
			unit = computeGreatestUnit(duration);
			range = this.buildRangeFromDuration(date, direction, duration, unit);
		}

		this.normalizeCurrentRange(range, unit); // modifies in-place

		return { duration: duration, unit: unit, range: range };
	},


	getFallbackDuration: function() {
		return moment.duration({ days: 1 });
	},


	// If the range has day units or larger, remove times. Otherwise, ensure times.
	normalizeCurrentRange: function(range, unit) {

		if (/^(year|month|week|day)$/.test(unit)) { // whole-days?
			range.start.stripTime();
			range.end.stripTime();
		}
		else { // needs to have a time?
			if (!range.start.hasTime()) {
				range.start.time(0); // give 00:00 time
			}
			if (!range.end.hasTime()) {
				range.end.time(0); // give 00:00 time
			}
		}
	},


	// Mutates the given activeRange to have time values (un-ambiguate)
	// if the minTime or maxTime causes the range to expand.
	// TODO: eventually activeRange should *always* have times.
	adjustActiveRange: function(range, minTime, maxTime) {
		var hasSpecialTimes = false;

		if (this.usesMinMaxTime) {

			if (minTime < 0) {
				range.start.time(0).add(minTime);
				hasSpecialTimes = true;
			}

			if (maxTime > 24 * 60 * 60 * 1000) { // beyond 24 hours?
				range.end.time(maxTime - (24 * 60 * 60 * 1000));
				hasSpecialTimes = true;
			}

			if (hasSpecialTimes) {
				if (!range.start.hasTime()) {
					range.start.time(0);
				}
				if (!range.end.hasTime()) {
					range.end.time(0);
				}
			}
		}
	},


	// Builds the "current" range when it is specified as an explicit duration.
	// `unit` is the already-computed computeGreatestUnit value of duration.
	buildRangeFromDuration: function(date, direction, duration, unit) {
		var alignment = this.opt('dateAlignment');
		var start = date.clone();
		var end;
		var dateIncrementInput;
		var dateIncrementDuration;

		// if the view displays a single day or smaller
		if (duration.as('days') <= 1) {
			if (this.isHiddenDay(start)) {
				start = this.skipHiddenDays(start, direction);
				start.startOf('day');
			}
		}

		// compute what the alignment should be
		if (!alignment) {
			dateIncrementInput = this.opt('dateIncrement');

			if (dateIncrementInput) {
				dateIncrementDuration = moment.duration(dateIncrementInput);

				// use the smaller of the two units
				if (dateIncrementDuration < duration) {
					alignment = computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);
				}
				else {
					alignment = unit;
				}
			}
			else {
				alignment = unit;
			}
		}

		start.startOf(alignment);
		end = start.clone().add(duration);

		return { start: start, end: end };
	},


	// Builds the "current" range when a dayCount is specified.
	buildRangeFromDayCount: function(date, direction, dayCount) {
		var customAlignment = this.opt('dateAlignment');
		var runningCount = 0;
		var start = date.clone();
		var end;

		if (customAlignment) {
			start.startOf(customAlignment);
		}

		start.startOf('day');
		start = this.skipHiddenDays(start, direction);

		end = start.clone();
		do {
			end.add(1, 'day');
			if (!this.isHiddenDay(end)) {
				runningCount++;
			}
		} while (runningCount < dayCount);

		return { start: start, end: end };
	},


	// Builds a normalized range object for the "visible" range,
	// which is a way to define the currentRange and activeRange at the same time.
	buildCustomVisibleRange: function(date) {
		var visibleRange = this.getRangeOption(
			'visibleRange',
			this.calendar.moment(date) // correct zone. also generates new obj that avoids mutations
		);

		if (visibleRange && (!visibleRange.start || !visibleRange.end)) {
			return null;
		}

		return visibleRange;
	},


	// Computes the range that will represent the element/cells for *rendering*,
	// but which may have voided days/times.
	buildRenderRange: function(currentRange, currentRangeUnit) {
		// cut off days in the currentRange that are hidden
		return this.trimHiddenDays(currentRange);
	},


	// Compute the duration value that should be added/substracted to the current date
	// when a prev/next operation happens.
	buildDateIncrement: function(fallback) {
		var dateIncrementInput = this.opt('dateIncrement');
		var customAlignment;

		if (dateIncrementInput) {
			return moment.duration(dateIncrementInput);
		}
		else if ((customAlignment = this.opt('dateAlignment'))) {
			return moment.duration(1, customAlignment);
		}
		else if (fallback) {
			return fallback;
		}
		else {
			return moment.duration({ days: 1 });
		}
	},


	// Remove days from the beginning and end of the range that are computed as hidden.
	trimHiddenDays: function(inputRange) {
		return {
			start: this.skipHiddenDays(inputRange.start),
			end: this.skipHiddenDays(inputRange.end, -1, true) // exclusively move backwards
		};
	},


	// Compute the number of the give units in the "current" range.
	// Will return a floating-point number. Won't round.
	currentRangeAs: function(unit) {
		var currentRange = this.currentRange;
		return currentRange.end.diff(currentRange.start, unit, true);
	},


	// Arguments after name will be forwarded to a hypothetical function value
	// WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.
	// Always clone your objects if you fear mutation.
	getRangeOption: function(name) {
		var val = this.opt(name);

		if (typeof val === 'function') {
			val = val.apply(
				null,
				Array.prototype.slice.call(arguments, 1)
			);
		}

		if (val) {
			return this.calendar.parseRange(val);
		}
	},


	/* Hidden Days
	------------------------------------------------------------------------------------------------------------------*/


	// Initializes internal variables related to calculating hidden days-of-week
	initHiddenDays: function() {
		var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden
		var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
		var dayCnt = 0;
		var i;

		if (this.opt('weekends') === false) {
			hiddenDays.push(0, 6); // 0=sunday, 6=saturday
		}

		for (i = 0; i < 7; i++) {
			if (
				!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)
			) {
				dayCnt++;
			}
		}

		if (!dayCnt) {
			throw 'invalid hiddenDays'; // all days were hidden? bad.
		}

		this.isHiddenDayHash = isHiddenDayHash;
	},


	// Is the current day hidden?
	// `day` is a day-of-week index (0-6), or a Moment
	isHiddenDay: function(day) {
		if (moment.isMoment(day)) {
			day = day.day();
		}
		return this.isHiddenDayHash[day];
	},


	// Incrementing the current day until it is no longer a hidden day, returning a copy.
	// DOES NOT CONSIDER validRange!
	// If the initial value of `date` is not a hidden day, don't do anything.
	// Pass `isExclusive` as `true` if you are dealing with an end date.
	// `inc` defaults to `1` (increment one day forward each time)
	skipHiddenDays: function(date, inc, isExclusive) {
		var out = date.clone();
		inc = inc || 1;
		while (
			this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]
		) {
			out.add(inc, 'days');
		}
		return out;
	}

});

;;

/*
Embodies a div that has potential scrollbars
*/
var Scroller = FC.Scroller = Class.extend({

	el: null, // the guaranteed outer element
	scrollEl: null, // the element with the scrollbars
	overflowX: null,
	overflowY: null,


	constructor: function(options) {
		options = options || {};
		this.overflowX = options.overflowX || options.overflow || 'auto';
		this.overflowY = options.overflowY || options.overflow || 'auto';
	},


	render: function() {
		this.el = this.renderEl();
		this.applyOverflow();
	},


	renderEl: function() {
		return (this.scrollEl = $('<div class="fc-scroller"></div>'));
	},


	// sets to natural height, unlocks overflow
	clear: function() {
		this.setHeight('auto');
		this.applyOverflow();
	},


	destroy: function() {
		this.el.remove();
	},


	// Overflow
	// -----------------------------------------------------------------------------------------------------------------


	applyOverflow: function() {
		this.scrollEl.css({
			'overflow-x': this.overflowX,
			'overflow-y': this.overflowY
		});
	},


	// Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.
	// Useful for preserving scrollbar widths regardless of future resizes.
	// Can pass in scrollbarWidths for optimization.
	lockOverflow: function(scrollbarWidths) {
		var overflowX = this.overflowX;
		var overflowY = this.overflowY;

		scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();

		if (overflowX === 'auto') {
			overflowX = (
					scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?
					// OR scrolling pane with massless scrollbars?
					this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth
						// subtract 1 because of IE off-by-one issue
				) ? 'scroll' : 'hidden';
		}

		if (overflowY === 'auto') {
			overflowY = (
					scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?
					// OR scrolling pane with massless scrollbars?
					this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight
						// subtract 1 because of IE off-by-one issue
				) ? 'scroll' : 'hidden';
		}

		this.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });
	},


	// Getters / Setters
	// -----------------------------------------------------------------------------------------------------------------


	setHeight: function(height) {
		this.scrollEl.height(height);
	},


	getScrollTop: function() {
		return this.scrollEl.scrollTop();
	},


	setScrollTop: function(top) {
		this.scrollEl.scrollTop(top);
	},


	getClientWidth: function() {
		return this.scrollEl[0].clientWidth;
	},


	getClientHeight: function() {
		return this.scrollEl[0].clientHeight;
	},


	getScrollbarWidths: function() {
		return getScrollbarWidths(this.scrollEl);
	}

});

;;
function Iterator(items) {
    this.items = items || [];
}


/* Calls a method on every item passing the arguments through */
Iterator.prototype.proxyCall = function(methodName) {
    var args = Array.prototype.slice.call(arguments, 1);
    var results = [];

    this.items.forEach(function(item) {
        results.push(item[methodName].apply(item, args));
    });

    return results;
};

;;

/* Toolbar with buttons and title
----------------------------------------------------------------------------------------------------------------------*/

function Toolbar(calendar, toolbarOptions) {
	var t = this;

	// exports
	t.setToolbarOptions = setToolbarOptions;
	t.render = render;
	t.removeElement = removeElement;
	t.updateTitle = updateTitle;
	t.activateButton = activateButton;
	t.deactivateButton = deactivateButton;
	t.disableButton = disableButton;
	t.enableButton = enableButton;
	t.getViewsWithButtons = getViewsWithButtons;
	t.el = null; // mirrors local `el`

	// locals
	var el;
	var viewsWithButtons = [];
	var tm;

	// method to update toolbar-specific options, not calendar-wide options
	function setToolbarOptions(newToolbarOptions) {
		toolbarOptions = newToolbarOptions;
	}

	// can be called repeatedly and will rerender
	function render() {
		var sections = toolbarOptions.layout;

		tm = calendar.opt('theme') ? 'ui' : 'fc';

		if (sections) {
			if (!el) {
				el = this.el = $("<div class='fc-toolbar "+ toolbarOptions.extraClasses + "'/>");
			}
			else {
				el.empty();
			}
			el.append(renderSection('left'))
				.append(renderSection('right'))
				.append(renderSection('center'))
				.append('<div class="fc-clear"/>');
		}
		else {
			removeElement();
		}
	}


	function removeElement() {
		if (el) {
			el.remove();
			el = t.el = null;
		}
	}


	function renderSection(position) {
		var sectionEl = $('<div class="fc-' + position + '"/>');
		var buttonStr = toolbarOptions.layout[position];
		var calendarCustomButtons = calendar.opt('customButtons') || {};
		var calendarButtonText = calendar.opt('buttonText') || {};

		if (buttonStr) {
			$.each(buttonStr.split(' '), function(i) {
				var groupChildren = $();
				var isOnlyButtons = true;
				var groupEl;

				$.each(this.split(','), function(j, buttonName) {
					var customButtonProps;
					var viewSpec;
					var buttonClick;
					var overrideText; // text explicitly set by calendar's constructor options. overcomes icons
					var defaultText;
					var themeIcon;
					var normalIcon;
					var innerHtml;
					var classes;
					var button; // the element

					if (buttonName == 'title') {
						groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height
						isOnlyButtons = false;
					}
					else {
						if ((customButtonProps = calendarCustomButtons[buttonName])) {
							buttonClick = function(ev) {
								if (customButtonProps.click) {
									customButtonProps.click.call(button[0], ev);
								}
							};
							overrideText = ''; // icons will override text
							defaultText = customButtonProps.text;
						}
						else if ((viewSpec = calendar.getViewSpec(buttonName))) {
							buttonClick = function() {
								calendar.changeView(buttonName);
							};
							viewsWithButtons.push(buttonName);
							overrideText = viewSpec.buttonTextOverride;
							defaultText = viewSpec.buttonTextDefault;
						}
						else if (calendar[buttonName]) { // a calendar method
							buttonClick = function() {
								calendar[buttonName]();
							};
							overrideText = (calendar.overrides.buttonText || {})[buttonName];
							defaultText = calendarButtonText[buttonName]; // everything else is considered default
						}

						if (buttonClick) {

							themeIcon =
								customButtonProps ?
									customButtonProps.themeIcon :
									calendar.opt('themeButtonIcons')[buttonName];

							normalIcon =
								customButtonProps ?
									customButtonProps.icon :
									calendar.opt('buttonIcons')[buttonName];

							if (overrideText) {
								innerHtml = htmlEscape(overrideText);
							}
							else if (themeIcon && calendar.opt('theme')) {
								innerHtml = "<span class='ui-icon ui-icon-" + themeIcon + "'></span>";
							}
							else if (normalIcon && !calendar.opt('theme')) {
								innerHtml = "<span class='fc-icon fc-icon-" + normalIcon + "'></span>";
							}
							else {
								innerHtml = htmlEscape(defaultText);
							}

							classes = [
								'fc-' + buttonName + '-button',
								tm + '-button',
								tm + '-state-default'
							];

							button = $( // type="button" so that it doesn't submit a form
								'<button type="button" class="' + classes.join(' ') + '">' +
									innerHtml +
								'</button>'
								)
								.click(function(ev) {
									// don't process clicks for disabled buttons
									if (!button.hasClass(tm + '-state-disabled')) {

										buttonClick(ev);

										// after the click action, if the button becomes the "active" tab, or disabled,
										// it should never have a hover class, so remove it now.
										if (
											button.hasClass(tm + '-state-active') ||
											button.hasClass(tm + '-state-disabled')
										) {
											button.removeClass(tm + '-state-hover');
										}
									}
								})
								.mousedown(function() {
									// the *down* effect (mouse pressed in).
									// only on buttons that are not the "active" tab, or disabled
									button
										.not('.' + tm + '-state-active')
										.not('.' + tm + '-state-disabled')
										.addClass(tm + '-state-down');
								})
								.mouseup(function() {
									// undo the *down* effect
									button.removeClass(tm + '-state-down');
								})
								.hover(
									function() {
										// the *hover* effect.
										// only on buttons that are not the "active" tab, or disabled
										button
											.not('.' + tm + '-state-active')
											.not('.' + tm + '-state-disabled')
											.addClass(tm + '-state-hover');
									},
									function() {
										// undo the *hover* effect
										button
											.removeClass(tm + '-state-hover')
											.removeClass(tm + '-state-down'); // if mouseleave happens before mouseup
									}
								);

							groupChildren = groupChildren.add(button);
						}
					}
				});

				if (isOnlyButtons) {
					groupChildren
						.first().addClass(tm + '-corner-left').end()
						.last().addClass(tm + '-corner-right').end();
				}

				if (groupChildren.length > 1) {
					groupEl = $('<div/>');
					if (isOnlyButtons) {
						groupEl.addClass('fc-button-group');
					}
					groupEl.append(groupChildren);
					sectionEl.append(groupEl);
				}
				else {
					sectionEl.append(groupChildren); // 1 or 0 children
				}
			});
		}

		return sectionEl;
	}


	function updateTitle(text) {
		if (el) {
			el.find('h2').text(text);
		}
	}


	function activateButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.addClass(tm + '-state-active');
		}
	}


	function deactivateButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.removeClass(tm + '-state-active');
		}
	}


	function disableButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.prop('disabled', true)
				.addClass(tm + '-state-disabled');
		}
	}


	function enableButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.prop('disabled', false)
				.removeClass(tm + '-state-disabled');
		}
	}


	function getViewsWithButtons() {
		return viewsWithButtons;
	}

}

;;

var Calendar = FC.Calendar = Class.extend(EmitterMixin, {

	view: null, // current View object
	viewsByType: null, // holds all instantiated view instances, current or not
	currentDate: null, // unzoned moment. private (public API should use getDate instead)
	loadingLevel: 0, // number of simultaneous loading tasks


	constructor: function(el, overrides) {

		// declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.
		// unneeded() is called in destroy.
		GlobalEmitter.needed();

		this.el = el;
		this.viewsByType = {};
		this.viewSpecCache = {};

		this.initOptionsInternals(overrides);
		this.initMomentInternals(); // needs to happen after options hash initialized
		this.initCurrentDate();

		EventManager.call(this); // needs options immediately
		this.initialize();
	},


	// Subclasses can override this for initialization logic after the constructor has been called
	initialize: function() {
	},


	// Public API
	// -----------------------------------------------------------------------------------------------------------------


	getCalendar: function() {
		return this;
	},


	getView: function() {
		return this.view;
	},


	publiclyTrigger: function(name, thisObj) {
		var args = Array.prototype.slice.call(arguments, 2);
		var optHandler = this.opt(name);

		thisObj = thisObj || this.el[0];
		this.triggerWith(name, thisObj, args); // Emitter's method

		if (optHandler) {
			return optHandler.apply(thisObj, args);
		}
	},


	// View
	// -----------------------------------------------------------------------------------------------------------------


	// Given a view name for a custom view or a standard view, creates a ready-to-go View object
	instantiateView: function(viewType) {
		var spec = this.getViewSpec(viewType);

		return new spec['class'](this, spec);
	},


	// Returns a boolean about whether the view is okay to instantiate at some point
	isValidViewType: function(viewType) {
		return Boolean(this.getViewSpec(viewType));
	},


	changeView: function(viewName, dateOrRange) {

		if (dateOrRange) {

			if (dateOrRange.start && dateOrRange.end) { // a range
				this.recordOptionOverrides({ // will not rerender
					visibleRange: dateOrRange
				});
			}
			else { // a date
				this.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate
			}
		}

		this.renderView(viewName);
	},


	// Forces navigation to a view for the given date.
	// `viewType` can be a specific view name or a generic one like "week" or "day".
	zoomTo: function(newDate, viewType) {
		var spec;

		viewType = viewType || 'day'; // day is default zoom
		spec = this.getViewSpec(viewType) || this.getUnitViewSpec(viewType);

		this.currentDate = newDate.clone();
		this.renderView(spec ? spec.type : null);
	},


	// Current Date
	// -----------------------------------------------------------------------------------------------------------------


	initCurrentDate: function() {
		var defaultDateInput = this.opt('defaultDate');

		// compute the initial ambig-timezone date
		if (defaultDateInput != null) {
			this.currentDate = this.moment(defaultDateInput).stripZone();
		}
		else {
			this.currentDate = this.getNow(); // getNow already returns unzoned
		}
	},


	prev: function() {
		var prevInfo = this.view.buildPrevDateProfile(this.currentDate);

		if (prevInfo.isValid) {
			this.currentDate = prevInfo.date;
			this.renderView();
		}
	},


	next: function() {
		var nextInfo = this.view.buildNextDateProfile(this.currentDate);

		if (nextInfo.isValid) {
			this.currentDate = nextInfo.date;
			this.renderView();
		}
	},


	prevYear: function() {
		this.currentDate.add(-1, 'years');
		this.renderView();
	},


	nextYear: function() {
		this.currentDate.add(1, 'years');
		this.renderView();
	},


	today: function() {
		this.currentDate = this.getNow(); // should deny like prev/next?
		this.renderView();
	},


	gotoDate: function(zonedDateInput) {
		this.currentDate = this.moment(zonedDateInput).stripZone();
		this.renderView();
	},


	incrementDate: function(delta) {
		this.currentDate.add(moment.duration(delta));
		this.renderView();
	},


	// for external API
	getDate: function() {
		return this.applyTimezone(this.currentDate); // infuse the calendar's timezone
	},


	// Loading Triggering
	// -----------------------------------------------------------------------------------------------------------------


	// Should be called when any type of async data fetching begins
	pushLoading: function() {
		if (!(this.loadingLevel++)) {
			this.publiclyTrigger('loading', null, true, this.view);
		}
	},


	// Should be called when any type of async data fetching completes
	popLoading: function() {
		if (!(--this.loadingLevel)) {
			this.publiclyTrigger('loading', null, false, this.view);
		}
	},


	// Selection
	// -----------------------------------------------------------------------------------------------------------------


	// this public method receives start/end dates in any format, with any timezone
	select: function(zonedStartInput, zonedEndInput) {
		this.view.select(
			this.buildSelectSpan.apply(this, arguments)
		);
	},


	unselect: function() { // safe to be called before renderView
		if (this.view) {
			this.view.unselect();
		}
	},


	// Given arguments to the select method in the API, returns a span (unzoned start/end and other info)
	buildSelectSpan: function(zonedStartInput, zonedEndInput) {
		var start = this.moment(zonedStartInput).stripZone();
		var end;

		if (zonedEndInput) {
			end = this.moment(zonedEndInput).stripZone();
		}
		else if (start.hasTime()) {
			end = start.clone().add(this.defaultTimedEventDuration);
		}
		else {
			end = start.clone().add(this.defaultAllDayEventDuration);
		}

		return { start: start, end: end };
	},


	// Misc
	// -----------------------------------------------------------------------------------------------------------------


	// will return `null` if invalid range
	parseRange: function(rangeInput) {
		var start = null;
		var end = null;

		if (rangeInput.start) {
			start = this.moment(rangeInput.start).stripZone();
		}

		if (rangeInput.end) {
			end = this.moment(rangeInput.end).stripZone();
		}

		if (!start && !end) {
			return null;
		}

		if (start && end && end.isBefore(start)) {
			return null;
		}

		return { start: start, end: end };
	},


	rerenderEvents: function() { // API method. destroys old events if previously rendered.
		if (this.elementVisible()) {
			this.reportEventChange(); // will re-trasmit events to the view, causing a rerender
		}
	}

});

;;
/*
Options binding/triggering system.
*/
Calendar.mixin({

	dirDefaults: null, // option defaults related to LTR or RTL
	localeDefaults: null, // option defaults related to current locale
	overrides: null, // option overrides given to the fullCalendar constructor
	dynamicOverrides: null, // options set with dynamic setter method. higher precedence than view overrides.
	optionsModel: null, // all defaults combined with overrides


	initOptionsInternals: function(overrides) {
		this.overrides = $.extend({}, overrides); // make a copy
		this.dynamicOverrides = {};
		this.optionsModel = new Model();

		this.populateOptionsHash();
	},


	// public getter/setter
	option: function(name, value) {
		var newOptionHash;

		if (typeof name === 'string') {
			if (value === undefined) { // getter
				return this.optionsModel.get(name);
			}
			else { // setter for individual option
				newOptionHash = {};
				newOptionHash[name] = value;
				this.setOptions(newOptionHash);
			}
		}
		else if (typeof name === 'object') { // compound setter with object input
			this.setOptions(name);
		}
	},


	// private getter
	opt: function(name) {
		return this.optionsModel.get(name);
	},


	setOptions: function(newOptionHash) {
		var optionCnt = 0;
		var optionName;

		this.recordOptionOverrides(newOptionHash);

		for (optionName in newOptionHash) {
			optionCnt++;
		}

		// special-case handling of single option change.
		// if only one option change, `optionName` will be its name.
		if (optionCnt === 1) {
			if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {
				this.updateSize(true); // true = allow recalculation of height
				return;
			}
			else if (optionName === 'defaultDate') {
				return; // can't change date this way. use gotoDate instead
			}
			else if (optionName === 'businessHours') {
				if (this.view) {
					this.view.unrenderBusinessHours();
					this.view.renderBusinessHours();
				}
				return;
			}
			else if (optionName === 'timezone') {
				this.rezoneArrayEventSources();
				this.refetchEvents();
				return;
			}
		}

		// catch-all. rerender the header and footer and rebuild/rerender the current view
		this.renderHeader();
		this.renderFooter();

		// even non-current views will be affected by this option change. do before rerender
		// TODO: detangle
		this.viewsByType = {};

		this.reinitView();
	},


	// Computes the flattened options hash for the calendar and assigns to `this.options`.
	// Assumes this.overrides and this.dynamicOverrides have already been initialized.
	populateOptionsHash: function() {
		var locale, localeDefaults;
		var isRTL, dirDefaults;
		var rawOptions;

		locale = firstDefined( // explicit locale option given?
			this.dynamicOverrides.locale,
			this.overrides.locale
		);
		localeDefaults = localeOptionHash[locale];
		if (!localeDefaults) { // explicit locale option not given or invalid?
			locale = Calendar.defaults.locale;
			localeDefaults = localeOptionHash[locale] || {};
		}

		isRTL = firstDefined( // based on options computed so far, is direction RTL?
			this.dynamicOverrides.isRTL,
			this.overrides.isRTL,
			localeDefaults.isRTL,
			Calendar.defaults.isRTL
		);
		dirDefaults = isRTL ? Calendar.rtlDefaults : {};

		this.dirDefaults = dirDefaults;
		this.localeDefaults = localeDefaults;

		rawOptions = mergeOptions([ // merge defaults and overrides. lowest to highest precedence
			Calendar.defaults, // global defaults
			dirDefaults,
			localeDefaults,
			this.overrides,
			this.dynamicOverrides
		]);
		populateInstanceComputableOptions(rawOptions); // fill in gaps with computed options

		this.optionsModel.reset(rawOptions);
	},


	// stores the new options internally, but does not rerender anything.
	recordOptionOverrides: function(newOptionHash) {
		var optionName;

		for (optionName in newOptionHash) {
			this.dynamicOverrides[optionName] = newOptionHash[optionName];
		}

		this.viewSpecCache = {}; // the dynamic override invalidates the options in this cache, so just clear it
		this.populateOptionsHash(); // this.options needs to be recomputed after the dynamic override
	}

});

;;

Calendar.mixin({

	defaultAllDayEventDuration: null,
	defaultTimedEventDuration: null,
	localeData: null,


	initMomentInternals: function() {
		var _this = this;

		this.defaultAllDayEventDuration = moment.duration(this.opt('defaultAllDayEventDuration'));
		this.defaultTimedEventDuration = moment.duration(this.opt('defaultTimedEventDuration'));

		// Called immediately, and when any of the options change.
		// Happens before any internal objects rebuild or rerender, because this is very core.
		this.optionsModel.watch('buildingMomentLocale', [
			'?locale', '?monthNames', '?monthNamesShort', '?dayNames', '?dayNamesShort',
			'?firstDay', '?weekNumberCalculation'
		], function(opts) {
			var weekNumberCalculation = opts.weekNumberCalculation;
			var firstDay = opts.firstDay;
			var _week;

			// normalize
			if (weekNumberCalculation === 'iso') {
				weekNumberCalculation = 'ISO'; // normalize
			}

			var localeData = createObject( // make a cheap copy
				getMomentLocaleData(opts.locale) // will fall back to en
			);

			if (opts.monthNames) {
				localeData._months = opts.monthNames;
			}
			if (opts.monthNamesShort) {
				localeData._monthsShort = opts.monthNamesShort;
			}
			if (opts.dayNames) {
				localeData._weekdays = opts.dayNames;
			}
			if (opts.dayNamesShort) {
				localeData._weekdaysShort = opts.dayNamesShort;
			}

			if (firstDay == null && weekNumberCalculation === 'ISO') {
				firstDay = 1;
			}
			if (firstDay != null) {
				_week = createObject(localeData._week); // _week: { dow: # }
				_week.dow = firstDay;
				localeData._week = _week;
			}

			if ( // whitelist certain kinds of input
				weekNumberCalculation === 'ISO' ||
				weekNumberCalculation === 'local' ||
				typeof weekNumberCalculation === 'function'
			) {
				localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it
			}

			_this.localeData = localeData;

			// If the internal current date object already exists, move to new locale.
			// We do NOT need to do this technique for event dates, because this happens when converting to "segments".
			if (_this.currentDate) {
				_this.localizeMoment(_this.currentDate); // sets to localeData
			}
		});
	},


	// Builds a moment using the settings of the current calendar: timezone and locale.
	// Accepts anything the vanilla moment() constructor accepts.
	moment: function() {
		var mom;

		if (this.opt('timezone') === 'local') {
			mom = FC.moment.apply(null, arguments);

			// Force the moment to be local, because FC.moment doesn't guarantee it.
			if (mom.hasTime()) { // don't give ambiguously-timed moments a local zone
				mom.local();
			}
		}
		else if (this.opt('timezone') === 'UTC') {
			mom = FC.moment.utc.apply(null, arguments); // process as UTC
		}
		else {
			mom = FC.moment.parseZone.apply(null, arguments); // let the input decide the zone
		}

		this.localizeMoment(mom); // TODO

		return mom;
	},


	// Updates the given moment's locale settings to the current calendar locale settings.
	localizeMoment: function(mom) {
		mom._locale = this.localeData;
	},


	// Returns a boolean about whether or not the calendar knows how to calculate
	// the timezone offset of arbitrary dates in the current timezone.
	getIsAmbigTimezone: function() {
		return this.opt('timezone') !== 'local' && this.opt('timezone') !== 'UTC';
	},


	// Returns a copy of the given date in the current timezone. Has no effect on dates without times.
	applyTimezone: function(date) {
		if (!date.hasTime()) {
			return date.clone();
		}

		var zonedDate = this.moment(date.toArray());
		var timeAdjust = date.time() - zonedDate.time();
		var adjustedZonedDate;

		// Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)
		if (timeAdjust) { // is the time result different than expected?
			adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds
			if (date.time() - adjustedZonedDate.time() === 0) { // does it match perfectly now?
				zonedDate = adjustedZonedDate;
			}
		}

		return zonedDate;
	},


	// Returns a moment for the current date, as defined by the client's computer or from the `now` option.
	// Will return an moment with an ambiguous timezone.
	getNow: function() {
		var now = this.opt('now');
		if (typeof now === 'function') {
			now = now();
		}
		return this.moment(now).stripZone();
	},


	// Produces a human-readable string for the given duration.
	// Side-effect: changes the locale of the given duration.
	humanizeDuration: function(duration) {
		return duration.locale(this.opt('locale')).humanize();
	},



	// Event-Specific Date Utilities. TODO: move
	// -----------------------------------------------------------------------------------------------------------------


	// Get an event's normalized end date. If not present, calculate it from the defaults.
	getEventEnd: function(event) {
		if (event.end) {
			return event.end.clone();
		}
		else {
			return this.getDefaultEventEnd(event.allDay, event.start);
		}
	},


	// Given an event's allDay status and start date, return what its fallback end date should be.
	// TODO: rename to computeDefaultEventEnd
	getDefaultEventEnd: function(allDay, zonedStart) {
		var end = zonedStart.clone();

		if (allDay) {
			end.stripTime().add(this.defaultAllDayEventDuration);
		}
		else {
			end.add(this.defaultTimedEventDuration);
		}

		if (this.getIsAmbigTimezone()) {
			end.stripZone(); // we don't know what the tzo should be
		}

		return end;
	}

});

;;

Calendar.mixin({

	viewSpecCache: null, // cache of view definitions (initialized in Calendar.js)


	// Gets information about how to create a view. Will use a cache.
	getViewSpec: function(viewType) {
		var cache = this.viewSpecCache;

		return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
	},


	// Given a duration singular unit, like "week" or "day", finds a matching view spec.
	// Preference is given to views that have corresponding buttons.
	getUnitViewSpec: function(unit) {
		var viewTypes;
		var i;
		var spec;

		if ($.inArray(unit, unitsDesc) != -1) {

			// put views that have buttons first. there will be duplicates, but oh well
			viewTypes = this.header.getViewsWithButtons(); // TODO: include footer as well?
			$.each(FC.views, function(viewType) { // all views
				viewTypes.push(viewType);
			});

			for (i = 0; i < viewTypes.length; i++) {
				spec = this.getViewSpec(viewTypes[i]);
				if (spec) {
					if (spec.singleUnit == unit) {
						return spec;
					}
				}
			}
		}
	},


	// Builds an object with information on how to create a given view
	buildViewSpec: function(requestedViewType) {
		var viewOverrides = this.overrides.views || {};
		var specChain = []; // for the view. lowest to highest priority
		var defaultsChain = []; // for the view. lowest to highest priority
		var overridesChain = []; // for the view. lowest to highest priority
		var viewType = requestedViewType;
		var spec; // for the view
		var overrides; // for the view
		var durationInput;
		var duration;
		var unit;

		// iterate from the specific view definition to a more general one until we hit an actual View class
		while (viewType) {
			spec = fcViews[viewType];
			overrides = viewOverrides[viewType];
			viewType = null; // clear. might repopulate for another iteration

			if (typeof spec === 'function') { // TODO: deprecate
				spec = { 'class': spec };
			}

			if (spec) {
				specChain.unshift(spec);
				defaultsChain.unshift(spec.defaults || {});
				durationInput = durationInput || spec.duration;
				viewType = viewType || spec.type;
			}

			if (overrides) {
				overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level
				durationInput = durationInput || overrides.duration;
				viewType = viewType || overrides.type;
			}
		}

		spec = mergeProps(specChain);
		spec.type = requestedViewType;
		if (!spec['class']) {
			return false;
		}

		// fall back to top-level `duration` option
		durationInput = durationInput ||
			this.dynamicOverrides.duration ||
			this.overrides.duration;

		if (durationInput) {
			duration = moment.duration(durationInput);

			if (duration.valueOf()) { // valid?

				unit = computeDurationGreatestUnit(duration, durationInput);

				spec.duration = duration;
				spec.durationUnit = unit;

				// view is a single-unit duration, like "week" or "day"
				// incorporate options for this. lowest priority
				if (duration.as(unit) === 1) {
					spec.singleUnit = unit;
					overridesChain.unshift(viewOverrides[unit] || {});
				}
			}
		}

		spec.defaults = mergeOptions(defaultsChain);
		spec.overrides = mergeOptions(overridesChain);

		this.buildViewSpecOptions(spec);
		this.buildViewSpecButtonText(spec, requestedViewType);

		return spec;
	},


	// Builds and assigns a view spec's options object from its already-assigned defaults and overrides
	buildViewSpecOptions: function(spec) {
		spec.options = mergeOptions([ // lowest to highest priority
			Calendar.defaults, // global defaults
			spec.defaults, // view's defaults (from ViewSubclass.defaults)
			this.dirDefaults,
			this.localeDefaults, // locale and dir take precedence over view's defaults!
			this.overrides, // calendar's overrides (options given to constructor)
			spec.overrides, // view's overrides (view-specific options)
			this.dynamicOverrides // dynamically set via setter. highest precedence
		]);
		populateInstanceComputableOptions(spec.options);
	},


	// Computes and assigns a view spec's buttonText-related options
	buildViewSpecButtonText: function(spec, requestedViewType) {

		// given an options object with a possible `buttonText` hash, lookup the buttonText for the
		// requested view, falling back to a generic unit entry like "week" or "day"
		function queryButtonText(options) {
			var buttonText = options.buttonText || {};
			return buttonText[requestedViewType] ||
				// view can decide to look up a certain key
				(spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||
				// a key like "month"
				(spec.singleUnit ? buttonText[spec.singleUnit] : null);
		}

		// highest to lowest priority
		spec.buttonTextOverride =
			queryButtonText(this.dynamicOverrides) ||
			queryButtonText(this.overrides) || // constructor-specified buttonText lookup hash takes precedence
			spec.overrides.buttonText; // `buttonText` for view-specific options is a string

		// highest to lowest priority. mirrors buildViewSpecOptions
		spec.buttonTextDefault =
			queryButtonText(this.localeDefaults) ||
			queryButtonText(this.dirDefaults) ||
			spec.defaults.buttonText || // a single string. from ViewSubclass.defaults
			queryButtonText(Calendar.defaults) ||
			(spec.duration ? this.humanizeDuration(spec.duration) : null) || // like "3 days"
			requestedViewType; // fall back to given view name
	}

});

;;

Calendar.mixin({

	el: null,
	contentEl: null,
	suggestedViewHeight: null,
	windowResizeProxy: null,
	ignoreWindowResize: 0,


	render: function() {
		if (!this.contentEl) {
			this.initialRender();
		}
		else if (this.elementVisible()) {
			// mainly for the public API
			this.calcSize();
			this.renderView();
		}
	},


	initialRender: function() {
		var _this = this;
		var el = this.el;

		el.addClass('fc');

		// event delegation for nav links
		el.on('click.fc', 'a[data-goto]', function(ev) {
			var anchorEl = $(this);
			var gotoOptions = anchorEl.data('goto'); // will automatically parse JSON
			var date = _this.moment(gotoOptions.date);
			var viewType = gotoOptions.type;

			// property like "navLinkDayClick". might be a string or a function
			var customAction = _this.view.opt('navLink' + capitaliseFirstLetter(viewType) + 'Click');

			if (typeof customAction === 'function') {
				customAction(date, ev);
			}
			else {
				if (typeof customAction === 'string') {
					viewType = customAction;
				}
				_this.zoomTo(date, viewType);
			}
		});

		// called immediately, and upon option change
		this.optionsModel.watch('applyingThemeClasses', [ '?theme' ], function(opts) {
			el.toggleClass('ui-widget', opts.theme);
			el.toggleClass('fc-unthemed', !opts.theme);
		});

		// called immediately, and upon option change.
		// HACK: locale often affects isRTL, so we explicitly listen to that too.
		this.optionsModel.watch('applyingDirClasses', [ '?isRTL', '?locale' ], function(opts) {
			el.toggleClass('fc-ltr', !opts.isRTL);
			el.toggleClass('fc-rtl', opts.isRTL);
		});

		this.contentEl = $("<div class='fc-view-container'/>").prependTo(el);

		this.initToolbars();
		this.renderHeader();
		this.renderFooter();
		this.renderView(this.opt('defaultView'));

		if (this.opt('handleWindowResize')) {
			$(window).resize(
				this.windowResizeProxy = debounce( // prevents rapid calls
					this.windowResize.bind(this),
					this.opt('windowResizeDelay')
				)
			);
		}
	},


	destroy: function() {

		if (this.view) {
			this.view.removeElement();

			// NOTE: don't null-out this.view in case API methods are called after destroy.
			// It is still the "current" view, just not rendered.
		}

		this.toolbarsManager.proxyCall('removeElement');
		this.contentEl.remove();
		this.el.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');

		this.el.off('.fc'); // unbind nav link handlers

		if (this.windowResizeProxy) {
			$(window).unbind('resize', this.windowResizeProxy);
			this.windowResizeProxy = null;
		}

		GlobalEmitter.unneeded();
	},


	elementVisible: function() {
		return this.el.is(':visible');
	},



	// View Rendering
	// -----------------------------------------------------------------------------------


	// Renders a view because of a date change, view-type change, or for the first time.
	// If not given a viewType, keep the current view but render different dates.
	// Accepts an optional scroll state to restore to.
	renderView: function(viewType, forcedScroll) {

		this.ignoreWindowResize++;

		var needsClearView = this.view && viewType && this.view.type !== viewType;

		// if viewType is changing, remove the old view's rendering
		if (needsClearView) {
			this.freezeContentHeight(); // prevent a scroll jump when view element is removed
			this.clearView();
		}

		// if viewType changed, or the view was never created, create a fresh view
		if (!this.view && viewType) {
			this.view =
				this.viewsByType[viewType] ||
				(this.viewsByType[viewType] = this.instantiateView(viewType));

			this.view.setElement(
				$("<div class='fc-view fc-" + viewType + "-view' />").appendTo(this.contentEl)
			);
			this.toolbarsManager.proxyCall('activateButton', viewType);
		}

		if (this.view) {

			if (forcedScroll) {
				this.view.addForcedScroll(forcedScroll);
			}

			if (this.elementVisible()) {
				this.currentDate = this.view.setDate(this.currentDate);
			}
		}

		if (needsClearView) {
			this.thawContentHeight();
		}

		this.ignoreWindowResize--;
	},


	// Unrenders the current view and reflects this change in the Header.
	// Unregsiters the `view`, but does not remove from viewByType hash.
	clearView: function() {
		this.toolbarsManager.proxyCall('deactivateButton', this.view.type);
		this.view.removeElement();
		this.view = null;
	},


	// Destroys the view, including the view object. Then, re-instantiates it and renders it.
	// Maintains the same scroll state.
	// TODO: maintain any other user-manipulated state.
	reinitView: function() {
		this.ignoreWindowResize++;
		this.freezeContentHeight();

		var viewType = this.view.type;
		var scrollState = this.view.queryScroll();
		this.clearView();
		this.calcSize();
		this.renderView(viewType, scrollState);

		this.thawContentHeight();
		this.ignoreWindowResize--;
	},


	// Resizing
	// -----------------------------------------------------------------------------------


	getSuggestedViewHeight: function() {
		if (this.suggestedViewHeight === null) {
			this.calcSize();
		}
		return this.suggestedViewHeight;
	},


	isHeightAuto: function() {
		return this.opt('contentHeight') === 'auto' || this.opt('height') === 'auto';
	},


	updateSize: function(shouldRecalc) {
		if (this.elementVisible()) {

			if (shouldRecalc) {
				this._calcSize();
			}

			this.ignoreWindowResize++;
			this.view.updateSize(true); // isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()
			this.ignoreWindowResize--;

			return true; // signal success
		}
	},


	calcSize: function() {
		if (this.elementVisible()) {
			this._calcSize();
		}
	},


	_calcSize: function() { // assumes elementVisible
		var contentHeightInput = this.opt('contentHeight');
		var heightInput = this.opt('height');

		if (typeof contentHeightInput === 'number') { // exists and not 'auto'
			this.suggestedViewHeight = contentHeightInput;
		}
		else if (typeof contentHeightInput === 'function') { // exists and is a function
			this.suggestedViewHeight = contentHeightInput();
		}
		else if (typeof heightInput === 'number') { // exists and not 'auto'
			this.suggestedViewHeight = heightInput - this.queryToolbarsHeight();
		}
		else if (typeof heightInput === 'function') { // exists and is a function
			this.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();
		}
		else if (heightInput === 'parent') { // set to height of parent element
			this.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();
		}
		else {
			this.suggestedViewHeight = Math.round(
				this.contentEl.width() /
				Math.max(this.opt('aspectRatio'), .5)
			);
		}
	},


	windowResize: function(ev) {
		if (
			!this.ignoreWindowResize &&
			ev.target === window && // so we don't process jqui "resize" events that have bubbled up
			this.view.renderRange // view has already been rendered
		) {
			if (this.updateSize(true)) {
				this.view.publiclyTrigger('windowResize', this.el[0]);
			}
		}
	},


	/* Height "Freezing"
	-----------------------------------------------------------------------------*/


	freezeContentHeight: function() {
		this.contentEl.css({
			width: '100%',
			height: this.contentEl.height(),
			overflow: 'hidden'
		});
	},


	thawContentHeight: function() {
		this.contentEl.css({
			width: '',
			height: '',
			overflow: ''
		});
	}

});

;;

Calendar.mixin({

	header: null,
	footer: null,
	toolbarsManager: null,


	initToolbars: function() {
		this.header = new Toolbar(this, this.computeHeaderOptions());
		this.footer = new Toolbar(this, this.computeFooterOptions());
		this.toolbarsManager = new Iterator([ this.header, this.footer ]);
	},


	computeHeaderOptions: function() {
		return {
			extraClasses: 'fc-header-toolbar',
			layout: this.opt('header')
		};
	},


	computeFooterOptions: function() {
		return {
			extraClasses: 'fc-footer-toolbar',
			layout: this.opt('footer')
		};
	},


	// can be called repeatedly and Header will rerender
	renderHeader: function() {
		var header = this.header;

		header.setToolbarOptions(this.computeHeaderOptions());
		header.render();

		if (header.el) {
			this.el.prepend(header.el);
		}
	},


	// can be called repeatedly and Footer will rerender
	renderFooter: function() {
		var footer = this.footer;

		footer.setToolbarOptions(this.computeFooterOptions());
		footer.render();

		if (footer.el) {
			this.el.append(footer.el);
		}
	},


	setToolbarsTitle: function(title) {
		this.toolbarsManager.proxyCall('updateTitle', title);
	},


	updateToolbarButtons: function() {
		var now = this.getNow();
		var view = this.view;
		var todayInfo = view.buildDateProfile(now);
		var prevInfo = view.buildPrevDateProfile(this.currentDate);
		var nextInfo = view.buildNextDateProfile(this.currentDate);

		this.toolbarsManager.proxyCall(
			(todayInfo.isValid && !isDateWithinRange(now, view.currentRange)) ?
				'enableButton' :
				'disableButton',
			'today'
		);

		this.toolbarsManager.proxyCall(
			prevInfo.isValid ?
				'enableButton' :
				'disableButton',
			'prev'
		);

		this.toolbarsManager.proxyCall(
			nextInfo.isValid ?
				'enableButton' :
				'disableButton',
			'next'
		);
	},


	queryToolbarsHeight: function() {
		return this.toolbarsManager.items.reduce(function(accumulator, toolbar) {
			var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin
			return accumulator + toolbarHeight;
		}, 0);
	}

});

;;

Calendar.defaults = {

	titleRangeSeparator: ' \u2013 ', // en dash
	monthYearFormat: 'MMMM YYYY', // required for en. other locales rely on datepicker computable option

	defaultTimedEventDuration: '02:00:00',
	defaultAllDayEventDuration: { days: 1 },
	forceEventDuration: false,
	nextDayThreshold: '09:00:00', // 9am

	// display
	defaultView: 'month',
	aspectRatio: 1.35,
	header: {
		left: 'title',
		center: '',
		right: 'today prev,next'
	},
	weekends: true,
	weekNumbers: false,

	weekNumberTitle: 'W',
	weekNumberCalculation: 'local',
	
	//editable: false,

	//nowIndicator: false,

	scrollTime: '06:00:00',
	minTime: '00:00:00',
	maxTime: '24:00:00',
	showNonCurrentDates: true,
	
	// event ajax
	lazyFetching: true,
	startParam: 'start',
	endParam: 'end',
	timezoneParam: 'timezone',

	timezone: false,

	//allDayDefault: undefined,

	// locale
	isRTL: false,
	buttonText: {
		prev: "prev",
		next: "next",
		prevYear: "prev year",
		nextYear: "next year",
		year: 'year', // TODO: locale files need to specify this
		today: 'today',
		month: 'month',
		week: 'week',
		day: 'day'
	},

	buttonIcons: {
		prev: 'left-single-arrow',
		next: 'right-single-arrow',
		prevYear: 'left-double-arrow',
		nextYear: 'right-double-arrow'
	},

	allDayText: 'all-day',
	
	// jquery-ui theming
	theme: false,
	themeButtonIcons: {
		prev: 'circle-triangle-w',
		next: 'circle-triangle-e',
		prevYear: 'seek-prev',
		nextYear: 'seek-next'
	},

	//eventResizableFromStart: false,
	dragOpacity: .75,
	dragRevertDuration: 500,
	dragScroll: true,
	
	//selectable: false,
	unselectAuto: true,
	//selectMinDistance: 0,
	
	dropAccept: '*',

	eventOrder: 'title',
	//eventRenderWait: null,

	eventLimit: false,
	eventLimitText: 'more',
	eventLimitClick: 'popover',
	dayPopoverFormat: 'LL',
	
	handleWindowResize: true,
	windowResizeDelay: 100, // milliseconds before an updateSize happens

	longPressDelay: 1000
	
};


Calendar.englishDefaults = { // used by locale.js
	dayPopoverFormat: 'dddd, MMMM D'
};


Calendar.rtlDefaults = { // right-to-left defaults
	header: { // TODO: smarter solution (first/center/last ?)
		left: 'next,prev today',
		center: '',
		right: 'title'
	},
	buttonIcons: {
		prev: 'right-single-arrow',
		next: 'left-single-arrow',
		prevYear: 'right-double-arrow',
		nextYear: 'left-double-arrow'
	},
	themeButtonIcons: {
		prev: 'circle-triangle-e',
		next: 'circle-triangle-w',
		nextYear: 'seek-prev',
		prevYear: 'seek-next'
	}
};

;;

var localeOptionHash = FC.locales = {}; // initialize and expose


// TODO: document the structure and ordering of a FullCalendar locale file


// Initialize jQuery UI datepicker translations while using some of the translations
// Will set this as the default locales for datepicker.
FC.datepickerLocale = function(localeCode, dpLocaleCode, dpOptions) {

	// get the FullCalendar internal option hash for this locale. create if necessary
	var fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});

	// transfer some simple options from datepicker to fc
	fcOptions.isRTL = dpOptions.isRTL;
	fcOptions.weekNumberTitle = dpOptions.weekHeader;

	// compute some more complex options from datepicker
	$.each(dpComputableOptions, function(name, func) {
		fcOptions[name] = func(dpOptions);
	});

	// is jQuery UI Datepicker is on the page?
	if ($.datepicker) {

		// Register the locale data.
		// FullCalendar and MomentJS use locale codes like "pt-br" but Datepicker
		// does it like "pt-BR" or if it doesn't have the locale, maybe just "pt".
		// Make an alias so the locale can be referenced either way.
		$.datepicker.regional[dpLocaleCode] =
			$.datepicker.regional[localeCode] = // alias
				dpOptions;

		// Alias 'en' to the default locale data. Do this every time.
		$.datepicker.regional.en = $.datepicker.regional[''];

		// Set as Datepicker's global defaults.
		$.datepicker.setDefaults(dpOptions);
	}
};


// Sets FullCalendar-specific translations. Will set the locales as the global default.
FC.locale = function(localeCode, newFcOptions) {
	var fcOptions;
	var momOptions;

	// get the FullCalendar internal option hash for this locale. create if necessary
	fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});

	// provided new options for this locales? merge them in
	if (newFcOptions) {
		fcOptions = localeOptionHash[localeCode] = mergeOptions([ fcOptions, newFcOptions ]);
	}

	// compute locale options that weren't defined.
	// always do this. newFcOptions can be undefined when initializing from i18n file,
	// so no way to tell if this is an initialization or a default-setting.
	momOptions = getMomentLocaleData(localeCode); // will fall back to en
	$.each(momComputableOptions, function(name, func) {
		if (fcOptions[name] == null) {
			fcOptions[name] = func(momOptions, fcOptions);
		}
	});

	// set it as the default locale for FullCalendar
	Calendar.defaults.locale = localeCode;
};


// NOTE: can't guarantee any of these computations will run because not every locale has datepicker
// configs, so make sure there are English fallbacks for these in the defaults file.
var dpComputableOptions = {

	buttonText: function(dpOptions) {
		return {
			// the translations sometimes wrongly contain HTML entities
			prev: stripHtmlEntities(dpOptions.prevText),
			next: stripHtmlEntities(dpOptions.nextText),
			today: stripHtmlEntities(dpOptions.currentText)
		};
	},

	// Produces format strings like "MMMM YYYY" -> "September 2014"
	monthYearFormat: function(dpOptions) {
		return dpOptions.showMonthAfterYear ?
			'YYYY[' + dpOptions.yearSuffix + '] MMMM' :
			'MMMM YYYY[' + dpOptions.yearSuffix + ']';
	}

};

var momComputableOptions = {

	// Produces format strings like "ddd M/D" -> "Fri 9/15"
	dayOfMonthFormat: function(momOptions, fcOptions) {
		var format = momOptions.longDateFormat('l'); // for the format like "M/D/YYYY"

		// strip the year off the edge, as well as other misc non-whitespace chars
		format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, '');

		if (fcOptions.isRTL) {
			format += ' ddd'; // for RTL, add day-of-week to end
		}
		else {
			format = 'ddd ' + format; // for LTR, add day-of-week to beginning
		}
		return format;
	},

	// Produces format strings like "h:mma" -> "6:00pm"
	mediumTimeFormat: function(momOptions) { // can't be called `timeFormat` because collides with option
		return momOptions.longDateFormat('LT')
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},

	// Produces format strings like "h(:mm)a" -> "6pm" / "6:30pm"
	smallTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '(:mm)')
			.replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},

	// Produces format strings like "h(:mm)t" -> "6p" / "6:30p"
	extraSmallTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '(:mm)')
			.replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
			.replace(/\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
	},

	// Produces format strings like "ha" / "H" -> "6pm" / "18"
	hourFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '')
			.replace(/(\Wmm)$/, '') // like above, but for foreign locales
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},

	// Produces format strings like "h:mm" -> "6:30" (with no AM/PM)
	noMeridiemTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(/\s*a$/i, ''); // remove trailing AM/PM
	}

};


// options that should be computed off live calendar options (considers override options)
// TODO: best place for this? related to locale?
// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it
var instanceComputableOptions = {

	// Produces format strings for results like "Mo 16"
	smallDayDateFormat: function(options) {
		return options.isRTL ?
			'D dd' :
			'dd D';
	},

	// Produces format strings for results like "Wk 5"
	weekFormat: function(options) {
		return options.isRTL ?
			'w[ ' + options.weekNumberTitle + ']' :
			'[' + options.weekNumberTitle + ' ]w';
	},

	// Produces format strings for results like "Wk5"
	smallWeekFormat: function(options) {
		return options.isRTL ?
			'w[' + options.weekNumberTitle + ']' :
			'[' + options.weekNumberTitle + ']w';
	}

};

// TODO: make these computable properties in optionsModel
function populateInstanceComputableOptions(options) {
	$.each(instanceComputableOptions, function(name, func) {
		if (options[name] == null) {
			options[name] = func(options);
		}
	});
}


// Returns moment's internal locale data. If doesn't exist, returns English.
function getMomentLocaleData(localeCode) {
	return moment.localeData(localeCode) || moment.localeData('en');
}


// Initialize English by forcing computation of moment-derived options.
// Also, sets it as the default.
FC.locale('en', Calendar.englishDefaults);

;;

FC.sourceNormalizers = [];
FC.sourceFetchers = [];

var ajaxDefaults = {
	dataType: 'json',
	cache: false
};

var eventGUID = 1;


function EventManager() { // assumed to be a calendar
	var t = this;


	// exports
	t.requestEvents = requestEvents;
	t.reportEventChange = reportEventChange;
	t.isFetchNeeded = isFetchNeeded;
	t.fetchEvents = fetchEvents;
	t.fetchEventSources = fetchEventSources;
	t.refetchEvents = refetchEvents;
	t.refetchEventSources = refetchEventSources;
	t.getEventSources = getEventSources;
	t.getEventSourceById = getEventSourceById;
	t.addEventSource = addEventSource;
	t.removeEventSource = removeEventSource;
	t.removeEventSources = removeEventSources;
	t.updateEvent = updateEvent;
	t.updateEvents = updateEvents;
	t.renderEvent = renderEvent;
	t.renderEvents = renderEvents;
	t.removeEvents = removeEvents;
	t.clientEvents = clientEvents;
	t.mutateEvent = mutateEvent;
	t.normalizeEventDates = normalizeEventDates;
	t.normalizeEventTimes = normalizeEventTimes;


	// locals
	var stickySource = { events: [] };
	var sources = [ stickySource ];
	var rangeStart, rangeEnd;
	var pendingSourceCnt = 0; // outstanding fetch requests, max one per source
	var cache = []; // holds events that have already been expanded
	var prunedCache; // like cache, but only events that intersect with rangeStart/rangeEnd


	$.each(
		(t.opt('events') ? [ t.opt('events') ] : []).concat(t.opt('eventSources') || []),
		function(i, sourceInput) {
			var source = buildEventSource(sourceInput);
			if (source) {
				sources.push(source);
			}
		}
	);



	function requestEvents(start, end) {
		if (!t.opt('lazyFetching') || isFetchNeeded(start, end)) {
			return fetchEvents(start, end);
		}
		else {
			return Promise.resolve(prunedCache);
		}
	}


	function reportEventChange() {
		prunedCache = filterEventsWithinRange(cache);
		t.trigger('eventsReset', prunedCache);
	}


	function filterEventsWithinRange(events) {
		var filteredEvents = [];
		var i, event;

		for (i = 0; i < events.length; i++) {
			event = events[i];

			if (
				event.start.clone().stripZone() < rangeEnd &&
				t.getEventEnd(event).stripZone() > rangeStart
			) {
				filteredEvents.push(event);
			}
		}

		return filteredEvents;
	}


	t.getEventCache = function() {
		return cache;
	};



	/* Fetching
	-----------------------------------------------------------------------------*/


	// start and end are assumed to be unzoned
	function isFetchNeeded(start, end) {
		return !rangeStart || // nothing has been fetched yet?
			start < rangeStart || end > rangeEnd; // is part of the new range outside of the old range?
	}


	function fetchEvents(start, end) {
		rangeStart = start;
		rangeEnd = end;
		return refetchEvents();
	}


	// poorly named. fetches all sources with current `rangeStart` and `rangeEnd`.
	function refetchEvents() {
		return fetchEventSources(sources, 'reset');
	}


	// poorly named. fetches a subset of event sources.
	function refetchEventSources(matchInputs) {
		return fetchEventSources(getEventSourcesByMatchArray(matchInputs));
	}


	// expects an array of event source objects (the originals, not copies)
	// `specialFetchType` is an optimization parameter that affects purging of the event cache.
	function fetchEventSources(specificSources, specialFetchType) {
		var i, source;

		if (specialFetchType === 'reset') {
			cache = [];
		}
		else if (specialFetchType !== 'add') {
			cache = excludeEventsBySources(cache, specificSources);
		}

		for (i = 0; i < specificSources.length; i++) {
			source = specificSources[i];

			// already-pending sources have already been accounted for in pendingSourceCnt
			if (source._status !== 'pending') {
				pendingSourceCnt++;
			}

			source._fetchId = (source._fetchId || 0) + 1;
			source._status = 'pending';
		}

		for (i = 0; i < specificSources.length; i++) {
			source = specificSources[i];
			tryFetchEventSource(source, source._fetchId);
		}

		if (pendingSourceCnt) {
			return Promise.construct(function(resolve) {
				t.one('eventsReceived', resolve); // will send prunedCache
			});
		}
		else { // executed all synchronously, or no sources at all
			return Promise.resolve(prunedCache);
		}
	}


	// fetches an event source and processes its result ONLY if it is still the current fetch.
	// caller is responsible for incrementing pendingSourceCnt first.
	function tryFetchEventSource(source, fetchId) {
		_fetchEventSource(source, function(eventInputs) {
			var isArraySource = $.isArray(source.events);
			var i, eventInput;
			var abstractEvent;

			if (
				// is this the source's most recent fetch?
				// if not, rely on an upcoming fetch of this source to decrement pendingSourceCnt
				fetchId === source._fetchId &&
				// event source no longer valid?
				source._status !== 'rejected'
			) {
				source._status = 'resolved';

				if (eventInputs) {
					for (i = 0; i < eventInputs.length; i++) {
						eventInput = eventInputs[i];

						if (isArraySource) { // array sources have already been convert to Event Objects
							abstractEvent = eventInput;
						}
						else {
							abstractEvent = buildEventFromInput(eventInput, source);
						}

						if (abstractEvent) { // not false (an invalid event)
							cache.push.apply( // append
								cache,
								expandEvent(abstractEvent) // add individual expanded events to the cache
							);
						}
					}
				}

				decrementPendingSourceCnt();
			}
		});
	}


	function rejectEventSource(source) {
		var wasPending = source._status === 'pending';

		source._status = 'rejected';

		if (wasPending) {
			decrementPendingSourceCnt();
		}
	}


	function decrementPendingSourceCnt() {
		pendingSourceCnt--;
		if (!pendingSourceCnt) {
			reportEventChange(cache); // updates prunedCache
			t.trigger('eventsReceived', prunedCache);
		}
	}


	function _fetchEventSource(source, callback) {
		var i;
		var fetchers = FC.sourceFetchers;
		var res;

		for (i=0; i<fetchers.length; i++) {
			res = fetchers[i].call(
				t, // this, the Calendar object
				source,
				rangeStart.clone(),
				rangeEnd.clone(),
				t.opt('timezone'),
				callback
			);

			if (res === true) {
				// the fetcher is in charge. made its own async request
				return;
			}
			else if (typeof res == 'object') {
				// the fetcher returned a new source. process it
				_fetchEventSource(res, callback);
				return;
			}
		}

		var events = source.events;
		if (events) {
			if ($.isFunction(events)) {
				t.pushLoading();
				events.call(
					t, // this, the Calendar object
					rangeStart.clone(),
					rangeEnd.clone(),
					t.opt('timezone'),
					function(events) {
						callback(events);
						t.popLoading();
					}
				);
			}
			else if ($.isArray(events)) {
				callback(events);
			}
			else {
				callback();
			}
		}else{
			var url = source.url;
			if (url) {
				var success = source.success;
				var error = source.error;
				var complete = source.complete;

				// retrieve any outbound GET/POST $.ajax data from the options
				var customData;
				if ($.isFunction(source.data)) {
					// supplied as a function that returns a key/value object
					customData = source.data();
				}
				else {
					// supplied as a straight key/value object
					customData = source.data;
				}

				// use a copy of the custom data so we can modify the parameters
				// and not affect the passed-in object.
				var data = $.extend({}, customData || {});

				var startParam = firstDefined(source.startParam, t.opt('startParam'));
				var endParam = firstDefined(source.endParam, t.opt('endParam'));
				var timezoneParam = firstDefined(source.timezoneParam, t.opt('timezoneParam'));

				if (startParam) {
					data[startParam] = rangeStart.format();
				}
				if (endParam) {
					data[endParam] = rangeEnd.format();
				}
				if (t.opt('timezone') && t.opt('timezone') != 'local') {
					data[timezoneParam] = t.opt('timezone');
				}

				t.pushLoading();
				$.ajax($.extend({}, ajaxDefaults, source, {
					data: data,
					success: function(events) {
						events = events || [];
						var res = applyAll(success, this, arguments);
						if ($.isArray(res)) {
							events = res;
						}
						callback(events);
					},
					error: function() {
						applyAll(error, this, arguments);
						callback();
					},
					complete: function() {
						applyAll(complete, this, arguments);
						t.popLoading();
					}
				}));
			}else{
				callback();
			}
		}
	}



	/* Sources
	-----------------------------------------------------------------------------*/


	function addEventSource(sourceInput) {
		var source = buildEventSource(sourceInput);
		if (source) {
			sources.push(source);
			fetchEventSources([ source ], 'add'); // will eventually call reportEventChange
		}
	}


	function buildEventSource(sourceInput) { // will return undefined if invalid source
		var normalizers = FC.sourceNormalizers;
		var source;
		var i;

		if ($.isFunction(sourceInput) || $.isArray(sourceInput)) {
			source = { events: sourceInput };
		}
		else if (typeof sourceInput === 'string') {
			source = { url: sourceInput };
		}
		else if (typeof sourceInput === 'object') {
			source = $.extend({}, sourceInput); // shallow copy
		}

		if (source) {

			// TODO: repeat code, same code for event classNames
			if (source.className) {
				if (typeof source.className === 'string') {
					source.className = source.className.split(/\s+/);
				}
				// otherwise, assumed to be an array
			}
			else {
				source.className = [];
			}

			// for array sources, we convert to standard Event Objects up front
			if ($.isArray(source.events)) {
				source.origArray = source.events; // for removeEventSource
				source.events = $.map(source.events, function(eventInput) {
					return buildEventFromInput(eventInput, source);
				});
			}

			for (i=0; i<normalizers.length; i++) {
				normalizers[i].call(t, source);
			}

			return source;
		}
	}


	function removeEventSource(matchInput) {
		removeSpecificEventSources(
			getEventSourcesByMatch(matchInput)
		);
	}


	// if called with no arguments, removes all.
	function removeEventSources(matchInputs) {
		if (matchInputs == null) {
			removeSpecificEventSources(sources, true); // isAll=true
		}
		else {
			removeSpecificEventSources(
				getEventSourcesByMatchArray(matchInputs)
			);
		}
	}


	function removeSpecificEventSources(targetSources, isAll) {
		var i;

		// cancel pending requests
		for (i = 0; i < targetSources.length; i++) {
			rejectEventSource(targetSources[i]);
		}

		if (isAll) { // an optimization
			sources = [];
			cache = [];
		}
		else {
			// remove from persisted source list
			sources = $.grep(sources, function(source) {
				for (i = 0; i < targetSources.length; i++) {
					if (source === targetSources[i]) {
						return false; // exclude
					}
				}
				return true; // include
			});

			cache = excludeEventsBySources(cache, targetSources);
		}

		reportEventChange();
	}


	function getEventSources() {
		return sources.slice(1); // returns a shallow copy of sources with stickySource removed
	}


	function getEventSourceById(id) {
		return $.grep(sources, function(source) {
			return source.id && source.id === id;
		})[0];
	}


	// like getEventSourcesByMatch, but accepts multple match criteria (like multiple IDs)
	function getEventSourcesByMatchArray(matchInputs) {

		// coerce into an array
		if (!matchInputs) {
			matchInputs = [];
		}
		else if (!$.isArray(matchInputs)) {
			matchInputs = [ matchInputs ];
		}

		var matchingSources = [];
		var i;

		// resolve raw inputs to real event source objects
		for (i = 0; i < matchInputs.length; i++) {
			matchingSources.push.apply( // append
				matchingSources,
				getEventSourcesByMatch(matchInputs[i])
			);
		}

		return matchingSources;
	}


	// matchInput can either by a real event source object, an ID, or the function/URL for the source.
	// returns an array of matching source objects.
	function getEventSourcesByMatch(matchInput) {
		var i, source;

		// given an proper event source object
		for (i = 0; i < sources.length; i++) {
			source = sources[i];
			if (source === matchInput) {
				return [ source ];
			}
		}

		// an ID match
		source = getEventSourceById(matchInput);
		if (source) {
			return [ source ];
		}

		return $.grep(sources, function(source) {
			return isSourcesEquivalent(matchInput, source);
		});
	}


	function isSourcesEquivalent(source1, source2) {
		return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
	}


	function getSourcePrimitive(source) {
		return (
			(typeof source === 'object') ? // a normalized event source?
				(source.origArray || source.googleCalendarId || source.url || source.events) : // get the primitive
				null
		) ||
		source; // the given argument *is* the primitive
	}


	// util
	// returns a filtered array without events that are part of any of the given sources
	function excludeEventsBySources(specificEvents, specificSources) {
		return $.grep(specificEvents, function(event) {
			for (var i = 0; i < specificSources.length; i++) {
				if (event.source === specificSources[i]) {
					return false; // exclude
				}
			}
			return true; // keep
		});
	}



	/* Manipulation
	-----------------------------------------------------------------------------*/


	// Only ever called from the externally-facing API
	function updateEvent(event) {
		updateEvents([ event ]);
	}


	// Only ever called from the externally-facing API
	function updateEvents(events) {
		var i, event;

		for (i = 0; i < events.length; i++) {
			event = events[i];

			// massage start/end values, even if date string values
			event.start = t.moment(event.start);
			if (event.end) {
				event.end = t.moment(event.end);
			}
			else {
				event.end = null;
			}

			mutateEvent(event, getMiscEventProps(event)); // will handle start/end/allDay normalization
		}

		reportEventChange(); // reports event modifications (so we can redraw)
	}


	// Returns a hash of misc event properties that should be copied over to related events.
	function getMiscEventProps(event) {
		var props = {};

		$.each(event, function(name, val) {
			if (isMiscEventPropName(name)) {
				if (val !== undefined && isAtomic(val)) { // a defined non-object
					props[name] = val;
				}
			}
		});

		return props;
	}

	// non-date-related, non-id-related, non-secret
	function isMiscEventPropName(name) {
		return !/^_|^(id|allDay|start|end)$/.test(name);
	}


	// returns the expanded events that were created
	function renderEvent(eventInput, stick) {
		return renderEvents([ eventInput ], stick);
	}


	// returns the expanded events that were created
	function renderEvents(eventInputs, stick) {
		var renderedEvents = [];
		var renderableEvents;
		var abstractEvent;
		var i, j, event;

		for (i = 0; i < eventInputs.length; i++) {
			abstractEvent = buildEventFromInput(eventInputs[i]);

			if (abstractEvent) { // not false (a valid input)
				renderableEvents = expandEvent(abstractEvent);

				for (j = 0; j < renderableEvents.length; j++) {
					event = renderableEvents[j];

					if (!event.source) {
						if (stick) {
							stickySource.events.push(event);
							event.source = stickySource;
						}
						cache.push(event);
					}
				}

				renderedEvents = renderedEvents.concat(renderableEvents);
			}
		}

		if (renderedEvents.length) { // any new events rendered?
			reportEventChange();
		}

		return renderedEvents;
	}


	function removeEvents(filter) {
		var eventID;
		var i;

		if (filter == null) { // null or undefined. remove all events
			filter = function() { return true; }; // will always match
		}
		else if (!$.isFunction(filter)) { // an event ID
			eventID = filter + '';
			filter = function(event) {
				return event._id == eventID;
			};
		}

		// Purge event(s) from our local cache
		cache = $.grep(cache, filter, true); // inverse=true

		// Remove events from array sources.
		// This works because they have been converted to official Event Objects up front.
		// (and as a result, event._id has been calculated).
		for (i=0; i<sources.length; i++) {
			if ($.isArray(sources[i].events)) {
				sources[i].events = $.grep(sources[i].events, filter, true);
			}
		}

		reportEventChange();
	}


	function clientEvents(filter) {
		if ($.isFunction(filter)) {
			return $.grep(cache, filter);
		}
		else if (filter != null) { // not null, not undefined. an event ID
			filter += '';
			return $.grep(cache, function(e) {
				return e._id == filter;
			});
		}
		return cache; // else, return all
	}


	// Makes sure all array event sources have their internal event objects
	// converted over to the Calendar's current timezone.
	t.rezoneArrayEventSources = function() {
		var i;
		var events;
		var j;

		for (i = 0; i < sources.length; i++) {
			events = sources[i].events;
			if ($.isArray(events)) {

				for (j = 0; j < events.length; j++) {
					rezoneEventDates(events[j]);
				}
			}
		}
	};

	function rezoneEventDates(event) {
		event.start = t.moment(event.start);
		if (event.end) {
			event.end = t.moment(event.end);
		}
		backupEventDates(event);
	}


	/* Event Normalization
	-----------------------------------------------------------------------------*/


	// Given a raw object with key/value properties, returns an "abstract" Event object.
	// An "abstract" event is an event that, if recurring, will not have been expanded yet.
	// Will return `false` when input is invalid.
	// `source` is optional
	function buildEventFromInput(input, source) {
		var calendarEventDataTransform = t.opt('eventDataTransform');
		var out = {};
		var start, end;
		var allDay;

		if (calendarEventDataTransform) {
			input = calendarEventDataTransform(input);
		}
		if (source && source.eventDataTransform) {
			input = source.eventDataTransform(input);
		}

		// Copy all properties over to the resulting object.
		// The special-case properties will be copied over afterwards.
		$.extend(out, input);

		if (source) {
			out.source = source;
		}

		out._id = input._id || (input.id === undefined ? '_fc' + eventGUID++ : input.id + '');

		if (input.className) {
			if (typeof input.className == 'string') {
				out.className = input.className.split(/\s+/);
			}
			else { // assumed to be an array
				out.className = input.className;
			}
		}
		else {
			out.className = [];
		}

		start = input.start || input.date; // "date" is an alias for "start"
		end = input.end;

		// parse as a time (Duration) if applicable
		if (isTimeString(start)) {
			start = moment.duration(start);
		}
		if (isTimeString(end)) {
			end = moment.duration(end);
		}

		if (input.dow || moment.isDuration(start) || moment.isDuration(end)) {

			// the event is "abstract" (recurring) so don't calculate exact start/end dates just yet
			out.start = start ? moment.duration(start) : null; // will be a Duration or null
			out.end = end ? moment.duration(end) : null; // will be a Duration or null
			out._recurring = true; // our internal marker
		}
		else {

			if (start) {
				start = t.moment(start);
				if (!start.isValid()) {
					return false;
				}
			}

			if (end) {
				end = t.moment(end);
				if (!end.isValid()) {
					end = null; // let defaults take over
				}
			}

			allDay = input.allDay;
			if (allDay === undefined) { // still undefined? fallback to default
				allDay = firstDefined(
					source ? source.allDayDefault : undefined,
					t.opt('allDayDefault')
				);
				// still undefined? normalizeEventDates will calculate it
			}

			assignDatesToEvent(start, end, allDay, out);
		}

		t.normalizeEvent(out); // hook for external use. a prototype method

		return out;
	}
	t.buildEventFromInput = buildEventFromInput;


	// Normalizes and assigns the given dates to the given partially-formed event object.
	// NOTE: mutates the given start/end moments. does not make a copy.
	function assignDatesToEvent(start, end, allDay, event) {
		event.start = start;
		event.end = end;
		event.allDay = allDay;
		normalizeEventDates(event);
		backupEventDates(event);
	}


	// Ensures proper values for allDay/start/end. Accepts an Event object, or a plain object with event-ish properties.
	// NOTE: Will modify the given object.
	function normalizeEventDates(eventProps) {

		normalizeEventTimes(eventProps);

		if (eventProps.end && !eventProps.end.isAfter(eventProps.start)) {
			eventProps.end = null;
		}

		if (!eventProps.end) {
			if (t.opt('forceEventDuration')) {
				eventProps.end = t.getDefaultEventEnd(eventProps.allDay, eventProps.start);
			}
			else {
				eventProps.end = null;
			}
		}
	}


	// Ensures the allDay property exists and the timeliness of the start/end dates are consistent
	function normalizeEventTimes(eventProps) {
		if (eventProps.allDay == null) {
			eventProps.allDay = !(eventProps.start.hasTime() || (eventProps.end && eventProps.end.hasTime()));
		}

		if (eventProps.allDay) {
			eventProps.start.stripTime();
			if (eventProps.end) {
				// TODO: consider nextDayThreshold here? If so, will require a lot of testing and adjustment
				eventProps.end.stripTime();
			}
		}
		else {
			if (!eventProps.start.hasTime()) {
				eventProps.start = t.applyTimezone(eventProps.start.time(0)); // will assign a 00:00 time
			}
			if (eventProps.end && !eventProps.end.hasTime()) {
				eventProps.end = t.applyTimezone(eventProps.end.time(0)); // will assign a 00:00 time
			}
		}
	}


	// If the given event is a recurring event, break it down into an array of individual instances.
	// If not a recurring event, return an array with the single original event.
	// If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.
	// HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).
	function expandEvent(abstractEvent, _rangeStart, _rangeEnd) {
		var events = [];
		var dowHash;
		var dow;
		var i;
		var date;
		var startTime, endTime;
		var start, end;
		var event;

		_rangeStart = _rangeStart || rangeStart;
		_rangeEnd = _rangeEnd || rangeEnd;

		if (abstractEvent) {
			if (abstractEvent._recurring) {

				// make a boolean hash as to whether the event occurs on each day-of-week
				if ((dow = abstractEvent.dow)) {
					dowHash = {};
					for (i = 0; i < dow.length; i++) {
						dowHash[dow[i]] = true;
					}
				}

				// iterate through every day in the current range
				date = _rangeStart.clone().stripTime(); // holds the date of the current day
				while (date.isBefore(_rangeEnd)) {

					if (!dowHash || dowHash[date.day()]) { // if everyday, or this particular day-of-week

						startTime = abstractEvent.start; // the stored start and end properties are times (Durations)
						endTime = abstractEvent.end; // "
						start = date.clone();
						end = null;

						if (startTime) {
							start = start.time(startTime);
						}
						if (endTime) {
							end = date.clone().time(endTime);
						}

						event = $.extend({}, abstractEvent); // make a copy of the original
						assignDatesToEvent(
							start, end,
							!startTime && !endTime, // allDay?
							event
						);
						events.push(event);
					}

					date.add(1, 'days');
				}
			}
			else {
				events.push(abstractEvent); // return the original event. will be a one-item array
			}
		}

		return events;
	}
	t.expandEvent = expandEvent;



	/* Event Modification Math
	-----------------------------------------------------------------------------------------*/


	// Modifies an event and all related events by applying the given properties.
	// Special date-diffing logic is used for manipulation of dates.
	// If `props` does not contain start/end dates, the updated values are assumed to be the event's current start/end.
	// All date comparisons are done against the event's pristine _start and _end dates.
	// Returns an object with delta information and a function to undo all operations.
	// For making computations in a granularity greater than day/time, specify largeUnit.
	// NOTE: The given `newProps` might be mutated for normalization purposes.
	function mutateEvent(event, newProps, largeUnit) {
		var miscProps = {};
		var oldProps;
		var clearEnd;
		var startDelta;
		var endDelta;
		var durationDelta;
		var undoFunc;

		// diffs the dates in the appropriate way, returning a duration
		function diffDates(date1, date0) { // date1 - date0
			if (largeUnit) {
				return diffByUnit(date1, date0, largeUnit);
			}
			else if (newProps.allDay) {
				return diffDay(date1, date0);
			}
			else {
				return diffDayTime(date1, date0);
			}
		}

		newProps = newProps || {};

		// normalize new date-related properties
		if (!newProps.start) {
			newProps.start = event.start.clone();
		}
		if (newProps.end === undefined) {
			newProps.end = event.end ? event.end.clone() : null;
		}
		if (newProps.allDay == null) { // is null or undefined?
			newProps.allDay = event.allDay;
		}
		normalizeEventDates(newProps);

		// create normalized versions of the original props to compare against
		// need a real end value, for diffing
		oldProps = {
			start: event._start.clone(),
			end: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),
			allDay: newProps.allDay // normalize the dates in the same regard as the new properties
		};
		normalizeEventDates(oldProps);

		// need to clear the end date if explicitly changed to null
		clearEnd = event._end !== null && newProps.end === null;

		// compute the delta for moving the start date
		startDelta = diffDates(newProps.start, oldProps.start);

		// compute the delta for moving the end date
		if (newProps.end) {
			endDelta = diffDates(newProps.end, oldProps.end);
			durationDelta = endDelta.subtract(startDelta);
		}
		else {
			durationDelta = null;
		}

		// gather all non-date-related properties
		$.each(newProps, function(name, val) {
			if (isMiscEventPropName(name)) {
				if (val !== undefined) {
					miscProps[name] = val;
				}
			}
		});

		// apply the operations to the event and all related events
		undoFunc = mutateEvents(
			clientEvents(event._id), // get events with this ID
			clearEnd,
			newProps.allDay,
			startDelta,
			durationDelta,
			miscProps
		);

		return {
			dateDelta: startDelta,
			durationDelta: durationDelta,
			undo: undoFunc
		};
	}


	// Modifies an array of events in the following ways (operations are in order):
	// - clear the event's `end`
	// - convert the event to allDay
	// - add `dateDelta` to the start and end
	// - add `durationDelta` to the event's duration
	// - assign `miscProps` to the event
	//
	// Returns a function that can be called to undo all the operations.
	//
	// TODO: don't use so many closures. possible memory issues when lots of events with same ID.
	//
	function mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {
		var isAmbigTimezone = t.getIsAmbigTimezone();
		var undoFunctions = [];

		// normalize zero-length deltas to be null
		if (dateDelta && !dateDelta.valueOf()) { dateDelta = null; }
		if (durationDelta && !durationDelta.valueOf()) { durationDelta = null; }

		$.each(events, function(i, event) {
			var oldProps;
			var newProps;

			// build an object holding all the old values, both date-related and misc.
			// for the undo function.
			oldProps = {
				start: event.start.clone(),
				end: event.end ? event.end.clone() : null,
				allDay: event.allDay
			};
			$.each(miscProps, function(name) {
				oldProps[name] = event[name];
			});

			// new date-related properties. work off the original date snapshot.
			// ok to use references because they will be thrown away when backupEventDates is called.
			newProps = {
				start: event._start,
				end: event._end,
				allDay: allDay // normalize the dates in the same regard as the new properties
			};
			normalizeEventDates(newProps); // massages start/end/allDay

			// strip or ensure the end date
			if (clearEnd) {
				newProps.end = null;
			}
			else if (durationDelta && !newProps.end) { // the duration translation requires an end date
				newProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);
			}

			if (dateDelta) {
				newProps.start.add(dateDelta);
				if (newProps.end) {
					newProps.end.add(dateDelta);
				}
			}

			if (durationDelta) {
				newProps.end.add(durationDelta); // end already ensured above
			}

			// if the dates have changed, and we know it is impossible to recompute the
			// timezone offsets, strip the zone.
			if (
				isAmbigTimezone &&
				!newProps.allDay &&
				(dateDelta || durationDelta)
			) {
				newProps.start.stripZone();
				if (newProps.end) {
					newProps.end.stripZone();
				}
			}

			$.extend(event, miscProps, newProps); // copy over misc props, then date-related props
			backupEventDates(event); // regenerate internal _start/_end/_allDay

			undoFunctions.push(function() {
				$.extend(event, oldProps);
				backupEventDates(event); // regenerate internal _start/_end/_allDay
			});
		});

		return function() {
			for (var i = 0; i < undoFunctions.length; i++) {
				undoFunctions[i]();
			}
		};
	}

}


// returns an undo function
Calendar.prototype.mutateSeg = function(seg, newProps) {
	return this.mutateEvent(seg.event, newProps);
};


// hook for external libs to manipulate event properties upon creation.
// should manipulate the event in-place.
Calendar.prototype.normalizeEvent = function(event) {
};


// Does the given span (start, end, and other location information)
// fully contain the other?
Calendar.prototype.spanContainsSpan = function(outerSpan, innerSpan) {
	var eventStart = outerSpan.start.clone().stripZone();
	var eventEnd = this.getEventEnd(outerSpan).stripZone();

	return innerSpan.start >= eventStart && innerSpan.end <= eventEnd;
};


// Returns a list of events that the given event should be compared against when being considered for a move to
// the specified span. Attached to the Calendar's prototype because EventManager is a mixin for a Calendar.
Calendar.prototype.getPeerEvents = function(span, event) {
	var cache = this.getEventCache();
	var peerEvents = [];
	var i, otherEvent;

	for (i = 0; i < cache.length; i++) {
		otherEvent = cache[i];
		if (
			!event ||
			event._id !== otherEvent._id // don't compare the event to itself or other related [repeating] events
		) {
			peerEvents.push(otherEvent);
		}
	}

	return peerEvents;
};


// updates the "backup" properties, which are preserved in order to compute diffs later on.
function backupEventDates(event) {
	event._allDay = event.allDay;
	event._start = event.start.clone();
	event._end = event.end ? event.end.clone() : null;
}


/* Overlapping / Constraining
-----------------------------------------------------------------------------------------*/


// Determines if the given event can be relocated to the given span (unzoned start/end with other misc data)
Calendar.prototype.isEventSpanAllowed = function(span, event) {
	var source = event.source || {};
	var eventAllowFunc = this.opt('eventAllow');

	var constraint = firstDefined(
		event.constraint,
		source.constraint,
		this.opt('eventConstraint')
	);

	var overlap = firstDefined(
		event.overlap,
		source.overlap,
		this.opt('eventOverlap')
	);

	return this.isSpanAllowed(span, constraint, overlap, event) &&
		(!eventAllowFunc || eventAllowFunc(span, event) !== false);
};


// Determines if an external event can be relocated to the given span (unzoned start/end with other misc data)
Calendar.prototype.isExternalSpanAllowed = function(eventSpan, eventLocation, eventProps) {
	var eventInput;
	var event;

	// note: very similar logic is in View's reportExternalDrop
	if (eventProps) {
		eventInput = $.extend({}, eventProps, eventLocation);
		event = this.expandEvent(
			this.buildEventFromInput(eventInput)
		)[0];
	}

	if (event) {
		return this.isEventSpanAllowed(eventSpan, event);
	}
	else { // treat it as a selection

		return this.isSelectionSpanAllowed(eventSpan);
	}
};


// Determines the given span (unzoned start/end with other misc data) can be selected.
Calendar.prototype.isSelectionSpanAllowed = function(span) {
	var selectAllowFunc = this.opt('selectAllow');

	return this.isSpanAllowed(span, this.opt('selectConstraint'), this.opt('selectOverlap')) &&
		(!selectAllowFunc || selectAllowFunc(span) !== false);
};


// Returns true if the given span (caused by an event drop/resize or a selection) is allowed to exist
// according to the constraint/overlap settings.
// `event` is not required if checking a selection.
Calendar.prototype.isSpanAllowed = function(span, constraint, overlap, event) {
	var constraintEvents;
	var anyContainment;
	var peerEvents;
	var i, peerEvent;
	var peerOverlap;

	// the range must be fully contained by at least one of produced constraint events
	if (constraint != null) {

		// not treated as an event! intermediate data structure
		// TODO: use ranges in the future
		constraintEvents = this.constraintToEvents(constraint);
		if (constraintEvents) { // not invalid

			anyContainment = false;
			for (i = 0; i < constraintEvents.length; i++) {
				if (this.spanContainsSpan(constraintEvents[i], span)) {
					anyContainment = true;
					break;
				}
			}

			if (!anyContainment) {
				return false;
			}
		}
	}

	peerEvents = this.getPeerEvents(span, event);

	for (i = 0; i < peerEvents.length; i++)  {
		peerEvent = peerEvents[i];

		// there needs to be an actual intersection before disallowing anything
		if (this.eventIntersectsRange(peerEvent, span)) {

			// evaluate overlap for the given range and short-circuit if necessary
			if (overlap === false) {
				return false;
			}
			// if the event's overlap is a test function, pass the peer event in question as the first param
			else if (typeof overlap === 'function' && !overlap(peerEvent, event)) {
				return false;
			}

			// if we are computing if the given range is allowable for an event, consider the other event's
			// EventObject-specific or Source-specific `overlap` property
			if (event) {
				peerOverlap = firstDefined(
					peerEvent.overlap,
					(peerEvent.source || {}).overlap
					// we already considered the global `eventOverlap`
				);
				if (peerOverlap === false) {
					return false;
				}
				// if the peer event's overlap is a test function, pass the subject event as the first param
				if (typeof peerOverlap === 'function' && !peerOverlap(event, peerEvent)) {
					return false;
				}
			}
		}
	}

	return true;
};


// Given an event input from the API, produces an array of event objects. Possible event inputs:
// 'businessHours'
// An event ID (number or string)
// An object with specific start/end dates or a recurring event (like what businessHours accepts)
Calendar.prototype.constraintToEvents = function(constraintInput) {

	if (constraintInput === 'businessHours') {
		return this.getCurrentBusinessHourEvents();
	}

	if (typeof constraintInput === 'object') {
		if (constraintInput.start != null) { // needs to be event-like input
			return this.expandEvent(this.buildEventFromInput(constraintInput));
		}
		else {
			return null; // invalid
		}
	}

	return this.clientEvents(constraintInput); // probably an ID
};


// Does the event's date range intersect with the given range?
// start/end already assumed to have stripped zones :(
Calendar.prototype.eventIntersectsRange = function(event, range) {
	var eventStart = event.start.clone().stripZone();
	var eventEnd = this.getEventEnd(event).stripZone();

	return range.start < eventEnd && range.end > eventStart;
};


/* Business Hours
-----------------------------------------------------------------------------------------*/

var BUSINESS_HOUR_EVENT_DEFAULTS = {
	id: '_fcBusinessHours', // will relate events from different calls to expandEvent
	start: '09:00',
	end: '17:00',
	dow: [ 1, 2, 3, 4, 5 ], // monday - friday
	rendering: 'inverse-background'
	// classNames are defined in businessHoursSegClasses
};

// Return events objects for business hours within the current view.
// Abuse of our event system :(
Calendar.prototype.getCurrentBusinessHourEvents = function(wholeDay) {
	return this.computeBusinessHourEvents(wholeDay, this.opt('businessHours'));
};

// Given a raw input value from options, return events objects for business hours within the current view.
Calendar.prototype.computeBusinessHourEvents = function(wholeDay, input) {
	if (input === true) {
		return this.expandBusinessHourEvents(wholeDay, [ {} ]);
	}
	else if ($.isPlainObject(input)) {
		return this.expandBusinessHourEvents(wholeDay, [ input ]);
	}
	else if ($.isArray(input)) {
		return this.expandBusinessHourEvents(wholeDay, input, true);
	}
	else {
		return [];
	}
};

// inputs expected to be an array of objects.
// if ignoreNoDow is true, will ignore entries that don't specify a day-of-week (dow) key.
Calendar.prototype.expandBusinessHourEvents = function(wholeDay, inputs, ignoreNoDow) {
	var view = this.getView();
	var events = [];
	var i, input;

	for (i = 0; i < inputs.length; i++) {
		input = inputs[i];

		if (ignoreNoDow && !input.dow) {
			continue;
		}

		// give defaults. will make a copy
		input = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, input);

		// if a whole-day series is requested, clear the start/end times
		if (wholeDay) {
			input.start = null;
			input.end = null;
		}

		events.push.apply(events, // append
			this.expandEvent(
				this.buildEventFromInput(input),
				view.activeRange.start,
				view.activeRange.end
			)
		);
	}

	return events;
};

;;

/* An abstract class for the "basic" views, as well as month view. Renders one or more rows of day cells.
----------------------------------------------------------------------------------------------------------------------*/
// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.

var BasicView = FC.BasicView = View.extend({

	scroller: null,

	dayGridClass: DayGrid, // class the dayGrid will be instantiated from (overridable by subclasses)
	dayGrid: null, // the main subcomponent that does most of the heavy lifting

	dayNumbersVisible: false, // display day numbers on each day cell?
	colWeekNumbersVisible: false, // display week numbers along the side?
	cellWeekNumbersVisible: false, // display week numbers in day cell?

	weekNumberWidth: null, // width of all the week-number cells running down the side

	headContainerEl: null, // div that hold's the dayGrid's rendered date header
	headRowEl: null, // the fake row element of the day-of-week header


	initialize: function() {
		this.dayGrid = this.instantiateDayGrid();

		this.scroller = new Scroller({
			overflowX: 'hidden',
			overflowY: 'auto'
		});
	},


	// Generates the DayGrid object this view needs. Draws from this.dayGridClass
	instantiateDayGrid: function() {
		// generate a subclass on the fly with BasicView-specific behavior
		// TODO: cache this subclass
		var subclass = this.dayGridClass.extend(basicDayGridMethods);

		return new subclass(this);
	},


	// Computes the date range that will be rendered.
	buildRenderRange: function(currentRange, currentRangeUnit) {
		var renderRange = View.prototype.buildRenderRange.apply(this, arguments);

		// year and month views should be aligned with weeks. this is already done for week
		if (/^(year|month)$/.test(currentRangeUnit)) {
			renderRange.start.startOf('week');

			// make end-of-week if not already
			if (renderRange.end.weekday()) {
				renderRange.end.add(1, 'week').startOf('week'); // exclusively move backwards
			}
		}

		return this.trimHiddenDays(renderRange);
	},


	// Renders the view into `this.el`, which should already be assigned
	renderDates: function() {

		this.dayGrid.breakOnWeeks = /year|month|week/.test(this.currentRangeUnit); // do before Grid::setRange
		this.dayGrid.setRange(this.renderRange);

		this.dayNumbersVisible = this.dayGrid.rowCnt > 1; // TODO: make grid responsible
		if (this.opt('weekNumbers')) {
			if (this.opt('weekNumbersWithinDays')) {
				this.cellWeekNumbersVisible = true;
				this.colWeekNumbersVisible = false;
			}
			else {
				this.cellWeekNumbersVisible = false;
				this.colWeekNumbersVisible = true;
			};
		}
		this.dayGrid.numbersVisible = this.dayNumbersVisible ||
			this.cellWeekNumbersVisible || this.colWeekNumbersVisible;

		this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());
		this.renderHead();

		this.scroller.render();
		var dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');
		var dayGridEl = $('<div class="fc-day-grid" />').appendTo(dayGridContainerEl);
		this.el.find('.fc-body > tr > td').append(dayGridContainerEl);

		this.dayGrid.setElement(dayGridEl);
		this.dayGrid.renderDates(this.hasRigidRows());
	},


	// render the day-of-week headers
	renderHead: function() {
		this.headContainerEl =
			this.el.find('.fc-head-container')
				.html(this.dayGrid.renderHeadHtml());
		this.headRowEl = this.headContainerEl.find('.fc-row');
	},


	// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
	// always completely kill the dayGrid's rendering.
	unrenderDates: function() {
		this.dayGrid.unrenderDates();
		this.dayGrid.removeElement();
		this.scroller.destroy();
	},


	renderBusinessHours: function() {
		this.dayGrid.renderBusinessHours();
	},


	unrenderBusinessHours: function() {
		this.dayGrid.unrenderBusinessHours();
	},


	// Builds the HTML skeleton for the view.
	// The day-grid component will render inside of a container defined by this HTML.
	renderSkeletonHtml: function() {
		return '' +
			'<table>' +
				'<thead class="fc-head">' +
					'<tr>' +
						'<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' +
					'</tr>' +
				'</thead>' +
				'<tbody class="fc-body">' +
					'<tr>' +
						'<td class="' + this.widgetContentClass + '"></td>' +
					'</tr>' +
				'</tbody>' +
			'</table>';
	},


	// Generates an HTML attribute string for setting the width of the week number column, if it is known
	weekNumberStyleAttr: function() {
		if (this.weekNumberWidth !== null) {
			return 'style="width:' + this.weekNumberWidth + 'px"';
		}
		return '';
	},


	// Determines whether each row should have a constant height
	hasRigidRows: function() {
		var eventLimit = this.opt('eventLimit');
		return eventLimit && typeof eventLimit !== 'number';
	},


	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


	// Refreshes the horizontal dimensions of the view
	updateWidth: function() {
		if (this.colWeekNumbersVisible) {
			// Make sure all week number cells running down the side have the same width.
			// Record the width for cells created later.
			this.weekNumberWidth = matchCellWidths(
				this.el.find('.fc-week-number')
			);
		}
	},


	// Adjusts the vertical dimensions of the view to the specified values
	setHeight: function(totalHeight, isAuto) {
		var eventLimit = this.opt('eventLimit');
		var scrollerHeight;
		var scrollbarWidths;

		// reset all heights to be natural
		this.scroller.clear();
		uncompensateScroll(this.headRowEl);

		this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

		// is the event limit a constant level number?
		if (eventLimit && typeof eventLimit === 'number') {
			this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
		}

		// distribute the height to the rows
		// (totalHeight is a "recommended" value if isAuto)
		scrollerHeight = this.computeScrollerHeight(totalHeight);
		this.setGridHeight(scrollerHeight, isAuto);

		// is the event limit dynamically calculated?
		if (eventLimit && typeof eventLimit !== 'number') {
			this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
		}

		if (!isAuto) { // should we force dimensions of the scroll container?

			this.scroller.setHeight(scrollerHeight);
			scrollbarWidths = this.scroller.getScrollbarWidths();

			if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?

				compensateScroll(this.headRowEl, scrollbarWidths);

				// doing the scrollbar compensation might have created text overflow which created more height. redo
				scrollerHeight = this.computeScrollerHeight(totalHeight);
				this.scroller.setHeight(scrollerHeight);
			}

			// guarantees the same scrollbar widths
			this.scroller.lockOverflow(scrollbarWidths);
		}
	},


	// given a desired total height of the view, returns what the height of the scroller should be
	computeScrollerHeight: function(totalHeight) {
		return totalHeight -
			subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
	},


	// Sets the height of just the DayGrid component in this view
	setGridHeight: function(height, isAuto) {
		if (isAuto) {
			undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
		}
		else {
			distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
		}
	},


	/* Scroll
	------------------------------------------------------------------------------------------------------------------*/


	computeInitialDateScroll: function() {
		return { top: 0 };
	},


	queryDateScroll: function() {
		return { top: this.scroller.getScrollTop() };
	},


	applyDateScroll: function(scroll) {
		if (scroll.top !== undefined) {
			this.scroller.setScrollTop(scroll.top);
		}
	},


	/* Hit Areas
	------------------------------------------------------------------------------------------------------------------*/
	// forward all hit-related method calls to dayGrid


	hitsNeeded: function() {
		this.dayGrid.hitsNeeded();
	},


	hitsNotNeeded: function() {
		this.dayGrid.hitsNotNeeded();
	},


	prepareHits: function() {
		this.dayGrid.prepareHits();
	},


	releaseHits: function() {
		this.dayGrid.releaseHits();
	},


	queryHit: function(left, top) {
		return this.dayGrid.queryHit(left, top);
	},


	getHitSpan: function(hit) {
		return this.dayGrid.getHitSpan(hit);
	},


	getHitEl: function(hit) {
		return this.dayGrid.getHitEl(hit);
	},


	/* Events
	------------------------------------------------------------------------------------------------------------------*/


	// Renders the given events onto the view and populates the segments array
	renderEvents: function(events) {
		this.dayGrid.renderEvents(events);

		this.updateHeight(); // must compensate for events that overflow the row
	},


	// Retrieves all segment objects that are rendered in the view
	getEventSegs: function() {
		return this.dayGrid.getEventSegs();
	},


	// Unrenders all event elements and clears internal segment data
	unrenderEvents: function() {
		this.dayGrid.unrenderEvents();

		// we DON'T need to call updateHeight() because
		// a renderEvents() call always happens after this, which will eventually call updateHeight()
	},


	/* Dragging (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// A returned value of `true` signals that a mock "helper" event has been rendered.
	renderDrag: function(dropLocation, seg) {
		return this.dayGrid.renderDrag(dropLocation, seg);
	},


	unrenderDrag: function() {
		this.dayGrid.unrenderDrag();
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection
	renderSelection: function(span) {
		this.dayGrid.renderSelection(span);
	},


	// Unrenders a visual indications of a selection
	unrenderSelection: function() {
		this.dayGrid.unrenderSelection();
	}

});


// Methods that will customize the rendering behavior of the BasicView's dayGrid
var basicDayGridMethods = {


	// Generates the HTML that will go before the day-of week header cells
	renderHeadIntroHtml: function() {
		var view = this.view;

		if (view.colWeekNumbersVisible) {
			return '' +
				'<th class="fc-week-number ' + view.widgetHeaderClass + '" ' + view.weekNumberStyleAttr() + '>' +
					'<span>' + // needed for matchCellWidths
						htmlEscape(view.opt('weekNumberTitle')) +
					'</span>' +
				'</th>';
		}

		return '';
	},


	// Generates the HTML that will go before content-skeleton cells that display the day/week numbers
	renderNumberIntroHtml: function(row) {
		var view = this.view;
		var weekStart = this.getCellDate(row, 0);

		if (view.colWeekNumbersVisible) {
			return '' +
				'<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '>' +
					view.buildGotoAnchorHtml( // aside from link, important for matchCellWidths
						{ date: weekStart, type: 'week', forceOff: this.colCnt === 1 },
						weekStart.format('w') // inner HTML
					) +
				'</td>';
		}

		return '';
	},


	// Generates the HTML that goes before the day bg cells for each day-row
	renderBgIntroHtml: function() {
		var view = this.view;

		if (view.colWeekNumbersVisible) {
			return '<td class="fc-week-number ' + view.widgetContentClass + '" ' +
				view.weekNumberStyleAttr() + '></td>';
		}

		return '';
	},


	// Generates the HTML that goes before every other type of row generated by DayGrid.
	// Affects helper-skeleton and highlight-skeleton rows.
	renderIntroHtml: function() {
		var view = this.view;

		if (view.colWeekNumbersVisible) {
			return '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '></td>';
		}

		return '';
	}

};

;;

/* A month view with day cells running in rows (one-per-week) and columns
----------------------------------------------------------------------------------------------------------------------*/

var MonthView = FC.MonthView = BasicView.extend({


	// Computes the date range that will be rendered.
	buildRenderRange: function() {
		var renderRange = BasicView.prototype.buildRenderRange.apply(this, arguments);
		var rowCnt;

		// ensure 6 weeks
		if (this.isFixedWeeks()) {
			rowCnt = Math.ceil( // could be partial weeks due to hiddenDays
				renderRange.end.diff(renderRange.start, 'weeks', true) // dontRound=true
			);
			renderRange.end.add(6 - rowCnt, 'weeks');
		}

		return renderRange;
	},


	// Overrides the default BasicView behavior to have special multi-week auto-height logic
	setGridHeight: function(height, isAuto) {

		// if auto, make the height of each row the height that it would be if there were 6 weeks
		if (isAuto) {
			height *= this.rowCnt / 6;
		}

		distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
	},


	isFixedWeeks: function() {
		return this.opt('fixedWeekCount');
	}

});

;;

fcViews.basic = {
	'class': BasicView
};

fcViews.basicDay = {
	type: 'basic',
	duration: { days: 1 }
};

fcViews.basicWeek = {
	type: 'basic',
	duration: { weeks: 1 }
};

fcViews.month = {
	'class': MonthView,
	duration: { months: 1 }, // important for prev/next
	defaults: {
		fixedWeekCount: true
	}
};
;;

/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
----------------------------------------------------------------------------------------------------------------------*/
// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.

var AgendaView = FC.AgendaView = View.extend({

	scroller: null,

	timeGridClass: TimeGrid, // class used to instantiate the timeGrid. subclasses can override
	timeGrid: null, // the main time-grid subcomponent of this view

	dayGridClass: DayGrid, // class used to instantiate the dayGrid. subclasses can override
	dayGrid: null, // the "all-day" subcomponent. if all-day is turned off, this will be null

	axisWidth: null, // the width of the time axis running down the side

	headContainerEl: null, // div that hold's the timeGrid's rendered date header
	noScrollRowEls: null, // set of fake row elements that must compensate when scroller has scrollbars

	// when the time-grid isn't tall enough to occupy the given height, we render an <hr> underneath
	bottomRuleEl: null,

	// indicates that minTime/maxTime affects rendering
	usesMinMaxTime: true,


	initialize: function() {
		this.timeGrid = this.instantiateTimeGrid();

		if (this.opt('allDaySlot')) { // should we display the "all-day" area?
			this.dayGrid = this.instantiateDayGrid(); // the all-day subcomponent of this view
		}

		this.scroller = new Scroller({
			overflowX: 'hidden',
			overflowY: 'auto'
		});
	},


	// Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass
	instantiateTimeGrid: function() {
		var subclass = this.timeGridClass.extend(agendaTimeGridMethods);

		return new subclass(this);
	},


	// Instantiates the DayGrid object this view might need. Draws from this.dayGridClass
	instantiateDayGrid: function() {
		var subclass = this.dayGridClass.extend(agendaDayGridMethods);

		return new subclass(this);
	},


	/* Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Renders the view into `this.el`, which has already been assigned
	renderDates: function() {

		this.timeGrid.setRange(this.renderRange);

		if (this.dayGrid) {
			this.dayGrid.setRange(this.renderRange);
		}

		this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());
		this.renderHead();

		this.scroller.render();
		var timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');
		var timeGridEl = $('<div class="fc-time-grid" />').appendTo(timeGridWrapEl);
		this.el.find('.fc-body > tr > td').append(timeGridWrapEl);

		this.timeGrid.setElement(timeGridEl);
		this.timeGrid.renderDates();

		// the <hr> that sometimes displays under the time-grid
		this.bottomRuleEl = $('<hr class="fc-divider ' + this.widgetHeaderClass + '"/>')
			.appendTo(this.timeGrid.el); // inject it into the time-grid

		if (this.dayGrid) {
			this.dayGrid.setElement(this.el.find('.fc-day-grid'));
			this.dayGrid.renderDates();

			// have the day-grid extend it's coordinate area over the <hr> dividing the two grids
			this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();
		}

		this.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)'); // fake rows not within the scroller
	},


	// render the day-of-week headers
	renderHead: function() {
		this.headContainerEl =
			this.el.find('.fc-head-container')
				.html(this.timeGrid.renderHeadHtml());
	},


	// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
	// always completely kill each grid's rendering.
	unrenderDates: function() {
		this.timeGrid.unrenderDates();
		this.timeGrid.removeElement();

		if (this.dayGrid) {
			this.dayGrid.unrenderDates();
			this.dayGrid.removeElement();
		}

		this.scroller.destroy();
	},


	// Builds the HTML skeleton for the view.
	// The day-grid and time-grid components will render inside containers defined by this HTML.
	renderSkeletonHtml: function() {
		return '' +
			'<table>' +
				'<thead class="fc-head">' +
					'<tr>' +
						'<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' +
					'</tr>' +
				'</thead>' +
				'<tbody class="fc-body">' +
					'<tr>' +
						'<td class="' + this.widgetContentClass + '">' +
							(this.dayGrid ?
								'<div class="fc-day-grid"/>' +
								'<hr class="fc-divider ' + this.widgetHeaderClass + '"/>' :
								''
								) +
						'</td>' +
					'</tr>' +
				'</tbody>' +
			'</table>';
	},


	// Generates an HTML attribute string for setting the width of the axis, if it is known
	axisStyleAttr: function() {
		if (this.axisWidth !== null) {
			 return 'style="width:' + this.axisWidth + 'px"';
		}
		return '';
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessHours: function() {
		this.timeGrid.renderBusinessHours();

		if (this.dayGrid) {
			this.dayGrid.renderBusinessHours();
		}
	},


	unrenderBusinessHours: function() {
		this.timeGrid.unrenderBusinessHours();

		if (this.dayGrid) {
			this.dayGrid.unrenderBusinessHours();
		}
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	getNowIndicatorUnit: function() {
		return this.timeGrid.getNowIndicatorUnit();
	},


	renderNowIndicator: function(date) {
		this.timeGrid.renderNowIndicator(date);
	},


	unrenderNowIndicator: function() {
		this.timeGrid.unrenderNowIndicator();
	},


	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


	updateSize: function(isResize) {
		this.timeGrid.updateSize(isResize);

		View.prototype.updateSize.call(this, isResize); // call the super-method
	},


	// Refreshes the horizontal dimensions of the view
	updateWidth: function() {
		// make all axis cells line up, and record the width so newly created axis cells will have it
		this.axisWidth = matchCellWidths(this.el.find('.fc-axis'));
	},


	// Adjusts the vertical dimensions of the view to the specified values
	setHeight: function(totalHeight, isAuto) {
		var eventLimit;
		var scrollerHeight;
		var scrollbarWidths;

		// reset all dimensions back to the original state
		this.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary
		this.scroller.clear(); // sets height to 'auto' and clears overflow
		uncompensateScroll(this.noScrollRowEls);

		// limit number of events in the all-day area
		if (this.dayGrid) {
			this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

			eventLimit = this.opt('eventLimit');
			if (eventLimit && typeof eventLimit !== 'number') {
				eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
			}
			if (eventLimit) {
				this.dayGrid.limitRows(eventLimit);
			}
		}

		if (!isAuto) { // should we force dimensions of the scroll container?

			scrollerHeight = this.computeScrollerHeight(totalHeight);
			this.scroller.setHeight(scrollerHeight);
			scrollbarWidths = this.scroller.getScrollbarWidths();

			if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?

				// make the all-day and header rows lines up
				compensateScroll(this.noScrollRowEls, scrollbarWidths);

				// the scrollbar compensation might have changed text flow, which might affect height, so recalculate
				// and reapply the desired height to the scroller.
				scrollerHeight = this.computeScrollerHeight(totalHeight);
				this.scroller.setHeight(scrollerHeight);
			}

			// guarantees the same scrollbar widths
			this.scroller.lockOverflow(scrollbarWidths);

			// if there's any space below the slats, show the horizontal rule.
			// this won't cause any new overflow, because lockOverflow already called.
			if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {
				this.bottomRuleEl.show();
			}
		}
	},


	// given a desired total height of the view, returns what the height of the scroller should be
	computeScrollerHeight: function(totalHeight) {
		return totalHeight -
			subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
	},


	/* Scroll
	------------------------------------------------------------------------------------------------------------------*/


	// Computes the initial pre-configured scroll state prior to allowing the user to change it
	computeInitialDateScroll: function() {
		var scrollTime = moment.duration(this.opt('scrollTime'));
		var top = this.timeGrid.computeTimeTop(scrollTime);

		// zoom can give weird floating-point values. rather scroll a little bit further
		top = Math.ceil(top);

		if (top) {
			top++; // to overcome top border that slots beyond the first have. looks better
		}

		return { top: top };
	},


	queryDateScroll: function() {
		return { top: this.scroller.getScrollTop() };
	},


	applyDateScroll: function(scroll) {
		if (scroll.top !== undefined) {
			this.scroller.setScrollTop(scroll.top);
		}
	},


	/* Hit Areas
	------------------------------------------------------------------------------------------------------------------*/
	// forward all hit-related method calls to the grids (dayGrid might not be defined)


	hitsNeeded: function() {
		this.timeGrid.hitsNeeded();
		if (this.dayGrid) {
			this.dayGrid.hitsNeeded();
		}
	},


	hitsNotNeeded: function() {
		this.timeGrid.hitsNotNeeded();
		if (this.dayGrid) {
			this.dayGrid.hitsNotNeeded();
		}
	},


	prepareHits: function() {
		this.timeGrid.prepareHits();
		if (this.dayGrid) {
			this.dayGrid.prepareHits();
		}
	},


	releaseHits: function() {
		this.timeGrid.releaseHits();
		if (this.dayGrid) {
			this.dayGrid.releaseHits();
		}
	},


	queryHit: function(left, top) {
		var hit = this.timeGrid.queryHit(left, top);

		if (!hit && this.dayGrid) {
			hit = this.dayGrid.queryHit(left, top);
		}

		return hit;
	},


	getHitSpan: function(hit) {
		// TODO: hit.component is set as a hack to identify where the hit came from
		return hit.component.getHitSpan(hit);
	},


	getHitEl: function(hit) {
		// TODO: hit.component is set as a hack to identify where the hit came from
		return hit.component.getHitEl(hit);
	},


	/* Events
	------------------------------------------------------------------------------------------------------------------*/


	// Renders events onto the view and populates the View's segment array
	renderEvents: function(events) {
		var dayEvents = [];
		var timedEvents = [];
		var daySegs = [];
		var timedSegs;
		var i;

		// separate the events into all-day and timed
		for (i = 0; i < events.length; i++) {
			if (events[i].allDay) {
				dayEvents.push(events[i]);
			}
			else {
				timedEvents.push(events[i]);
			}
		}

		// render the events in the subcomponents
		timedSegs = this.timeGrid.renderEvents(timedEvents);
		if (this.dayGrid) {
			daySegs = this.dayGrid.renderEvents(dayEvents);
		}

		// the all-day area is flexible and might have a lot of events, so shift the height
		this.updateHeight();
	},


	// Retrieves all segment objects that are rendered in the view
	getEventSegs: function() {
		return this.timeGrid.getEventSegs().concat(
			this.dayGrid ? this.dayGrid.getEventSegs() : []
		);
	},


	// Unrenders all event elements and clears internal segment data
	unrenderEvents: function() {

		// unrender the events in the subcomponents
		this.timeGrid.unrenderEvents();
		if (this.dayGrid) {
			this.dayGrid.unrenderEvents();
		}

		// we DON'T need to call updateHeight() because
		// a renderEvents() call always happens after this, which will eventually call updateHeight()
	},


	/* Dragging (for events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// A returned value of `true` signals that a mock "helper" event has been rendered.
	renderDrag: function(dropLocation, seg) {
		if (dropLocation.start.hasTime()) {
			return this.timeGrid.renderDrag(dropLocation, seg);
		}
		else if (this.dayGrid) {
			return this.dayGrid.renderDrag(dropLocation, seg);
		}
	},


	unrenderDrag: function() {
		this.timeGrid.unrenderDrag();
		if (this.dayGrid) {
			this.dayGrid.unrenderDrag();
		}
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection
	renderSelection: function(span) {
		if (span.start.hasTime() || span.end.hasTime()) {
			this.timeGrid.renderSelection(span);
		}
		else if (this.dayGrid) {
			this.dayGrid.renderSelection(span);
		}
	},


	// Unrenders a visual indications of a selection
	unrenderSelection: function() {
		this.timeGrid.unrenderSelection();
		if (this.dayGrid) {
			this.dayGrid.unrenderSelection();
		}
	}

});


// Methods that will customize the rendering behavior of the AgendaView's timeGrid
// TODO: move into TimeGrid
var agendaTimeGridMethods = {


	// Generates the HTML that will go before the day-of week header cells
	renderHeadIntroHtml: function() {
		var view = this.view;
		var weekText;

		if (view.opt('weekNumbers')) {
			weekText = this.start.format(view.opt('smallWeekFormat'));

			return '' +
				'<th class="fc-axis fc-week-number ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '>' +
					view.buildGotoAnchorHtml( // aside from link, important for matchCellWidths
						{ date: this.start, type: 'week', forceOff: this.colCnt > 1 },
						htmlEscape(weekText) // inner HTML
					) +
				'</th>';
		}
		else {
			return '<th class="fc-axis ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '></th>';
		}
	},


	// Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
	renderBgIntroHtml: function() {
		var view = this.view;

		return '<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '></td>';
	},


	// Generates the HTML that goes before all other types of cells.
	// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
	renderIntroHtml: function() {
		var view = this.view;

		return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
	}

};


// Methods that will customize the rendering behavior of the AgendaView's dayGrid
var agendaDayGridMethods = {


	// Generates the HTML that goes before the all-day cells
	renderBgIntroHtml: function() {
		var view = this.view;

		return '' +
			'<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' +
				'<span>' + // needed for matchCellWidths
					view.getAllDayHtml() +
				'</span>' +
			'</td>';
	},


	// Generates the HTML that goes before all other types of cells.
	// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
	renderIntroHtml: function() {
		var view = this.view;

		return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
	}

};

;;

var AGENDA_ALL_DAY_EVENT_LIMIT = 5;

// potential nice values for the slot-duration and interval-duration
// from largest to smallest
var AGENDA_STOCK_SUB_DURATIONS = [
	{ hours: 1 },
	{ minutes: 30 },
	{ minutes: 15 },
	{ seconds: 30 },
	{ seconds: 15 }
];

fcViews.agenda = {
	'class': AgendaView,
	defaults: {
		allDaySlot: true,
		slotDuration: '00:30:00',
		slotEventOverlap: true // a bad name. confused with overlap/constraint system
	}
};

fcViews.agendaDay = {
	type: 'agenda',
	duration: { days: 1 }
};

fcViews.agendaWeek = {
	type: 'agenda',
	duration: { weeks: 1 }
};
;;

/*
Responsible for the scroller, and forwarding event-related actions into the "grid"
*/
var ListView = View.extend({

	grid: null,
	scroller: null,

	initialize: function() {
		this.grid = new ListViewGrid(this);
		this.scroller = new Scroller({
			overflowX: 'hidden',
			overflowY: 'auto'
		});
	},

	renderSkeleton: function() {
		this.el.addClass(
			'fc-list-view ' +
			this.widgetContentClass
		);

		this.scroller.render();
		this.scroller.el.appendTo(this.el);

		this.grid.setElement(this.scroller.scrollEl);
	},

	unrenderSkeleton: function() {
		this.scroller.destroy(); // will remove the Grid too
	},

	setHeight: function(totalHeight, isAuto) {
		this.scroller.setHeight(this.computeScrollerHeight(totalHeight));
	},

	computeScrollerHeight: function(totalHeight) {
		return totalHeight -
			subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
	},

	renderDates: function() {
		this.grid.setRange(this.renderRange); // needs to process range-related options
	},

	renderEvents: function(events) {
		this.grid.renderEvents(events);
	},

	unrenderEvents: function() {
		this.grid.unrenderEvents();
	},

	isEventResizable: function(event) {
		return false;
	},

	isEventDraggable: function(event) {
		return false;
	}

});

/*
Responsible for event rendering and user-interaction.
Its "el" is the inner-content of the above view's scroller.
*/
var ListViewGrid = Grid.extend({

	segSelector: '.fc-list-item', // which elements accept event actions
	hasDayInteractions: false, // no day selection or day clicking

	// slices by day
	spanToSegs: function(span) {
		var view = this.view;
		var dayStart = view.renderRange.start.clone().time(0); // timed, so segs get times!
		var dayIndex = 0;
		var seg;
		var segs = [];

		while (dayStart < view.renderRange.end) {

			seg = intersectRanges(span, {
				start: dayStart,
				end: dayStart.clone().add(1, 'day')
			});

			if (seg) {
				seg.dayIndex = dayIndex;
				segs.push(seg);
			}

			dayStart.add(1, 'day');
			dayIndex++;

			// detect when span won't go fully into the next day,
			// and mutate the latest seg to the be the end.
			if (
				seg && !seg.isEnd && span.end.hasTime() &&
				span.end < dayStart.clone().add(this.view.nextDayThreshold)
			) {
				seg.end = span.end.clone();
				seg.isEnd = true;
				break;
			}
		}

		return segs;
	},

	// like "4:00am"
	computeEventTimeFormat: function() {
		return this.view.opt('mediumTimeFormat');
	},

	// for events with a url, the whole <tr> should be clickable,
	// but it's impossible to wrap with an <a> tag. simulate this.
	handleSegClick: function(seg, ev) {
		var url;

		Grid.prototype.handleSegClick.apply(this, arguments); // super. might prevent the default action

		// not clicking on or within an <a> with an href
		if (!$(ev.target).closest('a[href]').length) {
			url = seg.event.url;
			if (url && !ev.isDefaultPrevented()) { // jsEvent not cancelled in handler
				window.location.href = url; // simulate link click
			}
		}
	},

	// returns list of foreground segs that were actually rendered
	renderFgSegs: function(segs) {
		segs = this.renderFgSegEls(segs); // might filter away hidden events

		if (!segs.length) {
			this.renderEmptyMessage();
		}
		else {
			this.renderSegList(segs);
		}

		return segs;
	},

	renderEmptyMessage: function() {
		this.el.html(
			'<div class="fc-list-empty-wrap2">' + // TODO: try less wraps
			'<div class="fc-list-empty-wrap1">' +
			'<div class="fc-list-empty">' +
				htmlEscape(this.view.opt('noEventsMessage')) +
			'</div>' +
			'</div>' +
			'</div>'
		);
	},

	// render the event segments in the view
	renderSegList: function(allSegs) {
		var segsByDay = this.groupSegsByDay(allSegs); // sparse array
		var dayIndex;
		var daySegs;
		var i;
		var tableEl = $('<table class="fc-list-table"><tbody/></table>');
		var tbodyEl = tableEl.find('tbody');

		for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {
			daySegs = segsByDay[dayIndex];
			if (daySegs) { // sparse array, so might be undefined

				// append a day header
				tbodyEl.append(this.dayHeaderHtml(
					this.view.renderRange.start.clone().add(dayIndex, 'days')
				));

				this.sortEventSegs(daySegs);

				for (i = 0; i < daySegs.length; i++) {
					tbodyEl.append(daySegs[i].el); // append event row
				}
			}
		}

		this.el.empty().append(tableEl);
	},

	// Returns a sparse array of arrays, segs grouped by their dayIndex
	groupSegsByDay: function(segs) {
		var segsByDay = []; // sparse array
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			(segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))
				.push(seg);
		}

		return segsByDay;
	},

	// generates the HTML for the day headers that live amongst the event rows
	dayHeaderHtml: function(dayDate) {
		var view = this.view;
		var mainFormat = view.opt('listDayFormat');
		var altFormat = view.opt('listDayAltFormat');

		return '<tr class="fc-list-heading" data-date="' + dayDate.format('YYYY-MM-DD') + '">' +
			'<td class="' + view.widgetHeaderClass + '" colspan="3">' +
				(mainFormat ?
					view.buildGotoAnchorHtml(
						dayDate,
						{ 'class': 'fc-list-heading-main' },
						htmlEscape(dayDate.format(mainFormat)) // inner HTML
					) :
					'') +
				(altFormat ?
					view.buildGotoAnchorHtml(
						dayDate,
						{ 'class': 'fc-list-heading-alt' },
						htmlEscape(dayDate.format(altFormat)) // inner HTML
					) :
					'') +
			'</td>' +
		'</tr>';
	},

	// generates the HTML for a single event row
	fgSegHtml: function(seg) {
		var view = this.view;
		var classes = [ 'fc-list-item' ].concat(this.getSegCustomClasses(seg));
		var bgColor = this.getSegBackgroundColor(seg);
		var event = seg.event;
		var url = event.url;
		var timeHtml;

		if (event.allDay) {
			timeHtml = view.getAllDayHtml();
		}
		else if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day
			if (seg.isStart || seg.isEnd) { // outer segment that probably lasts part of the day
				timeHtml = htmlEscape(this.getEventTimeText(seg));
			}
			else { // inner segment that lasts the whole day
				timeHtml = view.getAllDayHtml();
			}
		}
		else {
			// Display the normal time text for the *event's* times
			timeHtml = htmlEscape(this.getEventTimeText(event));
		}

		if (url) {
			classes.push('fc-has-url');
		}

		return '<tr class="' + classes.join(' ') + '">' +
			(this.displayEventTime ?
				'<td class="fc-list-item-time ' + view.widgetContentClass + '">' +
					(timeHtml || '') +
				'</td>' :
				'') +
			'<td class="fc-list-item-marker ' + view.widgetContentClass + '">' +
				'<span class="fc-event-dot"' +
				(bgColor ?
					' style="background-color:' + bgColor + '"' :
					'') +
				'></span>' +
			'</td>' +
			'<td class="fc-list-item-title ' + view.widgetContentClass + '">' +
				'<a' + (url ? ' href="' + htmlEscape(url) + '"' : '') + '>' +
					htmlEscape(seg.event.title || '') +
				'</a>' +
			'</td>' +
		'</tr>';
	}

});

;;

fcViews.list = {
	'class': ListView,
	buttonTextKey: 'list', // what to lookup in locale files
	defaults: {
		buttonText: 'list', // text to display for English
		listDayFormat: 'LL', // like "January 1, 2016"
		noEventsMessage: 'No events to display'
	}
};

fcViews.listDay = {
	type: 'list',
	duration: { days: 1 },
	defaults: {
		listDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header
	}
};

fcViews.listWeek = {
	type: 'list',
	duration: { weeks: 1 },
	defaults: {
		listDayFormat: 'dddd', // day-of-week is more important
		listDayAltFormat: 'LL'
	}
};

fcViews.listMonth = {
	type: 'list',
	duration: { month: 1 },
	defaults: {
		listDayAltFormat: 'dddd' // day-of-week is nice-to-have
	}
};

fcViews.listYear = {
	type: 'list',
	duration: { year: 1 },
	defaults: {
		listDayAltFormat: 'dddd' // day-of-week is nice-to-have
	}
};

;;

return FC; // export for Node/CommonJS
});

/***/ }),

/***/ 590:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(78);
module.exports = __webpack_require__(351);


/***/ })

},[590]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9hZi5qcz8zZjMyIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2FyLWR6LmpzP2NhODkiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvYXIta3cuanM/MzNiNSIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9hci1seS5qcz80MGNlIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2FyLW1hLmpzP2I4YjciLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvYXItc2EuanM/MjE0ZCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9hci10bi5qcz80ZWU0Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2FyLmpzP2M4OGQiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvYmcuanM/OTdhZiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9jYS5qcz9kY2VjIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2NzLmpzP2EwOWMiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZGEuanM/ZmQyOCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9kZS1hdC5qcz83ODNkIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2RlLWNoLmpzPzExMzIiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZGUuanM/YzgxMyIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9lbC5qcz9jMGU3Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2VuLWF1LmpzP2E5ZTUiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZW4tY2EuanM/YWU1MCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9lbi1nYi5qcz8xNWUzIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2VuLWllLmpzP2ZiZTMiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZW4tbnouanM/NDczYiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9lcy1kby5qcz9jN2YwIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2VzLmpzPzk4ZDMiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZXQuanM/M2Q2NiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9ldS5qcz84OTcwIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2ZhLmpzPzBjZDciLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZmkuanM/N2IyZiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9mci1jYS5qcz83MzkzIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2ZyLWNoLmpzPzJkZDciLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZnIuanM/NjdkZiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9nbC5qcz81NmUzIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2hlLmpzPzJiYmYiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvaGkuanM/YzkwYiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9oci5qcz8zMTg5Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2h1LmpzP2YwMGMiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvaWQuanM/YWFjNSIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9pcy5qcz80NGQyIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2l0LmpzPzE2NTUiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvamEuanM/YzNkNyIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9ray5qcz9hY2E4Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2tvLmpzPzA4ZDUiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbGIuanM/MGQyZiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9sdC5qcz9iN2YxIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2x2LmpzPzhkY2UiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbWsuanM/YjI0OCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9tcy1teS5qcz9hYzU5Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL21zLmpzP2E4MWMiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbmIuanM/ZmQ5NiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9ubC1iZS5qcz8zOTFiIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL25sLmpzP2FmOWUiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbm4uanM/OWMwZCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9wbC5qcz8xY2U5Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3B0LWJyLmpzPzlmOGYiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvcHQuanM/ZjQ1OCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9yby5qcz80NjMxIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3J1LmpzPzZjN2MiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvc2suanM/MjZkOCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9zbC5qcz9mYjJhIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3NyLWN5cmwuanM/OGU4MCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9zci5qcz9kODgwIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3N2LmpzPzkxMGQiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvdGguanM/NDgyNyIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS90ci5qcz83NzM1Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3VrLmpzPzA0MmEiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvdmkuanM/ODdkOSIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS96aC1jbi5qcz9hZGQ5Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3poLXR3LmpzPzA1ZTciLCJ3ZWJwYWNrOi8vLyBeXFwuXFwvLiokPzM0YWEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbGVuZGFyL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9jYWxlbmRhci9jb252ZXJ0VG9GQy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FsZW5kYXIvZGlzcGxheUV2ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvdGVtcGxhdGVzLmpzIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvZnVsbGNhbGVuZGFyLmpzIl0sIm5hbWVzIjpbInF1ZXJ5UmVnRXhwIiwiYmVnaW4iLCJtb21lbnRMYW5nIiwiY2FsZW5kYXJPcHRpb25zIiwiZWRpdGFibGUiLCJoZWFkZXIiLCJsZWZ0IiwiY2VudGVyIiwicmlnaHQiLCJsYW5nIiwiZXZlbnRzIiwic3RhcnQiLCJlbmQiLCJ0aW1lem9uZSIsImNhbGxiYWNrIiwic29ja2V0IiwiZW1pdCIsInN0YXJ0RGF0ZSIsInZhbHVlT2YiLCJlbmREYXRlIiwiZXJyIiwibWVzc2FnZSIsImFwcCIsImFsZXJ0RXJyb3IiLCJldmVudENsaWNrIiwiZSIsIm9yaWdpbmFsIiwicGlkIiwiaWQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImV4dGVybmFsIiwicmVwZWF0cyIsImFqYXhpZnkiLCJ1cGRhdGVIaXN0b3J5IiwiZGF5Iiwic2hvdWxkSGFuZGxlIiwibGlzdGVuIiwic3RhdGUiLCJkYXRhIiwicHJldiIsInN0YXJ0c1dpdGgiLCJjdXJyZW50IiwidXJsIiwiaW5pdCIsIiRjYWxlbmRhciIsIiQiLCJmdWxsQ2FsZW5kYXIiLCJidG4iLCJvbiIsInRvZ2dsZUNsYXNzIiwiZGV0YWNoIiwiYXBwZW5kVG8iLCJmaW5kIiwiJGRpc3BsYXkiLCJtb2RhbCIsIm1hdGNoZXMiLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwibWF0Y2giLCJwYXJzZUludCIsImVsIiwiZ2V0RXZlbnRDYWNoZSIsIngiLCJldmVudCIsImhpc3RvcnkiLCJyZXBsYWNlU3RhdGUiLCJSRUxBVElWRV9QQVRIIiwid2luZG93IiwiY2FsZW5kYXJFdmVudERhdGEiLCJkb2N1bWVudCIsInJlYWR5IiwiX193ZWJwYWNrX3B1YmxpY19wYXRoX18iLCJjb25maWciLCJ1c2VyTGFuZyIsImRlZmF1bHRMYW5nIiwidG9Mb3dlckNhc2UiLCJyZXBsYWNlIiwicmVxdWlyZSIsInNwbGl0IiwiZXIiLCJFcnJvciIsIm1hcHBlciIsIm5ld0V2ZW50IiwidGl0bGUiLCJuYW1lIiwiYWxsRGF5IiwiYWxsZGF5IiwiY2xhc3NOYW1lIiwiY2lkIiwicmVzcG9uc2VzIiwidXNlciIsInVpZCIsInRvcGljRGVsZXRlZCIsImNvbnZlcnRUb0ZDIiwibWFwIiwiZGlzcGxheUV2ZW50IiwiY2IiLCJjb250ZW50IiwiZGl2IiwiJGdvVG9Qb3N0IiwiJGdvVG9VcmwiLCJlbXB0eSIsImFwcGVuZCIsImhpZGUiLCJzaG93IiwiYXR0ciIsInRyaWdnZXIiLCJwYXJzZWQiLCJtYWtlTGlzdEVsZW1lbnQiLCJuIiwibGkiLCJldmVudFRlbXBsYXRlIiwiaXNFbWFpbCIsInJlc3BvbnNlIiwicmVzcG9uc2VzVGVtcGxhdGUiLCJhY3RpdmUiLCJubyIsIm1heWJlIiwieWVzIiwiaHRtbCIsInNvdXJjZSIsImRlc2NyaXB0aW9uIiwicmVtaW5kZXJzIiwic29ydCIsImEiLCJiIiwiam9pbiIsImtleSIsImV2ZXJ5IiwiZGF5c09mV2VlayIsImRheXMiLCJlbmREYXRlVGV4dCIsIk51bWJlciIsImlzRmluaXRlIiwibWFuZGF0b3J5Il0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Qjs7Ozs7Ozs7OztBQ3RKQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBLElBQU1BLGNBQWMscUNBQXBCOztBQUVBLElBQU1DLFFBQVEsU0FBUkEsS0FB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RDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFtQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVDQUF1QztBQUM3QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFtQjtBQUNuQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGLHNCQUFzQjtBQUN0QjtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUEsY0FBYztBQUNkLEVBQUU7OztBQUdGO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBLGlDQUFpQyxhQUFhOztBQUU5QyxjQUFjO0FBQ2QsRUFBRTs7O0FBR0Y7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0I7O0FBRWhFLGNBQWM7QUFDZDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUF5RDtBQUN6RDtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLGlFQUFpRSxzQkFBc0I7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBLHFFQUFxRTs7QUFFckU7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSSxpQkFBaUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0UsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5Qzs7QUFFQTs7QUFFQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix1QkFBdUI7QUFDdkI7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQjtBQUNwQixJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxJQUFJO0FBQ0osd0JBQXdCO0FBQ3hCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QixVQUFVO0FBQ1YsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQSxFQUFFOzs7QUFHRjtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStEOztB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QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7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Q0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDZEQUE2RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0EsZ0NBQWdDO0FBQ2hDLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLDJCQUEyQjtBQUNoQyxLQUFLLDRCQUE0QjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSywyQkFBMkI7QUFDaEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7O0FBRUEsNERBQTREO0FBQzVELEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQix3RUFBd0U7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQyxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHVEQUF1RDtBQUN2RCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILDREQUE0RDtBQUM1RCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGNBQWM7QUFDZCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQztBQUNBLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGNBQWMsT0FBTztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCLE9BQU87QUFDNUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGlCQUFpQjtBQUM5Qjs7QUFFQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTs7QUFFQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBLFlBQVksc0JBQXNCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUEsZUFBZSx5QkFBeUI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZixFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CO0FBQ0EsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThEO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMsMENBQTBDO0FBQzFDO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFlBQVk7QUFDWjs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBLGFBQWEsaUJBQWlCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxELHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkMsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0EsMkNBQTJDO0FBQzNDLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBOztBQUVBLFVBQVU7QUFDVixFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw0QkFBNEI7QUFDaEQscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7Ozs7QUFJRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkUsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQSxrQkFBa0I7QUFDbEIsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCO0FBQ3RCLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTs7QUFFQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUJBQW1CLFNBQVM7QUFDM0M7O0FBRUEsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7OztBQUlGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DOztBQUVBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7O0FBRXBCOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBOztBQUVBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxzQ0FBc0M7QUFDdEMsK0NBQStDO0FBQy9DLFdBQVc7QUFDWCxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGVBQWU7QUFDekI7O0FBRUE7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGlCQUFpQjtBQUMzQjs7QUFFQSxXQUFXLGdCQUFnQjtBQUMzQjs7QUFFQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7O0FBRXpDLFdBQVcsc0JBQXNCO0FBQ2pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSx5QkFBeUI7O0FBRXpCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQywrREFBK0Q7QUFDL0QsS0FBSztBQUNMO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0EsWUFBWTtBQUNaLEVBQUU7OztBQUdGO0FBQ0EsWUFBWTtBQUNaLEVBQUU7OztBQUdGO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVixFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLHFEQUFxRDtBQUNyRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7O0FBRTFDLFVBQVU7QUFDVixFQUFFOzs7QUFHRjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVO0FBQ1YsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsVUFBVTtBQUNWLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFD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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBOztBQUVBLDhDQUE4QztBQUM5QyxnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxTQUFTO0FBQ1QsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1YsRUFBRTs7O0FBR0YsNkJBQTZCO0FBQzdCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3Qjs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUEsZUFBZTtBQUNmO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRix3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFtQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUEsNEVBQTRFO0FBQzVFOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUEsZ0JBQWdCOztBQUVoQjtBQUNBOztBQUVBLHVEQUF1RDs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQSxVQUFVO0FBQ1YsRUFBRTs7O0FBR0Y7QUFDQSxVQUFVO0FBQ1YsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdG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QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBOztBQUVBLHVEQUF1RDs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsVUFBVTtBQUNWLEVBQUU7OztBQUdGO0FBQ0EsVUFBVTtBQUNWLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBLE9BQU8sa0NBQWtDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8saUNBQWlDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVO0FBQ1YsQ0FBQyxFIiwiZmlsZSI6ImNhbGVuZGFyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vYWYuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2FmLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9hci1kei5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvYXItZHouanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2FyLWt3LmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9hci1rdy5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vYXItbHkuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2FyLWx5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9hci1tYS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvYXItbWEuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2FyLXNhLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9hci1zYS5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vYXItdG4uanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2FyLXRuLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9hci5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvYXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2JnLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9iZy5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vY2EuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2NhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9jcy5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvY3MuanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2RhLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9kYS5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZGUtYXQuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2RlLWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9kZS1jaC5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZGUtY2guanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2RlLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZWwuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2VsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9lbi1hdS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZW4tYXUuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2VuLWNhLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9lbi1jYS5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZW4tZ2IuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2VuLWdiLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9lbi1pZS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZW4taWUuanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2VuLW56LmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9lbi1uei5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZXMtZG8uanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2VzLWRvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9lcy5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2V0LmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9ldC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZXUuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2V1LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9mYS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZmEuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2ZpLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9maS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZnItY2EuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2ZyLWNhLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9mci1jaC5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZnItY2guanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2ZyLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9mci5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZ2wuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2dsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9oZS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvaGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2hpLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9oaS5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vaHIuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2hyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9odS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvaHUuanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2lkLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9pZC5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vaXMuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2lzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9pdC5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvaXQuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2phLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9qYS5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4va2suanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2trLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9rby5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUva28uanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2xiLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9sYi5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vbHQuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2x0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9sdi5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbHYuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL21rLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9tay5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vbXMtbXkuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL21zLW15LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9tcy5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbXMuanNcbi8vIG1vZHVsZSBpZCA9IDE2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL25iLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9uYi5qc1xuLy8gbW9kdWxlIGlkID0gMTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vbmwtYmUuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL25sLWJlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9ubC5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbmwuanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL25uLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9ubi5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vcGwuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3BsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9wdC1ici5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvcHQtYnIuanNcbi8vIG1vZHVsZSBpZCA9IDE3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL3B0LmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9wdC5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vcm8uanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3JvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9ydS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvcnUuanNcbi8vIG1vZHVsZSBpZCA9IDE3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL3NrLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9zay5qc1xuLy8gbW9kdWxlIGlkID0gMTc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vc2wuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3NsLmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9zci1jeXJsLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9zci1jeXJsLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9zci5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvc3IuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL3N2LmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9zdi5qc1xuLy8gbW9kdWxlIGlkID0gMTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vdGguanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3RoLmpzXG4vLyBtb2R1bGUgaWQgPSAxODRcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi90ci5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvdHIuanNcbi8vIG1vZHVsZSBpZCA9IDE4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL3VrLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS91ay5qc1xuLy8gbW9kdWxlIGlkID0gMTg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vdmkuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3ZpLmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi96aC1jbi5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvemgtY24uanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL3poLXR3LmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS96aC10dy5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIG1hcCA9IHtcblx0XCIuL2FmXCI6IDEyMyxcblx0XCIuL2FmLmpzXCI6IDEyMyxcblx0XCIuL2FyXCI6IDEzMCxcblx0XCIuL2FyLWR6XCI6IDEyNCxcblx0XCIuL2FyLWR6LmpzXCI6IDEyNCxcblx0XCIuL2FyLWt3XCI6IDEyNSxcblx0XCIuL2FyLWt3LmpzXCI6IDEyNSxcblx0XCIuL2FyLWx5XCI6IDEyNixcblx0XCIuL2FyLWx5LmpzXCI6IDEyNixcblx0XCIuL2FyLW1hXCI6IDEyNyxcblx0XCIuL2FyLW1hLmpzXCI6IDEyNyxcblx0XCIuL2FyLXNhXCI6IDEyOCxcblx0XCIuL2FyLXNhLmpzXCI6IDEyOCxcblx0XCIuL2FyLXRuXCI6IDEyOSxcblx0XCIuL2FyLXRuLmpzXCI6IDEyOSxcblx0XCIuL2FyLmpzXCI6IDEzMCxcblx0XCIuL2JnXCI6IDEzMSxcblx0XCIuL2JnLmpzXCI6IDEzMSxcblx0XCIuL2NhXCI6IDEzMixcblx0XCIuL2NhLmpzXCI6IDEzMixcblx0XCIuL2NzXCI6IDEzMyxcblx0XCIuL2NzLmpzXCI6IDEzMyxcblx0XCIuL2RhXCI6IDEzNCxcblx0XCIuL2RhLmpzXCI6IDEzNCxcblx0XCIuL2RlXCI6IDEzNyxcblx0XCIuL2RlLWF0XCI6IDEzNSxcblx0XCIuL2RlLWF0LmpzXCI6IDEzNSxcblx0XCIuL2RlLWNoXCI6IDEzNixcblx0XCIuL2RlLWNoLmpzXCI6IDEzNixcblx0XCIuL2RlLmpzXCI6IDEzNyxcblx0XCIuL2VsXCI6IDEzOCxcblx0XCIuL2VsLmpzXCI6IDEzOCxcblx0XCIuL2VuLWF1XCI6IDEzOSxcblx0XCIuL2VuLWF1LmpzXCI6IDEzOSxcblx0XCIuL2VuLWNhXCI6IDE0MCxcblx0XCIuL2VuLWNhLmpzXCI6IDE0MCxcblx0XCIuL2VuLWdiXCI6IDE0MSxcblx0XCIuL2VuLWdiLmpzXCI6IDE0MSxcblx0XCIuL2VuLWllXCI6IDE0Mixcblx0XCIuL2VuLWllLmpzXCI6IDE0Mixcblx0XCIuL2VuLW56XCI6IDE0Myxcblx0XCIuL2VuLW56LmpzXCI6IDE0Myxcblx0XCIuL2VzXCI6IDE0NSxcblx0XCIuL2VzLWRvXCI6IDE0NCxcblx0XCIuL2VzLWRvLmpzXCI6IDE0NCxcblx0XCIuL2VzLmpzXCI6IDE0NSxcblx0XCIuL2V0XCI6IDE0Nixcblx0XCIuL2V0LmpzXCI6IDE0Nixcblx0XCIuL2V1XCI6IDE0Nyxcblx0XCIuL2V1LmpzXCI6IDE0Nyxcblx0XCIuL2ZhXCI6IDE0OCxcblx0XCIuL2ZhLmpzXCI6IDE0OCxcblx0XCIuL2ZpXCI6IDE0OSxcblx0XCIuL2ZpLmpzXCI6IDE0OSxcblx0XCIuL2ZyXCI6IDE1Mixcblx0XCIuL2ZyLWNhXCI6IDE1MCxcblx0XCIuL2ZyLWNhLmpzXCI6IDE1MCxcblx0XCIuL2ZyLWNoXCI6IDE1MSxcblx0XCIuL2ZyLWNoLmpzXCI6IDE1MSxcblx0XCIuL2ZyLmpzXCI6IDE1Mixcblx0XCIuL2dsXCI6IDE1Myxcblx0XCIuL2dsLmpzXCI6IDE1Myxcblx0XCIuL2hlXCI6IDE1NCxcblx0XCIuL2hlLmpzXCI6IDE1NCxcblx0XCIuL2hpXCI6IDE1NSxcblx0XCIuL2hpLmpzXCI6IDE1NSxcblx0XCIuL2hyXCI6IDE1Nixcblx0XCIuL2hyLmpzXCI6IDE1Nixcblx0XCIuL2h1XCI6IDE1Nyxcblx0XCIuL2h1LmpzXCI6IDE1Nyxcblx0XCIuL2lkXCI6IDE1OCxcblx0XCIuL2lkLmpzXCI6IDE1OCxcblx0XCIuL2lzXCI6IDE1OSxcblx0XCIuL2lzLmpzXCI6IDE1OSxcblx0XCIuL2l0XCI6IDE2MCxcblx0XCIuL2l0LmpzXCI6IDE2MCxcblx0XCIuL2phXCI6IDE2MSxcblx0XCIuL2phLmpzXCI6IDE2MSxcblx0XCIuL2trXCI6IDE2Mixcblx0XCIuL2trLmpzXCI6IDE2Mixcblx0XCIuL2tvXCI6IDE2Myxcblx0XCIuL2tvLmpzXCI6IDE2Myxcblx0XCIuL2xiXCI6IDE2NCxcblx0XCIuL2xiLmpzXCI6IDE2NCxcblx0XCIuL2x0XCI6IDE2NSxcblx0XCIuL2x0LmpzXCI6IDE2NSxcblx0XCIuL2x2XCI6IDE2Nixcblx0XCIuL2x2LmpzXCI6IDE2Nixcblx0XCIuL21rXCI6IDE2Nyxcblx0XCIuL21rLmpzXCI6IDE2Nyxcblx0XCIuL21zXCI6IDE2OSxcblx0XCIuL21zLW15XCI6IDE2OCxcblx0XCIuL21zLW15LmpzXCI6IDE2OCxcblx0XCIuL21zLmpzXCI6IDE2OSxcblx0XCIuL25iXCI6IDE3MCxcblx0XCIuL25iLmpzXCI6IDE3MCxcblx0XCIuL25sXCI6IDE3Mixcblx0XCIuL25sLWJlXCI6IDE3MSxcblx0XCIuL25sLWJlLmpzXCI6IDE3MSxcblx0XCIuL25sLmpzXCI6IDE3Mixcblx0XCIuL25uXCI6IDE3Myxcblx0XCIuL25uLmpzXCI6IDE3Myxcblx0XCIuL3BsXCI6IDE3NCxcblx0XCIuL3BsLmpzXCI6IDE3NCxcblx0XCIuL3B0XCI6IDE3Nixcblx0XCIuL3B0LWJyXCI6IDE3NSxcblx0XCIuL3B0LWJyLmpzXCI6IDE3NSxcblx0XCIuL3B0LmpzXCI6IDE3Nixcblx0XCIuL3JvXCI6IDE3Nyxcblx0XCIuL3JvLmpzXCI6IDE3Nyxcblx0XCIuL3J1XCI6IDE3OCxcblx0XCIuL3J1LmpzXCI6IDE3OCxcblx0XCIuL3NrXCI6IDE3OSxcblx0XCIuL3NrLmpzXCI6IDE3OSxcblx0XCIuL3NsXCI6IDE4MCxcblx0XCIuL3NsLmpzXCI6IDE4MCxcblx0XCIuL3NyXCI6IDE4Mixcblx0XCIuL3NyLWN5cmxcIjogMTgxLFxuXHRcIi4vc3ItY3lybC5qc1wiOiAxODEsXG5cdFwiLi9zci5qc1wiOiAxODIsXG5cdFwiLi9zdlwiOiAxODMsXG5cdFwiLi9zdi5qc1wiOiAxODMsXG5cdFwiLi90aFwiOiAxODQsXG5cdFwiLi90aC5qc1wiOiAxODQsXG5cdFwiLi90clwiOiAxODUsXG5cdFwiLi90ci5qc1wiOiAxODUsXG5cdFwiLi91a1wiOiAxODYsXG5cdFwiLi91ay5qc1wiOiAxODYsXG5cdFwiLi92aVwiOiAxODcsXG5cdFwiLi92aS5qc1wiOiAxODcsXG5cdFwiLi96aC1jblwiOiAxODgsXG5cdFwiLi96aC1jbi5qc1wiOiAxODgsXG5cdFwiLi96aC10d1wiOiAxODksXG5cdFwiLi96aC10dy5qc1wiOiAxODlcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18od2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkpO1xufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0dmFyIGlkID0gbWFwW3JlcV07XG5cdGlmKCEoaWQgKyAxKSkgLy8gY2hlY2sgZm9yIG51bWJlciBvciBzdHJpbmdcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKTtcblx0cmV0dXJuIGlkO1xufTtcbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSAzMDU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZSAuL34vYnVuZGxlLWxvYWRlciEgXlxcLlxcLy4qJFxuLy8gbW9kdWxlIGlkID0gMzA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwiaW1wb3J0ICdmdWxsY2FsZW5kYXInO1xuaW1wb3J0IGNvbnZlcnRUb0ZDIGZyb20gJy4vY29udmVydFRvRkMnO1xuaW1wb3J0IGRpc3BsYXlFdmVudCBmcm9tICcuL2Rpc3BsYXlFdmVudCc7XG5pbXBvcnQgbG9jYXRpb25IaXN0b3J5IGZyb20gJy4uL2NsaWVudC9sb2NhdGlvbkhpc3RvcnknO1xuaW1wb3J0IHsgc2V0dXBEVFAgfSBmcm9tICcuLi9jbGllbnQvcmVzcG9uc2VzJztcblxuY29uc3QgcXVlcnlSZWdFeHAgPSAvY2FsZW5kYXJcXC8/KD86XFwvKmV2ZW50XFwvKyhbMC05XSspKT8vO1xuXG5jb25zdCBiZWdpbiA9IChtb21lbnRMYW5nKSA9PiB7XG4gIGNvbnN0IGNhbGVuZGFyT3B0aW9ucyA9IHtcbiAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgaGVhZGVyOiB7XG4gICAgICBsZWZ0OiAncHJldixuZXh0IHRvZGF5JyxcbiAgICAgIGNlbnRlcjogJ3RpdGxlJyxcbiAgICAgIHJpZ2h0OiAnbW9udGgsYWdlbmRhV2VlayxhZ2VuZGFEYXknLFxuICAgIH0sXG4gICAgbGFuZzogbW9tZW50TGFuZyxcbiAgICBldmVudHM6IChzdGFydCwgZW5kLCB0aW1lem9uZSwgY2FsbGJhY2spID0+IHtcbiAgICAgIHNvY2tldC5lbWl0KCdwbHVnaW5zLmNhbGVuZGFyLmdldEV2ZW50c0J5RGF0ZScsIHtcbiAgICAgICAgc3RhcnREYXRlOiBzdGFydC52YWx1ZU9mKCksXG4gICAgICAgIGVuZERhdGU6IGVuZC52YWx1ZU9mKCksXG4gICAgICB9LCAoZXJyLCBldmVudHMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgICAgICAgYXBwLmFsZXJ0RXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soY29udmVydFRvRkMoZXZlbnRzKSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGV2ZW50Q2xpY2s6ICh7IG9yaWdpbmFsLCBpZDogcGlkIH0sIGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBkaXNwbGF5RXZlbnQob3JpZ2luYWwpO1xuICAgICAgaWYgKG9yaWdpbmFsLmV4dGVybmFsKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcmlnaW5hbC5yZXBlYXRzKSB7XG4gICAgICAgICAgYWpheGlmeS51cGRhdGVIaXN0b3J5KGBjYWxlbmRhci9ldmVudC8ke3BpZH0vJHtvcmlnaW5hbC5kYXl9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWpheGlmeS51cGRhdGVIaXN0b3J5KGBjYWxlbmRhci9ldmVudC8ke3BpZH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdGltZXpvbmU6ICdsb2NhbCcsXG4gIH07XG5cbiAgbGV0IHNob3VsZEhhbmRsZSA9IGZhbHNlO1xuXG4gIGxvY2F0aW9uSGlzdG9yeS5saXN0ZW4oKHN0YXRlLCBkYXRhKSA9PiB7XG4gICAgaWYgKHN0YXRlLnByZXYuc3RhcnRzV2l0aCgnY2FsZW5kYXInKSAmJiBzdGF0ZS5jdXJyZW50LnN0YXJ0c1dpdGgoJ2NhbGVuZGFyJykpIHtcbiAgICAgIGRhdGEudXJsID0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgc2hvdWxkSGFuZGxlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkSGFuZGxlID0gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgIGNvbnN0ICRjYWxlbmRhciA9ICQoJyNjYWxlbmRhcicpO1xuXG4gICAgaWYgKCRjYWxlbmRhciAmJiAhc2hvdWxkSGFuZGxlKSB7XG4gICAgICAkY2FsZW5kYXIuZnVsbENhbGVuZGFyKGNhbGVuZGFyT3B0aW9ucyk7XG4gICAgICBjb25zdCBidG4gPSAkKCcjcGx1Z2luLWNhbGVuZGFyLWNhbC1vbmx5LXllcycpO1xuICAgICAgYnRuXG4gICAgICAgIC5vbignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAkY2FsZW5kYXIudG9nZ2xlQ2xhc3MoJ3BsdWdpbi1jYWxlbmRhci1jYWwtb25seS15ZXMnKTtcbiAgICAgICAgICBidG4udG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICB9KVxuICAgICAgICAuZGV0YWNoKClcbiAgICAgICAgLmFwcGVuZFRvKCRjYWxlbmRhci5maW5kKCcuZmMtdG9vbGJhciAuZmMtcmlnaHQnKSk7XG4gICAgfVxuXG4gICAgY29uc3QgJGRpc3BsYXkgPSAkKCcjcGx1Z2luLWNhbGVuZGFyLWNhbC1ldmVudC1kaXNwbGF5Jyk7XG4gICAgaWYgKCRkaXNwbGF5KSB7XG4gICAgICAkZGlzcGxheS5vbignY2xpY2snLCAnLmRpc21pc3MnLCAoKSA9PiB7XG4gICAgICAgICRkaXNwbGF5Lm1vZGFsKCdoaWRlJyk7XG4gICAgICAgIGFqYXhpZnkudXBkYXRlSGlzdG9yeSgnY2FsZW5kYXInKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoZXMgPSBsb2NhdGlvbi5wYXRobmFtZS5tYXRjaChxdWVyeVJlZ0V4cCk7XG4gICAgY29uc3QgcGlkID0gbWF0Y2hlcyAmJiBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgaWYgKHBpZCkge1xuICAgICAgY29uc3QgZWwgPSAkY2FsZW5kYXJcbiAgICAgICAgLmRhdGEoJ2Z1bGxDYWxlbmRhcicpXG4gICAgICAgIC5nZXRFdmVudENhY2hlKClcbiAgICAgICAgLmZpbmQoeCA9PiB4LmlkID09PSBwaWQpO1xuXG4gICAgICBpZiAoc2hvdWxkSGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZWwgJiYgZWwub3JpZ2luYWw7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgIGRpc3BsYXlFdmVudChldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCBgJHtSRUxBVElWRV9QQVRIfS9jYWxlbmRhcmApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXR1cERUUCgkZGlzcGxheS5maW5kKCdbZGF0YS1kYXldJyksIHdpbmRvdy5jYWxlbmRhckV2ZW50RGF0YS5kYXkpO1xuICAgICAgfVxuICAgICAgJGNhbGVuZGFyLmZ1bGxDYWxlbmRhcignZ290b0RhdGUnLCBlbCA/IGVsLnN0YXJ0IDogKFxuICAgICAgICB3aW5kb3cuY2FsZW5kYXJFdmVudERhdGEuZGF5IHx8IHdpbmRvdy5jYWxlbmRhckV2ZW50RGF0YS5zdGFydERhdGVcbiAgICAgICkpO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkSGFuZGxlKSB7XG4gICAgICAkZGlzcGxheS5tb2RhbCgnaGlkZScpO1xuICAgIH1cbiAgfTtcblxuICAkKGRvY3VtZW50KS5yZWFkeShpbml0KTtcbiAgJCh3aW5kb3cpLm9uKCdhY3Rpb246YWpheGlmeS5lbmQnLCBpbml0KTtcbn07XG5cbl9fd2VicGFja19wdWJsaWNfcGF0aF9fID0gYCR7UkVMQVRJVkVfUEFUSH0vcGx1Z2lucy9ub2RlYmItcGx1Z2luLWNhbGVuZGFyL2J1bmRsZXMvYDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5jb25zdCBsYW5nID0gY29uZmlnLnVzZXJMYW5nIHx8IGNvbmZpZy5kZWZhdWx0TGFuZztcbmNvbnN0IG1vbWVudExhbmcgPSBsYW5nLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXy9nLCAnLScpO1xuXG50cnkge1xuICBpZiAobW9tZW50TGFuZyA9PT0gJ2VuLXVzJykge1xuICAgIGJlZ2luKCdlbi11cycpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVpcmUoYGJ1bmRsZS1sb2FkZXIhZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlLyR7bW9tZW50TGFuZ31gKSgoKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGJlZ2luKG1vbWVudExhbmcpO1xuICAgIH0pO1xuICB9XG59IGNhdGNoIChlKSB7XG4gIHRyeSB7XG4gICAgcmVxdWlyZShgYnVuZGxlLWxvYWRlciFmdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvJHttb21lbnRMYW5nLnNwbGl0KCctJylbMF19YCkoKCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBiZWdpbihtb21lbnRMYW5nKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBiZWdpbignZW4tdXMnKTtcbiAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90IGxvYWQgbG9jYWxlIGRhdGEgKCR7bW9tZW50TGFuZ30pIGZvciBmdWxsY2FsZW5kYXJgKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NhbGVuZGFyL2luZGV4LmpzIiwiY29uc3QgbWFwcGVyID0gZXZlbnQgPT4ge1xuICBjb25zdCBuZXdFdmVudCA9IHtcbiAgICBpZDogZXZlbnQucGlkLFxuICAgIHRpdGxlOiBldmVudC5uYW1lLFxuICAgIGFsbERheTogZXZlbnQuYWxsZGF5LFxuICAgIHN0YXJ0OiBldmVudC5zdGFydERhdGUsXG4gICAgZW5kOiBldmVudC5lbmREYXRlICsgMSxcbiAgICBjbGFzc05hbWU6IFtdLFxuICAgIG9yaWdpbmFsOiBldmVudCxcbiAgfTtcblxuICBpZiAoZXZlbnQuZXh0ZXJuYWwpIHtcbiAgICBuZXdFdmVudC5jbGFzc05hbWUgPSBbJ3BsdWdpbi1jYWxlbmRhci1jYWwtZXZlbnQtZXh0ZXJuYWwnXTtcbiAgfSBlbHNlIHtcbiAgICBuZXdFdmVudC5jbGFzc05hbWUgPSBbXG4gICAgICBgcGx1Z2luLWNhbGVuZGFyLWNhbC1ldmVudC1jYXRlZ29yeS0ke2V2ZW50LmNpZH1gLFxuICAgICAgYHBsdWdpbi1jYWxlbmRhci1jYWwtZXZlbnQtcmVzcG9uc2UtJHtldmVudC5yZXNwb25zZXNbYXBwLnVzZXIudWlkXSB8fCAnbm8nfWAsXG4gICAgICBldmVudC50b3BpY0RlbGV0ZWQgPyAncGx1Z2luLWNhbGVuZGFyLWNhbC1ldmVudC10b3BpYy1kZWxldGVkJyA6ICcnLFxuICAgIF07XG4gIH1cblxuICByZXR1cm4gbmV3RXZlbnQ7XG59O1xuXG5jb25zdCBjb252ZXJ0VG9GQyA9IGV2ZW50cyA9PiBldmVudHMubWFwKG1hcHBlcik7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnZlcnRUb0ZDO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NhbGVuZGFyL2NvbnZlcnRUb0ZDLmpzIiwiaW1wb3J0IHsgZXZlbnRUZW1wbGF0ZSB9IGZyb20gJy4uL2xpYi90ZW1wbGF0ZXMnO1xuaW1wb3J0IHsgc2V0dXBQb3N0IH0gZnJvbSAnLi4vY2xpZW50L3Jlc3BvbnNlcyc7XG5cbmNvbnN0IGRpc3BsYXlFdmVudCA9IChldmVudCwgY2IpID0+IHtcbiAgY29uc3QgY29udGVudCA9IGV2ZW50VGVtcGxhdGUoeyBldmVudCwgdWlkOiBhcHAudXNlci51aWQgfSk7XG4gIGNvbnN0IHBpZCA9IGV2ZW50LnBpZDtcblxuICBjb25zdCBkaXYgPSAkKGNvbnRlbnQpO1xuICBjb25zdCAkZGlzcGxheSA9ICQoJyNwbHVnaW4tY2FsZW5kYXItY2FsLWV2ZW50LWRpc3BsYXknKTtcbiAgY29uc3QgJGdvVG9Qb3N0ID0gJGRpc3BsYXkuZmluZCgnLm1vZGFsLWZvb3RlciBhLmJ0bi1wcmltYXJ5LmdvdG9wb3N0Jyk7XG4gIGNvbnN0ICRnb1RvVXJsID0gJGRpc3BsYXkuZmluZCgnLm1vZGFsLWZvb3RlciBhLmJ0bi1wcmltYXJ5LmdvdG91cmwnKTtcbiAgJGRpc3BsYXlcbiAgICAubW9kYWwoJ2hpZGUnKVxuICAgIC5maW5kKCcubW9kYWwtYm9keSAucG9zdHMnKVxuICAgIC5lbXB0eSgpXG4gICAgLmFwcGVuZChkaXYpO1xuICBpZiAoZXZlbnQuZXh0ZXJuYWwpIHtcbiAgICAkZ29Ub1Bvc3QuaGlkZSgpO1xuXG4gICAgaWYgKGV2ZW50LnVybCkge1xuICAgICAgJGdvVG9VcmxcbiAgICAgICAgLnNob3coKVxuICAgICAgICAuYXR0cignaHJlZicsIGV2ZW50LnVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRnb1RvVXJsLmhpZGUoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgJGdvVG9VcmwuaGlkZSgpO1xuICAgICRnb1RvUG9zdFxuICAgICAgLnNob3coKVxuICAgICAgLmF0dHIoJ2hyZWYnLCBgJHtSRUxBVElWRV9QQVRIfS9wb3N0LyR7cGlkfWApO1xuICB9XG4gICRkaXNwbGF5XG4gICAgLmZpbmQoJy5tb2RhbC1ib2R5JylcbiAgICAuYXR0cignZGF0YS1waWQnLCBwaWQpO1xuICBpZiAoIWV2ZW50LmV4dGVybmFsICYmIGV2ZW50LnJlcGVhdHMpIHtcbiAgICAkZGlzcGxheS5maW5kKCdbZGF0YS1kYXldJykuYXR0cignZGF0YS1kYXknLCBldmVudC5kYXkpO1xuICB9XG4gICRkaXNwbGF5XG4gICAgLm1vZGFsKCdzaG93Jyk7XG5cbiAgc2V0dXBQb3N0KHsgcGlkIH0sICgpID0+IHtcbiAgICAkKHdpbmRvdykudHJpZ2dlcignYWN0aW9uOmNhbGVuZGFyLmV2ZW50LmRpc3BsYXknLCB7IHBpZCwgZGF5OiBldmVudC5kYXksIG1vZGFsOiAkZGlzcGxheSB9KTtcblxuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiKHsgY29udGVudCwgcGFyc2VkOiBldmVudCB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZGlzcGxheUV2ZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NhbGVuZGFyL2Rpc3BsYXlFdmVudC5qcyIsImNvbnN0IG1ha2VMaXN0RWxlbWVudCA9IChuKSA9PiB7XG4gIGNvbnN0IGxpID0gYDxsaSBkYXRhLXZhbHVlPVwiJHtufVwiPltbbW9tZW50OnRpbWUtZHVyYXRpb24sICR7bn1dXTwvbGk+YDtcbiAgcmV0dXJuIGxpO1xufTtcblxuY29uc3QgZXZlbnRUZW1wbGF0ZSA9ICh7IGV2ZW50LCBpc0VtYWlsLCB1aWQgfSkgPT4ge1xuICBjb25zdCB7IHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgYWxsZGF5IH0gPSBldmVudDtcblxuICBsZXQgcmVzcG9uc2UgPSAnbm8nO1xuICBpZiAodWlkICYmIGV2ZW50LnJlc3BvbnNlcyAmJiBldmVudC5yZXNwb25zZXNbdWlkXSkge1xuICAgIHJlc3BvbnNlID0gZXZlbnQucmVzcG9uc2VzW3VpZF07XG4gIH1cbiAgY29uc3QgcmVzcG9uc2VzVGVtcGxhdGUgPSAoKSA9PiBgXG48ZGl2IGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLWV2ZW50LXJlc3BvbnNlc1wiIGRhdGEtZGF5PVwiJHtldmVudC5kYXkgfHwgJyd9XCI+XG4gIDxpIGNsYXNzPVwiZmEgZmEtcmVwbHlcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gIDxkaXYgY2xhc3M9XCJjb2wteHMtMTIgY29sLXNtLTZcIj5cbiAgICAke2V2ZW50LnJlcGVhdHMgPyBgXG4gICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIHBsdWdpbi1jYWxlbmRhci1ldmVudC1yZXNwb25zZXMtZGF5XCI+XG4gICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiB0aXRsZT1cIltbY2FsZW5kYXI6c2VsZWN0X2RheV1dXCIgdHlwZT1cInRleHRcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIj5cbiAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1jYWxlbmRhci1jaGVjay1vXCI+PC9pPlxuICAgICAgPC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIGAgOiAnJ31cbiAgICAke3VpZCA9PT0gMCA/ICcnIDogYFxuICAgIDxkaXYgY2xhc3M9XCJwbHVnaW4tY2FsZW5kYXItZXZlbnQtcmVzcG9uc2VzLXVzZXIgYnRuLWdyb3VwXCI+XG4gICAgICAkeygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHtcbiAgICAgICAgICBubzogJycsXG4gICAgICAgICAgbWF5YmU6ICcnLFxuICAgICAgICAgIHllczogJycsXG4gICAgICAgICAgW3Jlc3BvbnNlXTogJ2FjdGl2ZScsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGBcbiAgICAgIDxidXR0b24gZGF0YS12YWx1ZT1cIm5vXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tZGFuZ2VyICR7YWN0aXZlLm5vfVwiPlxuICAgICAgICBbW2NhbGVuZGFyOnJlc3BvbnNlX25vXV1cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBkYXRhLXZhbHVlPVwibWF5YmVcIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1kZWZhdWx0ICR7YWN0aXZlLm1heWJlfVwiPlxuICAgICAgICBbW2NhbGVuZGFyOnJlc3BvbnNlX21heWJlXV1cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBkYXRhLXZhbHVlPVwieWVzXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tc3VjY2VzcyAke2FjdGl2ZS55ZXN9XCI+XG4gICAgICAgIFtbY2FsZW5kYXI6cmVzcG9uc2VfeWVzXV1cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgICBgO1xuICAgICAgfSkoKX1cbiAgICA8L2Rpdj5cbiAgICBgfVxuICAgIDxkaXYgY2xhc3M9XCJwYW5lbC1ncm91cCBwbHVnaW4tY2FsZW5kYXItZXZlbnQtcmVzcG9uc2VzLWxpc3RzXCIgZGF0YS1sb2FkZWQ9XCJmYWxzZVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInBhbmVsIHBhbmVsLWRlZmF1bHQgY2xvc2VkXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYW5lbC1oZWFkaW5nXCI+XG4gICAgICAgICAgPGEgcm9sZT1cImJ1dHRvblwiIGRhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIiBocmVmPVwiI1wiXG4gICAgICAgICAgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1pbmZvXCIgYXJpYS1leHBhbmRlZD1cInRydWVcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtY2hldnJvbi1kb3duIHB1bGwtcmlnaHRcIj48L2k+XG4gICAgICAgICAgICBbW2NhbGVuZGFyOnJlc3BvbnNlX3llc11dXG4gICAgICAgICAgPC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhbmVsLWNvbGxhcHNlXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInBhbmVsLWJvZHlcIj5cbiAgICAgICAgICAgIDx1bCBjbGFzcz1cInBsdWdpbi1jYWxlbmRhci1ldmVudC1yZXNwb25zZXMtbGlzdC15ZXNcIj5cbiAgICAgICAgICAgICAgPCEtLSB5ZXMgcmVzcG9uc2VzIGdvIGhlcmUgLS0+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInBhbmVsIHBhbmVsLWRlZmF1bHQgY2xvc2VkXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYW5lbC1oZWFkaW5nXCI+XG4gICAgICAgICAgPGEgcm9sZT1cImJ1dHRvblwiIGRhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIiBocmVmPVwiI1wiXG4gICAgICAgICAgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1saW5rXCIgYXJpYS1leHBhbmRlZD1cInRydWVcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtY2hldnJvbi1kb3duIHB1bGwtcmlnaHRcIj48L2k+XG4gICAgICAgICAgICBbW2NhbGVuZGFyOnJlc3BvbnNlX21heWJlXV1cbiAgICAgICAgICA8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicGFuZWwtY29sbGFwc2VcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFuZWwtYm9keVwiPlxuICAgICAgICAgICAgPHVsIGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLWV2ZW50LXJlc3BvbnNlcy1saXN0LW1heWJlXCI+XG4gICAgICAgICAgICAgIDwhLS0gbWF5YmUgcmVzcG9uc2VzIGdvIGhlcmUgLS0+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInBhbmVsIHBhbmVsLWRlZmF1bHQgY2xvc2VkXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYW5lbC1oZWFkaW5nXCI+XG4gICAgICAgICAgPGEgcm9sZT1cImJ1dHRvblwiIGRhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIiBocmVmPVwiI1wiXG4gICAgICAgICAgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi13YXJuaW5nXCIgYXJpYS1leHBhbmRlZD1cInRydWVcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtY2hldnJvbi1kb3duIHB1bGwtcmlnaHRcIj48L2k+XG4gICAgICAgICAgICBbW2NhbGVuZGFyOnJlc3BvbnNlX25vXV1cbiAgICAgICAgICA8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicGFuZWwtY29sbGFwc2VcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFuZWwtYm9keVwiPlxuICAgICAgICAgICAgPHVsIGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLWV2ZW50LXJlc3BvbnNlcy1saXN0LW5vXCI+XG4gICAgICAgICAgICAgIDwhLS0gbm8gcmVzcG9uc2VzIGdvIGhlcmUgLS0+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PmA7XG4gIGxldCByZXNwb25zZXMgPSBpc0VtYWlsID8gYFxuICA8ZGl2IGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLWV2ZW50LXJlc3BvbnNlc1wiPlxuICAgIDxpIGNsYXNzPVwiZmEgZmEtcmVwbHlcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgW1tjYWxlbmRhcjp5b3VfcmVzcG9uZGVkLCBbW2NhbGVuZGFyOnJlc3BvbnNlXyR7cmVzcG9uc2V9XV1dXVxuICA8L2Rpdj5cbiAgYCA6IHJlc3BvbnNlc1RlbXBsYXRlKCk7XG5cbiAgaWYgKGV2ZW50LmV4dGVybmFsKSB7XG4gICAgcmVzcG9uc2VzID0gJyc7XG4gIH1cblxuICBjb25zdCBodG1sID0gYFxuPGRpdiBjbGFzcz1cInBsdWdpbi1jYWxlbmRhci1ldmVudCBwYW5lbCBwYW5lbC1zdWNjZXNzXCIgZGF0YS10cmFuc2xhdGVkPVwiZmFsc2VcIj5cbiAgPGRpdiBjbGFzcz1cInBsdWdpbi1jYWxlbmRhci1ldmVudC1uYW1lIHBhbmVsLWhlYWRpbmdcIj5cbiAgICAke2V2ZW50Lm5hbWV9XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwicGFuZWwtYm9keVwiPlxuICAgIDxkaXYgY2xhc3M9XCJwbHVnaW4tY2FsZW5kYXItZXZlbnQtZGF0ZVwiPlxuICAgICAgPGkgY2xhc3M9XCJmYSBmYS1jbG9jay1vXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgPGFcbiAgICAgICAgdGl0bGU9XCJbW21vbWVudDp0aW1lLWRhdGUtdmlldywgdXRjLCAke3N0YXJ0RGF0ZX0sICR7ZW5kRGF0ZX0sICR7YWxsZGF5fV1dIFVUQ1wiXG4gICAgICAgIGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLXRpbWUtZGF0ZS12aWV3XCJcbiAgICAgID5bW21vbWVudDp0aW1lLWRhdGUtdmlldywgbG9jYWwsICR7c3RhcnREYXRlfSwgJHtlbmREYXRlfSwgJHthbGxkYXl9XV08L2E+XG4gICAgPC9kaXY+XG4gICAgJHtldmVudC5leHRlcm5hbCA/IGBcbiAgICA8ZGl2IGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLWV2ZW50LWxvY2F0aW9uXCI+XG4gICAgICA8aSBjbGFzcz1cImZhIGZhLWxvY2F0aW9uLWFycm93XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgPHNwYW4+RXh0ZXJuYWw6ICR7ZXZlbnQuc291cmNlfTxzcGFuPlxuICAgIDwvZGl2PlxuICAgIGAgOiAnJ31cbiAgICAke2V2ZW50LmxvY2F0aW9uID8gYFxuICAgIDxkaXYgY2xhc3M9XCJwbHVnaW4tY2FsZW5kYXItZXZlbnQtbG9jYXRpb25cIj5cbiAgICAgIDxpIGNsYXNzPVwiZmEgZmEtbG9jYXRpb24tYXJyb3dcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgICA8c3Bhbj4ke2V2ZW50LmxvY2F0aW9ufTxzcGFuPlxuICAgIDwvZGl2PlxuICAgIGAgOiAnJ31cbiAgICAke2V2ZW50LmRlc2NyaXB0aW9uID8gYFxuICAgIDxkaXYgY2xhc3M9XCJwbHVnaW4tY2FsZW5kYXItZXZlbnQtZGVzY3JpcHRpb25cIj5cbiAgICAgIDxpIGNsYXNzPVwiZmEgZmEtaW5mby1jaXJjbGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgICA8ZGl2PiR7ZXZlbnQuZGVzY3JpcHRpb259PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYCA6ICcnfVxuICAgICR7IWV2ZW50LmV4dGVybmFsICYmIGV2ZW50LnJlbWluZGVycyA/IGBcbiAgICA8ZGl2IGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLWV2ZW50LXJlbWluZGVyc1wiPlxuICAgICAgPGkgY2xhc3M9XCJmYSBmYS1iZWxsXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgPHVsPlxuICAgICAgICAke2V2ZW50LnJlbWluZGVyc1xuICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgICAgICAgICAubWFwKG1ha2VMaXN0RWxlbWVudCkuam9pbignXFxuJyl9XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PlxuICAgIGAgOiAnJ31cbiAgICAkeygoKSA9PiB7XG4gICAgICBpZiAoZXZlbnQucmVwZWF0cykge1xuICAgICAgICBjb25zdCBrZXkgPSBbJ2RheScsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInXS5maW5kKHggPT4gZXZlbnQucmVwZWF0cy5ldmVyeVt4XSk7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCJwbHVnaW4tY2FsZW5kYXItZXZlbnQtcmVwZWF0c1wiPlxuICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1yZXBlYXRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgICAgICAgICA8c3Bhbj5bW2NhbGVuZGFyOmV2ZXJ5XyR7a2V5fV1dPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PmA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LnJlcGVhdHMuZXZlcnkuZGF5c09mV2Vlaykge1xuICAgICAgICAgIGNvbnN0IGRheXMgPSBldmVudC5yZXBlYXRzLmV2ZXJ5LmRheXNPZldlZWtcbiAgICAgICAgICAgIC5tYXAoZGF5ID0+IGBbW21vbWVudDpsb2NhbGUtZGF0YSwgX3dlZWtkYXlzU2hvcnQsICR7ZGF5fV1dYClcbiAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgIGNvbnN0IGVuZERhdGVUZXh0ID0gYFtbbW9tZW50OnRpbWUtZGF0ZS12aWV3LCB1dGMsICR7ZXZlbnQucmVwZWF0cy5lbmREYXRlfSwgYCArXG4gICAgICAgICAgICBgJHtldmVudC5yZXBlYXRzLmVuZERhdGV9LCB0cnVlXV1gO1xuICAgICAgICAgIHJldHVybiBgPGRpdiBjbGFzcz1cInBsdWdpbi1jYWxlbmRhci1ldmVudC1yZXBlYXRzXCI+XG4gICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXJlcGVhdFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cbiAgICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgICAke051bWJlci5pc0Zpbml0ZShldmVudC5yZXBlYXRzLmVuZERhdGUpID8gYFxuICAgICAgICAgICAgICBbW2NhbGVuZGFyOnJlcGVhdHNfd2Vla2x5X29uX3VudGlsLCAke2VuZERhdGVUZXh0fV1dICR7ZGF5c31cbiAgICAgICAgICAgICAgYCA6IGBcbiAgICAgICAgICAgICAgW1tjYWxlbmRhcjpyZXBlYXRzX3dlZWtseV9vbl9mb3JldmVyXV0gJHtkYXlzfVxuICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9KSgpfVxuICAgICR7ZXZlbnQubWFuZGF0b3J5ID8gYFxuICAgIDxkaXYgY2xhc3M9XCJwbHVnaW4tY2FsZW5kYXItZXZlbnQtbWFuZGF0b3J5XCI+XG4gICAgICA8aSBjbGFzcz1cImZhIGZhLWV4Y2xhbWF0aW9uLWNpcmNsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cbiAgICAgIDxzcGFuPltbY2FsZW5kYXI6bWFuZGF0b3J5XV08L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgYCA6IHJlc3BvbnNlc31cbiAgPC9kaXY+XG48L2Rpdj5gO1xuXG4gIHJldHVybiBodG1sO1xufTtcblxuZXhwb3J0IHsgZXZlbnRUZW1wbGF0ZSB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xpYi90ZW1wbGF0ZXMuanMiLCIvKiFcbiAqIEZ1bGxDYWxlbmRhciB2My40LjBcbiAqIERvY3MgJiBMaWNlbnNlOiBodHRwczovL2Z1bGxjYWxlbmRhci5pby9cbiAqIChjKSAyMDE3IEFkYW0gU2hhd1xuICovXG5cbmltcG9ydCBtb21lbnQgZnJvbSBcIm1vbWVudFwiO1xuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgZmFjdG9yeShqUXVlcnksIG1vbWVudCk7XG59KShmdW5jdGlvbigkLCBtb21lbnQpIHtcblxuOztcblxudmFyIEZDID0gJC5mdWxsQ2FsZW5kYXIgPSB7XG5cdHZlcnNpb246IFwiMy40LjBcIixcblx0Ly8gV2hlbiBpbnRyb2R1Y2luZyBpbnRlcm5hbCBBUEkgaW5jb21wYXRpYmlsaXRpZXMgKHdoZXJlIGZ1bGxjYWxlbmRhciBwbHVnaW5zIHdvdWxkIGJyZWFrKSxcblx0Ly8gdGhlIG1pbm9yIHZlcnNpb24gb2YgdGhlIGNhbGVuZGFyIHNob3VsZCBiZSB1cHBlZCAoZXg6IDIuNy4yIC0+IDIuOC4wKVxuXHQvLyBhbmQgdGhlIGJlbG93IGludGVnZXIgc2hvdWxkIGJlIGluY3JlbWVudGVkLlxuXHRpbnRlcm5hbEFwaVZlcnNpb246IDlcbn07XG52YXIgZmNWaWV3cyA9IEZDLnZpZXdzID0ge307XG5cblxuJC5mbi5mdWxsQ2FsZW5kYXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIGEgcG9zc2libGUgbWV0aG9kIGNhbGxcblx0dmFyIHJlcyA9IHRoaXM7IC8vIHdoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiAodGhpcyBqUXVlcnkgb2JqZWN0IGJ5IGRlZmF1bHQpXG5cblx0dGhpcy5lYWNoKGZ1bmN0aW9uKGksIF9lbGVtZW50KSB7IC8vIGxvb3AgZWFjaCBET00gZWxlbWVudCBpbnZvbHZlZFxuXHRcdHZhciBlbGVtZW50ID0gJChfZWxlbWVudCk7XG5cdFx0dmFyIGNhbGVuZGFyID0gZWxlbWVudC5kYXRhKCdmdWxsQ2FsZW5kYXInKTsgLy8gZ2V0IHRoZSBleGlzdGluZyBjYWxlbmRhciBvYmplY3QgKGlmIGFueSlcblx0XHR2YXIgc2luZ2xlUmVzOyAvLyB0aGUgcmV0dXJuZWQgdmFsdWUgb2YgdGhpcyBzaW5nbGUgbWV0aG9kIGNhbGxcblxuXHRcdC8vIGEgbWV0aG9kIGNhbGxcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpZiAoY2FsZW5kYXIgJiYgJC5pc0Z1bmN0aW9uKGNhbGVuZGFyW29wdGlvbnNdKSkge1xuXHRcdFx0XHRzaW5nbGVSZXMgPSBjYWxlbmRhcltvcHRpb25zXS5hcHBseShjYWxlbmRhciwgYXJncyk7XG5cdFx0XHRcdGlmICghaSkge1xuXHRcdFx0XHRcdHJlcyA9IHNpbmdsZVJlczsgLy8gcmVjb3JkIHRoZSBmaXJzdCBtZXRob2QgY2FsbCByZXN1bHRcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3B0aW9ucyA9PT0gJ2Rlc3Ryb3knKSB7IC8vIGZvciB0aGUgZGVzdHJveSBtZXRob2QsIG11c3QgcmVtb3ZlIENhbGVuZGFyIG9iamVjdCBkYXRhXG5cdFx0XHRcdFx0ZWxlbWVudC5yZW1vdmVEYXRhKCdmdWxsQ2FsZW5kYXInKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBhIG5ldyBjYWxlbmRhciBpbml0aWFsaXphdGlvblxuXHRcdGVsc2UgaWYgKCFjYWxlbmRhcikgeyAvLyBkb24ndCBpbml0aWFsaXplIHR3aWNlXG5cdFx0XHRjYWxlbmRhciA9IG5ldyBDYWxlbmRhcihlbGVtZW50LCBvcHRpb25zKTtcblx0XHRcdGVsZW1lbnQuZGF0YSgnZnVsbENhbGVuZGFyJywgY2FsZW5kYXIpO1xuXHRcdFx0Y2FsZW5kYXIucmVuZGVyKCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gcmVzO1xufTtcblxuXG52YXIgY29tcGxleE9wdGlvbnMgPSBbIC8vIG5hbWVzIG9mIG9wdGlvbnMgdGhhdCBhcmUgb2JqZWN0cyB3aG9zZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSBjb21iaW5lZFxuXHQnaGVhZGVyJyxcblx0J2Zvb3RlcicsXG5cdCdidXR0b25UZXh0Jyxcblx0J2J1dHRvbkljb25zJyxcblx0J3RoZW1lQnV0dG9uSWNvbnMnXG5dO1xuXG5cbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvcHRpb24gb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdFxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbk9ianMpIHtcblx0cmV0dXJuIG1lcmdlUHJvcHMob3B0aW9uT2JqcywgY29tcGxleE9wdGlvbnMpO1xufVxuXG47O1xuXG4vLyBleHBvcnRzXG5GQy5pbnRlcnNlY3RSYW5nZXMgPSBpbnRlcnNlY3RSYW5nZXM7XG5GQy5hcHBseUFsbCA9IGFwcGx5QWxsO1xuRkMuZGVib3VuY2UgPSBkZWJvdW5jZTtcbkZDLmlzSW50ID0gaXNJbnQ7XG5GQy5odG1sRXNjYXBlID0gaHRtbEVzY2FwZTtcbkZDLmNzc1RvU3RyID0gY3NzVG9TdHI7XG5GQy5wcm94eSA9IHByb3h5O1xuRkMuY2FwaXRhbGlzZUZpcnN0TGV0dGVyID0gY2FwaXRhbGlzZUZpcnN0TGV0dGVyO1xuXG5cbi8qIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyBET00gVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG4vLyBHaXZlbiB0aGUgc2Nyb2xsYmFyIHdpZHRocyBvZiBzb21lIG90aGVyIGNvbnRhaW5lciwgY3JlYXRlIGJvcmRlcnMvbWFyZ2lucyBvbiByb3dFbHMgaW4gb3JkZXIgdG8gbWF0Y2ggdGhlIGxlZnRcbi8vIGFuZCByaWdodCBzcGFjZSB0aGF0IHdhcyBvZmZzZXQgYnkgdGhlIHNjcm9sbGJhcnMuIEEgMS1waXhlbCBib3JkZXIgZmlyc3QsIHRoZW4gbWFyZ2luIGJleW9uZCB0aGF0LlxuZnVuY3Rpb24gY29tcGVuc2F0ZVNjcm9sbChyb3dFbHMsIHNjcm9sbGJhcldpZHRocykge1xuXHRpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQpIHtcblx0XHRyb3dFbHMuY3NzKHtcblx0XHRcdCdib3JkZXItbGVmdC13aWR0aCc6IDEsXG5cdFx0XHQnbWFyZ2luLWxlZnQnOiBzY3JvbGxiYXJXaWR0aHMubGVmdCAtIDFcblx0XHR9KTtcblx0fVxuXHRpZiAoc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7XG5cdFx0cm93RWxzLmNzcyh7XG5cdFx0XHQnYm9yZGVyLXJpZ2h0LXdpZHRoJzogMSxcblx0XHRcdCdtYXJnaW4tcmlnaHQnOiBzY3JvbGxiYXJXaWR0aHMucmlnaHQgLSAxXG5cdFx0fSk7XG5cdH1cbn1cblxuXG4vLyBVbmRvZXMgY29tcGVuc2F0ZVNjcm9sbCBhbmQgcmVzdG9yZXMgYWxsIGJvcmRlcnMvbWFyZ2luc1xuZnVuY3Rpb24gdW5jb21wZW5zYXRlU2Nyb2xsKHJvd0Vscykge1xuXHRyb3dFbHMuY3NzKHtcblx0XHQnbWFyZ2luLWxlZnQnOiAnJyxcblx0XHQnbWFyZ2luLXJpZ2h0JzogJycsXG5cdFx0J2JvcmRlci1sZWZ0LXdpZHRoJzogJycsXG5cdFx0J2JvcmRlci1yaWdodC13aWR0aCc6ICcnXG5cdH0pO1xufVxuXG5cbi8vIE1ha2UgdGhlIG1vdXNlIGN1cnNvciBleHByZXNzIHRoYXQgYW4gZXZlbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgYXJlYVxuZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcblx0JCgnYm9keScpLmFkZENsYXNzKCdmYy1ub3QtYWxsb3dlZCcpO1xufVxuXG5cbi8vIFJldHVybnMgdGhlIG1vdXNlIGN1cnNvciB0byBpdHMgb3JpZ2luYWwgbG9va1xuZnVuY3Rpb24gZW5hYmxlQ3Vyc29yKCkge1xuXHQkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG5cblxuLy8gR2l2ZW4gYSB0b3RhbCBhdmFpbGFibGUgaGVpZ2h0IHRvIGZpbGwsIGhhdmUgYGVsc2AgKGVzc2VudGlhbGx5IGNoaWxkIHJvd3MpIGV4cGFuZCB0byBhY2NvbW9kYXRlLlxuLy8gQnkgZGVmYXVsdCwgYWxsIGVsZW1lbnRzIHRoYXQgYXJlIHNob3J0ZXIgdGhhbiB0aGUgcmVjb21tZW5kZWQgaGVpZ2h0IGFyZSBleHBhbmRlZCB1bmlmb3JtbHksIG5vdCBjb25zaWRlcmluZ1xuLy8gYW55IG90aGVyIGVscyB0aGF0IGFyZSBhbHJlYWR5IHRvbyB0YWxsLiBpZiBgc2hvdWxkUmVkaXN0cmlidXRlYCBpcyBvbiwgaXQgY29uc2lkZXJzIHRoZXNlIHRhbGwgcm93cyBhbmQgXG4vLyByZWR1Y2VzIHRoZSBhdmFpbGFibGUgaGVpZ2h0LlxuZnVuY3Rpb24gZGlzdHJpYnV0ZUhlaWdodChlbHMsIGF2YWlsYWJsZUhlaWdodCwgc2hvdWxkUmVkaXN0cmlidXRlKSB7XG5cblx0Ly8gKkZMT09SSU5HIE5PVEUqOiB3ZSBmbG9vciBpbiBjZXJ0YWluIHBsYWNlcyBiZWNhdXNlIHpvb20gY2FuIGdpdmUgaW5hY2N1cmF0ZSBmbG9hdGluZy1wb2ludCBkaW1lbnNpb25zLFxuXHQvLyBhbmQgaXQgaXMgYmV0dGVyIHRvIGJlIHNob3J0ZXIgdGhhbiB0YWxsZXIsIHRvIGF2b2lkIGNyZWF0aW5nIHVubmVjZXNzYXJ5IHNjcm9sbGJhcnMuXG5cblx0dmFyIG1pbk9mZnNldDEgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAvIGVscy5sZW5ndGgpOyAvLyBmb3Igbm9uLWxhc3QgZWxlbWVudFxuXHR2YXIgbWluT2Zmc2V0MiA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC0gbWluT2Zmc2V0MSAqIChlbHMubGVuZ3RoIC0gMSkpOyAvLyBmb3IgbGFzdCBlbGVtZW50ICpGTE9PUklORyBOT1RFKlxuXHR2YXIgZmxleEVscyA9IFtdOyAvLyBlbGVtZW50cyB0aGF0IGFyZSBhbGxvd2VkIHRvIGV4cGFuZC4gYXJyYXkgb2YgRE9NIG5vZGVzXG5cdHZhciBmbGV4T2Zmc2V0cyA9IFtdOyAvLyBhbW91bnQgb2YgdmVydGljYWwgc3BhY2UgaXQgdGFrZXMgdXBcblx0dmFyIGZsZXhIZWlnaHRzID0gW107IC8vIGFjdHVhbCBjc3MgaGVpZ2h0XG5cdHZhciB1c2VkSGVpZ2h0ID0gMDtcblxuXHR1bmRpc3RyaWJ1dGVIZWlnaHQoZWxzKTsgLy8gZ2l2ZSBhbGwgZWxlbWVudHMgdGhlaXIgbmF0dXJhbCBoZWlnaHRcblxuXHQvLyBmaW5kIGVsZW1lbnRzIHRoYXQgYXJlIGJlbG93IHRoZSByZWNvbW1lbmRlZCBoZWlnaHQgKGV4cGFuZGFibGUpLlxuXHQvLyBpbXBvcnRhbnQgdG8gcXVlcnkgZm9yIGhlaWdodHMgaW4gYSBzaW5nbGUgZmlyc3QgcGFzcyAodG8gYXZvaWQgcmVmbG93IG9zY2lsbGF0aW9uKS5cblx0ZWxzLmVhY2goZnVuY3Rpb24oaSwgZWwpIHtcblx0XHR2YXIgbWluT2Zmc2V0ID0gaSA9PT0gZWxzLmxlbmd0aCAtIDEgPyBtaW5PZmZzZXQyIDogbWluT2Zmc2V0MTtcblx0XHR2YXIgbmF0dXJhbE9mZnNldCA9ICQoZWwpLm91dGVySGVpZ2h0KHRydWUpO1xuXG5cdFx0aWYgKG5hdHVyYWxPZmZzZXQgPCBtaW5PZmZzZXQpIHtcblx0XHRcdGZsZXhFbHMucHVzaChlbCk7XG5cdFx0XHRmbGV4T2Zmc2V0cy5wdXNoKG5hdHVyYWxPZmZzZXQpO1xuXHRcdFx0ZmxleEhlaWdodHMucHVzaCgkKGVsKS5oZWlnaHQoKSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gdGhpcyBlbGVtZW50IHN0cmV0Y2hlcyBwYXN0IHJlY29tbWVuZGVkIGhlaWdodCAobm9uLWV4cGFuZGFibGUpLiBtYXJrIHRoZSBzcGFjZSBhcyBvY2N1cGllZC5cblx0XHRcdHVzZWRIZWlnaHQgKz0gbmF0dXJhbE9mZnNldDtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIHJlYWRqdXN0IHRoZSByZWNvbW1lbmRlZCBoZWlnaHQgdG8gb25seSBjb25zaWRlciB0aGUgaGVpZ2h0IGF2YWlsYWJsZSB0byBub24tbWF4ZWQtb3V0IHJvd3MuXG5cdGlmIChzaG91bGRSZWRpc3RyaWJ1dGUpIHtcblx0XHRhdmFpbGFibGVIZWlnaHQgLT0gdXNlZEhlaWdodDtcblx0XHRtaW5PZmZzZXQxID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLyBmbGV4RWxzLmxlbmd0aCk7XG5cdFx0bWluT2Zmc2V0MiA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC0gbWluT2Zmc2V0MSAqIChmbGV4RWxzLmxlbmd0aCAtIDEpKTsgLy8gKkZMT09SSU5HIE5PVEUqXG5cdH1cblxuXHQvLyBhc3NpZ24gaGVpZ2h0cyB0byBhbGwgZXhwYW5kYWJsZSBlbGVtZW50c1xuXHQkKGZsZXhFbHMpLmVhY2goZnVuY3Rpb24oaSwgZWwpIHtcblx0XHR2YXIgbWluT2Zmc2V0ID0gaSA9PT0gZmxleEVscy5sZW5ndGggLSAxID8gbWluT2Zmc2V0MiA6IG1pbk9mZnNldDE7XG5cdFx0dmFyIG5hdHVyYWxPZmZzZXQgPSBmbGV4T2Zmc2V0c1tpXTtcblx0XHR2YXIgbmF0dXJhbEhlaWdodCA9IGZsZXhIZWlnaHRzW2ldO1xuXHRcdHZhciBuZXdIZWlnaHQgPSBtaW5PZmZzZXQgLSAobmF0dXJhbE9mZnNldCAtIG5hdHVyYWxIZWlnaHQpOyAvLyBzdWJ0cmFjdCB0aGUgbWFyZ2luL3BhZGRpbmdcblxuXHRcdGlmIChuYXR1cmFsT2Zmc2V0IDwgbWluT2Zmc2V0KSB7IC8vIHdlIGNoZWNrIHRoaXMgYWdhaW4gYmVjYXVzZSByZWRpc3RyaWJ1dGlvbiBtaWdodCBoYXZlIGNoYW5nZWQgdGhpbmdzXG5cdFx0XHQkKGVsKS5oZWlnaHQobmV3SGVpZ2h0KTtcblx0XHR9XG5cdH0pO1xufVxuXG5cbi8vIFVuZG9lcyBkaXN0cnVidXRlSGVpZ2h0LCByZXN0b3JpbmcgYWxsIGVscyB0byB0aGVpciBuYXR1cmFsIGhlaWdodFxuZnVuY3Rpb24gdW5kaXN0cmlidXRlSGVpZ2h0KGVscykge1xuXHRlbHMuaGVpZ2h0KCcnKTtcbn1cblxuXG4vLyBHaXZlbiBgZWxzYCwgYSBqUXVlcnkgc2V0IG9mIDx0ZD4gY2VsbHMsIGZpbmQgdGhlIGNlbGwgd2l0aCB0aGUgbGFyZ2VzdCBuYXR1cmFsIHdpZHRoIGFuZCBzZXQgdGhlIHdpZHRocyBvZiBhbGwgdGhlXG4vLyBjZWxscyB0byBiZSB0aGF0IHdpZHRoLlxuLy8gUFJFUkVRVUlTSVRFOiBpZiB5b3Ugd2FudCBhIGNlbGwgdG8gdGFrZSB1cCB3aWR0aCwgaXQgbmVlZHMgdG8gaGF2ZSBhIHNpbmdsZSBpbm5lciBlbGVtZW50IHcvIGRpc3BsYXk6aW5saW5lXG5mdW5jdGlvbiBtYXRjaENlbGxXaWR0aHMoZWxzKSB7XG5cdHZhciBtYXhJbm5lcldpZHRoID0gMDtcblxuXHRlbHMuZmluZCgnPiAqJykuZWFjaChmdW5jdGlvbihpLCBpbm5lckVsKSB7XG5cdFx0dmFyIGlubmVyV2lkdGggPSAkKGlubmVyRWwpLm91dGVyV2lkdGgoKTtcblx0XHRpZiAoaW5uZXJXaWR0aCA+IG1heElubmVyV2lkdGgpIHtcblx0XHRcdG1heElubmVyV2lkdGggPSBpbm5lcldpZHRoO1xuXHRcdH1cblx0fSk7XG5cblx0bWF4SW5uZXJXaWR0aCsrOyAvLyBzb21ldGltZXMgbm90IGFjY3VyYXRlIG9mIHdpZHRoIHRoZSB0ZXh0IG5lZWRzIHRvIHN0YXkgb24gb25lIGxpbmUuIGluc3VyYW5jZVxuXG5cdGVscy53aWR0aChtYXhJbm5lcldpZHRoKTtcblxuXHRyZXR1cm4gbWF4SW5uZXJXaWR0aDtcbn1cblxuXG4vLyBHaXZlbiBvbmUgZWxlbWVudCB0aGF0IHJlc2lkZXMgaW5zaWRlIGFub3RoZXIsXG4vLyBTdWJ0cmFjdHMgdGhlIGhlaWdodCBvZiB0aGUgaW5uZXIgZWxlbWVudCBmcm9tIHRoZSBvdXRlciBlbGVtZW50LlxuZnVuY3Rpb24gc3VidHJhY3RJbm5lckVsSGVpZ2h0KG91dGVyRWwsIGlubmVyRWwpIHtcblx0dmFyIGJvdGggPSBvdXRlckVsLmFkZChpbm5lckVsKTtcblx0dmFyIGRpZmY7XG5cblx0Ly8gZWZmaW4nIElFOC85LzEwLzExIHNvbWV0aW1lcyByZXR1cm5zIDAgZm9yIGRpbWVuc2lvbnMuIHRoaXMgd2VpcmQgaGFjayB3YXMgdGhlIG9ubHkgdGhpbmcgdGhhdCB3b3JrZWRcblx0Ym90aC5jc3Moe1xuXHRcdHBvc2l0aW9uOiAncmVsYXRpdmUnLCAvLyBjYXVzZSBhIHJlZmxvdywgd2hpY2ggd2lsbCBmb3JjZSBmcmVzaCBkaW1lbnNpb24gcmVjYWxjdWxhdGlvblxuXHRcdGxlZnQ6IC0xIC8vIGVuc3VyZSByZWZsb3cgaW4gY2FzZSB0aGUgZWwgd2FzIGFscmVhZHkgcmVsYXRpdmUuIG5lZ2F0aXZlIGlzIGxlc3MgbGlrZWx5IHRvIGNhdXNlIG5ldyBzY3JvbGxcblx0fSk7XG5cdGRpZmYgPSBvdXRlckVsLm91dGVySGVpZ2h0KCkgLSBpbm5lckVsLm91dGVySGVpZ2h0KCk7IC8vIGdyYWIgdGhlIGRpbWVuc2lvbnNcblx0Ym90aC5jc3MoeyBwb3NpdGlvbjogJycsIGxlZnQ6ICcnIH0pOyAvLyB1bmRvIGhhY2tcblxuXHRyZXR1cm4gZGlmZjtcbn1cblxuXG4vKiBFbGVtZW50IEdlb20gVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuRkMuZ2V0T3V0ZXJSZWN0ID0gZ2V0T3V0ZXJSZWN0O1xuRkMuZ2V0Q2xpZW50UmVjdCA9IGdldENsaWVudFJlY3Q7XG5GQy5nZXRDb250ZW50UmVjdCA9IGdldENvbnRlbnRSZWN0O1xuRkMuZ2V0U2Nyb2xsYmFyV2lkdGhzID0gZ2V0U2Nyb2xsYmFyV2lkdGhzO1xuXG5cbi8vIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktdWkvYmxvYi8xLjExLjAvdWkvY29yZS5qcyNMNTFcbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbCkge1xuXHR2YXIgcG9zaXRpb24gPSBlbC5jc3MoJ3Bvc2l0aW9uJyksXG5cdFx0c2Nyb2xsUGFyZW50ID0gZWwucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwYXJlbnQgPSAkKHRoaXMpO1xuXHRcdFx0cmV0dXJuICgvKGF1dG98c2Nyb2xsKS8pLnRlc3QoXG5cdFx0XHRcdHBhcmVudC5jc3MoJ292ZXJmbG93JykgKyBwYXJlbnQuY3NzKCdvdmVyZmxvdy15JykgKyBwYXJlbnQuY3NzKCdvdmVyZmxvdy14Jylcblx0XHRcdCk7XG5cdFx0fSkuZXEoMCk7XG5cblx0cmV0dXJuIHBvc2l0aW9uID09PSAnZml4ZWQnIHx8ICFzY3JvbGxQYXJlbnQubGVuZ3RoID8gJChlbFswXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KSA6IHNjcm9sbFBhcmVudDtcbn1cblxuXG4vLyBRdWVyaWVzIHRoZSBvdXRlciBib3VuZGluZyBhcmVhIG9mIGEgalF1ZXJ5IGVsZW1lbnQuXG4vLyBSZXR1cm5zIGEgcmVjdGFuZ2xlIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXM6IGxlZnQsIHJpZ2h0IChleGNsdXNpdmUpLCB0b3AsIGJvdHRvbSAoZXhjbHVzaXZlKS5cbi8vIE9yaWdpbiBpcyBvcHRpb25hbC5cbmZ1bmN0aW9uIGdldE91dGVyUmVjdChlbCwgb3JpZ2luKSB7XG5cdHZhciBvZmZzZXQgPSBlbC5vZmZzZXQoKTtcblx0dmFyIGxlZnQgPSBvZmZzZXQubGVmdCAtIChvcmlnaW4gPyBvcmlnaW4ubGVmdCA6IDApO1xuXHR2YXIgdG9wID0gb2Zmc2V0LnRvcCAtIChvcmlnaW4gPyBvcmlnaW4udG9wIDogMCk7XG5cblx0cmV0dXJuIHtcblx0XHRsZWZ0OiBsZWZ0LFxuXHRcdHJpZ2h0OiBsZWZ0ICsgZWwub3V0ZXJXaWR0aCgpLFxuXHRcdHRvcDogdG9wLFxuXHRcdGJvdHRvbTogdG9wICsgZWwub3V0ZXJIZWlnaHQoKVxuXHR9O1xufVxuXG5cbi8vIFF1ZXJpZXMgdGhlIGFyZWEgd2l0aGluIHRoZSBtYXJnaW4vYm9yZGVyL3Njcm9sbGJhcnMgb2YgYSBqUXVlcnkgZWxlbWVudC4gRG9lcyBub3QgZ28gd2l0aGluIHRoZSBwYWRkaW5nLlxuLy8gUmV0dXJucyBhIHJlY3RhbmdsZSB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzOiBsZWZ0LCByaWdodCAoZXhjbHVzaXZlKSwgdG9wLCBib3R0b20gKGV4Y2x1c2l2ZSkuXG4vLyBPcmlnaW4gaXMgb3B0aW9uYWwuXG4vLyBXQVJOSU5HOiBnaXZlbiBlbGVtZW50IGNhbid0IGhhdmUgYm9yZGVyc1xuLy8gTk9URTogc2hvdWxkIHVzZSBjbGllbnRMZWZ0L2NsaWVudFRvcCwgYnV0IHZlcnkgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyLlxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChlbCwgb3JpZ2luKSB7XG5cdHZhciBvZmZzZXQgPSBlbC5vZmZzZXQoKTtcblx0dmFyIHNjcm9sbGJhcldpZHRocyA9IGdldFNjcm9sbGJhcldpZHRocyhlbCk7XG5cdHZhciBsZWZ0ID0gb2Zmc2V0LmxlZnQgKyBnZXRDc3NGbG9hdChlbCwgJ2JvcmRlci1sZWZ0LXdpZHRoJykgKyBzY3JvbGxiYXJXaWR0aHMubGVmdCAtIChvcmlnaW4gPyBvcmlnaW4ubGVmdCA6IDApO1xuXHR2YXIgdG9wID0gb2Zmc2V0LnRvcCArIGdldENzc0Zsb2F0KGVsLCAnYm9yZGVyLXRvcC13aWR0aCcpICsgc2Nyb2xsYmFyV2lkdGhzLnRvcCAtIChvcmlnaW4gPyBvcmlnaW4udG9wIDogMCk7XG5cblx0cmV0dXJuIHtcblx0XHRsZWZ0OiBsZWZ0LFxuXHRcdHJpZ2h0OiBsZWZ0ICsgZWxbMF0uY2xpZW50V2lkdGgsIC8vIGNsaWVudFdpZHRoIGluY2x1ZGVzIHBhZGRpbmcgYnV0IE5PVCBzY3JvbGxiYXJzXG5cdFx0dG9wOiB0b3AsXG5cdFx0Ym90dG9tOiB0b3AgKyBlbFswXS5jbGllbnRIZWlnaHQgLy8gY2xpZW50SGVpZ2h0IGluY2x1ZGVzIHBhZGRpbmcgYnV0IE5PVCBzY3JvbGxiYXJzXG5cdH07XG59XG5cblxuLy8gUXVlcmllcyB0aGUgYXJlYSB3aXRoaW4gdGhlIG1hcmdpbi9ib3JkZXIvcGFkZGluZyBvZiBhIGpRdWVyeSBlbGVtZW50LiBBc3N1bWVkIG5vdCB0byBoYXZlIHNjcm9sbGJhcnMuXG4vLyBSZXR1cm5zIGEgcmVjdGFuZ2xlIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXM6IGxlZnQsIHJpZ2h0IChleGNsdXNpdmUpLCB0b3AsIGJvdHRvbSAoZXhjbHVzaXZlKS5cbi8vIE9yaWdpbiBpcyBvcHRpb25hbC5cbmZ1bmN0aW9uIGdldENvbnRlbnRSZWN0KGVsLCBvcmlnaW4pIHtcblx0dmFyIG9mZnNldCA9IGVsLm9mZnNldCgpOyAvLyBqdXN0IG91dHNpZGUgb2YgYm9yZGVyLCBtYXJnaW4gbm90IGluY2x1ZGVkXG5cdHZhciBsZWZ0ID0gb2Zmc2V0LmxlZnQgKyBnZXRDc3NGbG9hdChlbCwgJ2JvcmRlci1sZWZ0LXdpZHRoJykgKyBnZXRDc3NGbG9hdChlbCwgJ3BhZGRpbmctbGVmdCcpIC1cblx0XHQob3JpZ2luID8gb3JpZ2luLmxlZnQgOiAwKTtcblx0dmFyIHRvcCA9IG9mZnNldC50b3AgKyBnZXRDc3NGbG9hdChlbCwgJ2JvcmRlci10b3Atd2lkdGgnKSArIGdldENzc0Zsb2F0KGVsLCAncGFkZGluZy10b3AnKSAtXG5cdFx0KG9yaWdpbiA/IG9yaWdpbi50b3AgOiAwKTtcblxuXHRyZXR1cm4ge1xuXHRcdGxlZnQ6IGxlZnQsXG5cdFx0cmlnaHQ6IGxlZnQgKyBlbC53aWR0aCgpLFxuXHRcdHRvcDogdG9wLFxuXHRcdGJvdHRvbTogdG9wICsgZWwuaGVpZ2h0KClcblx0fTtcbn1cblxuXG4vLyBSZXR1cm5zIHRoZSBjb21wdXRlZCBsZWZ0L3JpZ2h0L3RvcC9ib3R0b20gc2Nyb2xsYmFyIHdpZHRocyBmb3IgdGhlIGdpdmVuIGpRdWVyeSBlbGVtZW50LlxuLy8gV0FSTklORzogZ2l2ZW4gZWxlbWVudCBjYW4ndCBoYXZlIGJvcmRlcnMgKHdoaWNoIHdpbGwgY2F1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHRvIGJlIGxhcmdlcikuXG4vLyBOT1RFOiBzaG91bGQgdXNlIGNsaWVudExlZnQvY2xpZW50VG9wLCBidXQgdmVyeSB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIuXG5mdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aHMoZWwpIHtcblx0dmFyIGxlZnRSaWdodFdpZHRoID0gZWxbMF0ub2Zmc2V0V2lkdGggLSBlbFswXS5jbGllbnRXaWR0aDtcblx0dmFyIGJvdHRvbVdpZHRoID0gZWxbMF0ub2Zmc2V0SGVpZ2h0IC0gZWxbMF0uY2xpZW50SGVpZ2h0O1xuXHR2YXIgd2lkdGhzO1xuXG5cdGxlZnRSaWdodFdpZHRoID0gc2FuaXRpemVTY3JvbGxiYXJXaWR0aChsZWZ0UmlnaHRXaWR0aCk7XG5cdGJvdHRvbVdpZHRoID0gc2FuaXRpemVTY3JvbGxiYXJXaWR0aChib3R0b21XaWR0aCk7XG5cblx0d2lkdGhzID0geyBsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IGJvdHRvbVdpZHRoIH07XG5cblx0aWYgKGdldElzTGVmdFJ0bFNjcm9sbGJhcnMoKSAmJiBlbC5jc3MoJ2RpcmVjdGlvbicpID09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cblx0XHR3aWR0aHMubGVmdCA9IGxlZnRSaWdodFdpZHRoO1xuXHR9XG5cdGVsc2Uge1xuXHRcdHdpZHRocy5yaWdodCA9IGxlZnRSaWdodFdpZHRoO1xuXHR9XG5cblx0cmV0dXJuIHdpZHRocztcbn1cblxuXG4vLyBUaGUgc2Nyb2xsYmFyIHdpZHRoIGNvbXB1dGF0aW9ucyBpbiBnZXRTY3JvbGxiYXJXaWR0aHMgYXJlIHNvbWV0aW1lcyBmbGF3ZWQgd2hlbiBpdCBjb21lcyB0b1xuLy8gcmV0aW5hIGRpc3BsYXlzLCByb3VuZGluZywgYW5kIElFMTEuIE1hc3NhZ2UgdGhlbSBpbnRvIGEgdXNhYmxlIHZhbHVlLlxuZnVuY3Rpb24gc2FuaXRpemVTY3JvbGxiYXJXaWR0aCh3aWR0aCkge1xuXHR3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoKTsgLy8gbm8gbmVnYXRpdmVzXG5cdHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG5cdHJldHVybiB3aWR0aDtcbn1cblxuXG4vLyBMb2dpYyBmb3IgZGV0ZXJtaW5pbmcgaWYsIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmlnaHQtdG8tbGVmdCwgdGhlIHNjcm9sbGJhciBhcHBlYXJzIG9uIHRoZSBsZWZ0IHNpZGVcblxudmFyIF9pc0xlZnRSdGxTY3JvbGxiYXJzID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0SXNMZWZ0UnRsU2Nyb2xsYmFycygpIHsgLy8gcmVzcG9uc2libGUgZm9yIGNhY2hpbmcgdGhlIGNvbXB1dGF0aW9uXG5cdGlmIChfaXNMZWZ0UnRsU2Nyb2xsYmFycyA9PT0gbnVsbCkge1xuXHRcdF9pc0xlZnRSdGxTY3JvbGxiYXJzID0gY29tcHV0ZUlzTGVmdFJ0bFNjcm9sbGJhcnMoKTtcblx0fVxuXHRyZXR1cm4gX2lzTGVmdFJ0bFNjcm9sbGJhcnM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVJc0xlZnRSdGxTY3JvbGxiYXJzKCkgeyAvLyBjcmVhdGVzIGFuIG9mZnNjcmVlbiB0ZXN0IGVsZW1lbnQsIHRoZW4gcmVtb3ZlcyBpdFxuXHR2YXIgZWwgPSAkKCc8ZGl2PjxkaXYvPjwvZGl2PicpXG5cdFx0LmNzcyh7XG5cdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdHRvcDogLTEwMDAsXG5cdFx0XHRsZWZ0OiAwLFxuXHRcdFx0Ym9yZGVyOiAwLFxuXHRcdFx0cGFkZGluZzogMCxcblx0XHRcdG92ZXJmbG93OiAnc2Nyb2xsJyxcblx0XHRcdGRpcmVjdGlvbjogJ3J0bCdcblx0XHR9KVxuXHRcdC5hcHBlbmRUbygnYm9keScpO1xuXHR2YXIgaW5uZXJFbCA9IGVsLmNoaWxkcmVuKCk7XG5cdHZhciByZXMgPSBpbm5lckVsLm9mZnNldCgpLmxlZnQgPiBlbC5vZmZzZXQoKS5sZWZ0OyAvLyBpcyB0aGUgaW5uZXIgZGl2IHNoaWZ0ZWQgdG8gYWNjb21tb2RhdGUgYSBsZWZ0IHNjcm9sbGJhcj9cblx0ZWwucmVtb3ZlKCk7XG5cdHJldHVybiByZXM7XG59XG5cblxuLy8gUmV0cmlldmVzIGEgalF1ZXJ5IGVsZW1lbnQncyBjb21wdXRlZCBDU1MgdmFsdWUgYXMgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4vLyBJZiB0aGUgcXVlcmllZCB2YWx1ZSBpcyBub24tbnVtZXJpYyAoZXg6IElFIGNhbiByZXR1cm4gXCJtZWRpdW1cIiBmb3IgYm9yZGVyIHdpZHRoKSwgd2lsbCBqdXN0IHJldHVybiB6ZXJvLlxuZnVuY3Rpb24gZ2V0Q3NzRmxvYXQoZWwsIHByb3ApIHtcblx0cmV0dXJuIHBhcnNlRmxvYXQoZWwuY3NzKHByb3ApKSB8fCAwO1xufVxuXG5cbi8qIE1vdXNlIC8gVG91Y2ggVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuRkMucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcblxuXG4vLyBSZXR1cm5zIGEgYm9vbGVhbiB3aGV0aGVyIHRoaXMgd2FzIGEgbGVmdCBtb3VzZSBjbGljayBhbmQgbm8gY3RybCBrZXkgKHdoaWNoIG1lYW5zIHJpZ2h0IGNsaWNrIG9uIE1hYylcbmZ1bmN0aW9uIGlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2KSB7XG5cdHJldHVybiBldi53aGljaCA9PSAxICYmICFldi5jdHJsS2V5O1xufVxuXG5cbmZ1bmN0aW9uIGdldEV2WChldikge1xuXHR2YXIgdG91Y2hlcyA9IGV2Lm9yaWdpbmFsRXZlbnQudG91Y2hlcztcblxuXHQvLyBvbiBtb2JpbGUgRkYsIHBhZ2VYIGZvciB0b3VjaCBldmVudHMgaXMgcHJlc2VudCwgYnV0IGluY29ycmVjdCxcblx0Ly8gc28sIGxvb2sgYXQgdG91Y2ggY29vcmRpbmF0ZXMgZmlyc3QuXG5cdGlmICh0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIHRvdWNoZXNbMF0ucGFnZVg7XG5cdH1cblxuXHRyZXR1cm4gZXYucGFnZVg7XG59XG5cblxuZnVuY3Rpb24gZ2V0RXZZKGV2KSB7XG5cdHZhciB0b3VjaGVzID0gZXYub3JpZ2luYWxFdmVudC50b3VjaGVzO1xuXG5cdC8vIG9uIG1vYmlsZSBGRiwgcGFnZVggZm9yIHRvdWNoIGV2ZW50cyBpcyBwcmVzZW50LCBidXQgaW5jb3JyZWN0LFxuXHQvLyBzbywgbG9vayBhdCB0b3VjaCBjb29yZGluYXRlcyBmaXJzdC5cblx0aWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGgpIHtcblx0XHRyZXR1cm4gdG91Y2hlc1swXS5wYWdlWTtcblx0fVxuXG5cdHJldHVybiBldi5wYWdlWTtcbn1cblxuXG5mdW5jdGlvbiBnZXRFdklzVG91Y2goZXYpIHtcblx0cmV0dXJuIC9edG91Y2gvLnRlc3QoZXYudHlwZSk7XG59XG5cblxuZnVuY3Rpb24gcHJldmVudFNlbGVjdGlvbihlbCkge1xuXHRlbC5hZGRDbGFzcygnZmMtdW5zZWxlY3RhYmxlJylcblx0XHQub24oJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xufVxuXG5cbmZ1bmN0aW9uIGFsbG93U2VsZWN0aW9uKGVsKSB7XG5cdGVsLnJlbW92ZUNsYXNzKCdmYy11bnNlbGVjdGFibGUnKVxuXHRcdC5vZmYoJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xufVxuXG5cbi8vIFN0b3BzIGEgbW91c2UvdG91Y2ggZXZlbnQgZnJvbSBkb2luZyBpdCdzIG5hdGl2ZSBicm93c2VyIGFjdGlvblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXYpIHtcblx0ZXYucHJldmVudERlZmF1bHQoKTtcbn1cblxuXG4vKiBHZW5lcmFsIEdlb21ldHJ5IFV0aWxzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuRkMuaW50ZXJzZWN0UmVjdHMgPSBpbnRlcnNlY3RSZWN0cztcblxuLy8gUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgdGhhdCBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gcmVjdGFuZ2xlcy4gSWYgdGhleSBkb24ndCBpbnRlcnNlY3QsIHJldHVybnMgZmFsc2VcbmZ1bmN0aW9uIGludGVyc2VjdFJlY3RzKHJlY3QxLCByZWN0Mikge1xuXHR2YXIgcmVzID0ge1xuXHRcdGxlZnQ6IE1hdGgubWF4KHJlY3QxLmxlZnQsIHJlY3QyLmxlZnQpLFxuXHRcdHJpZ2h0OiBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpLFxuXHRcdHRvcDogTWF0aC5tYXgocmVjdDEudG9wLCByZWN0Mi50b3ApLFxuXHRcdGJvdHRvbTogTWF0aC5taW4ocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20pXG5cdH07XG5cblx0aWYgKHJlcy5sZWZ0IDwgcmVzLnJpZ2h0ICYmIHJlcy50b3AgPCByZXMuYm90dG9tKSB7XG5cdFx0cmV0dXJuIHJlcztcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuLy8gUmV0dXJucyBhIG5ldyBwb2ludCB0aGF0IHdpbGwgaGF2ZSBiZWVuIG1vdmVkIHRvIHJlc2lkZSB3aXRoaW4gdGhlIGdpdmVuIHJlY3RhbmdsZVxuZnVuY3Rpb24gY29uc3RyYWluUG9pbnQocG9pbnQsIHJlY3QpIHtcblx0cmV0dXJuIHtcblx0XHRsZWZ0OiBNYXRoLm1pbihNYXRoLm1heChwb2ludC5sZWZ0LCByZWN0LmxlZnQpLCByZWN0LnJpZ2h0KSxcblx0XHR0b3A6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LnRvcCwgcmVjdC50b3ApLCByZWN0LmJvdHRvbSlcblx0fTtcbn1cblxuXG4vLyBSZXR1cm5zIGEgcG9pbnQgdGhhdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGdldFJlY3RDZW50ZXIocmVjdCkge1xuXHRyZXR1cm4ge1xuXHRcdGxlZnQ6IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsXG5cdFx0dG9wOiAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyXG5cdH07XG59XG5cblxuLy8gU3VidHJhY3RzIHBvaW50MidzIGNvb3JkaW5hdGVzIGZyb20gcG9pbnQxJ3MgY29vcmRpbmF0ZXMsIHJldHVybmluZyBhIGRlbHRhXG5mdW5jdGlvbiBkaWZmUG9pbnRzKHBvaW50MSwgcG9pbnQyKSB7XG5cdHJldHVybiB7XG5cdFx0bGVmdDogcG9pbnQxLmxlZnQgLSBwb2ludDIubGVmdCxcblx0XHR0b3A6IHBvaW50MS50b3AgLSBwb2ludDIudG9wXG5cdH07XG59XG5cblxuLyogT2JqZWN0IE9yZGVyaW5nIGJ5IEZpZWxkXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuRkMucGFyc2VGaWVsZFNwZWNzID0gcGFyc2VGaWVsZFNwZWNzO1xuRkMuY29tcGFyZUJ5RmllbGRTcGVjcyA9IGNvbXBhcmVCeUZpZWxkU3BlY3M7XG5GQy5jb21wYXJlQnlGaWVsZFNwZWMgPSBjb21wYXJlQnlGaWVsZFNwZWM7XG5GQy5mbGV4aWJsZUNvbXBhcmUgPSBmbGV4aWJsZUNvbXBhcmU7XG5cblxuZnVuY3Rpb24gcGFyc2VGaWVsZFNwZWNzKGlucHV0KSB7XG5cdHZhciBzcGVjcyA9IFtdO1xuXHR2YXIgdG9rZW5zID0gW107XG5cdHZhciBpLCB0b2tlbjtcblxuXHRpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuXHRcdHRva2VucyA9IGlucHV0LnNwbGl0KC9cXHMqLFxccyovKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHR0b2tlbnMgPSBbIGlucHV0IF07XG5cdH1cblx0ZWxzZSBpZiAoJC5pc0FycmF5KGlucHV0KSkge1xuXHRcdHRva2VucyA9IGlucHV0O1xuXHR9XG5cblx0Zm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuXHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0aWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHNwZWNzLnB1c2goXG5cdFx0XHRcdHRva2VuLmNoYXJBdCgwKSA9PSAnLScgP1xuXHRcdFx0XHRcdHsgZmllbGQ6IHRva2VuLnN1YnN0cmluZygxKSwgb3JkZXI6IC0xIH0gOlxuXHRcdFx0XHRcdHsgZmllbGQ6IHRva2VuLCBvcmRlcjogMSB9XG5cdFx0XHQpO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHNwZWNzLnB1c2goeyBmdW5jOiB0b2tlbiB9KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3BlY3M7XG59XG5cblxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmoxLCBvYmoyLCBmaWVsZFNwZWNzKSB7XG5cdHZhciBpO1xuXHR2YXIgY21wO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBmaWVsZFNwZWNzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y21wID0gY29tcGFyZUJ5RmllbGRTcGVjKG9iajEsIG9iajIsIGZpZWxkU3BlY3NbaV0pO1xuXHRcdGlmIChjbXApIHtcblx0XHRcdHJldHVybiBjbXA7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIDA7XG59XG5cblxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjKG9iajEsIG9iajIsIGZpZWxkU3BlYykge1xuXHRpZiAoZmllbGRTcGVjLmZ1bmMpIHtcblx0XHRyZXR1cm4gZmllbGRTcGVjLmZ1bmMob2JqMSwgb2JqMik7XG5cdH1cblx0cmV0dXJuIGZsZXhpYmxlQ29tcGFyZShvYmoxW2ZpZWxkU3BlYy5maWVsZF0sIG9iajJbZmllbGRTcGVjLmZpZWxkXSkgKlxuXHRcdChmaWVsZFNwZWMub3JkZXIgfHwgMSk7XG59XG5cblxuZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcblx0aWYgKCFhICYmICFiKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblx0aWYgKGIgPT0gbnVsbCkge1xuXHRcdHJldHVybiAtMTtcblx0fVxuXHRpZiAoYSA9PSBudWxsKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblx0aWYgKCQudHlwZShhKSA9PT0gJ3N0cmluZycgfHwgJC50eXBlKGIpID09PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYikpO1xuXHR9XG5cdHJldHVybiBhIC0gYjtcbn1cblxuXG4vKiBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgTWlzYyBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbi8vIENvbXB1dGVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByYW5nZXMuIFdpbGwgcmV0dXJuIGZyZXNoIGRhdGUgY2xvbmVzIGluIGEgcmFuZ2UuXG4vLyBSZXR1cm5zIHVuZGVmaW5lZCBpZiBubyBpbnRlcnNlY3Rpb24uXG4vLyBFeHBlY3RzIGFsbCBkYXRlcyB0byBiZSBub3JtYWxpemVkIHRvIHRoZSBzYW1lIHRpbWV6b25lIGJlZm9yZWhhbmQuXG4vLyBUT0RPOiBtb3ZlIHRvIGRhdGUgc2VjdGlvbj9cbmZ1bmN0aW9uIGludGVyc2VjdFJhbmdlcyhzdWJqZWN0UmFuZ2UsIGNvbnN0cmFpbnRSYW5nZSkge1xuXHR2YXIgc3ViamVjdFN0YXJ0ID0gc3ViamVjdFJhbmdlLnN0YXJ0O1xuXHR2YXIgc3ViamVjdEVuZCA9IHN1YmplY3RSYW5nZS5lbmQ7XG5cdHZhciBjb25zdHJhaW50U3RhcnQgPSBjb25zdHJhaW50UmFuZ2Uuc3RhcnQ7XG5cdHZhciBjb25zdHJhaW50RW5kID0gY29uc3RyYWludFJhbmdlLmVuZDtcblx0dmFyIHNlZ1N0YXJ0LCBzZWdFbmQ7XG5cdHZhciBpc1N0YXJ0LCBpc0VuZDtcblxuXHRpZiAoc3ViamVjdEVuZCA+IGNvbnN0cmFpbnRTdGFydCAmJiBzdWJqZWN0U3RhcnQgPCBjb25zdHJhaW50RW5kKSB7IC8vIGluIGJvdW5kcyBhdCBhbGw/XG5cblx0XHRpZiAoc3ViamVjdFN0YXJ0ID49IGNvbnN0cmFpbnRTdGFydCkge1xuXHRcdFx0c2VnU3RhcnQgPSBzdWJqZWN0U3RhcnQuY2xvbmUoKTtcblx0XHRcdGlzU3RhcnQgPSB0cnVlO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHNlZ1N0YXJ0ID0gY29uc3RyYWludFN0YXJ0LmNsb25lKCk7XG5cdFx0XHRpc1N0YXJ0ID0gIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChzdWJqZWN0RW5kIDw9IGNvbnN0cmFpbnRFbmQpIHtcblx0XHRcdHNlZ0VuZCA9IHN1YmplY3RFbmQuY2xvbmUoKTtcblx0XHRcdGlzRW5kID0gdHJ1ZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzZWdFbmQgPSBjb25zdHJhaW50RW5kLmNsb25lKCk7XG5cdFx0XHRpc0VuZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRzdGFydDogc2VnU3RhcnQsXG5cdFx0XHRlbmQ6IHNlZ0VuZCxcblx0XHRcdGlzU3RhcnQ6IGlzU3RhcnQsXG5cdFx0XHRpc0VuZDogaXNFbmRcblx0XHR9O1xuXHR9XG59XG5cblxuLyogRGF0ZSBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5GQy5jb21wdXRlR3JlYXRlc3RVbml0ID0gY29tcHV0ZUdyZWF0ZXN0VW5pdDtcbkZDLmRpdmlkZVJhbmdlQnlEdXJhdGlvbiA9IGRpdmlkZVJhbmdlQnlEdXJhdGlvbjtcbkZDLmRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbiA9IGRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbjtcbkZDLm11bHRpcGx5RHVyYXRpb24gPSBtdWx0aXBseUR1cmF0aW9uO1xuRkMuZHVyYXRpb25IYXNUaW1lID0gZHVyYXRpb25IYXNUaW1lO1xuXG52YXIgZGF5SURzID0gWyAnc3VuJywgJ21vbicsICd0dWUnLCAnd2VkJywgJ3RodScsICdmcmknLCAnc2F0JyBdO1xudmFyIHVuaXRzRGVzYyA9IFsgJ3llYXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJyBdOyAvLyBkZXNjZW5kaW5nXG5cblxuLy8gRGlmZnMgdGhlIHR3byBtb21lbnRzIGludG8gYSBEdXJhdGlvbiB3aGVyZSBmdWxsLWRheXMgYXJlIHJlY29yZGVkIGZpcnN0LCB0aGVuIHRoZSByZW1haW5pbmcgdGltZS5cbi8vIE1vbWVudHMgd2lsbCBoYXZlIHRoZWlyIHRpbWV6b25lcyBub3JtYWxpemVkLlxuZnVuY3Rpb24gZGlmZkRheVRpbWUoYSwgYikge1xuXHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKHtcblx0XHRkYXlzOiBhLmNsb25lKCkuc3RyaXBUaW1lKCkuZGlmZihiLmNsb25lKCkuc3RyaXBUaW1lKCksICdkYXlzJyksXG5cdFx0bXM6IGEudGltZSgpIC0gYi50aW1lKCkgLy8gdGltZS1vZi1kYXkgZnJvbSBkYXkgc3RhcnQuIGRpc3JlZ2FyZHMgdGltZXpvbmVcblx0fSk7XG59XG5cblxuLy8gRGlmZnMgdGhlIHR3byBtb21lbnRzIHZpYSB0aGVpciBzdGFydC1vZi1kYXkgKHJlZ2FyZGxlc3Mgb2YgdGltZXpvbmUpLiBQcm9kdWNlcyB3aG9sZS1kYXkgZHVyYXRpb25zLlxuZnVuY3Rpb24gZGlmZkRheShhLCBiKSB7XG5cdHJldHVybiBtb21lbnQuZHVyYXRpb24oe1xuXHRcdGRheXM6IGEuY2xvbmUoKS5zdHJpcFRpbWUoKS5kaWZmKGIuY2xvbmUoKS5zdHJpcFRpbWUoKSwgJ2RheXMnKVxuXHR9KTtcbn1cblxuXG4vLyBEaWZmcyB0d28gbW9tZW50cywgcHJvZHVjaW5nIGEgZHVyYXRpb24sIG1hZGUgb2YgYSB3aG9sZS11bml0LWluY3JlbWVudCBvZiB0aGUgZ2l2ZW4gdW5pdC4gVXNlcyByb3VuZGluZy5cbmZ1bmN0aW9uIGRpZmZCeVVuaXQoYSwgYiwgdW5pdCkge1xuXHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKFxuXHRcdE1hdGgucm91bmQoYS5kaWZmKGIsIHVuaXQsIHRydWUpKSwgLy8gcmV0dXJuRmxvYXQ9dHJ1ZVxuXHRcdHVuaXRcblx0KTtcbn1cblxuXG4vLyBDb21wdXRlcyB0aGUgdW5pdCBuYW1lIG9mIHRoZSBsYXJnZXN0IHdob2xlLXVuaXQgcGVyaW9kIG9mIHRpbWUuXG4vLyBGb3IgZXhhbXBsZSwgNDggaG91cnMgd2lsbCBiZSBcImRheXNcIiB3aGVyZWFzIDQ5IGhvdXJzIHdpbGwgYmUgXCJob3Vyc1wiLlxuLy8gQWNjZXB0cyBzdGFydC9lbmQsIGEgcmFuZ2Ugb2JqZWN0LCBvciBhbiBvcmlnaW5hbCBkdXJhdGlvbiBvYmplY3QuXG5mdW5jdGlvbiBjb21wdXRlR3JlYXRlc3RVbml0KHN0YXJ0LCBlbmQpIHtcblx0dmFyIGksIHVuaXQ7XG5cdHZhciB2YWw7XG5cblx0Zm9yIChpID0gMDsgaSA8IHVuaXRzRGVzYy5sZW5ndGg7IGkrKykge1xuXHRcdHVuaXQgPSB1bml0c0Rlc2NbaV07XG5cdFx0dmFsID0gY29tcHV0ZVJhbmdlQXModW5pdCwgc3RhcnQsIGVuZCk7XG5cblx0XHRpZiAodmFsID49IDEgJiYgaXNJbnQodmFsKSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHVuaXQ7IC8vIHdpbGwgYmUgXCJtaWxsaXNlY29uZHNcIiBpZiBub3RoaW5nIGVsc2UgbWF0Y2hlc1xufVxuXG5cbi8vIGxpa2UgY29tcHV0ZUdyZWF0ZXN0VW5pdCwgYnV0IGhhcyBzcGVjaWFsIGFiaWxpdGllcyB0byBpbnRlcnByZXQgdGhlIHNvdXJjZSBpbnB1dCBmb3IgY2x1ZXNcbmZ1bmN0aW9uIGNvbXB1dGVEdXJhdGlvbkdyZWF0ZXN0VW5pdChkdXJhdGlvbiwgZHVyYXRpb25JbnB1dCkge1xuXHR2YXIgdW5pdCA9IGNvbXB1dGVHcmVhdGVzdFVuaXQoZHVyYXRpb24pO1xuXG5cdC8vIHByZXZlbnQgZGF5czo3IGZyb20gYmVpbmcgaW50ZXJwcmV0ZWQgYXMgYSB3ZWVrXG5cdGlmICh1bml0ID09PSAnd2VlaycgJiYgdHlwZW9mIGR1cmF0aW9uSW5wdXQgPT09ICdvYmplY3QnICYmIGR1cmF0aW9uSW5wdXQuZGF5cykge1xuXHRcdHVuaXQgPSAnZGF5Jztcblx0fVxuXG5cdHJldHVybiB1bml0O1xufVxuXG5cbi8vIENvbXB1dGVzIHRoZSBudW1iZXIgb2YgdW5pdHMgKGxpa2UgXCJob3Vyc1wiKSBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXG4vLyBSYW5nZSBjYW4gYmUgYSB7c3RhcnQsZW5kfSBvYmplY3QsIHNlcGFyYXRlIHN0YXJ0L2VuZCBhcmdzLCBvciBhIER1cmF0aW9uLlxuLy8gUmVzdWx0cyBhcmUgYmFzZWQgb24gTW9tZW50J3MgLmFzKCkgYW5kIC5kaWZmKCkgbWV0aG9kcywgc28gcmVzdWx0cyBjYW4gZGVwZW5kIG9uIGludGVybmFsIGhhbmRsaW5nXG4vLyBvZiBtb250aC1kaWZmaW5nIGxvZ2ljICh3aGljaCB0ZW5kcyB0byB2YXJ5IGZyb20gdmVyc2lvbiB0byB2ZXJzaW9uKS5cbmZ1bmN0aW9uIGNvbXB1dGVSYW5nZUFzKHVuaXQsIHN0YXJ0LCBlbmQpIHtcblxuXHRpZiAoZW5kICE9IG51bGwpIHsgLy8gZ2l2ZW4gc3RhcnQsIGVuZFxuXHRcdHJldHVybiBlbmQuZGlmZihzdGFydCwgdW5pdCwgdHJ1ZSk7XG5cdH1cblx0ZWxzZSBpZiAobW9tZW50LmlzRHVyYXRpb24oc3RhcnQpKSB7IC8vIGdpdmVuIGR1cmF0aW9uXG5cdFx0cmV0dXJuIHN0YXJ0LmFzKHVuaXQpO1xuXHR9XG5cdGVsc2UgeyAvLyBnaXZlbiB7IHN0YXJ0LCBlbmQgfSByYW5nZSBvYmplY3Rcblx0XHRyZXR1cm4gc3RhcnQuZW5kLmRpZmYoc3RhcnQuc3RhcnQsIHVuaXQsIHRydWUpO1xuXHR9XG59XG5cblxuLy8gSW50ZWxsaWdlbnRseSBkaXZpZGVzIGEgcmFuZ2UgKHNwZWNpZmllZCBieSBhIHN0YXJ0L2VuZCBwYXJhbXMpIGJ5IGEgZHVyYXRpb25cbmZ1bmN0aW9uIGRpdmlkZVJhbmdlQnlEdXJhdGlvbihzdGFydCwgZW5kLCBkdXIpIHtcblx0dmFyIG1vbnRocztcblxuXHRpZiAoZHVyYXRpb25IYXNUaW1lKGR1cikpIHtcblx0XHRyZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cjtcblx0fVxuXHRtb250aHMgPSBkdXIuYXNNb250aHMoKTtcblx0aWYgKE1hdGguYWJzKG1vbnRocykgPj0gMSAmJiBpc0ludChtb250aHMpKSB7XG5cdFx0cmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCAnbW9udGhzJywgdHJ1ZSkgLyBtb250aHM7XG5cdH1cblx0cmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCAnZGF5cycsIHRydWUpIC8gZHVyLmFzRGF5cygpO1xufVxuXG5cbi8vIEludGVsbGlnZW50bHkgZGl2aWRlcyBvbmUgZHVyYXRpb24gYnkgYW5vdGhlclxuZnVuY3Rpb24gZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uKGR1cjEsIGR1cjIpIHtcblx0dmFyIG1vbnRoczEsIG1vbnRoczI7XG5cblx0aWYgKGR1cmF0aW9uSGFzVGltZShkdXIxKSB8fCBkdXJhdGlvbkhhc1RpbWUoZHVyMikpIHtcblx0XHRyZXR1cm4gZHVyMSAvIGR1cjI7XG5cdH1cblx0bW9udGhzMSA9IGR1cjEuYXNNb250aHMoKTtcblx0bW9udGhzMiA9IGR1cjIuYXNNb250aHMoKTtcblx0aWYgKFxuXHRcdE1hdGguYWJzKG1vbnRoczEpID49IDEgJiYgaXNJbnQobW9udGhzMSkgJiZcblx0XHRNYXRoLmFicyhtb250aHMyKSA+PSAxICYmIGlzSW50KG1vbnRoczIpXG5cdCkge1xuXHRcdHJldHVybiBtb250aHMxIC8gbW9udGhzMjtcblx0fVxuXHRyZXR1cm4gZHVyMS5hc0RheXMoKSAvIGR1cjIuYXNEYXlzKCk7XG59XG5cblxuLy8gSW50ZWxsaWdlbnRseSBtdWx0aXBsaWVzIGEgZHVyYXRpb24gYnkgYSBudW1iZXJcbmZ1bmN0aW9uIG11bHRpcGx5RHVyYXRpb24oZHVyLCBuKSB7XG5cdHZhciBtb250aHM7XG5cblx0aWYgKGR1cmF0aW9uSGFzVGltZShkdXIpKSB7XG5cdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbihkdXIgKiBuKTtcblx0fVxuXHRtb250aHMgPSBkdXIuYXNNb250aHMoKTtcblx0aWYgKE1hdGguYWJzKG1vbnRocykgPj0gMSAmJiBpc0ludChtb250aHMpKSB7XG5cdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbih7IG1vbnRoczogbW9udGhzICogbiB9KTtcblx0fVxuXHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKHsgZGF5czogZHVyLmFzRGF5cygpICogbiB9KTtcbn1cblxuXG5mdW5jdGlvbiBjbG9uZVJhbmdlKHJhbmdlKSB7XG5cdHJldHVybiB7XG5cdFx0c3RhcnQ6IHJhbmdlLnN0YXJ0LmNsb25lKCksXG5cdFx0ZW5kOiByYW5nZS5lbmQuY2xvbmUoKVxuXHR9O1xufVxuXG5cbi8vIFRyaW1zIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBpbm5lciByYW5nZSB0byBiZSBjb21wbGV0ZWx5IHdpdGhpbiBvdXRlclJhbmdlLlxuLy8gUmV0dXJucyBhIG5ldyByYW5nZSBvYmplY3QuXG5mdW5jdGlvbiBjb25zdHJhaW5SYW5nZShpbm5lclJhbmdlLCBvdXRlclJhbmdlKSB7XG5cdGlubmVyUmFuZ2UgPSBjbG9uZVJhbmdlKGlubmVyUmFuZ2UpO1xuXG5cdGlmIChvdXRlclJhbmdlLnN0YXJ0KSB7XG5cdFx0Ly8gbmVlZHMgdG8gYmUgaW5jbHVzaXZlbHkgYmVmb3JlIG91dGVyUmFuZ2UncyBlbmRcblx0XHRpbm5lclJhbmdlLnN0YXJ0ID0gY29uc3RyYWluRGF0ZShpbm5lclJhbmdlLnN0YXJ0LCBvdXRlclJhbmdlKTtcblx0fVxuXG5cdGlmIChvdXRlclJhbmdlLmVuZCkge1xuXHRcdGlubmVyUmFuZ2UuZW5kID0gbWluTW9tZW50KGlubmVyUmFuZ2UuZW5kLCBvdXRlclJhbmdlLmVuZCk7XG5cdH1cblxuXHRyZXR1cm4gaW5uZXJSYW5nZTtcbn1cblxuXG4vLyBJZiB0aGUgZ2l2ZW4gZGF0ZSBpcyBub3Qgd2l0aGluIHRoZSBnaXZlbiByYW5nZSwgbW92ZSBpdCBpbnNpZGUuXG4vLyAoSWYgaXQncyBwYXN0IHRoZSBlbmQsIG1ha2UgaXQgb25lIG1pbGxpc2Vjb25kIGJlZm9yZSB0aGUgZW5kKS5cbi8vIEFsd2F5cyByZXR1cm5zIGEgbmV3IG1vbWVudC5cbmZ1bmN0aW9uIGNvbnN0cmFpbkRhdGUoZGF0ZSwgcmFuZ2UpIHtcblx0ZGF0ZSA9IGRhdGUuY2xvbmUoKTtcblxuXHRpZiAocmFuZ2Uuc3RhcnQpIHtcblx0XHRkYXRlID0gbWF4TW9tZW50KGRhdGUsIHJhbmdlLnN0YXJ0KTtcblx0fVxuXG5cdGlmIChyYW5nZS5lbmQgJiYgZGF0ZSA+PSByYW5nZS5lbmQpIHtcblx0XHRkYXRlID0gcmFuZ2UuZW5kLmNsb25lKCkuc3VidHJhY3QoMSk7XG5cdH1cblxuXHRyZXR1cm4gZGF0ZTtcbn1cblxuXG5mdW5jdGlvbiBpc0RhdGVXaXRoaW5SYW5nZShkYXRlLCByYW5nZSkge1xuXHRyZXR1cm4gKCFyYW5nZS5zdGFydCB8fCBkYXRlID49IHJhbmdlLnN0YXJ0KSAmJlxuXHRcdCghcmFuZ2UuZW5kIHx8IGRhdGUgPCByYW5nZS5lbmQpO1xufVxuXG5cbi8vIFRPRE86IGRlYWwgd2l0aCByZXBlYXQgY29kZSBpbiBpbnRlcnNlY3RSYW5nZXNcbi8vIGNvbnN0cmFpbnRSYW5nZSBjYW4gaGF2ZSB1bnNwZWNpZmllZCBzdGFydC9lbmQsIGFuIG9wZW4tZW5kZWQgcmFuZ2UuXG5mdW5jdGlvbiBkb1Jhbmdlc0ludGVyc2VjdChzdWJqZWN0UmFuZ2UsIGNvbnN0cmFpbnRSYW5nZSkge1xuXHRyZXR1cm4gKCFjb25zdHJhaW50UmFuZ2Uuc3RhcnQgfHwgc3ViamVjdFJhbmdlLmVuZCA+PSBjb25zdHJhaW50UmFuZ2Uuc3RhcnQpICYmXG5cdFx0KCFjb25zdHJhaW50UmFuZ2UuZW5kIHx8IHN1YmplY3RSYW5nZS5zdGFydCA8IGNvbnN0cmFpbnRSYW5nZS5lbmQpO1xufVxuXG5cbmZ1bmN0aW9uIGlzUmFuZ2VXaXRoaW5SYW5nZShpbm5lclJhbmdlLCBvdXRlclJhbmdlKSB7XG5cdHJldHVybiAoIW91dGVyUmFuZ2Uuc3RhcnQgfHwgaW5uZXJSYW5nZS5zdGFydCA+PSBvdXRlclJhbmdlLnN0YXJ0KSAmJlxuXHRcdCghb3V0ZXJSYW5nZS5lbmQgfHwgaW5uZXJSYW5nZS5lbmQgPD0gb3V0ZXJSYW5nZS5lbmQpO1xufVxuXG5cbmZ1bmN0aW9uIGlzUmFuZ2VzRXF1YWwocmFuZ2UwLCByYW5nZTEpIHtcblx0cmV0dXJuICgocmFuZ2UwLnN0YXJ0ICYmIHJhbmdlMS5zdGFydCAmJiByYW5nZTAuc3RhcnQuaXNTYW1lKHJhbmdlMS5zdGFydCkpIHx8ICghcmFuZ2UwLnN0YXJ0ICYmICFyYW5nZTEuc3RhcnQpKSAmJlxuXHRcdCgocmFuZ2UwLmVuZCAmJiByYW5nZTEuZW5kICYmIHJhbmdlMC5lbmQuaXNTYW1lKHJhbmdlMS5lbmQpKSB8fCAoIXJhbmdlMC5lbmQgJiYgIXJhbmdlMS5lbmQpKTtcbn1cblxuXG4vLyBSZXR1cm5zIHRoZSBtb21lbnQgdGhhdCdzIGVhcmxpZXIgaW4gdGltZS4gQWx3YXlzIGEgY29weS5cbmZ1bmN0aW9uIG1pbk1vbWVudChtb20xLCBtb20yKSB7XG5cdHJldHVybiAobW9tMS5pc0JlZm9yZShtb20yKSA/IG1vbTEgOiBtb20yKS5jbG9uZSgpO1xufVxuXG5cbi8vIFJldHVybnMgdGhlIG1vbWVudCB0aGF0J3MgbGF0ZXIgaW4gdGltZS4gQWx3YXlzIGEgY29weS5cbmZ1bmN0aW9uIG1heE1vbWVudChtb20xLCBtb20yKSB7XG5cdHJldHVybiAobW9tMS5pc0FmdGVyKG1vbTIpID8gbW9tMSA6IG1vbTIpLmNsb25lKCk7XG59XG5cblxuLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciB0aGUgZ2l2ZW4gZHVyYXRpb24gaGFzIGFueSB0aW1lIHBhcnRzIChob3Vycy9taW51dGVzL3NlY29uZHMvbXMpXG5mdW5jdGlvbiBkdXJhdGlvbkhhc1RpbWUoZHVyKSB7XG5cdHJldHVybiBCb29sZWFuKGR1ci5ob3VycygpIHx8IGR1ci5taW51dGVzKCkgfHwgZHVyLnNlY29uZHMoKSB8fCBkdXIubWlsbGlzZWNvbmRzKCkpO1xufVxuXG5cbmZ1bmN0aW9uIGlzTmF0aXZlRGF0ZShpbnB1dCkge1xuXHRyZXR1cm4gIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJyB8fCBpbnB1dCBpbnN0YW5jZW9mIERhdGU7XG59XG5cblxuLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciB0aGUgZ2l2ZW4gaW5wdXQgaXMgYSB0aW1lIHN0cmluZywgbGlrZSBcIjA2OjQwOjAwXCIgb3IgXCIwNjowMFwiXG5mdW5jdGlvbiBpc1RpbWVTdHJpbmcoc3RyKSB7XG5cdHJldHVybiAvXlxcZCtcXDpcXGQrKD86XFw6XFxkK1xcLj8oPzpcXGR7M30pPyk/JC8udGVzdChzdHIpO1xufVxuXG5cbi8qIExvZ2dpbmcgYW5kIERlYnVnXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuRkMubG9nID0gZnVuY3Rpb24oKSB7XG5cdHZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XG5cblx0aWYgKGNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcblx0XHRyZXR1cm4gY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcblx0fVxufTtcblxuRkMud2FybiA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xuXG5cdGlmIChjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuXHRcdHJldHVybiBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcblx0fVxuXHRlbHNlIHtcblx0XHRyZXR1cm4gRkMubG9nLmFwcGx5KEZDLCBhcmd1bWVudHMpO1xuXHR9XG59O1xuXG5cbi8qIEdlbmVyYWwgVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxudmFyIGhhc093blByb3BNZXRob2QgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXG4vLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdC5cbi8vIFRoZSBzZWNvbmQgYXJndW1lbnQgYWxsb3dzIGZvciBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB3aG8ncyBvYmplY3QgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHRvZ2V0aGVyLlxuZnVuY3Rpb24gbWVyZ2VQcm9wcyhwcm9wT2JqcywgY29tcGxleFByb3BzKSB7XG5cdHZhciBkZXN0ID0ge307XG5cdHZhciBpLCBuYW1lO1xuXHR2YXIgY29tcGxleE9ianM7XG5cdHZhciBqLCB2YWw7XG5cdHZhciBwcm9wcztcblxuXHRpZiAoY29tcGxleFByb3BzKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGNvbXBsZXhQcm9wcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0bmFtZSA9IGNvbXBsZXhQcm9wc1tpXTtcblx0XHRcdGNvbXBsZXhPYmpzID0gW107XG5cblx0XHRcdC8vIGNvbGxlY3QgdGhlIHRyYWlsaW5nIG9iamVjdCB2YWx1ZXMsIHN0b3BwaW5nIHdoZW4gYSBub24tb2JqZWN0IGlzIGRpc2NvdmVyZWRcblx0XHRcdGZvciAoaiA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdHZhbCA9IHByb3BPYmpzW2pdW25hbWVdO1xuXG5cdFx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdGNvbXBsZXhPYmpzLnVuc2hpZnQodmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGRlc3RbbmFtZV0gPSB2YWw7IC8vIGlmIHRoZXJlIHdlcmUgbm8gb2JqZWN0cywgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiB0aGUgdHJhaWxpbmcgdmFsdWVzIHdlcmUgb2JqZWN0cywgdXNlIHRoZSBtZXJnZWQgdmFsdWVcblx0XHRcdGlmIChjb21wbGV4T2Jqcy5sZW5ndGgpIHtcblx0XHRcdFx0ZGVzdFtuYW1lXSA9IG1lcmdlUHJvcHMoY29tcGxleE9ianMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIGNvcHkgdmFsdWVzIGludG8gdGhlIGRlc3RpbmF0aW9uLCBnb2luZyBmcm9tIGxhc3QgdG8gZmlyc3Rcblx0Zm9yIChpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRwcm9wcyA9IHByb3BPYmpzW2ldO1xuXG5cdFx0Zm9yIChuYW1lIGluIHByb3BzKSB7XG5cdFx0XHRpZiAoIShuYW1lIGluIGRlc3QpKSB7IC8vIGlmIGFscmVhZHkgYXNzaWduZWQgYnkgcHJldmlvdXMgcHJvcHMgb3IgY29tcGxleCBwcm9wcywgZG9uJ3QgcmVhc3NpZ25cblx0XHRcdFx0ZGVzdFtuYW1lXSA9IHByb3BzW25hbWVdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkZXN0O1xufVxuXG5cbi8vIENyZWF0ZSBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIGdpdmVuIHByb3RvdHlwZS4gSnVzdCBsaWtlIE9iamVjdC5jcmVhdGVcbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdChwcm90bykge1xuXHR2YXIgZiA9IGZ1bmN0aW9uKCkge307XG5cdGYucHJvdG90eXBlID0gcHJvdG87XG5cdHJldHVybiBuZXcgZigpO1xufVxuRkMuY3JlYXRlT2JqZWN0ID0gY3JlYXRlT2JqZWN0O1xuXG5cbmZ1bmN0aW9uIGNvcHlPd25Qcm9wcyhzcmMsIGRlc3QpIHtcblx0Zm9yICh2YXIgbmFtZSBpbiBzcmMpIHtcblx0XHRpZiAoaGFzT3duUHJvcChzcmMsIG5hbWUpKSB7XG5cdFx0XHRkZXN0W25hbWVdID0gc3JjW25hbWVdO1xuXHRcdH1cblx0fVxufVxuXG5cbmZ1bmN0aW9uIGhhc093blByb3Aob2JqLCBuYW1lKSB7XG5cdHJldHVybiBoYXNPd25Qcm9wTWV0aG9kLmNhbGwob2JqLCBuYW1lKTtcbn1cblxuXG4vLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYSBub24tb2JqZWN0IG5vbi1mdW5jdGlvbiB2YWx1ZT9cbmZ1bmN0aW9uIGlzQXRvbWljKHZhbCkge1xuXHRyZXR1cm4gL3VuZGVmaW5lZHxudWxsfGJvb2xlYW58bnVtYmVyfHN0cmluZy8udGVzdCgkLnR5cGUodmFsKSk7XG59XG5cblxuZnVuY3Rpb24gYXBwbHlBbGwoZnVuY3Rpb25zLCB0aGlzT2JqLCBhcmdzKSB7XG5cdGlmICgkLmlzRnVuY3Rpb24oZnVuY3Rpb25zKSkge1xuXHRcdGZ1bmN0aW9ucyA9IFsgZnVuY3Rpb25zIF07XG5cdH1cblx0aWYgKGZ1bmN0aW9ucykge1xuXHRcdHZhciBpO1xuXHRcdHZhciByZXQ7XG5cdFx0Zm9yIChpPTA7IGk8ZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRyZXQgPSBmdW5jdGlvbnNbaV0uYXBwbHkodGhpc09iaiwgYXJncykgfHwgcmV0O1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9XG59XG5cblxuZnVuY3Rpb24gZmlyc3REZWZpbmVkKCkge1xuXHRmb3IgKHZhciBpPTA7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKGFyZ3VtZW50c1tpXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzW2ldO1xuXHRcdH1cblx0fVxufVxuXG5cbmZ1bmN0aW9uIGh0bWxFc2NhcGUocykge1xuXHRyZXR1cm4gKHMgKyAnJykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuXHRcdC5yZXBsYWNlKC88L2csICcmbHQ7Jylcblx0XHQucmVwbGFjZSgvPi9nLCAnJmd0OycpXG5cdFx0LnJlcGxhY2UoLycvZywgJyYjMDM5OycpXG5cdFx0LnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuXHRcdC5yZXBsYWNlKC9cXG4vZywgJzxiciAvPicpO1xufVxuXG5cbmZ1bmN0aW9uIHN0cmlwSHRtbEVudGl0aWVzKHRleHQpIHtcblx0cmV0dXJuIHRleHQucmVwbGFjZSgvJi4qPzsvZywgJycpO1xufVxuXG5cbi8vIEdpdmVuIGEgaGFzaCBvZiBDU1MgcHJvcGVydGllcywgcmV0dXJucyBhIHN0cmluZyBvZiBDU1MuXG4vLyBVc2VzIHByb3BlcnR5IG5hbWVzIGFzLWlzIChubyBjYW1lbC1jYXNlIGNvbnZlcnNpb24pLiBXaWxsIG5vdCBtYWtlIHN0YXRlbWVudHMgZm9yIG51bGwvdW5kZWZpbmVkIHZhbHVlcy5cbmZ1bmN0aW9uIGNzc1RvU3RyKGNzc1Byb3BzKSB7XG5cdHZhciBzdGF0ZW1lbnRzID0gW107XG5cblx0JC5lYWNoKGNzc1Byb3BzLCBmdW5jdGlvbihuYW1lLCB2YWwpIHtcblx0XHRpZiAodmFsICE9IG51bGwpIHtcblx0XHRcdHN0YXRlbWVudHMucHVzaChuYW1lICsgJzonICsgdmFsKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBzdGF0ZW1lbnRzLmpvaW4oJzsnKTtcbn1cblxuXG4vLyBHaXZlbiBhbiBvYmplY3QgaGFzaCBvZiBIVE1MIGF0dHJpYnV0ZSBuYW1lcyB0byB2YWx1ZXMsXG4vLyBnZW5lcmF0ZXMgYSBzdHJpbmcgdGhhdCBjYW4gYmUgaW5qZWN0ZWQgYmV0d2VlbiA8ID4gaW4gSFRNTFxuZnVuY3Rpb24gYXR0cnNUb1N0cihhdHRycykge1xuXHR2YXIgcGFydHMgPSBbXTtcblxuXHQkLmVhY2goYXR0cnMsIGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuXHRcdGlmICh2YWwgIT0gbnVsbCkge1xuXHRcdFx0cGFydHMucHVzaChuYW1lICsgJz1cIicgKyBodG1sRXNjYXBlKHZhbCkgKyAnXCInKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBwYXJ0cy5qb2luKCcgJyk7XG59XG5cblxuZnVuY3Rpb24gY2FwaXRhbGlzZUZpcnN0TGV0dGVyKHN0cikge1xuXHRyZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuXG5cbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHsgLy8gZm9yIC5zb3J0KClcblx0cmV0dXJuIGEgLSBiO1xufVxuXG5cbmZ1bmN0aW9uIGlzSW50KG4pIHtcblx0cmV0dXJuIG4gJSAxID09PSAwO1xufVxuXG5cbi8vIFJldHVybnMgYSBtZXRob2QgYm91bmQgdG8gdGhlIGdpdmVuIG9iamVjdCBjb250ZXh0LlxuLy8gSnVzdCBsaWtlIG9uZSBvZiB0aGUgalF1ZXJ5LnByb3h5IHNpZ25hdHVyZXMsIGJ1dCB3aXRob3V0IHRoZSB1bmRlc2lyZWQgYmVoYXZpb3Igb2YgdHJlYXRpbmcgdGhlIHNhbWUgbWV0aG9kIHdpdGhcbi8vIGRpZmZlcmVudCBjb250ZXh0cyBhcyBpZGVudGljYWwgd2hlbiBiaW5kaW5nL3VuYmluZGluZyBldmVudHMuXG5mdW5jdGlvbiBwcm94eShvYmosIG1ldGhvZE5hbWUpIHtcblx0dmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG5cdH07XG59XG5cblxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4vLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL2Jsb2IvMS42LjAvdW5kZXJzY29yZS5qcyNMNzE0XG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcblx0dmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG5cdHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXN0ID0gK25ldyBEYXRlKCkgLSB0aW1lc3RhbXA7XG5cdFx0aWYgKGxhc3QgPCB3YWl0KSB7XG5cdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRpbWVvdXQgPSBudWxsO1xuXHRcdFx0aWYgKCFpbW1lZGlhdGUpIHtcblx0XHRcdFx0cmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcblx0XHRcdFx0Y29udGV4dCA9IGFyZ3MgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0Y29udGV4dCA9IHRoaXM7XG5cdFx0YXJncyA9IGFyZ3VtZW50cztcblx0XHR0aW1lc3RhbXAgPSArbmV3IERhdGUoKTtcblx0XHR2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcblx0XHRpZiAoIXRpbWVvdXQpIHtcblx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcblx0XHR9XG5cdFx0aWYgKGNhbGxOb3cpIHtcblx0XHRcdHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG5cdFx0XHRjb250ZXh0ID0gYXJncyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG59XG5cbjs7XG5cbi8qXG5HRU5FUkFMIE5PVEUgb24gbW9tZW50cyB0aHJvdWdob3V0IHRoZSAqZW50aXJlIHJlc3QqIG9mIHRoZSBjb2RlYmFzZTpcbkFsbCBtb21lbnRzIGFyZSBhc3N1bWVkIHRvIGJlIGFtYmlndW91c2x5LXpvbmVkIHVubGVzcyBvdGhlcndpc2Ugbm90ZWQsXG53aXRoIHRoZSBOT1RBQkxFIEVYQ0VPUFRJT04gb2Ygc3RhcnQvZW5kIGRhdGVzIHRoYXQgbGl2ZSBvbiAqRXZlbnQgT2JqZWN0cyouXG5BbWJpZ3VvdXNseS1USU1FRCBtb21lbnRzIGFyZSBhc3N1bWVkIHRvIGJlIGFtYmlndW91c2x5LXpvbmVkIGJ5IG5hdHVyZS5cbiovXG5cbnZhciBhbWJpZ0RhdGVPZk1vbnRoUmVnZXggPSAvXlxccypcXGR7NH0tXFxkXFxkJC87XG52YXIgYW1iaWdUaW1lT3Jab25lUmVnZXggPVxuXHQvXlxccypcXGR7NH0tKD86KFxcZFxcZC1cXGRcXGQpfChXXFxkXFxkJCl8KFdcXGRcXGQtXFxkKXwoXFxkXFxkXFxkKSkoKFR8ICkoXFxkXFxkKDpcXGRcXGQoOlxcZFxcZChcXC5cXGQrKT8pPyk/KT8pPyQvO1xudmFyIG5ld01vbWVudFByb3RvID0gbW9tZW50LmZuOyAvLyB3aGVyZSB3ZSB3aWxsIGF0dGFjaCBvdXIgbmV3IG1ldGhvZHNcbnZhciBvbGRNb21lbnRQcm90byA9ICQuZXh0ZW5kKHt9LCBuZXdNb21lbnRQcm90byk7IC8vIGNvcHkgb2Ygb3JpZ2luYWwgbW9tZW50IG1ldGhvZHNcblxuLy8gdGVsbCBtb21lbnRqcyB0byB0cmFuc2ZlciB0aGVzZSBwcm9wZXJ0aWVzIHVwb24gY2xvbmVcbnZhciBtb21lbnRQcm9wZXJ0aWVzID0gbW9tZW50Lm1vbWVudFByb3BlcnRpZXM7XG5tb21lbnRQcm9wZXJ0aWVzLnB1c2goJ19mdWxsQ2FsZW5kYXInKTtcbm1vbWVudFByb3BlcnRpZXMucHVzaCgnX2FtYmlnVGltZScpO1xubW9tZW50UHJvcGVydGllcy5wdXNoKCdfYW1iaWdab25lJyk7XG5cblxuLy8gQ3JlYXRpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQ3JlYXRlcyBhIG5ldyBtb21lbnQsIHNpbWlsYXIgdG8gdGhlIHZhbmlsbGEgbW9tZW50KC4uLikgY29uc3RydWN0b3IsIGJ1dCB3aXRoXG4vLyBleHRyYSBmZWF0dXJlcyAoYW1iaWd1b3VzIHRpbWUsIGVuaGFuY2VkIGZvcm1hdHRpbmcpLiBXaGVuIGdpdmVuIGFuIGV4aXN0aW5nIG1vbWVudCxcbi8vIGl0IHdpbGwgZnVuY3Rpb24gYXMgYSBjbG9uZSAoYW5kIHJldGFpbiB0aGUgem9uZSBvZiB0aGUgbW9tZW50KS4gQW55dGhpbmcgZWxzZSB3aWxsXG4vLyByZXN1bHQgaW4gYSBtb21lbnQgaW4gdGhlIGxvY2FsIHpvbmUuXG5GQy5tb21lbnQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIG1ha2VNb21lbnQoYXJndW1lbnRzKTtcbn07XG5cbi8vIFNhbWVzIGFzIEZDLm1vbWVudCwgYnV0IGZvcmNlcyB0aGUgcmVzdWx0aW5nIG1vbWVudCB0byBiZSBpbiB0aGUgVVRDIHRpbWV6b25lLlxuRkMubW9tZW50LnV0YyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgbW9tID0gbWFrZU1vbWVudChhcmd1bWVudHMsIHRydWUpO1xuXG5cdC8vIEZvcmNlIGl0IGludG8gVVRDIGJlY2F1c2UgbWFrZU1vbWVudCBkb2Vzbid0IGd1YXJhbnRlZSBpdFxuXHQvLyAoaWYgZ2l2ZW4gYSBwcmUtZXhpc3RpbmcgbW9tZW50IGZvciBleGFtcGxlKVxuXHRpZiAobW9tLmhhc1RpbWUoKSkgeyAvLyBkb24ndCBnaXZlIGFtYmlndW91c2x5LXRpbWVkIG1vbWVudHMgYSBVVEMgem9uZVxuXHRcdG1vbS51dGMoKTtcblx0fVxuXG5cdHJldHVybiBtb207XG59O1xuXG4vLyBTYW1lIGFzIEZDLm1vbWVudCwgYnV0IHdoZW4gZ2l2ZW4gYW4gSVNPODYwMSBzdHJpbmcsIHRoZSB0aW1lem9uZSBvZmZzZXQgaXMgcHJlc2VydmVkLlxuLy8gSVNPODYwMSBzdHJpbmdzIHdpdGggbm8gdGltZXpvbmUgb2Zmc2V0IHdpbGwgYmVjb21lIGFtYmlndW91c2x5IHpvbmVkLlxuRkMubW9tZW50LnBhcnNlWm9uZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gbWFrZU1vbWVudChhcmd1bWVudHMsIHRydWUsIHRydWUpO1xufTtcblxuLy8gQnVpbGRzIGFuIGVuaGFuY2VkIG1vbWVudCBmcm9tIGFyZ3MuIFdoZW4gZ2l2ZW4gYW4gZXhpc3RpbmcgbW9tZW50LCBpdCBjbG9uZXMuIFdoZW4gZ2l2ZW4gYVxuLy8gbmF0aXZlIERhdGUsIG9yIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cyAodGhlIGN1cnJlbnQgdGltZSksIHRoZSByZXN1bHRpbmcgbW9tZW50IHdpbGwgYmUgbG9jYWwuXG4vLyBBbnl0aGluZyBlbHNlIG5lZWRzIHRvIGJlIFwicGFyc2VkXCIgKGEgc3RyaW5nIG9yIGFuIGFycmF5KSwgYW5kIHdpbGwgYmUgYWZmZWN0ZWQgYnk6XG4vLyAgICBwYXJzZUFzVVRDIC0gaWYgdGhlcmUgaXMgbm8gem9uZSBpbmZvcm1hdGlvbiwgc2hvdWxkIHdlIHBhcnNlIHRoZSBpbnB1dCBpbiBVVEM/XG4vLyAgICBwYXJzZVpvbmUgLSBpZiB0aGVyZSBpcyB6b25lIGluZm9ybWF0aW9uLCBzaG91bGQgd2UgZm9yY2UgdGhlIHpvbmUgb2YgdGhlIG1vbWVudD9cbmZ1bmN0aW9uIG1ha2VNb21lbnQoYXJncywgcGFyc2VBc1VUQywgcGFyc2Vab25lKSB7XG5cdHZhciBpbnB1dCA9IGFyZ3NbMF07XG5cdHZhciBpc1NpbmdsZVN0cmluZyA9IGFyZ3MubGVuZ3RoID09IDEgJiYgdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJztcblx0dmFyIGlzQW1iaWdUaW1lO1xuXHR2YXIgaXNBbWJpZ1pvbmU7XG5cdHZhciBhbWJpZ01hdGNoO1xuXHR2YXIgbW9tO1xuXG5cdGlmIChtb21lbnQuaXNNb21lbnQoaW5wdXQpIHx8IGlzTmF0aXZlRGF0ZShpbnB1dCkgfHwgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuXHRcdG1vbSA9IG1vbWVudC5hcHBseShudWxsLCBhcmdzKTtcblx0fVxuXHRlbHNlIHsgLy8gXCJwYXJzaW5nXCIgaXMgcmVxdWlyZWRcblx0XHRpc0FtYmlnVGltZSA9IGZhbHNlO1xuXHRcdGlzQW1iaWdab25lID0gZmFsc2U7XG5cblx0XHRpZiAoaXNTaW5nbGVTdHJpbmcpIHtcblx0XHRcdGlmIChhbWJpZ0RhdGVPZk1vbnRoUmVnZXgudGVzdChpbnB1dCkpIHtcblx0XHRcdFx0Ly8gYWNjZXB0IHN0cmluZ3MgbGlrZSAnMjAxNC0wNScsIGJ1dCBjb252ZXJ0IHRvIHRoZSBmaXJzdCBvZiB0aGUgbW9udGhcblx0XHRcdFx0aW5wdXQgKz0gJy0wMSc7XG5cdFx0XHRcdGFyZ3MgPSBbIGlucHV0IF07IC8vIGZvciB3aGVuIHdlIHBhc3MgaXQgb24gdG8gbW9tZW50J3MgY29uc3RydWN0b3Jcblx0XHRcdFx0aXNBbWJpZ1RpbWUgPSB0cnVlO1xuXHRcdFx0XHRpc0FtYmlnWm9uZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICgoYW1iaWdNYXRjaCA9IGFtYmlnVGltZU9yWm9uZVJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuXHRcdFx0XHRpc0FtYmlnVGltZSA9ICFhbWJpZ01hdGNoWzVdOyAvLyBubyB0aW1lIHBhcnQ/XG5cdFx0XHRcdGlzQW1iaWdab25lID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoJC5pc0FycmF5KGlucHV0KSkge1xuXHRcdFx0Ly8gYXJyYXlzIGhhdmUgbm8gdGltZXpvbmUgaW5mb3JtYXRpb24sIHNvIGFzc3VtZSBhbWJpZ3VvdXMgem9uZVxuXHRcdFx0aXNBbWJpZ1pvbmUgPSB0cnVlO1xuXHRcdH1cblx0XHQvLyBvdGhlcndpc2UsIHByb2JhYmx5IGEgc3RyaW5nIHdpdGggYSBmb3JtYXRcblxuXHRcdGlmIChwYXJzZUFzVVRDIHx8IGlzQW1iaWdUaW1lKSB7XG5cdFx0XHRtb20gPSBtb21lbnQudXRjLmFwcGx5KG1vbWVudCwgYXJncyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bW9tID0gbW9tZW50LmFwcGx5KG51bGwsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGlmIChpc0FtYmlnVGltZSkge1xuXHRcdFx0bW9tLl9hbWJpZ1RpbWUgPSB0cnVlO1xuXHRcdFx0bW9tLl9hbWJpZ1pvbmUgPSB0cnVlOyAvLyBhbWJpZ3VvdXMgdGltZSBhbHdheXMgbWVhbnMgYW1iaWd1b3VzIHpvbmVcblx0XHR9XG5cdFx0ZWxzZSBpZiAocGFyc2Vab25lKSB7IC8vIGxldCdzIHJlY29yZCB0aGUgaW5wdXR0ZWQgem9uZSBzb21laG93XG5cdFx0XHRpZiAoaXNBbWJpZ1pvbmUpIHtcblx0XHRcdFx0bW9tLl9hbWJpZ1pvbmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoaXNTaW5nbGVTdHJpbmcpIHtcblx0XHRcdFx0bW9tLnV0Y09mZnNldChpbnB1dCk7IC8vIGlmIG5vdCBhIHZhbGlkIHpvbmUsIHdpbGwgYXNzaWduIFVUQ1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdG1vbS5fZnVsbENhbGVuZGFyID0gdHJ1ZTsgLy8gZmxhZyBmb3IgZXh0ZW5kZWQgZnVuY3Rpb25hbGl0eVxuXG5cdHJldHVybiBtb207XG59XG5cblxuLy8gV2VlayBOdW1iZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vLyBSZXR1cm5zIHRoZSB3ZWVrIG51bWJlciwgY29uc2lkZXJpbmcgdGhlIGxvY2FsZSdzIGN1c3RvbSB3ZWVrIG51bWJlciBjYWxjdWF0aW9uXG4vLyBgd2Vla3NgIGlzIGFuIGFsaWFzIGZvciBgd2Vla2Bcbm5ld01vbWVudFByb3RvLndlZWsgPSBuZXdNb21lbnRQcm90by53ZWVrcyA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHZhciB3ZWVrQ2FsYyA9IHRoaXMuX2xvY2FsZS5fZnVsbENhbGVuZGFyX3dlZWtDYWxjO1xuXG5cdGlmIChpbnB1dCA9PSBudWxsICYmIHR5cGVvZiB3ZWVrQ2FsYyA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBjdXN0b20gZnVuY3Rpb24gb25seSB3b3JrcyBmb3IgZ2V0dGVyXG5cdFx0cmV0dXJuIHdlZWtDYWxjKHRoaXMpO1xuXHR9XG5cdGVsc2UgaWYgKHdlZWtDYWxjID09PSAnSVNPJykge1xuXHRcdHJldHVybiBvbGRNb21lbnRQcm90by5pc29XZWVrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIElTTyBnZXR0ZXIvc2V0dGVyXG5cdH1cblxuXHRyZXR1cm4gb2xkTW9tZW50UHJvdG8ud2Vlay5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBsb2NhbCBnZXR0ZXIvc2V0dGVyXG59O1xuXG5cbi8vIFRpbWUtb2YtZGF5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEdFVFRFUlxuLy8gUmV0dXJucyBhIER1cmF0aW9uIHdpdGggdGhlIGhvdXJzL21pbnV0ZXMvc2Vjb25kcy9tcyB2YWx1ZXMgb2YgdGhlIG1vbWVudC5cbi8vIElmIHRoZSBtb21lbnQgaGFzIGFuIGFtYmlndW91cyB0aW1lLCBhIGR1cmF0aW9uIG9mIDAwOjAwIHdpbGwgYmUgcmV0dXJuZWQuXG4vL1xuLy8gU0VUVEVSXG4vLyBZb3UgY2FuIHN1cHBseSBhIER1cmF0aW9uLCBhIE1vbWVudCwgb3IgYSBEdXJhdGlvbi1saWtlIGFyZ3VtZW50LlxuLy8gV2hlbiBzZXR0aW5nIHRoZSB0aW1lLCBhbmQgdGhlIG1vbWVudCBoYXMgYW4gYW1iaWd1b3VzIHRpbWUsIGl0IHRoZW4gYmVjb21lcyB1bmFtYmlndW91cy5cbm5ld01vbWVudFByb3RvLnRpbWUgPSBmdW5jdGlvbih0aW1lKSB7XG5cblx0Ly8gRmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIG1ldGhvZCAoaWYgdGhlcmUgaXMgb25lKSBpZiB0aGlzIG1vbWVudCB3YXNuJ3QgY3JlYXRlZCB2aWEgRnVsbENhbGVuZGFyLlxuXHQvLyBgdGltZWAgaXMgYSBnZW5lcmljIGVub3VnaCBtZXRob2QgbmFtZSB3aGVyZSB0aGlzIHByZWNhdXRpb24gaXMgbmVjZXNzYXJ5IHRvIGF2b2lkIGNvbGxpc2lvbnMgdy8gb3RoZXIgcGx1Z2lucy5cblx0aWYgKCF0aGlzLl9mdWxsQ2FsZW5kYXIpIHtcblx0XHRyZXR1cm4gb2xkTW9tZW50UHJvdG8udGltZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9XG5cblx0aWYgKHRpbWUgPT0gbnVsbCkgeyAvLyBnZXR0ZXJcblx0XHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKHtcblx0XHRcdGhvdXJzOiB0aGlzLmhvdXJzKCksXG5cdFx0XHRtaW51dGVzOiB0aGlzLm1pbnV0ZXMoKSxcblx0XHRcdHNlY29uZHM6IHRoaXMuc2Vjb25kcygpLFxuXHRcdFx0bWlsbGlzZWNvbmRzOiB0aGlzLm1pbGxpc2Vjb25kcygpXG5cdFx0fSk7XG5cdH1cblx0ZWxzZSB7IC8vIHNldHRlclxuXG5cdFx0dGhpcy5fYW1iaWdUaW1lID0gZmFsc2U7IC8vIG1hcmsgdGhhdCB0aGUgbW9tZW50IG5vdyBoYXMgYSB0aW1lXG5cblx0XHRpZiAoIW1vbWVudC5pc0R1cmF0aW9uKHRpbWUpICYmICFtb21lbnQuaXNNb21lbnQodGltZSkpIHtcblx0XHRcdHRpbWUgPSBtb21lbnQuZHVyYXRpb24odGltZSk7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGRheSB2YWx1ZSBzaG91bGQgY2F1c2Ugb3ZlcmZsb3cgKHNvIDI0IGhvdXJzIGJlY29tZXMgMDA6MDA6MDAgb2YgbmV4dCBkYXkpLlxuXHRcdC8vIE9ubHkgZm9yIER1cmF0aW9uIHRpbWVzLCBub3QgTW9tZW50IHRpbWVzLlxuXHRcdHZhciBkYXlIb3VycyA9IDA7XG5cdFx0aWYgKG1vbWVudC5pc0R1cmF0aW9uKHRpbWUpKSB7XG5cdFx0XHRkYXlIb3VycyA9IE1hdGguZmxvb3IodGltZS5hc0RheXMoKSkgKiAyNDtcblx0XHR9XG5cblx0XHQvLyBXZSBuZWVkIHRvIHNldCB0aGUgaW5kaXZpZHVhbCBmaWVsZHMuXG5cdFx0Ly8gQ2FuJ3QgdXNlIHN0YXJ0T2YoJ2RheScpIHRoZW4gYWRkIGR1cmF0aW9uLiBJbiBjYXNlIG9mIERTVCBhdCBzdGFydCBvZiBkYXkuXG5cdFx0cmV0dXJuIHRoaXMuaG91cnMoZGF5SG91cnMgKyB0aW1lLmhvdXJzKCkpXG5cdFx0XHQubWludXRlcyh0aW1lLm1pbnV0ZXMoKSlcblx0XHRcdC5zZWNvbmRzKHRpbWUuc2Vjb25kcygpKVxuXHRcdFx0Lm1pbGxpc2Vjb25kcyh0aW1lLm1pbGxpc2Vjb25kcygpKTtcblx0fVxufTtcblxuLy8gQ29udmVydHMgdGhlIG1vbWVudCB0byBVVEMsIHN0cmlwcGluZyBvdXQgaXRzIHRpbWUtb2YtZGF5IGFuZCB0aW1lem9uZSBvZmZzZXQsXG4vLyBidXQgcHJlc2VydmluZyBpdHMgWU1ELiBBIG1vbWVudCB3aXRoIGEgc3RyaXBwZWQgdGltZSB3aWxsIGRpc3BsYXkgbm8gdGltZVxuLy8gbm9yIHRpbWV6b25lIG9mZnNldCB3aGVuIC5mb3JtYXQoKSBpcyBjYWxsZWQuXG5uZXdNb21lbnRQcm90by5zdHJpcFRpbWUgPSBmdW5jdGlvbigpIHtcblxuXHRpZiAoIXRoaXMuX2FtYmlnVGltZSkge1xuXG5cdFx0dGhpcy51dGModHJ1ZSk7IC8vIGtlZXBMb2NhbFRpbWU9dHJ1ZSAoZm9yIGtlZXBpbmcgKmRhdGUqIHZhbHVlKVxuXG5cdFx0Ly8gc2V0IHRpbWUgdG8gemVyb1xuXHRcdHRoaXMuc2V0KHtcblx0XHRcdGhvdXJzOiAwLFxuXHRcdFx0bWludXRlczogMCxcblx0XHRcdHNlY29uZHM6IDAsXG5cdFx0XHRtczogMFxuXHRcdH0pO1xuXG5cdFx0Ly8gTWFyayB0aGUgdGltZSBhcyBhbWJpZ3VvdXMuIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHRoZSAudXRjKCkgY2FsbCwgd2hpY2ggbWlnaHQgY2FsbCAudXRjT2Zmc2V0KCksXG5cdFx0Ly8gd2hpY2ggY2xlYXJzIGFsbCBhbWJpZyBmbGFncy5cblx0XHR0aGlzLl9hbWJpZ1RpbWUgPSB0cnVlO1xuXHRcdHRoaXMuX2FtYmlnWm9uZSA9IHRydWU7IC8vIGlmIGFtYmlndW91cyB0aW1lLCBhbHNvIGFtYmlndW91cyB0aW1lem9uZSBvZmZzZXRcblx0fVxuXG5cdHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cbi8vIFJldHVybnMgaWYgdGhlIG1vbWVudCBoYXMgYSBub24tYW1iaWd1b3VzIHRpbWUgKGJvb2xlYW4pXG5uZXdNb21lbnRQcm90by5oYXNUaW1lID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAhdGhpcy5fYW1iaWdUaW1lO1xufTtcblxuXG4vLyBUaW1lem9uZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBDb252ZXJ0cyB0aGUgbW9tZW50IHRvIFVUQywgc3RyaXBwaW5nIG91dCBpdHMgdGltZXpvbmUgb2Zmc2V0LCBidXQgcHJlc2VydmluZyBpdHNcbi8vIFlNRCBhbmQgdGltZS1vZi1kYXkuIEEgbW9tZW50IHdpdGggYSBzdHJpcHBlZCB0aW1lem9uZSBvZmZzZXQgd2lsbCBkaXNwbGF5IG5vXG4vLyB0aW1lem9uZSBvZmZzZXQgd2hlbiAuZm9ybWF0KCkgaXMgY2FsbGVkLlxubmV3TW9tZW50UHJvdG8uc3RyaXBab25lID0gZnVuY3Rpb24oKSB7XG5cdHZhciB3YXNBbWJpZ1RpbWU7XG5cblx0aWYgKCF0aGlzLl9hbWJpZ1pvbmUpIHtcblxuXHRcdHdhc0FtYmlnVGltZSA9IHRoaXMuX2FtYmlnVGltZTtcblxuXHRcdHRoaXMudXRjKHRydWUpOyAvLyBrZWVwTG9jYWxUaW1lPXRydWUgKGZvciBrZWVwaW5nIGRhdGUgYW5kIHRpbWUgdmFsdWVzKVxuXG5cdFx0Ly8gdGhlIGFib3ZlIGNhbGwgdG8gLnV0YygpLy51dGNPZmZzZXQoKSB1bmZvcnR1bmF0ZWx5IG1pZ2h0IGNsZWFyIHRoZSBhbWJpZyBmbGFncywgc28gcmVzdG9yZVxuXHRcdHRoaXMuX2FtYmlnVGltZSA9IHdhc0FtYmlnVGltZSB8fCBmYWxzZTtcblxuXHRcdC8vIE1hcmsgdGhlIHpvbmUgYXMgYW1iaWd1b3VzLiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBhZnRlciB0aGUgLnV0YygpIGNhbGwsIHdoaWNoIG1pZ2h0IGNhbGwgLnV0Y09mZnNldCgpLFxuXHRcdC8vIHdoaWNoIGNsZWFycyB0aGUgYW1iaWcgZmxhZ3MuXG5cdFx0dGhpcy5fYW1iaWdab25lID0gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cbi8vIFJldHVybnMgb2YgdGhlIG1vbWVudCBoYXMgYSBub24tYW1iaWd1b3VzIHRpbWV6b25lIG9mZnNldCAoYm9vbGVhbilcbm5ld01vbWVudFByb3RvLmhhc1pvbmUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuICF0aGlzLl9hbWJpZ1pvbmU7XG59O1xuXG5cbi8vIGltcGxpY2l0bHkgbWFya3MgYSB6b25lXG5uZXdNb21lbnRQcm90by5sb2NhbCA9IGZ1bmN0aW9uKGtlZXBMb2NhbFRpbWUpIHtcblxuXHQvLyBmb3Igd2hlbiBjb252ZXJ0aW5nIGZyb20gYW1iaWd1b3VzbHktem9uZWQgdG8gbG9jYWwsXG5cdC8vIGtlZXAgdGhlIHRpbWUgdmFsdWVzIHdoZW4gY29udmVydGluZyBmcm9tIFVUQyAtPiBsb2NhbFxuXHRvbGRNb21lbnRQcm90by5sb2NhbC5jYWxsKHRoaXMsIHRoaXMuX2FtYmlnWm9uZSB8fCBrZWVwTG9jYWxUaW1lKTtcblxuXHQvLyBlbnN1cmUgbm9uLWFtYmlndW91c1xuXHQvLyB0aGlzIHByb2JhYmx5IGFscmVhZHkgaGFwcGVuZWQgdmlhIGxvY2FsKCkgLT4gdXRjT2Zmc2V0KCksIGJ1dCBkb24ndCByZWx5IG9uIE1vbWVudCdzIGludGVybmFsc1xuXHR0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTtcblx0dGhpcy5fYW1iaWdab25lID0gZmFsc2U7XG5cblx0cmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuXG4vLyBpbXBsaWNpdGx5IG1hcmtzIGEgem9uZVxubmV3TW9tZW50UHJvdG8udXRjID0gZnVuY3Rpb24oa2VlcExvY2FsVGltZSkge1xuXG5cdG9sZE1vbWVudFByb3RvLnV0Yy5jYWxsKHRoaXMsIGtlZXBMb2NhbFRpbWUpO1xuXG5cdC8vIGVuc3VyZSBub24tYW1iaWd1b3VzXG5cdC8vIHRoaXMgcHJvYmFibHkgYWxyZWFkeSBoYXBwZW5lZCB2aWEgdXRjKCkgLT4gdXRjT2Zmc2V0KCksIGJ1dCBkb24ndCByZWx5IG9uIE1vbWVudCdzIGludGVybmFsc1xuXHR0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTtcblx0dGhpcy5fYW1iaWdab25lID0gZmFsc2U7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cbi8vIGltcGxpY2l0bHkgbWFya3MgYSB6b25lICh3aWxsIHByb2JhYmx5IGdldCBjYWxsZWQgdXBvbiAudXRjKCkgYW5kIC5sb2NhbCgpKVxubmV3TW9tZW50UHJvdG8udXRjT2Zmc2V0ID0gZnVuY3Rpb24odHpvKSB7XG5cblx0aWYgKHR6byAhPSBudWxsKSB7IC8vIHNldHRlclxuXHRcdC8vIHRoZXNlIGFzc2lnbm1lbnRzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIG9yaWdpbmFsIHpvbmUgbWV0aG9kIGlzIGNhbGxlZC5cblx0XHQvLyBJIGZvcmdldCB3aHksIHNvbWV0aGluZyB0byBkbyB3aXRoIGEgYnJvd3NlciBjcmFzaC5cblx0XHR0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTtcblx0XHR0aGlzLl9hbWJpZ1pvbmUgPSBmYWxzZTtcblx0fVxuXG5cdHJldHVybiBvbGRNb21lbnRQcm90by51dGNPZmZzZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cblxuLy8gRm9ybWF0dGluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5uZXdNb21lbnRQcm90by5mb3JtYXQgPSBmdW5jdGlvbigpIHtcblxuXHRpZiAodGhpcy5fZnVsbENhbGVuZGFyICYmIGFyZ3VtZW50c1swXSkgeyAvLyBhbiBlbmhhbmNlZCBtb21lbnQ/IGFuZCBhIGZvcm1hdCBzdHJpbmcgcHJvdmlkZWQ/XG5cdFx0cmV0dXJuIGZvcm1hdERhdGUodGhpcywgYXJndW1lbnRzWzBdKTsgLy8gb3VyIGV4dGVuZGVkIGZvcm1hdHRpbmdcblx0fVxuXHRpZiAodGhpcy5fYW1iaWdUaW1lKSB7XG5cdFx0cmV0dXJuIG9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpLCAnWVlZWS1NTS1ERCcpO1xuXHR9XG5cdGlmICh0aGlzLl9hbWJpZ1pvbmUpIHtcblx0XHRyZXR1cm4gb2xkTW9tZW50Rm9ybWF0KGVuZ2xpc2hNb21lbnQodGhpcyksICdZWVlZLU1NLUREW1RdSEg6bW06c3MnKTtcblx0fVxuXHRpZiAodGhpcy5fZnVsbENhbGVuZGFyKSB7IC8vIGVuaGFuY2VkIG5vbi1hbWJpZyBtb21lbnQ/XG5cdFx0Ly8gbW9tZW50LmZvcm1hdCgpIGRvZXNuJ3QgZW5zdXJlIGVuZ2xpc2gsIGJ1dCB3ZSB3YW50IHRvLlxuXHRcdHJldHVybiBvbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSk7XG5cdH1cblxuXHRyZXR1cm4gb2xkTW9tZW50UHJvdG8uZm9ybWF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5uZXdNb21lbnRQcm90by50b0lTT1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXG5cdGlmICh0aGlzLl9hbWJpZ1RpbWUpIHtcblx0XHRyZXR1cm4gb2xkTW9tZW50Rm9ybWF0KGVuZ2xpc2hNb21lbnQodGhpcyksICdZWVlZLU1NLUREJyk7XG5cdH1cblx0aWYgKHRoaXMuX2FtYmlnWm9uZSkge1xuXHRcdHJldHVybiBvbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcycpO1xuXHR9XG5cdGlmICh0aGlzLl9mdWxsQ2FsZW5kYXIpIHsgLy8gZW5oYW5jZWQgbm9uLWFtYmlnIG1vbWVudD9cblx0XHQvLyBkZXBlbmRpbmcgb24gYnJvd3NlciwgbW9tZW50IG1pZ2h0IG5vdCBvdXRwdXQgZW5nbGlzaC4gZW5zdXJlIGVuZ2xpc2guXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvYmxvYi8yLjE4LjEvc3JjL2xpYi9tb21lbnQvZm9ybWF0LmpzI0wyMlxuXHRcdHJldHVybiBvbGRNb21lbnRQcm90by50b0lTT1N0cmluZy5hcHBseShlbmdsaXNoTW9tZW50KHRoaXMpLCBhcmd1bWVudHMpO1xuXHR9XG5cblx0cmV0dXJuIG9sZE1vbWVudFByb3RvLnRvSVNPU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5mdW5jdGlvbiBlbmdsaXNoTW9tZW50KG1vbSkge1xuXHRpZiAobW9tLmxvY2FsZSgpICE9PSAnZW4nKSB7XG5cdFx0cmV0dXJuIG1vbS5jbG9uZSgpLmxvY2FsZSgnZW4nKTtcblx0fVxuXHRyZXR1cm4gbW9tO1xufVxuXG47O1xuKGZ1bmN0aW9uKCkge1xuXG4vLyBleHBvcnRzXG5GQy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcbkZDLmZvcm1hdFJhbmdlID0gZm9ybWF0UmFuZ2U7XG5GQy5vbGRNb21lbnRGb3JtYXQgPSBvbGRNb21lbnRGb3JtYXQ7XG5GQy5xdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQgPSBxdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQ7XG5cblxuLy8gQ29uZmlnXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbkluc2VydGVkIGJldHdlZW4gY2h1bmtzIGluIHRoZSBmYWtlIChcImludGVybWVkaWF0ZVwiKSBmb3JtYXR0aW5nIHN0cmluZy5cbkltcG9ydGFudCB0aGF0IGl0IHBhc3NlcyBhcyB3aGl0ZXNwYWNlIChcXHMpIGJlY2F1c2UgbW9tZW50IG9mdGVuIGlkZW50aWZpZXMgbm9uLXN0YW5kYWxvbmUgbW9udGhzXG52aWEgYSByZWdleHAgd2l0aCBhbiBcXHMuXG4qL1xudmFyIFBBUlRfU0VQQVJBVE9SID0gJ1xcdTAwMGInOyAvLyB2ZXJ0aWNhbCB0YWJcblxuLypcbkluc2VydGVkIGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBsaXRlcmFsLXRleHQgY2h1bmsgdG8gaW5kaWNhdGUgdGhhdCB0aGUgbGl0ZXJhbCB0ZXh0IGlzIG5vdCBhY3R1YWxseSBsaXRlcmFsIHRleHQsXG5idXQgcmF0aGVyLCBhIFwic3BlY2lhbFwiIHRva2VuIHRoYXQgaGFzIGN1c3RvbSByZW5kZXJpbmcgKHNlZSBzcGVjaWFsVG9rZW5zIG1hcCkuXG4qL1xudmFyIFNQRUNJQUxfVE9LRU5fTUFSS0VSID0gJ1xcdTAwMWYnOyAvLyBpbmZvcm1hdGlvbiBzZXBhcmF0b3IgMVxuXG4vKlxuSW5zZXJ0ZWQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3BhbiBvZiB0ZXh0IHRoYXQgbXVzdCBoYXZlIG5vbi16ZXJvIG51bWVyaWMgY2hhcmFjdGVycy5cbkhhbmRsaW5nIG9mIHRoZXNlIG1hcmtlcnMgaXMgZG9uZSBpbiBhIHBvc3QtcHJvY2Vzc2luZyBzdGVwIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0ZXh0IHJlbmRlcmluZy5cbiovXG52YXIgTUFZQkVfTUFSS0VSID0gJ1xcdTAwMWUnOyAvLyBpbmZvcm1hdGlvbiBzZXBhcmF0b3IgMlxudmFyIE1BWUJFX1JFR0VYUCA9IG5ldyBSZWdFeHAoTUFZQkVfTUFSS0VSICsgJyhbXicgKyBNQVlCRV9NQVJLRVIgKyAnXSopJyArIE1BWUJFX01BUktFUiwgJ2cnKTsgLy8gbXVzdCBiZSBnbG9iYWxcblxuLypcbkFkZGl0aW9uIGZvcm1hdHRpbmcgdG9rZW5zIHdlIHdhbnQgcmVjb2duaXplZFxuKi9cbnZhciBzcGVjaWFsVG9rZW5zID0ge1xuXHR0OiBmdW5jdGlvbihkYXRlKSB7IC8vIFwiYVwiIG9yIFwicFwiXG5cdFx0cmV0dXJuIG9sZE1vbWVudEZvcm1hdChkYXRlLCAnYScpLmNoYXJBdCgwKTtcblx0fSxcblx0VDogZnVuY3Rpb24oZGF0ZSkgeyAvLyBcIkFcIiBvciBcIlBcIlxuXHRcdHJldHVybiBvbGRNb21lbnRGb3JtYXQoZGF0ZSwgJ0EnKS5jaGFyQXQoMCk7XG5cdH1cbn07XG5cbi8qXG5UaGUgZmlyc3QgY2hhcmFjdGVycyBvZiBmb3JtYXR0aW5nIHRva2VucyBmb3IgdW5pdHMgdGhhdCBhcmUgMSBkYXkgb3IgbGFyZ2VyLlxuYHZhbHVlYCBpcyBmb3IgcmFua2luZyByZWxhdGl2ZSBzaXplIChsb3dlciBtZWFucyBiaWdnZXIpLlxuYHVuaXRgIGlzIGEgbm9ybWFsaXplZCB1bml0LCB1c2VkIGZvciBjb21wYXJpbmcgbW9tZW50cy5cbiovXG52YXIgbGFyZ2VUb2tlbk1hcCA9IHtcblx0WTogeyB2YWx1ZTogMSwgdW5pdDogJ3llYXInIH0sXG5cdE06IHsgdmFsdWU6IDIsIHVuaXQ6ICdtb250aCcgfSxcblx0VzogeyB2YWx1ZTogMywgdW5pdDogJ3dlZWsnIH0sIC8vIElTTyB3ZWVrXG5cdHc6IHsgdmFsdWU6IDMsIHVuaXQ6ICd3ZWVrJyB9LCAvLyBsb2NhbCB3ZWVrXG5cdEQ6IHsgdmFsdWU6IDQsIHVuaXQ6ICdkYXknIH0sIC8vIGRheSBvZiBtb250aFxuXHRkOiB7IHZhbHVlOiA0LCB1bml0OiAnZGF5JyB9IC8vIGRheSBvZiB3ZWVrXG59O1xuXG5cbi8vIFNpbmdsZSBEYXRlIEZvcm1hdHRpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuRm9ybWF0cyBgZGF0ZWAgd2l0aCBhIE1vbWVudCBmb3JtYXR0aW5nIHN0cmluZywgYnV0IGFsbG93IG91ciBub24temVybyBhcmVhcyBhbmQgc3BlY2lhbCB0b2tlblxuKi9cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0U3RyKSB7XG5cdHJldHVybiByZW5kZXJGYWtlRm9ybWF0U3RyaW5nKFxuXHRcdGdldFBhcnNlZEZvcm1hdFN0cmluZyhmb3JtYXRTdHIpLmZha2VGb3JtYXRTdHJpbmcsXG5cdFx0ZGF0ZVxuXHQpO1xufVxuXG4vKlxuQ2FsbCB0aGlzIGlmIHlvdSB3YW50IE1vbWVudCdzIG9yaWdpbmFsIGZvcm1hdCBtZXRob2QgdG8gYmUgdXNlZFxuKi9cbmZ1bmN0aW9uIG9sZE1vbWVudEZvcm1hdChtb20sIGZvcm1hdFN0cikge1xuXHRyZXR1cm4gb2xkTW9tZW50UHJvdG8uZm9ybWF0LmNhbGwobW9tLCBmb3JtYXRTdHIpOyAvLyBvbGRNb21lbnRQcm90byBkZWZpbmVkIGluIG1vbWVudC1leHQuanNcbn1cblxuXG4vLyBEYXRlIFJhbmdlIEZvcm1hdHRpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRPRE86IG1ha2UgaXQgd29yayB3aXRoIHRpbWV6b25lIG9mZnNldFxuXG4vKlxuVXNpbmcgYSBmb3JtYXR0aW5nIHN0cmluZyBtZWFudCBmb3IgYSBzaW5nbGUgZGF0ZSwgZ2VuZXJhdGUgYSByYW5nZSBzdHJpbmcsIGxpa2VcblwiU2VwIDIgLSA5IDIwMTNcIiwgdGhhdCBpbnRlbGxpZ2VudGx5IGluc2VydHMgYSBzZXBhcmF0b3Igd2hlcmUgdGhlIGRhdGVzIGRpZmZlci5cbklmIHRoZSBkYXRlcyBhcmUgdGhlIHNhbWUgYXMgZmFyIGFzIHRoZSBmb3JtYXQgc3RyaW5nIGlzIGNvbmNlcm5lZCwganVzdCByZXR1cm4gYSBzaW5nbGVcbnJlbmRlcmluZyBvZiBvbmUgZGF0ZSwgd2l0aG91dCBhbnkgc2VwYXJhdG9yLlxuKi9cbmZ1bmN0aW9uIGZvcm1hdFJhbmdlKGRhdGUxLCBkYXRlMiwgZm9ybWF0U3RyLCBzZXBhcmF0b3IsIGlzUlRMKSB7XG5cdHZhciBsb2NhbGVEYXRhO1xuXG5cdGRhdGUxID0gRkMubW9tZW50LnBhcnNlWm9uZShkYXRlMSk7XG5cdGRhdGUyID0gRkMubW9tZW50LnBhcnNlWm9uZShkYXRlMik7XG5cblx0bG9jYWxlRGF0YSA9IGRhdGUxLmxvY2FsZURhdGEoKTtcblxuXHQvLyBFeHBhbmQgbG9jYWxpemVkIGZvcm1hdCBzdHJpbmdzLCBsaWtlIFwiTExcIiAtPiBcIk1NTU0gRCBZWVlZXCIuXG5cdC8vIEJUVywgdGhpcyBpcyBub3QgaW1wb3J0YW50IGZvciBgZm9ybWF0RGF0ZWAgYmVjYXVzZSBpdCBpcyBpbXBvc3NpYmxlIHRvIHB1dCBjdXN0b20gdG9rZW5zXG5cdC8vIG9yIG5vbi16ZXJvIGFyZWFzIGluIE1vbWVudCdzIGxvY2FsaXplZCBmb3JtYXQgc3RyaW5ncy5cblx0Zm9ybWF0U3RyID0gbG9jYWxlRGF0YS5sb25nRGF0ZUZvcm1hdChmb3JtYXRTdHIpIHx8IGZvcm1hdFN0cjtcblxuXHRyZXR1cm4gcmVuZGVyUGFyc2VkRm9ybWF0KFxuXHRcdGdldFBhcnNlZEZvcm1hdFN0cmluZyhmb3JtYXRTdHIpLFxuXHRcdGRhdGUxLFxuXHRcdGRhdGUyLFxuXHRcdHNlcGFyYXRvciB8fCAnIC0gJyxcblx0XHRpc1JUTFxuXHQpO1xufVxuXG4vKlxuUmVuZGVycyBhIHJhbmdlIHdpdGggYW4gYWxyZWFkeS1wYXJzZWQgZm9ybWF0IHN0cmluZy5cbiovXG5mdW5jdGlvbiByZW5kZXJQYXJzZWRGb3JtYXQocGFyc2VkRm9ybWF0LCBkYXRlMSwgZGF0ZTIsIHNlcGFyYXRvciwgaXNSVEwpIHtcblx0dmFyIHNhbWVVbml0cyA9IHBhcnNlZEZvcm1hdC5zYW1lVW5pdHM7XG5cdHZhciB1bnpvbmVkRGF0ZTEgPSBkYXRlMS5jbG9uZSgpLnN0cmlwWm9uZSgpOyAvLyBmb3Igc2FtZS11bml0IGNvbXBhcmlzb25zXG5cdHZhciB1bnpvbmVkRGF0ZTIgPSBkYXRlMi5jbG9uZSgpLnN0cmlwWm9uZSgpOyAvLyBcIlxuXG5cdHZhciByZW5kZXJlZFBhcnRzMSA9IHJlbmRlckZha2VGb3JtYXRTdHJpbmdQYXJ0cyhwYXJzZWRGb3JtYXQuZmFrZUZvcm1hdFN0cmluZywgZGF0ZTEpO1xuXHR2YXIgcmVuZGVyZWRQYXJ0czIgPSByZW5kZXJGYWtlRm9ybWF0U3RyaW5nUGFydHMocGFyc2VkRm9ybWF0LmZha2VGb3JtYXRTdHJpbmcsIGRhdGUyKTtcblxuXHR2YXIgbGVmdEk7XG5cdHZhciBsZWZ0U3RyID0gJyc7XG5cdHZhciByaWdodEk7XG5cdHZhciByaWdodFN0ciA9ICcnO1xuXHR2YXIgbWlkZGxlSTtcblx0dmFyIG1pZGRsZVN0cjEgPSAnJztcblx0dmFyIG1pZGRsZVN0cjIgPSAnJztcblx0dmFyIG1pZGRsZVN0ciA9ICcnO1xuXG5cdC8vIFN0YXJ0IGF0IHRoZSBsZWZ0bW9zdCBzaWRlIG9mIHRoZSBmb3JtYXR0aW5nIHN0cmluZyBhbmQgY29udGludWUgdW50aWwgeW91IGhpdCBhIHRva2VuXG5cdC8vIHRoYXQgaXMgbm90IHRoZSBzYW1lIGJldHdlZW4gZGF0ZXMuXG5cdGZvciAoXG5cdFx0bGVmdEkgPSAwO1xuXHRcdGxlZnRJIDwgc2FtZVVuaXRzLmxlbmd0aCAmJiAoIXNhbWVVbml0c1tsZWZ0SV0gfHwgdW56b25lZERhdGUxLmlzU2FtZSh1bnpvbmVkRGF0ZTIsIHNhbWVVbml0c1tsZWZ0SV0pKTtcblx0XHRsZWZ0SSsrXG5cdCkge1xuXHRcdGxlZnRTdHIgKz0gcmVuZGVyZWRQYXJ0czFbbGVmdEldO1xuXHR9XG5cblx0Ly8gU2ltaWxhcmx5LCBzdGFydCBhdCB0aGUgcmlnaHRtb3N0IHNpZGUgb2YgdGhlIGZvcm1hdHRpbmcgc3RyaW5nIGFuZCBtb3ZlIGxlZnRcblx0Zm9yIChcblx0XHRyaWdodEkgPSBzYW1lVW5pdHMubGVuZ3RoIC0gMTtcblx0XHRyaWdodEkgPiBsZWZ0SSAmJiAoIXNhbWVVbml0c1tyaWdodEldIHx8IHVuem9uZWREYXRlMS5pc1NhbWUodW56b25lZERhdGUyLCBzYW1lVW5pdHNbcmlnaHRJXSkpO1xuXHRcdHJpZ2h0SS0tXG5cdCkge1xuXHRcdC8vIElmIGN1cnJlbnQgY2h1bmsgaXMgb24gdGhlIGJvdW5kYXJ5IG9mIHVuaXF1ZSBkYXRlLWNvbnRlbnQsIGFuZCBpcyBhIHNwZWNpYWwtY2FzZVxuXHRcdC8vIGRhdGUtZm9ybWF0dGluZyBwb3N0Zml4IGNoYXJhY3RlciwgdGhlbiBkb24ndCBjb25zdW1lIGl0LiBDb25zaWRlciBpdCB1bmlxdWUgZGF0ZS1jb250ZW50LlxuXHRcdC8vIFRPRE86IG1ha2UgY29uZmlndXJhYmxlXG5cdFx0aWYgKHJpZ2h0SSAtIDEgPT09IGxlZnRJICYmIHJlbmRlcmVkUGFydHMxW3JpZ2h0SV0gPT09ICcuJykge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmlnaHRTdHIgPSByZW5kZXJlZFBhcnRzMVtyaWdodEldICsgcmlnaHRTdHI7XG5cdH1cblxuXHQvLyBUaGUgYXJlYSBpbiB0aGUgbWlkZGxlIGlzIGRpZmZlcmVudCBmb3IgYm90aCBvZiB0aGUgZGF0ZXMuXG5cdC8vIENvbGxlY3QgdGhlbSBkaXN0aW5jdGx5IHNvIHdlIGNhbiBqYW0gdGhlbSB0b2dldGhlciBsYXRlci5cblx0Zm9yIChtaWRkbGVJID0gbGVmdEk7IG1pZGRsZUkgPD0gcmlnaHRJOyBtaWRkbGVJKyspIHtcblx0XHRtaWRkbGVTdHIxICs9IHJlbmRlcmVkUGFydHMxW21pZGRsZUldO1xuXHRcdG1pZGRsZVN0cjIgKz0gcmVuZGVyZWRQYXJ0czJbbWlkZGxlSV07XG5cdH1cblxuXHRpZiAobWlkZGxlU3RyMSB8fCBtaWRkbGVTdHIyKSB7XG5cdFx0aWYgKGlzUlRMKSB7XG5cdFx0XHRtaWRkbGVTdHIgPSBtaWRkbGVTdHIyICsgc2VwYXJhdG9yICsgbWlkZGxlU3RyMTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRtaWRkbGVTdHIgPSBtaWRkbGVTdHIxICsgc2VwYXJhdG9yICsgbWlkZGxlU3RyMjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcHJvY2Vzc01heWJlTWFya2Vycyhcblx0XHRsZWZ0U3RyICsgbWlkZGxlU3RyICsgcmlnaHRTdHJcblx0KTtcbn1cblxuXG4vLyBGb3JtYXQgU3RyaW5nIFBhcnNpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgcGFyc2VkRm9ybWF0U3RyQ2FjaGUgPSB7fTtcblxuLypcblJldHVybnMgYSBwYXJzZWQgZm9ybWF0IHN0cmluZywgbGV2ZXJhZ2luZyBhIGNhY2hlLlxuKi9cbmZ1bmN0aW9uIGdldFBhcnNlZEZvcm1hdFN0cmluZyhmb3JtYXRTdHIpIHtcblx0cmV0dXJuIHBhcnNlZEZvcm1hdFN0ckNhY2hlW2Zvcm1hdFN0cl0gfHxcblx0XHQocGFyc2VkRm9ybWF0U3RyQ2FjaGVbZm9ybWF0U3RyXSA9IHBhcnNlRm9ybWF0U3RyaW5nKGZvcm1hdFN0cikpO1xufVxuXG4vKlxuUGFyc2VzIGEgZm9ybWF0IHN0cmluZyBpbnRvIHRoZSBmb2xsb3dpbmc6XG4tIGZha2VGb3JtYXRTdHJpbmc6IGEgbW9tZW50SlMgZm9ybWF0dGluZyBzdHJpbmcsIGxpdHRlcmVkIHdpdGggc3BlY2lhbCBjb250cm9sIGNoYXJhY3RlcnMgdGhhdCBnZXQgcG9zdC1wcm9jZXNzZWQuXG4tIHNhbWVVbml0czogZm9yIGV2ZXJ5IHBhcnQgaW4gZmFrZUZvcm1hdFN0cmluZywgaWYgdGhlIHBhcnQgaXMgYSB0b2tlbiwgdGhlIHZhbHVlIHdpbGwgYmUgYSB1bml0IHN0cmluZyAobGlrZSBcImRheVwiKSxcbiAgdGhhdCBpbmRpY2F0ZXMgaG93IHNpbWlsYXIgYSByYW5nZSdzIHN0YXJ0ICYgZW5kIG11c3QgYmUgaW4gb3JkZXIgdG8gc2hhcmUgdGhlIHNhbWUgZm9ybWF0dGVkIHRleHQuXG4gIElmIG5vdCBhIHRva2VuLCB0aGVuIHRoZSB2YWx1ZSBpcyBudWxsLlxuICBBbHdheXMgYSBmbGF0IGFycmF5IChub3QgbmVzdGVkIGxpa2VkIFwiY2h1bmtzXCIpLlxuKi9cbmZ1bmN0aW9uIHBhcnNlRm9ybWF0U3RyaW5nKGZvcm1hdFN0cikge1xuXHR2YXIgY2h1bmtzID0gY2h1bmtGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKTtcblx0XG5cdHJldHVybiB7XG5cdFx0ZmFrZUZvcm1hdFN0cmluZzogYnVpbGRGYWtlRm9ybWF0U3RyaW5nKGNodW5rcyksXG5cdFx0c2FtZVVuaXRzOiBidWlsZFNhbWVVbml0cyhjaHVua3MpXG5cdH07XG59XG5cbi8qXG5CcmVhayB0aGUgZm9ybWF0dGluZyBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBjaHVua3MuXG5BICdtYXliZScgY2h1bmsgd2lsbCBoYXZlIG5lc3RlZCBjaHVua3MuXG4qL1xuZnVuY3Rpb24gY2h1bmtGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSB7XG5cdHZhciBjaHVua3MgPSBbXTtcblx0dmFyIG1hdGNoO1xuXG5cdC8vIFRPRE86IG1vcmUgZGVzY3JpbWluYXRpb25cblx0Ly8gXFw0IGlzIGEgYmFja3JlZmVyZW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgbXVsdGktY2hhcmFjdGVyIHNldC5cblx0dmFyIGNodW5rZXIgPSAvXFxbKFteXFxdXSopXFxdfFxcKChbXlxcKV0qKVxcKXwoTFRTfExUfChcXHcpXFw0Km8/KXwoW15cXHdcXFtcXChdKykvZztcblxuXHR3aGlsZSAoKG1hdGNoID0gY2h1bmtlci5leGVjKGZvcm1hdFN0cikpKSB7XG5cdFx0aWYgKG1hdGNoWzFdKSB7IC8vIGEgbGl0ZXJhbCBzdHJpbmcgaW5zaWRlIFsgLi4uIF1cblx0XHRcdGNodW5rcy5wdXNoLmFwcGx5KGNodW5rcywgLy8gYXBwZW5kXG5cdFx0XHRcdHNwbGl0U3RyaW5nTGl0ZXJhbChtYXRjaFsxXSlcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKG1hdGNoWzJdKSB7IC8vIG5vbi16ZXJvIGZvcm1hdHRpbmcgaW5zaWRlICggLi4uIClcblx0XHRcdGNodW5rcy5wdXNoKHsgbWF5YmU6IGNodW5rRm9ybWF0U3RyaW5nKG1hdGNoWzJdKSB9KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAobWF0Y2hbM10pIHsgLy8gYSBmb3JtYXR0aW5nIHRva2VuXG5cdFx0XHRjaHVua3MucHVzaCh7IHRva2VuOiBtYXRjaFszXSB9KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAobWF0Y2hbNV0pIHsgLy8gYW4gdW5lbmNsb3NlZCBsaXRlcmFsIHN0cmluZ1xuXHRcdFx0Y2h1bmtzLnB1c2guYXBwbHkoY2h1bmtzLCAvLyBhcHBlbmRcblx0XHRcdFx0c3BsaXRTdHJpbmdMaXRlcmFsKG1hdGNoWzVdKVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2h1bmtzO1xufVxuXG4vKlxuUG90ZW50aWFsbHkgc3BsaXRzIGEgbGl0ZXJhbC10ZXh0IHN0cmluZyBpbnRvIG11bHRpcGxlIHBhcnRzLiBGb3Igc3BlY2lhbCBjYXNlcy5cbiovXG5mdW5jdGlvbiBzcGxpdFN0cmluZ0xpdGVyYWwocykge1xuXHRpZiAocyA9PT0gJy4gJykge1xuXHRcdHJldHVybiBbICcuJywgJyAnIF07IC8vIGZvciBsb2NhbGVzIHdpdGggcGVyaW9kcyBib3VuZCB0byB0aGUgZW5kIG9mIGVhY2ggeWVhci9tb250aC9kYXRlXG5cdH1cblx0ZWxzZSB7XG5cdFx0cmV0dXJuIFsgcyBdO1xuXHR9XG59XG5cbi8qXG5HaXZlbiBjaHVua3MgcGFyc2VkIGZyb20gYSByZWFsIGZvcm1hdCBzdHJpbmcsIGdlbmVyYXRlIGEgZmFrZSAoYWthIFwiaW50ZXJtZWRpYXRlXCIpIGZvcm1hdCBzdHJpbmcgd2l0aCBzcGVjaWFsIGNvbnRyb2xcbmNoYXJhY3RlcnMgdGhhdCB3aWxsIGV2ZW50dWFsbHkgYmUgZ2l2ZW4gdG8gbW9tZW50IGZvciBmb3JtYXR0aW5nLCBhbmQgdGhlbiBwb3N0LXByb2Nlc3NlZC5cbiovXG5mdW5jdGlvbiBidWlsZEZha2VGb3JtYXRTdHJpbmcoY2h1bmtzKSB7XG5cdHZhciBwYXJ0cyA9IFtdO1xuXHR2YXIgaSwgY2h1bms7XG5cblx0Zm9yIChpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuXHRcdGNodW5rID0gY2h1bmtzW2ldO1xuXG5cdFx0aWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHBhcnRzLnB1c2goJ1snICsgY2h1bmsgKyAnXScpO1xuXHRcdH1cblx0XHRlbHNlIGlmIChjaHVuay50b2tlbikge1xuXHRcdFx0aWYgKGNodW5rLnRva2VuIGluIHNwZWNpYWxUb2tlbnMpIHtcblx0XHRcdFx0cGFydHMucHVzaChcblx0XHRcdFx0XHRTUEVDSUFMX1RPS0VOX01BUktFUiArIC8vIHVzZWZ1bCBkdXJpbmcgcG9zdC1wcm9jZXNzaW5nXG5cdFx0XHRcdFx0J1snICsgY2h1bmsudG9rZW4gKyAnXScgLy8gcHJlc2VydmUgYXMgbGl0ZXJhbCB0ZXh0XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cGFydHMucHVzaChjaHVuay50b2tlbik7IC8vIHVucHJvdGVjdGVkIHRleHQgaW1wbGllcyBhIGZvcm1hdCBzdHJpbmdcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoY2h1bmsubWF5YmUpIHtcblx0XHRcdHBhcnRzLnB1c2goXG5cdFx0XHRcdE1BWUJFX01BUktFUiArIC8vIHVzZWZ1bCBkdXJpbmcgcG9zdC1wcm9jZXNzaW5nXG5cdFx0XHRcdGJ1aWxkRmFrZUZvcm1hdFN0cmluZyhjaHVuay5tYXliZSkgK1xuXHRcdFx0XHRNQVlCRV9NQVJLRVJcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHBhcnRzLmpvaW4oUEFSVF9TRVBBUkFUT1IpO1xufVxuXG4vKlxuR2l2ZW4gcGFyc2VkIGNodW5rcyBmcm9tIGEgcmVhbCBmb3JtYXR0aW5nIHN0cmluZywgZ2VuZXJhdGVzIGFuIGFycmF5IG9mIHVuaXQgc3RyaW5ncyAobGlrZSBcImRheVwiKSB0aGF0IGluZGljYXRlXG5pbiB3aGljaCByZWdhcmQgdHdvIGRhdGVzIG11c3QgYmUgc2ltaWxhciBpbiBvcmRlciB0byBzaGFyZSByYW5nZSBmb3JtYXR0aW5nIHRleHQuXG5UaGUgYGNodW5rc2AgY2FuIGJlIG5lc3RlZCAoYmVjYXVzZSBvZiBcIm1heWJlXCIgY2h1bmtzKSwgaG93ZXZlciwgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgYmUgZmxhdC5cbiovXG5mdW5jdGlvbiBidWlsZFNhbWVVbml0cyhjaHVua3MpIHtcblx0dmFyIHVuaXRzID0gW107XG5cdHZhciBpLCBjaHVuaztcblx0dmFyIHRva2VuSW5mbztcblxuXHRmb3IgKGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2h1bmsgPSBjaHVua3NbaV07XG5cblx0XHRpZiAoY2h1bmsudG9rZW4pIHtcblx0XHRcdHRva2VuSW5mbyA9IGxhcmdlVG9rZW5NYXBbY2h1bmsudG9rZW4uY2hhckF0KDApXTtcblx0XHRcdHVuaXRzLnB1c2godG9rZW5JbmZvID8gdG9rZW5JbmZvLnVuaXQgOiAnc2Vjb25kJyk7IC8vIGRlZmF1bHQgdG8gYSB2ZXJ5IHN0cmljdCBzYW1lLXNlY29uZFxuXHRcdH1cblx0XHRlbHNlIGlmIChjaHVuay5tYXliZSkge1xuXHRcdFx0dW5pdHMucHVzaC5hcHBseSh1bml0cywgLy8gYXBwZW5kXG5cdFx0XHRcdGJ1aWxkU2FtZVVuaXRzKGNodW5rLm1heWJlKVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR1bml0cy5wdXNoKG51bGwpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB1bml0cztcbn1cblxuXG4vLyBSZW5kZXJpbmcgdG8gdGV4dFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG5Gb3JtYXRzIGEgZGF0ZSB3aXRoIGEgZmFrZSBmb3JtYXQgc3RyaW5nLCBwb3N0LXByb2Nlc3NlcyB0aGUgY29udHJvbCBjaGFyYWN0ZXJzLCB0aGVuIHJldHVybnMuXG4qL1xuZnVuY3Rpb24gcmVuZGVyRmFrZUZvcm1hdFN0cmluZyhmYWtlRm9ybWF0U3RyaW5nLCBkYXRlKSB7XG5cdHJldHVybiBwcm9jZXNzTWF5YmVNYXJrZXJzKFxuXHRcdHJlbmRlckZha2VGb3JtYXRTdHJpbmdQYXJ0cyhmYWtlRm9ybWF0U3RyaW5nLCBkYXRlKS5qb2luKCcnKVxuXHQpO1xufVxuXG4vKlxuRm9ybWF0cyBhIGRhdGUgaW50byBwYXJ0cyB0aGF0IHdpbGwgaGF2ZSBiZWVuIHBvc3QtcHJvY2Vzc2VkLCBFWENFUFQgZm9yIHRoZSBcIm1heWJlXCIgbWFya2Vycy5cbiovXG5mdW5jdGlvbiByZW5kZXJGYWtlRm9ybWF0U3RyaW5nUGFydHMoZmFrZUZvcm1hdFN0cmluZywgZGF0ZSkge1xuXHR2YXIgcGFydHMgPSBbXTtcblx0dmFyIGZha2VSZW5kZXIgPSBvbGRNb21lbnRGb3JtYXQoZGF0ZSwgZmFrZUZvcm1hdFN0cmluZyk7XG5cdHZhciBmYWtlUGFydHMgPSBmYWtlUmVuZGVyLnNwbGl0KFBBUlRfU0VQQVJBVE9SKTtcblx0dmFyIGksIGZha2VQYXJ0O1xuXG5cdGZvciAoaSA9IDA7IGkgPCBmYWtlUGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRmYWtlUGFydCA9IGZha2VQYXJ0c1tpXTtcblxuXHRcdGlmIChmYWtlUGFydC5jaGFyQXQoMCkgPT09IFNQRUNJQUxfVE9LRU5fTUFSS0VSKSB7XG5cdFx0XHRwYXJ0cy5wdXNoKFxuXHRcdFx0XHQvLyB0aGUgbGl0ZXJhbCBzdHJpbmcgSVMgdGhlIHRva2VuJ3MgbmFtZS5cblx0XHRcdFx0Ly8gY2FsbCBzcGVjaWFsIHRva2VuJ3MgcmVnaXN0ZXJlZCBmdW5jdGlvbi5cblx0XHRcdFx0c3BlY2lhbFRva2Vuc1tmYWtlUGFydC5zdWJzdHJpbmcoMSldKGRhdGUpXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHBhcnRzLnB1c2goZmFrZVBhcnQpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwYXJ0cztcbn1cblxuLypcbkFjY2VwdHMgYW4gYWxtb3N0LWZpbmFsbHktZm9ybWF0dGVkIHN0cmluZyBhbmQgcHJvY2Vzc2VzIHRoZSBcIm1heWJlXCIgY29udHJvbCBjaGFyYWN0ZXJzLCByZXR1cm5pbmcgYSBuZXcgc3RyaW5nLlxuKi9cbmZ1bmN0aW9uIHByb2Nlc3NNYXliZU1hcmtlcnMocykge1xuXHRyZXR1cm4gcy5yZXBsYWNlKE1BWUJFX1JFR0VYUCwgZnVuY3Rpb24obTAsIG0xKSB7IC8vIHJlZ2V4IGFzc3VtZWQgdG8gaGF2ZSAnZycgZmxhZ1xuXHRcdGlmIChtMS5tYXRjaCgvWzEtOV0vKSkgeyAvLyBhbnkgbm9uLXplcm8gbnVtZXJpYyBjaGFyYWN0ZXJzP1xuXHRcdFx0cmV0dXJuIG0xO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdH0pO1xufVxuXG5cbi8vIE1pc2MgVXRpbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcblJldHVybnMgYSB1bml0IHN0cmluZywgZWl0aGVyICd5ZWFyJywgJ21vbnRoJywgJ2RheScsIG9yIG51bGwgZm9yIHRoZSBtb3N0IGdyYW51bGFyIGZvcm1hdHRpbmcgdG9rZW4gaW4gdGhlIHN0cmluZy5cbiovXG5mdW5jdGlvbiBxdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQoZm9ybWF0U3RyKSB7XG5cdHZhciBjaHVua3MgPSBjaHVua0Zvcm1hdFN0cmluZyhmb3JtYXRTdHIpO1xuXHR2YXIgaSwgY2h1bms7XG5cdHZhciBjYW5kaWRhdGU7XG5cdHZhciBiZXN0O1xuXG5cdGZvciAoaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcblx0XHRjaHVuayA9IGNodW5rc1tpXTtcblxuXHRcdGlmIChjaHVuay50b2tlbikge1xuXHRcdFx0Y2FuZGlkYXRlID0gbGFyZ2VUb2tlbk1hcFtjaHVuay50b2tlbi5jaGFyQXQoMCldO1xuXHRcdFx0aWYgKGNhbmRpZGF0ZSkge1xuXHRcdFx0XHRpZiAoIWJlc3QgfHwgY2FuZGlkYXRlLnZhbHVlID4gYmVzdC52YWx1ZSkge1xuXHRcdFx0XHRcdGJlc3QgPSBjYW5kaWRhdGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoYmVzdCkge1xuXHRcdHJldHVybiBiZXN0LnVuaXQ7XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn07XG5cbn0pKCk7XG5cbi8vIHF1aWNrIGxvY2FsIHJlZmVyZW5jZXNcbnZhciBmb3JtYXREYXRlID0gRkMuZm9ybWF0RGF0ZTtcbnZhciBmb3JtYXRSYW5nZSA9IEZDLmZvcm1hdFJhbmdlO1xudmFyIG9sZE1vbWVudEZvcm1hdCA9IEZDLm9sZE1vbWVudEZvcm1hdDtcblxuOztcblxuRkMuQ2xhc3MgPSBDbGFzczsgLy8gZXhwb3J0XG5cbi8vIENsYXNzIHRoYXQgYWxsIG90aGVyIGNsYXNzZXMgd2lsbCBpbmhlcml0IGZyb21cbmZ1bmN0aW9uIENsYXNzKCkgeyB9XG5cblxuLy8gQ2FsbGVkIG9uIGEgY2xhc3MgdG8gY3JlYXRlIGEgc3ViY2xhc3MuXG4vLyBMYXN0IGFyZ3VtZW50IGNvbnRhaW5zIGluc3RhbmNlIG1ldGhvZHMuIEFueSBhcmd1bWVudCBiZWZvcmUgdGhlIGxhc3QgYXJlIGNvbnNpZGVyZWQgbWl4aW5zLlxuQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXHR2YXIgaTtcblx0dmFyIG1lbWJlcnM7XG5cblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0bWVtYmVycyA9IGFyZ3VtZW50c1tpXTtcblx0XHRpZiAoaSA8IGxlbiAtIDEpIHsgLy8gbm90IHRoZSBsYXN0IGFyZ3VtZW50P1xuXHRcdFx0bWl4SW50b0NsYXNzKHRoaXMsIG1lbWJlcnMpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBleHRlbmRDbGFzcyh0aGlzLCBtZW1iZXJzIHx8IHt9KTsgLy8gbWVtYmVycyB3aWxsIGJlIHVuZGVmaW5lZCBpZiBubyBhcmd1bWVudHNcbn07XG5cblxuLy8gQWRkcyBuZXcgbWVtYmVyIHZhcmlhYmxlcy9tZXRob2RzIHRvIHRoZSBjbGFzcydzIHByb3RvdHlwZS5cbi8vIENhbiBiZSBjYWxsZWQgd2l0aCBhbm90aGVyIGNsYXNzLCBvciBhIHBsYWluIG9iamVjdCBoYXNoIGNvbnRhaW5pbmcgbmV3IG1lbWJlcnMuXG5DbGFzcy5taXhpbiA9IGZ1bmN0aW9uKG1lbWJlcnMpIHtcblx0bWl4SW50b0NsYXNzKHRoaXMsIG1lbWJlcnMpO1xufTtcblxuXG5mdW5jdGlvbiBleHRlbmRDbGFzcyhzdXBlckNsYXNzLCBtZW1iZXJzKSB7XG5cdHZhciBzdWJDbGFzcztcblxuXHQvLyBlbnN1cmUgYSBjb25zdHJ1Y3RvciBmb3IgdGhlIHN1YmNsYXNzLCBmb3J3YXJkaW5nIGFsbCBhcmd1bWVudHMgdG8gdGhlIHN1cGVyLWNvbnN0cnVjdG9yIGlmIGl0IGRvZXNuJ3QgZXhpc3Rcblx0aWYgKGhhc093blByb3AobWVtYmVycywgJ2NvbnN0cnVjdG9yJykpIHtcblx0XHRzdWJDbGFzcyA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG5cdH1cblx0aWYgKHR5cGVvZiBzdWJDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHN1YkNsYXNzID0gbWVtYmVycy5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwZXJDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH1cblxuXHQvLyBidWlsZCB0aGUgYmFzZSBwcm90b3R5cGUgZm9yIHRoZSBzdWJjbGFzcywgd2hpY2ggaXMgYW4gbmV3IG9iamVjdCBjaGFpbmVkIHRvIHRoZSBzdXBlcmNsYXNzJ3MgcHJvdG90eXBlXG5cdHN1YkNsYXNzLnByb3RvdHlwZSA9IGNyZWF0ZU9iamVjdChzdXBlckNsYXNzLnByb3RvdHlwZSk7XG5cblx0Ly8gY29weSBlYWNoIG1lbWJlciB2YXJpYWJsZS9tZXRob2Qgb250byB0aGUgdGhlIHN1YmNsYXNzJ3MgcHJvdG90eXBlXG5cdGNvcHlPd25Qcm9wcyhtZW1iZXJzLCBzdWJDbGFzcy5wcm90b3R5cGUpO1xuXG5cdC8vIGNvcHkgb3ZlciBhbGwgY2xhc3MgdmFyaWFibGVzL21ldGhvZHMgdG8gdGhlIHN1YmNsYXNzLCBzdWNoIGFzIGBleHRlbmRgIGFuZCBgbWl4aW5gXG5cdGNvcHlPd25Qcm9wcyhzdXBlckNsYXNzLCBzdWJDbGFzcyk7XG5cblx0cmV0dXJuIHN1YkNsYXNzO1xufVxuXG5cbmZ1bmN0aW9uIG1peEludG9DbGFzcyh0aGVDbGFzcywgbWVtYmVycykge1xuXHRjb3B5T3duUHJvcHMobWVtYmVycywgdGhlQ2xhc3MucHJvdG90eXBlKTtcbn1cbjs7XG5cbnZhciBNb2RlbCA9IENsYXNzLmV4dGVuZChFbWl0dGVyTWl4aW4sIExpc3RlbmVyTWl4aW4sIHtcblxuXHRfcHJvcHM6IG51bGwsXG5cdF93YXRjaGVyczogbnVsbCxcblx0X2dsb2JhbFdhdGNoQXJnczogbnVsbCxcblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fd2F0Y2hlcnMgPSB7fTtcblx0XHR0aGlzLl9wcm9wcyA9IHt9O1xuXHRcdHRoaXMuYXBwbHlHbG9iYWxXYXRjaGVycygpO1xuXHR9LFxuXG5cdGFwcGx5R2xvYmFsV2F0Y2hlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmdTZXRzID0gdGhpcy5fZ2xvYmFsV2F0Y2hBcmdzIHx8IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGFyZ1NldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMud2F0Y2guYXBwbHkodGhpcywgYXJnU2V0c1tpXSk7XG5cdFx0fVxuXHR9LFxuXG5cdGhhczogZnVuY3Rpb24obmFtZSkge1xuXHRcdHJldHVybiBuYW1lIGluIHRoaXMuX3Byb3BzO1xuXHR9LFxuXG5cdGdldDogZnVuY3Rpb24obmFtZSkge1xuXHRcdGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wcm9wcztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fcHJvcHNbbmFtZV07XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbihuYW1lLCB2YWwpIHtcblx0XHR2YXIgbmV3UHJvcHM7XG5cblx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRuZXdQcm9wcyA9IHt9O1xuXHRcdFx0bmV3UHJvcHNbbmFtZV0gPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWw7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bmV3UHJvcHMgPSBuYW1lO1xuXHRcdH1cblxuXHRcdHRoaXMuc2V0UHJvcHMobmV3UHJvcHMpO1xuXHR9LFxuXG5cdHJlc2V0OiBmdW5jdGlvbihuZXdQcm9wcykge1xuXHRcdHZhciBvbGRQcm9wcyA9IHRoaXMuX3Byb3BzO1xuXHRcdHZhciBjaGFuZ2VzZXQgPSB7fTsgLy8gd2lsbCBoYXZlIHVuZGVmaW5lZCdzIHRvIHNpZ25hbCB1bnNldHNcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAobmFtZSBpbiBvbGRQcm9wcykge1xuXHRcdFx0Y2hhbmdlc2V0W25hbWVdID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGZvciAobmFtZSBpbiBuZXdQcm9wcykge1xuXHRcdFx0Y2hhbmdlc2V0W25hbWVdID0gbmV3UHJvcHNbbmFtZV07XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRQcm9wcyhjaGFuZ2VzZXQpO1xuXHR9LFxuXG5cdHVuc2V0OiBmdW5jdGlvbihuYW1lKSB7IC8vIGFjY2VwdHMgYSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5nc1xuXHRcdHZhciBuZXdQcm9wcyA9IHt9O1xuXHRcdHZhciBuYW1lcztcblx0XHR2YXIgaTtcblxuXHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdG5hbWVzID0gWyBuYW1lIF07XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bmFtZXMgPSBuYW1lO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0bmV3UHJvcHNbbmFtZXNbaV1dID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHRoaXMuc2V0UHJvcHMobmV3UHJvcHMpO1xuXHR9LFxuXG5cdHNldFByb3BzOiBmdW5jdGlvbihuZXdQcm9wcykge1xuXHRcdHZhciBjaGFuZ2VkUHJvcHMgPSB7fTtcblx0XHR2YXIgY2hhbmdlZENudCA9IDA7XG5cdFx0dmFyIG5hbWUsIHZhbDtcblxuXHRcdGZvciAobmFtZSBpbiBuZXdQcm9wcykge1xuXHRcdFx0dmFsID0gbmV3UHJvcHNbbmFtZV07XG5cblx0XHRcdC8vIGEgY2hhbmdlIGluIHZhbHVlP1xuXHRcdFx0Ly8gaWYgYW4gb2JqZWN0LCBkb24ndCBjaGVjayBlcXVhbGl0eSwgYmVjYXVzZSBtaWdodCBoYXZlIGJlZW4gbXV0YXRlZCBpbnRlcm5hbGx5LlxuXHRcdFx0Ly8gVE9ETzogZXZlbnR1YWxseSBlbmZvcmNlIGltbXV0YWJpbGl0eS5cblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHxcblx0XHRcdFx0dmFsICE9PSB0aGlzLl9wcm9wc1tuYW1lXVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNoYW5nZWRQcm9wc1tuYW1lXSA9IHZhbDtcblx0XHRcdFx0Y2hhbmdlZENudCsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjaGFuZ2VkQ250KSB7XG5cblx0XHRcdHRoaXMudHJpZ2dlcignYmVmb3JlOmJhdGNoQ2hhbmdlJywgY2hhbmdlZFByb3BzKTtcblxuXHRcdFx0Zm9yIChuYW1lIGluIGNoYW5nZWRQcm9wcykge1xuXHRcdFx0XHR2YWwgPSBjaGFuZ2VkUHJvcHNbbmFtZV07XG5cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdiZWZvcmU6Y2hhbmdlJywgbmFtZSwgdmFsKTtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdiZWZvcmU6Y2hhbmdlOicgKyBuYW1lLCB2YWwpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKG5hbWUgaW4gY2hhbmdlZFByb3BzKSB7XG5cdFx0XHRcdHZhbCA9IGNoYW5nZWRQcm9wc1tuYW1lXTtcblxuXHRcdFx0XHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fcHJvcHNbbmFtZV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcHNbbmFtZV0gPSB2YWw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgbmFtZSwgdmFsKTtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCBuYW1lLCB2YWwpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2JhdGNoQ2hhbmdlJywgY2hhbmdlZFByb3BzKTtcblx0XHR9XG5cdH0sXG5cblx0d2F0Y2g6IGZ1bmN0aW9uKG5hbWUsIGRlcExpc3QsIHN0YXJ0RnVuYywgc3RvcEZ1bmMpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0dGhpcy51bndhdGNoKG5hbWUpO1xuXG5cdFx0dGhpcy5fd2F0Y2hlcnNbbmFtZV0gPSB0aGlzLl93YXRjaERlcHMoZGVwTGlzdCwgZnVuY3Rpb24oZGVwcykge1xuXHRcdFx0dmFyIHJlcyA9IHN0YXJ0RnVuYy5jYWxsKF90aGlzLCBkZXBzKTtcblxuXHRcdFx0aWYgKHJlcyAmJiByZXMudGhlbikge1xuXHRcdFx0XHRfdGhpcy51bnNldChuYW1lKTsgLy8gcHV0IGluIGFuIHVuc2V0IHN0YXRlIHdoaWxlIHJlc29sdmluZ1xuXHRcdFx0XHRyZXMudGhlbihmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0XHRfdGhpcy5zZXQobmFtZSwgdmFsKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0X3RoaXMuc2V0KG5hbWUsIHJlcyk7XG5cdFx0XHR9XG5cdFx0fSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRfdGhpcy51bnNldChuYW1lKTtcblxuXHRcdFx0aWYgKHN0b3BGdW5jKSB7XG5cdFx0XHRcdHN0b3BGdW5jLmNhbGwoX3RoaXMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHVud2F0Y2g6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIgd2F0Y2hlciA9IHRoaXMuX3dhdGNoZXJzW25hbWVdO1xuXG5cdFx0aWYgKHdhdGNoZXIpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl93YXRjaGVyc1tuYW1lXTtcblx0XHRcdHdhdGNoZXIudGVhcmRvd24oKTtcblx0XHR9XG5cdH0sXG5cblx0X3dhdGNoRGVwczogZnVuY3Rpb24oZGVwTGlzdCwgc3RhcnRGdW5jLCBzdG9wRnVuYykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHF1ZXVlZENoYW5nZUNudCA9IDA7XG5cdFx0dmFyIGRlcENudCA9IGRlcExpc3QubGVuZ3RoO1xuXHRcdHZhciBzYXRpc2Z5Q250ID0gMDtcblx0XHR2YXIgdmFsdWVzID0ge307IC8vIHdoYXQncyBwYXNzZWQgYXMgdGhlIGBkZXBzYCBhcmd1bWVudHNcblx0XHR2YXIgYmluZFR1cGxlcyA9IFtdOyAvLyBhcnJheSBvZiBbIGV2ZW50TmFtZSwgaGFuZGxlckZ1bmMgXSBhcnJheXNcblx0XHR2YXIgaXNDYWxsaW5nU3RvcCA9IGZhbHNlO1xuXG5cdFx0ZnVuY3Rpb24gb25CZWZvcmVEZXBDaGFuZ2UoZGVwTmFtZSwgdmFsLCBpc09wdGlvbmFsKSB7XG5cdFx0XHRxdWV1ZWRDaGFuZ2VDbnQrKztcblx0XHRcdGlmIChxdWV1ZWRDaGFuZ2VDbnQgPT09IDEpIHsgLy8gZmlyc3QgY2hhbmdlIHRvIGNhdXNlIGEgXCJzdG9wXCIgP1xuXHRcdFx0XHRpZiAoc2F0aXNmeUNudCA9PT0gZGVwQ250KSB7IC8vIGFsbCBkZXBzIHByZXZpb3VzbHkgc2F0aXNmaWVkP1xuXHRcdFx0XHRcdGlzQ2FsbGluZ1N0b3AgPSB0cnVlO1xuXHRcdFx0XHRcdHN0b3BGdW5jKCk7XG5cdFx0XHRcdFx0aXNDYWxsaW5nU3RvcCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25EZXBDaGFuZ2UoZGVwTmFtZSwgdmFsLCBpc09wdGlvbmFsKSB7XG5cblx0XHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkgeyAvLyB1bnNldHRpbmcgYSB2YWx1ZT9cblxuXHRcdFx0XHQvLyByZXF1aXJlZCBkZXBlbmRlbmN5IHRoYXQgd2FzIHByZXZpb3VzbHkgc2V0P1xuXHRcdFx0XHRpZiAoIWlzT3B0aW9uYWwgJiYgdmFsdWVzW2RlcE5hbWVdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzYXRpc2Z5Q250LS07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgdmFsdWVzW2RlcE5hbWVdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IC8vIHNldHRpbmcgYSB2YWx1ZT9cblxuXHRcdFx0XHQvLyByZXF1aXJlZCBkZXBlbmRlbmN5IHRoYXQgd2FzIHByZXZpb3VzbHkgdW5zZXQ/XG5cdFx0XHRcdGlmICghaXNPcHRpb25hbCAmJiB2YWx1ZXNbZGVwTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHNhdGlzZnlDbnQrKztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhbHVlc1tkZXBOYW1lXSA9IHZhbDtcblx0XHRcdH1cblxuXHRcdFx0cXVldWVkQ2hhbmdlQ250LS07XG5cdFx0XHRpZiAoIXF1ZXVlZENoYW5nZUNudCkgeyAvLyBsYXN0IGNoYW5nZSB0byBjYXVzZSBhIFwic3RhcnRcIj9cblxuXHRcdFx0XHQvLyBub3cgZmluYWxseSBzYXRpc2ZpZWQgb3Igc2F0aXNmaWVkIGFsbCBhbG9uZz9cblx0XHRcdFx0aWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIHN0b3BGdW5jIGluaXRpYXRlZCBhbm90aGVyIHZhbHVlIGNoYW5nZSwgaWdub3JlIGl0LlxuXHRcdFx0XHRcdC8vIGl0IHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IGFub3RoZXIgY2hhbmdlIGV2ZW50IGFueXdheS5cblx0XHRcdFx0XHRpZiAoIWlzQ2FsbGluZ1N0b3ApIHtcblx0XHRcdFx0XHRcdHN0YXJ0RnVuYyh2YWx1ZXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGludGVyY2VwdCBmb3IgLm9uKCkgdGhhdCByZW1lbWJlcnMgaGFuZGxlcnNcblx0XHRmdW5jdGlvbiBiaW5kKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuXHRcdFx0X3RoaXMub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcblx0XHRcdGJpbmRUdXBsZXMucHVzaChbIGV2ZW50TmFtZSwgaGFuZGxlciBdKTtcblx0XHR9XG5cblx0XHQvLyBsaXN0ZW4gdG8gZGVwZW5kZW5jeSBjaGFuZ2VzXG5cdFx0ZGVwTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGRlcE5hbWUpIHtcblx0XHRcdHZhciBpc09wdGlvbmFsID0gZmFsc2U7XG5cblx0XHRcdGlmIChkZXBOYW1lLmNoYXJBdCgwKSA9PT0gJz8nKSB7IC8vIFRPRE86IG1vcmUgRFJZXG5cdFx0XHRcdGRlcE5hbWUgPSBkZXBOYW1lLnN1YnN0cmluZygxKTtcblx0XHRcdFx0aXNPcHRpb25hbCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGJpbmQoJ2JlZm9yZTpjaGFuZ2U6JyArIGRlcE5hbWUsIGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHRvbkJlZm9yZURlcENoYW5nZShkZXBOYW1lLCB2YWwsIGlzT3B0aW9uYWwpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGJpbmQoJ2NoYW5nZTonICsgZGVwTmFtZSwgZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRcdG9uRGVwQ2hhbmdlKGRlcE5hbWUsIHZhbCwgaXNPcHRpb25hbCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdC8vIHByb2Nlc3MgY3VycmVudCBkZXBlbmRlbmN5IHZhbHVlc1xuXHRcdGRlcExpc3QuZm9yRWFjaChmdW5jdGlvbihkZXBOYW1lKSB7XG5cdFx0XHR2YXIgaXNPcHRpb25hbCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoZGVwTmFtZS5jaGFyQXQoMCkgPT09ICc/JykgeyAvLyBUT0RPOiBtb3JlIERSWVxuXHRcdFx0XHRkZXBOYW1lID0gZGVwTmFtZS5zdWJzdHJpbmcoMSk7XG5cdFx0XHRcdGlzT3B0aW9uYWwgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX3RoaXMuaGFzKGRlcE5hbWUpKSB7XG5cdFx0XHRcdHZhbHVlc1tkZXBOYW1lXSA9IF90aGlzLmdldChkZXBOYW1lKTtcblx0XHRcdFx0c2F0aXNmeUNudCsrO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoaXNPcHRpb25hbCkge1xuXHRcdFx0XHRzYXRpc2Z5Q250Kys7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBpbml0aWFsbHkgc2F0aXNmaWVkXG5cdFx0aWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xuXHRcdFx0c3RhcnRGdW5jKHZhbHVlcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRUdXBsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRfdGhpcy5vZmYoYmluZFR1cGxlc1tpXVswXSwgYmluZFR1cGxlc1tpXVsxXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YmluZFR1cGxlcyA9IG51bGw7XG5cblx0XHRcdFx0Ly8gd2FzIHNhdGlzZmllZCwgc28gY2FsbCBzdG9wRnVuY1xuXHRcdFx0XHRpZiAoc2F0aXNmeUNudCA9PT0gZGVwQ250KSB7XG5cdFx0XHRcdFx0c3RvcEZ1bmMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZsYXNoOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xuXHRcdFx0XHRcdHN0b3BGdW5jKCk7XG5cdFx0XHRcdFx0c3RhcnRGdW5jKHZhbHVlcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9LFxuXG5cdGZsYXNoOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyc1tuYW1lXTtcblxuXHRcdGlmICh3YXRjaGVyKSB7XG5cdFx0XHR3YXRjaGVyLmZsYXNoKCk7XG5cdFx0fVxuXHR9XG5cbn0pO1xuXG5cbk1vZGVsLndhdGNoID0gZnVuY3Rpb24oLyogc2FtZSBhcmd1bWVudHMgYXMgdGhpcy53YXRjaCgpICovKSB7XG5cdHZhciBwcm90byA9IHRoaXMucHJvdG90eXBlO1xuXG5cdGlmICghcHJvdG8uX2dsb2JhbFdhdGNoQXJncykge1xuXHRcdHByb3RvLl9nbG9iYWxXYXRjaEFyZ3MgPSBbXTtcblx0fVxuXG5cdHByb3RvLl9nbG9iYWxXYXRjaEFyZ3MucHVzaChhcmd1bWVudHMpO1xufTtcblxuXG5GQy5Nb2RlbCA9IE1vZGVsO1xuXG5cbjs7XG5cbnZhciBQcm9taXNlID0ge1xuXG5cdGNvbnN0cnVjdDogZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0XHR2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XG5cdFx0dmFyIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XG5cblx0XHRpZiAodHlwZW9mIGV4ZWN1dG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRleGVjdXRvcihcblx0XHRcdFx0ZnVuY3Rpb24odmFsKSB7IC8vIHJlc29sdmVcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKHZhbCk7XG5cdFx0XHRcdFx0YXR0YWNoSW1tZWRpYXRlbHlSZXNvbHZpbmdUaGVuKHByb21pc2UsIHZhbCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyAvLyByZWplY3Rcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3QoKTtcblx0XHRcdFx0XHRhdHRhY2hJbW1lZGlhdGVseVJlamVjdGluZ1RoZW4ocHJvbWlzZSk7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb21pc2U7XG5cdH0sXG5cblx0cmVzb2x2ZTogZnVuY3Rpb24odmFsKSB7XG5cdFx0dmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpLnJlc29sdmUodmFsKTtcblx0XHR2YXIgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UoKTtcblxuXHRcdGF0dGFjaEltbWVkaWF0ZWx5UmVzb2x2aW5nVGhlbihwcm9taXNlLCB2YWwpO1xuXG5cdFx0cmV0dXJuIHByb21pc2U7XG5cdH0sXG5cblx0cmVqZWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCkucmVqZWN0KCk7XG5cdFx0dmFyIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XG5cblx0XHRhdHRhY2hJbW1lZGlhdGVseVJlamVjdGluZ1RoZW4ocHJvbWlzZSk7XG5cblx0XHRyZXR1cm4gcHJvbWlzZTtcblx0fVxuXG59O1xuXG5cbmZ1bmN0aW9uIGF0dGFjaEltbWVkaWF0ZWx5UmVzb2x2aW5nVGhlbihwcm9taXNlLCB2YWwpIHtcblx0cHJvbWlzZS50aGVuID0gZnVuY3Rpb24ob25SZXNvbHZlKSB7XG5cdFx0aWYgKHR5cGVvZiBvblJlc29sdmUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG9uUmVzb2x2ZSh2YWwpO1xuXHRcdH1cblx0XHRyZXR1cm4gcHJvbWlzZTsgLy8gZm9yIGNoYWluaW5nXG5cdH07XG59XG5cblxuZnVuY3Rpb24gYXR0YWNoSW1tZWRpYXRlbHlSZWplY3RpbmdUaGVuKHByb21pc2UpIHtcblx0cHJvbWlzZS50aGVuID0gZnVuY3Rpb24ob25SZXNvbHZlLCBvblJlamVjdCkge1xuXHRcdGlmICh0eXBlb2Ygb25SZWplY3QgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG9uUmVqZWN0KCk7XG5cdFx0fVxuXHRcdHJldHVybiBwcm9taXNlOyAvLyBmb3IgY2hhaW5pbmdcblx0fTtcbn1cblxuXG5GQy5Qcm9taXNlID0gUHJvbWlzZTtcblxuOztcblxudmFyIFRhc2tRdWV1ZSA9IENsYXNzLmV4dGVuZChFbWl0dGVyTWl4aW4sIHtcblxuXHRxOiBudWxsLFxuXHRpc1BhdXNlZDogZmFsc2UsXG5cdGlzUnVubmluZzogZmFsc2UsXG5cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5xID0gW107XG5cdH0sXG5cblxuXHRxdWV1ZTogZnVuY3Rpb24oLyogdGFza0Z1bmMsIHRhc2tGdW5jLi4uICovKSB7XG5cdFx0dGhpcy5xLnB1c2guYXBwbHkodGhpcy5xLCBhcmd1bWVudHMpOyAvLyBhcHBlbmRcblx0XHR0aGlzLnRyeVN0YXJ0KCk7XG5cdH0sXG5cblxuXHRwYXVzZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc1BhdXNlZCA9IHRydWU7XG5cdH0sXG5cblxuXHRyZXN1bWU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcblx0XHR0aGlzLnRyeVN0YXJ0KCk7XG5cdH0sXG5cblxuXHR0cnlTdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzUnVubmluZyAmJiB0aGlzLmNhblJ1bk5leHQoKSkge1xuXHRcdFx0dGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdzdGFydCcpO1xuXHRcdFx0dGhpcy5ydW5OZXh0KCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Y2FuUnVuTmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLmlzUGF1c2VkICYmIHRoaXMucS5sZW5ndGg7XG5cdH0sXG5cblxuXHRydW5OZXh0OiBmdW5jdGlvbigpIHsgLy8gZG9lcyBub3QgY2hlY2sgY2FuUnVuTmV4dFxuXHRcdHRoaXMucnVuVGFzayh0aGlzLnEuc2hpZnQoKSk7XG5cdH0sXG5cblxuXHRydW5UYXNrOiBmdW5jdGlvbih0YXNrKSB7XG5cdFx0dGhpcy5ydW5UYXNrRnVuYyh0YXNrKTtcblx0fSxcblxuXG5cdHJ1blRhc2tGdW5jOiBmdW5jdGlvbih0YXNrRnVuYykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHJlcyA9IHRhc2tGdW5jKCk7XG5cblx0XHRpZiAocmVzICYmIHJlcy50aGVuKSB7XG5cdFx0XHRyZXMudGhlbihkb25lKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRkb25lKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZG9uZSgpIHtcblx0XHRcdGlmIChfdGhpcy5jYW5SdW5OZXh0KCkpIHtcblx0XHRcdFx0X3RoaXMucnVuTmV4dCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdF90aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHRfdGhpcy50cmlnZ2VyKCdzdG9wJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbn0pO1xuXG5GQy5UYXNrUXVldWUgPSBUYXNrUXVldWU7XG5cbjs7XG5cbnZhciBSZW5kZXJRdWV1ZSA9IFRhc2tRdWV1ZS5leHRlbmQoe1xuXG5cdHdhaXRzQnlOYW1lc3BhY2U6IG51bGwsXG5cdHdhaXROYW1lc3BhY2U6IG51bGwsXG5cdHdhaXRJZDogbnVsbCxcblxuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbih3YWl0c0J5TmFtZXNwYWNlKSB7XG5cdFx0VGFza1F1ZXVlLmNhbGwodGhpcyk7IC8vIHN1cGVyLWNvbnN0cnVjdG9yXG5cblx0XHR0aGlzLndhaXRzQnlOYW1lc3BhY2UgPSB3YWl0c0J5TmFtZXNwYWNlIHx8IHt9O1xuXHR9LFxuXG5cblx0cXVldWU6IGZ1bmN0aW9uKHRhc2tGdW5jLCBuYW1lc3BhY2UsIHR5cGUpIHtcblx0XHR2YXIgdGFzayA9IHtcblx0XHRcdGZ1bmM6IHRhc2tGdW5jLFxuXHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0XHR0eXBlOiB0eXBlXG5cdFx0fTtcblx0XHR2YXIgd2FpdE1zO1xuXG5cdFx0aWYgKG5hbWVzcGFjZSkge1xuXHRcdFx0d2FpdE1zID0gdGhpcy53YWl0c0J5TmFtZXNwYWNlW25hbWVzcGFjZV07XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMud2FpdE5hbWVzcGFjZSkge1xuXHRcdFx0aWYgKG5hbWVzcGFjZSA9PT0gdGhpcy53YWl0TmFtZXNwYWNlICYmIHdhaXRNcyAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuZGVsYXlXYWl0KHdhaXRNcyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5jbGVhcldhaXQoKTtcblx0XHRcdFx0dGhpcy50cnlTdGFydCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLmNvbXBvdW5kVGFzayh0YXNrKSkgeyAvLyBhcHBlbmRlZCB0byBxdWV1ZT9cblxuXHRcdFx0aWYgKCF0aGlzLndhaXROYW1lc3BhY2UgJiYgd2FpdE1zICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zdGFydFdhaXQobmFtZXNwYWNlLCB3YWl0TXMpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMudHJ5U3RhcnQoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHRzdGFydFdhaXQ6IGZ1bmN0aW9uKG5hbWVzcGFjZSwgd2FpdE1zKSB7XG5cdFx0dGhpcy53YWl0TmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdHRoaXMuc3Bhd25XYWl0KHdhaXRNcyk7XG5cdH0sXG5cblxuXHRkZWxheVdhaXQ6IGZ1bmN0aW9uKHdhaXRNcykge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLndhaXRJZCk7XG5cdFx0dGhpcy5zcGF3bldhaXQod2FpdE1zKTtcblx0fSxcblxuXG5cdHNwYXduV2FpdDogZnVuY3Rpb24od2FpdE1zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHRoaXMud2FpdElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdF90aGlzLndhaXROYW1lc3BhY2UgPSBudWxsO1xuXHRcdFx0X3RoaXMudHJ5U3RhcnQoKTtcblx0XHR9LCB3YWl0TXMpO1xuXHR9LFxuXG5cblx0Y2xlYXJXYWl0OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy53YWl0TmFtZXNwYWNlKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy53YWl0SWQpO1xuXHRcdFx0dGhpcy53YWl0SWQgPSBudWxsO1xuXHRcdFx0dGhpcy53YWl0TmFtZXNwYWNlID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblxuXHRjYW5SdW5OZXh0OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIVRhc2tRdWV1ZS5wcm90b3R5cGUuY2FuUnVuTmV4dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gd2FpdGluZyBmb3IgYSBjZXJ0YWluIG5hbWVzcGFjZSB0byBzdG9wIHJlY2VpdmluZyB0YXNrcz9cblx0XHRpZiAodGhpcy53YWl0TmFtZXNwYWNlKSB7XG5cblx0XHRcdC8vIGlmIHRoZXJlIHdhcyBhIGRpZmZlcmVudCBuYW1lc3BhY2UgdGFzayBpbiB0aGUgbWVhbnRpbWUsXG5cdFx0XHQvLyB0aGF0IGZvcmNlcyBhbGwgcHJldmlvdXNseS13YWl0aW5nIHRhc2tzIHRvIHN1ZGRlbmx5IGV4ZWN1dGUuXG5cdFx0XHQvLyBUT0RPOiBmaW5kIGEgd2F5IHRvIGRvIHRoaXMgaW4gY29uc3RhbnQgdGltZS5cblx0XHRcdGZvciAodmFyIHEgPSB0aGlzLnEsIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocVtpXS5uYW1lc3BhY2UgIT09IHRoaXMud2FpdE5hbWVzcGFjZSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlOyAvLyBhbGxvdyBleGVjdXRpb25cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblxuXHRydW5UYXNrOiBmdW5jdGlvbih0YXNrKSB7XG5cdFx0dGhpcy5ydW5UYXNrRnVuYyh0YXNrLmZ1bmMpO1xuXHR9LFxuXG5cblx0Y29tcG91bmRUYXNrOiBmdW5jdGlvbihuZXdUYXNrKSB7XG5cdFx0dmFyIHEgPSB0aGlzLnE7XG5cdFx0dmFyIHNob3VsZEFwcGVuZCA9IHRydWU7XG5cdFx0dmFyIGksIHRhc2s7XG5cblx0XHRpZiAobmV3VGFzay5uYW1lc3BhY2UpIHtcblxuXHRcdFx0aWYgKG5ld1Rhc2sudHlwZSA9PT0gJ2Rlc3Ryb3knIHx8IG5ld1Rhc2sudHlwZSA9PT0gJ2luaXQnKSB7XG5cblx0XHRcdFx0Ly8gcmVtb3ZlIGFsbCBhZGQvcmVtb3ZlIG9wcyB3aXRoIHNhbWUgbmFtZXNwYWNlLCByZWdhcmRsZXNzIG9mIG9yZGVyXG5cdFx0XHRcdGZvciAoaSA9IHEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHR0YXNrID0gcVtpXTtcblxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdHRhc2submFtZXNwYWNlID09PSBuZXdUYXNrLm5hbWVzcGFjZSAmJlxuXHRcdFx0XHRcdFx0KHRhc2sudHlwZSA9PT0gJ2FkZCcgfHwgdGFzay50eXBlID09PSAncmVtb3ZlJylcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdHEuc3BsaWNlKGksIDEpOyAvLyByZW1vdmUgdGFza1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChuZXdUYXNrLnR5cGUgPT09ICdkZXN0cm95Jykge1xuXHRcdFx0XHRcdC8vIGVhdCBhd2F5IGZpbmFsIGluaXQvZGVzdHJveSBvcGVyYXRpb25cblx0XHRcdFx0XHRpZiAocS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHRhc2sgPSBxW3EubGVuZ3RoIC0gMV07IC8vIGxhc3QgdGFza1xuXG5cdFx0XHRcdFx0XHRpZiAodGFzay5uYW1lc3BhY2UgPT09IG5ld1Rhc2submFtZXNwYWNlKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gdGhlIGluaXQgYW5kIG91ciBkZXN0cm95IGNhbmNlbCBlYWNoIG90aGVyIG91dFxuXHRcdFx0XHRcdFx0XHRpZiAodGFzay50eXBlID09PSAnaW5pdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRzaG91bGRBcHBlbmQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRxLnBvcCgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIHByZWZlciB0byB1c2UgdGhlIGRlc3Ryb3kgb3BlcmF0aW9uIHRoYXQncyBhbHJlYWR5IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAodGFzay50eXBlID09PSAnZGVzdHJveScpIHtcblx0XHRcdFx0XHRcdFx0XHRzaG91bGRBcHBlbmQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChuZXdUYXNrLnR5cGUgPT09ICdpbml0Jykge1xuXHRcdFx0XHRcdC8vIGVhdCBhd2F5IGZpbmFsIGluaXQgb3BlcmF0aW9uXG5cdFx0XHRcdFx0aWYgKHEubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0YXNrID0gcVtxLmxlbmd0aCAtIDFdOyAvLyBsYXN0IHRhc2tcblxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHR0YXNrLm5hbWVzcGFjZSA9PT0gbmV3VGFzay5uYW1lc3BhY2UgJiZcblx0XHRcdFx0XHRcdFx0dGFzay50eXBlID09PSAnaW5pdCdcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHQvLyBvdXIgaW5pdCBvcGVyYXRpb24gdGFrZXMgcHJlY2VkZW5jZVxuXHRcdFx0XHRcdFx0XHRxLnBvcCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChzaG91bGRBcHBlbmQpIHtcblx0XHRcdHEucHVzaChuZXdUYXNrKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2hvdWxkQXBwZW5kO1xuXHR9XG5cbn0pO1xuXG5GQy5SZW5kZXJRdWV1ZSA9IFJlbmRlclF1ZXVlO1xuXG47O1xuXG52YXIgRW1pdHRlck1peGluID0gRkMuRW1pdHRlck1peGluID0ge1xuXG5cdC8vIGpRdWVyeS1pZmljYXRpb24gdmlhICQodGhpcykgYWxsb3dzIGEgbm9uLURPTSBvYmplY3QgdG8gaGF2ZVxuXHQvLyB0aGUgc2FtZSBldmVudCBoYW5kbGluZyBjYXBhYmlsaXRpZXMgKGluY2x1ZGluZyBuYW1lc3BhY2VzKS5cblxuXG5cdG9uOiBmdW5jdGlvbih0eXBlcywgaGFuZGxlcikge1xuXHRcdCQodGhpcykub24odHlwZXMsIHRoaXMuX3ByZXBhcmVJbnRlcmNlcHQoaGFuZGxlcikpO1xuXHRcdHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcblx0fSxcblxuXG5cdG9uZTogZnVuY3Rpb24odHlwZXMsIGhhbmRsZXIpIHtcblx0XHQkKHRoaXMpLm9uZSh0eXBlcywgdGhpcy5fcHJlcGFyZUludGVyY2VwdChoYW5kbGVyKSk7XG5cdFx0cmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xuXHR9LFxuXG5cblx0X3ByZXBhcmVJbnRlcmNlcHQ6IGZ1bmN0aW9uKGhhbmRsZXIpIHtcblx0XHQvLyBoYW5kbGVycyBhcmUgYWx3YXlzIGNhbGxlZCB3aXRoIGFuIFwiZXZlbnRcIiBvYmplY3QgYXMgdGhlaXIgZmlyc3QgcGFyYW0uXG5cdFx0Ly8gc25lYWsgdGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhcmd1bWVudHMgaW50byB0aGUgZXh0cmEgcGFyYW1ldGVyIG9iamVjdFxuXHRcdC8vIGFuZCBmb3J3YXJkIHRoZW0gb24gdG8gdGhlIG9yaWdpbmFsIGhhbmRsZXIuXG5cdFx0dmFyIGludGVyY2VwdCA9IGZ1bmN0aW9uKGV2LCBleHRyYSkge1xuXHRcdFx0cmV0dXJuIGhhbmRsZXIuYXBwbHkoXG5cdFx0XHRcdGV4dHJhLmNvbnRleHQgfHwgdGhpcyxcblx0XHRcdFx0ZXh0cmEuYXJncyB8fCBbXVxuXHRcdFx0KTtcblx0XHR9O1xuXG5cdFx0Ly8gbWltaWNrIGpRdWVyeSdzIGludGVybmFsIFwicHJveHlcIiBzeXN0ZW0gKHJpc2t5LCBJIGtub3cpXG5cdFx0Ly8gY2F1c2luZyBhbGwgZnVuY3Rpb25zIHdpdGggdGhlIHNhbWUgLmd1aWQgdG8gYXBwZWFyIHRvIGJlIHRoZSBzYW1lLlxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvMi4yLjQvc3JjL2NvcmUuanMjTDQ0OFxuXHRcdC8vIHRoaXMgaXMgbmVlZGVkIGZvciBjYWxsaW5nIC5vZmYgd2l0aCB0aGUgb3JpZ2luYWwgbm9uLWludGVyY2VwdCBoYW5kbGVyLlxuXHRcdGlmICghaGFuZGxlci5ndWlkKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSAkLmd1aWQrKztcblx0XHR9XG5cdFx0aW50ZXJjZXB0Lmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cblx0XHRyZXR1cm4gaW50ZXJjZXB0O1xuXHR9LFxuXG5cblx0b2ZmOiBmdW5jdGlvbih0eXBlcywgaGFuZGxlcikge1xuXHRcdCQodGhpcykub2ZmKHR5cGVzLCBoYW5kbGVyKTtcblxuXHRcdHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcblx0fSxcblxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKHR5cGVzKSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBhcmd1bWVudHMgYWZ0ZXIgdGhlIGZpcnN0XG5cblx0XHQvLyBwYXNzIGluIFwiZXh0cmFcIiBpbmZvIHRvIHRoZSBpbnRlcmNlcHRcblx0XHQkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKHR5cGVzLCB7IGFyZ3M6IGFyZ3MgfSk7XG5cblx0XHRyZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG5cdH0sXG5cblxuXHR0cmlnZ2VyV2l0aDogZnVuY3Rpb24odHlwZXMsIGNvbnRleHQsIGFyZ3MpIHtcblxuXHRcdC8vIGB0cmlnZ2VySGFuZGxlcmAgaXMgbGVzcyByZWxpYW50IG9uIHRoZSBET00gY29tcGFyZWQgdG8gYHRyaWdnZXJgLlxuXHRcdC8vIHBhc3MgaW4gXCJleHRyYVwiIGluZm8gdG8gdGhlIGludGVyY2VwdC5cblx0XHQkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKHR5cGVzLCB7IGNvbnRleHQ6IGNvbnRleHQsIGFyZ3M6IGFyZ3MgfSk7XG5cblx0XHRyZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG5cdH1cblxufTtcblxuOztcblxuLypcblV0aWxpdHkgbWV0aG9kcyBmb3IgZWFzaWx5IGxpc3RlbmluZyB0byBldmVudHMgb24gYW5vdGhlciBvYmplY3QsXG5hbmQgbW9yZSBpbXBvcnRhbnRseSwgZWFzaWx5IHVubGlzdGVuaW5nIGZyb20gdGhlbS5cbiovXG52YXIgTGlzdGVuZXJNaXhpbiA9IEZDLkxpc3RlbmVyTWl4aW4gPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBndWlkID0gMDtcblx0dmFyIExpc3RlbmVyTWl4aW4gPSB7XG5cblx0XHRsaXN0ZW5lcklkOiBudWxsLFxuXG5cdFx0Lypcblx0XHRHaXZlbiBhbiBgb3RoZXJgIG9iamVjdCB0aGF0IGhhcyBvbi9vZmYgbWV0aG9kcywgYmluZCB0aGUgZ2l2ZW4gYGNhbGxiYWNrYCB0byBhbiBldmVudCBieSB0aGUgZ2l2ZW4gbmFtZS5cblx0XHRUaGUgYGNhbGxiYWNrYCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgb2JqZWN0IHRoYXQgLmxpc3RlblRvIGlzIGJlaW5nIGNhbGxlZCBvbi5cblx0XHRDYW4gYmUgY2FsbGVkOlxuXHRcdFx0Lmxpc3RlblRvKG90aGVyLCBldmVudE5hbWUsIGNhbGxiYWNrKVxuXHRcdE9SXG5cdFx0XHQubGlzdGVuVG8ob3RoZXIsIHtcblx0XHRcdFx0ZXZlbnROYW1lMTogY2FsbGJhY2sxLFxuXHRcdFx0XHRldmVudE5hbWUyOiBjYWxsYmFjazJcblx0XHRcdH0pXG5cdFx0Ki9cblx0XHRsaXN0ZW5UbzogZnVuY3Rpb24ob3RoZXIsIGFyZywgY2FsbGJhY2spIHtcblx0XHRcdGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JykgeyAvLyBnaXZlbiBkaWN0aW9uYXJ5IG9mIGNhbGxiYWNrc1xuXHRcdFx0XHRmb3IgKHZhciBldmVudE5hbWUgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGFyZy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmxpc3RlblRvKG90aGVyLCBldmVudE5hbWUsIGFyZ1tldmVudE5hbWVdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdG90aGVyLm9uKFxuXHRcdFx0XHRcdGFyZyArICcuJyArIHRoaXMuZ2V0TGlzdGVuZXJOYW1lc3BhY2UoKSwgLy8gdXNlIGV2ZW50IG5hbWVzcGFjaW5nIHRvIGlkZW50aWZ5IHRoaXMgb2JqZWN0XG5cdFx0XHRcdFx0JC5wcm94eShjYWxsYmFjaywgdGhpcykgLy8gYWx3YXlzIHVzZSBgdGhpc2AgY29udGV4dFxuXHRcdFx0XHRcdFx0Ly8gdGhlIHVzdWFsbHktdW5kZXNpcmVkIGpRdWVyeSBndWlkIGJlaGF2aW9yIGRvZXNuJ3QgbWF0dGVyLFxuXHRcdFx0XHRcdFx0Ly8gYmVjYXVzZSB3ZSBhbHdheXMgdW5iaW5kIHZpYSBuYW1lc3BhY2Vcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Lypcblx0XHRDYXVzZXMgdGhlIGN1cnJlbnQgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGV2ZW50cyBvbiB0aGUgYG90aGVyYCBvYmplY3QuXG5cdFx0YGV2ZW50TmFtZWAgaXMgb3B0aW9uYWwuIElmIG9taXR0ZWQsIHdpbGwgc3RvcCBsaXN0ZW5pbmcgdG8gQUxMIGV2ZW50cyBvbiBgb3RoZXJgLlxuXHRcdCovXG5cdFx0c3RvcExpc3RlbmluZ1RvOiBmdW5jdGlvbihvdGhlciwgZXZlbnROYW1lKSB7XG5cdFx0XHRvdGhlci5vZmYoKGV2ZW50TmFtZSB8fCAnJykgKyAnLicgKyB0aGlzLmdldExpc3RlbmVyTmFtZXNwYWNlKCkpO1xuXHRcdH0sXG5cblx0XHQvKlxuXHRcdFJldHVybnMgYSBzdHJpbmcsIHVuaXF1ZSB0byB0aGlzIG9iamVjdCwgdG8gYmUgdXNlZCBmb3IgZXZlbnQgbmFtZXNwYWNpbmdcblx0XHQqL1xuXHRcdGdldExpc3RlbmVyTmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLmxpc3RlbmVySWQgPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmxpc3RlbmVySWQgPSBndWlkKys7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ19saXN0ZW5lcicgKyB0aGlzLmxpc3RlbmVySWQ7XG5cdFx0fVxuXG5cdH07XG5cdHJldHVybiBMaXN0ZW5lck1peGluO1xufSkoKTtcbjs7XG5cbi8qIEEgcmVjdGFuZ3VsYXIgcGFuZWwgdGhhdCBpcyBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgb3ZlciBvdGhlciBjb250ZW50XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbk9wdGlvbnM6XG5cdC0gY2xhc3NOYW1lIChzdHJpbmcpXG5cdC0gY29udGVudCAoSFRNTCBzdHJpbmcgb3IgalF1ZXJ5IGVsZW1lbnQgc2V0KVxuXHQtIHBhcmVudEVsXG5cdC0gdG9wXG5cdC0gbGVmdFxuXHQtIHJpZ2h0ICh0aGUgeCBjb29yZCBvZiB3aGVyZSB0aGUgcmlnaHQgZWRnZSBzaG91bGQgYmUuIG5vdCBhIFwiQ1NTXCIgcmlnaHQpXG5cdC0gYXV0b0hpZGUgKGJvb2xlYW4pXG5cdC0gc2hvdyAoY2FsbGJhY2spXG5cdC0gaGlkZSAoY2FsbGJhY2spXG4qL1xuXG52YXIgUG9wb3ZlciA9IENsYXNzLmV4dGVuZChMaXN0ZW5lck1peGluLCB7XG5cblx0aXNIaWRkZW46IHRydWUsXG5cdG9wdGlvbnM6IG51bGwsXG5cdGVsOiBudWxsLCAvLyB0aGUgY29udGFpbmVyIGVsZW1lbnQgZm9yIHRoZSBwb3BvdmVyLiBnZW5lcmF0ZWQgYnkgdGhpcyBvYmplY3Rcblx0bWFyZ2luOiAxMCwgLy8gdGhlIHNwYWNlIHJlcXVpcmVkIGJldHdlZW4gdGhlIHBvcG92ZXIgYW5kIHRoZSBlZGdlcyBvZiB0aGUgc2Nyb2xsIGNvbnRhaW5lclxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHR9LFxuXG5cblx0Ly8gU2hvd3MgdGhlIHBvcG92ZXIgb24gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gUmVuZGVycyBpdCBpZiBub3QgYWxyZWFkeVxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5pc0hpZGRlbikge1xuXHRcdFx0aWYgKCF0aGlzLmVsKSB7XG5cdFx0XHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVsLnNob3coKTtcblx0XHRcdHRoaXMucG9zaXRpb24oKTtcblx0XHRcdHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcblx0XHRcdHRoaXMudHJpZ2dlcignc2hvdycpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEhpZGVzIHRoZSBwb3BvdmVyLCB0aHJvdWdoIENTUywgYnV0IGRvZXMgbm90IHJlbW92ZSBpdCBmcm9tIHRoZSBET01cblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzSGlkZGVuKSB7XG5cdFx0XHR0aGlzLmVsLmhpZGUoKTtcblx0XHRcdHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdoaWRlJyk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ3JlYXRlcyBgdGhpcy5lbGAgYW5kIHJlbmRlcnMgY29udGVudCBpbnNpZGUgb2YgaXRcblx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5lbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1wb3BvdmVyXCIvPicpXG5cdFx0XHQuYWRkQ2xhc3Mob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpXG5cdFx0XHQuY3NzKHtcblx0XHRcdFx0Ly8gcG9zaXRpb24gaW5pdGlhbGx5IHRvIHRoZSB0b3AgbGVmdCB0byBhdm9pZCBjcmVhdGluZyBzY3JvbGxiYXJzXG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0bGVmdDogMFxuXHRcdFx0fSlcblx0XHRcdC5hcHBlbmQob3B0aW9ucy5jb250ZW50KVxuXHRcdFx0LmFwcGVuZFRvKG9wdGlvbnMucGFyZW50RWwpO1xuXG5cdFx0Ly8gd2hlbiBhIGNsaWNrIGhhcHBlbnMgb24gYW55dGhpbmcgaW5zaWRlIHdpdGggYSAnZmMtY2xvc2UnIGNsYXNzTmFtZSwgaGlkZSB0aGUgcG9wb3ZlclxuXHRcdHRoaXMuZWwub24oJ2NsaWNrJywgJy5mYy1jbG9zZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0X3RoaXMuaGlkZSgpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKG9wdGlvbnMuYXV0b0hpZGUpIHtcblx0XHRcdHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksICdtb3VzZWRvd24nLCB0aGlzLmRvY3VtZW50TW91c2Vkb3duKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKmFueXdoZXJlKiBpbiB0aGUgZG9jdW1lbnQsIGZvciB0aGUgYXV0b0hpZGUgZmVhdHVyZVxuXHRkb2N1bWVudE1vdXNlZG93bjogZnVuY3Rpb24oZXYpIHtcblx0XHQvLyBvbmx5IGhpZGUgdGhlIHBvcG92ZXIgaWYgdGhlIGNsaWNrIGhhcHBlbmVkIG91dHNpZGUgdGhlIHBvcG92ZXJcblx0XHRpZiAodGhpcy5lbCAmJiAhJChldi50YXJnZXQpLmNsb3Nlc3QodGhpcy5lbCkubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmhpZGUoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBIaWRlcyBhbmQgdW5yZWdpc3RlcnMgYW55IGhhbmRsZXJzXG5cdHJlbW92ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGlkZSgpO1xuXG5cdFx0aWYgKHRoaXMuZWwpIHtcblx0XHRcdHRoaXMuZWwucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLmVsID0gbnVsbDtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSwgJ21vdXNlZG93bicpO1xuXHR9LFxuXG5cblx0Ly8gUG9zaXRpb25zIHRoZSBwb3BvdmVyIG9wdGltYWxseSwgdXNpbmcgdGhlIHRvcC9sZWZ0L3JpZ2h0IG9wdGlvbnNcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdHZhciBvcmlnaW4gPSB0aGlzLmVsLm9mZnNldFBhcmVudCgpLm9mZnNldCgpO1xuXHRcdHZhciB3aWR0aCA9IHRoaXMuZWwub3V0ZXJXaWR0aCgpO1xuXHRcdHZhciBoZWlnaHQgPSB0aGlzLmVsLm91dGVySGVpZ2h0KCk7XG5cdFx0dmFyIHdpbmRvd0VsID0gJCh3aW5kb3cpO1xuXHRcdHZhciB2aWV3cG9ydEVsID0gZ2V0U2Nyb2xsUGFyZW50KHRoaXMuZWwpO1xuXHRcdHZhciB2aWV3cG9ydFRvcDtcblx0XHR2YXIgdmlld3BvcnRMZWZ0O1xuXHRcdHZhciB2aWV3cG9ydE9mZnNldDtcblx0XHR2YXIgdG9wOyAvLyB0aGUgXCJwb3NpdGlvblwiIChub3QgXCJvZmZzZXRcIikgdmFsdWVzIGZvciB0aGUgcG9wb3ZlclxuXHRcdHZhciBsZWZ0OyAvL1xuXG5cdFx0Ly8gY29tcHV0ZSB0b3AgYW5kIGxlZnRcblx0XHR0b3AgPSBvcHRpb25zLnRvcCB8fCAwO1xuXHRcdGlmIChvcHRpb25zLmxlZnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bGVmdCA9IG9wdGlvbnMubGVmdDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAob3B0aW9ucy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRsZWZ0ID0gb3B0aW9ucy5yaWdodCAtIHdpZHRoOyAvLyBkZXJpdmUgdGhlIGxlZnQgdmFsdWUgZnJvbSB0aGUgcmlnaHQgdmFsdWVcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRsZWZ0ID0gMDtcblx0XHR9XG5cblx0XHRpZiAodmlld3BvcnRFbC5pcyh3aW5kb3cpIHx8IHZpZXdwb3J0RWwuaXMoZG9jdW1lbnQpKSB7IC8vIG5vcm1hbGl6ZSBnZXRTY3JvbGxQYXJlbnQncyByZXN1bHRcblx0XHRcdHZpZXdwb3J0RWwgPSB3aW5kb3dFbDtcblx0XHRcdHZpZXdwb3J0VG9wID0gMDsgLy8gdGhlIHdpbmRvdyBpcyBhbHdheXMgYXQgdGhlIHRvcCBsZWZ0XG5cdFx0XHR2aWV3cG9ydExlZnQgPSAwOyAvLyAoYW5kIC5vZmZzZXQoKSB3b24ndCB3b3JrIGlmIGNhbGxlZCBoZXJlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZpZXdwb3J0T2Zmc2V0ID0gdmlld3BvcnRFbC5vZmZzZXQoKTtcblx0XHRcdHZpZXdwb3J0VG9wID0gdmlld3BvcnRPZmZzZXQudG9wO1xuXHRcdFx0dmlld3BvcnRMZWZ0ID0gdmlld3BvcnRPZmZzZXQubGVmdDtcblx0XHR9XG5cblx0XHQvLyBpZiB0aGUgd2luZG93IGlzIHNjcm9sbGVkLCBpdCBjYXVzZXMgdGhlIHZpc2libGUgYXJlYSB0byBiZSBmdXJ0aGVyIGRvd25cblx0XHR2aWV3cG9ydFRvcCArPSB3aW5kb3dFbC5zY3JvbGxUb3AoKTtcblx0XHR2aWV3cG9ydExlZnQgKz0gd2luZG93RWwuc2Nyb2xsTGVmdCgpO1xuXG5cdFx0Ly8gY29uc3RyYWluIHRvIHRoZSB2aWV3IHBvcnQuIGlmIGNvbnN0cmFpbmVkIGJ5IHR3byBlZGdlcywgZ2l2ZSBwcmVjZWRlbmNlIHRvIHRvcC9sZWZ0XG5cdFx0aWYgKG9wdGlvbnMudmlld3BvcnRDb25zdHJhaW4gIT09IGZhbHNlKSB7XG5cdFx0XHR0b3AgPSBNYXRoLm1pbih0b3AsIHZpZXdwb3J0VG9wICsgdmlld3BvcnRFbC5vdXRlckhlaWdodCgpIC0gaGVpZ2h0IC0gdGhpcy5tYXJnaW4pO1xuXHRcdFx0dG9wID0gTWF0aC5tYXgodG9wLCB2aWV3cG9ydFRvcCArIHRoaXMubWFyZ2luKTtcblx0XHRcdGxlZnQgPSBNYXRoLm1pbihsZWZ0LCB2aWV3cG9ydExlZnQgKyB2aWV3cG9ydEVsLm91dGVyV2lkdGgoKSAtIHdpZHRoIC0gdGhpcy5tYXJnaW4pO1xuXHRcdFx0bGVmdCA9IE1hdGgubWF4KGxlZnQsIHZpZXdwb3J0TGVmdCArIHRoaXMubWFyZ2luKTtcblx0XHR9XG5cblx0XHR0aGlzLmVsLmNzcyh7XG5cdFx0XHR0b3A6IHRvcCAtIG9yaWdpbi50b3AsXG5cdFx0XHRsZWZ0OiBsZWZ0IC0gb3JpZ2luLmxlZnRcblx0XHR9KTtcblx0fSxcblxuXG5cdC8vIFRyaWdnZXJzIGEgY2FsbGJhY2suIENhbGxzIGEgZnVuY3Rpb24gaW4gdGhlIG9wdGlvbiBoYXNoIG9mIHRoZSBzYW1lIG5hbWUuXG5cdC8vIEFyZ3VtZW50cyBiZXlvbmQgdGhlIGZpcnN0IGBuYW1lYCBhcmUgZm9yd2FyZGVkIG9uLlxuXHQvLyBUT0RPOiBiZXR0ZXIgY29kZSByZXVzZSBmb3IgdGhpcy4gUmVwZWF0IGNvZGVcblx0dHJpZ2dlcjogZnVuY3Rpb24obmFtZSkge1xuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcblx0XHRcdHRoaXMub3B0aW9uc1tuYW1lXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcblx0XHR9XG5cdH1cblxufSk7XG5cbjs7XG5cbi8qXG5BIGNhY2hlIGZvciB0aGUgbGVmdC9yaWdodC90b3AvYm90dG9tL3dpZHRoL2hlaWdodCB2YWx1ZXMgZm9yIG9uZSBvciBtb3JlIGVsZW1lbnRzLlxuV29ya3Mgd2l0aCBib3RoIG9mZnNldCAoZnJvbSB0b3BsZWZ0IGRvY3VtZW50KSBhbmQgcG9zaXRpb24gKGZyb20gb2Zmc2V0UGFyZW50KS5cblxub3B0aW9uczpcbi0gZWxzXG4tIGlzSG9yaXpvbnRhbFxuLSBpc1ZlcnRpY2FsXG4qL1xudmFyIENvb3JkQ2FjaGUgPSBGQy5Db29yZENhY2hlID0gQ2xhc3MuZXh0ZW5kKHtcblxuXHRlbHM6IG51bGwsIC8vIGpRdWVyeSBzZXQgKGFzc3VtZWQgdG8gYmUgc2libGluZ3MpXG5cdGZvcmNlZE9mZnNldFBhcmVudEVsOiBudWxsLCAvLyBvcHRpb25zIGNhbiBvdmVycmlkZSB0aGUgbmF0dXJhbCBvZmZzZXRQYXJlbnRcblx0b3JpZ2luOiBudWxsLCAvLyB7bGVmdCx0b3B9IHBvc2l0aW9uIG9mIG9mZnNldFBhcmVudCBvZiBlbHNcblx0Ym91bmRpbmdSZWN0OiBudWxsLCAvLyBjb25zdHJhaW4gY29yZGluYXRlcyB0byB0aGlzIHJlY3RhbmdsZS4ge2xlZnQscmlnaHQsdG9wLGJvdHRvbX0gb3IgbnVsbFxuXHRpc0hvcml6b250YWw6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHF1ZXJ5IGZvciBsZWZ0L3JpZ2h0L3dpZHRoXG5cdGlzVmVydGljYWw6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHF1ZXJ5IGZvciB0b3AvYm90dG9tL2hlaWdodFxuXG5cdC8vIGFycmF5cyBvZiBjb29yZGluYXRlcyAob2Zmc2V0cyBmcm9tIHRvcGxlZnQgb2YgZG9jdW1lbnQpXG5cdGxlZnRzOiBudWxsLFxuXHRyaWdodHM6IG51bGwsXG5cdHRvcHM6IG51bGwsXG5cdGJvdHRvbXM6IG51bGwsXG5cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHRoaXMuZWxzID0gJChvcHRpb25zLmVscyk7XG5cdFx0dGhpcy5pc0hvcml6b250YWwgPSBvcHRpb25zLmlzSG9yaXpvbnRhbDtcblx0XHR0aGlzLmlzVmVydGljYWwgPSBvcHRpb25zLmlzVmVydGljYWw7XG5cdFx0dGhpcy5mb3JjZWRPZmZzZXRQYXJlbnRFbCA9IG9wdGlvbnMub2Zmc2V0UGFyZW50ID8gJChvcHRpb25zLm9mZnNldFBhcmVudCkgOiBudWxsO1xuXHR9LFxuXG5cblx0Ly8gUXVlcmllcyB0aGUgZWxzIGZvciBjb29yZGluYXRlcyBhbmQgc3RvcmVzIHRoZW0uXG5cdC8vIENhbGwgdGhpcyBtZXRob2QgYmVmb3JlIHVzaW5nIGFuZCBvZiB0aGUgZ2V0KiBtZXRob2RzIGJlbG93LlxuXHRidWlsZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9mZnNldFBhcmVudEVsID0gdGhpcy5mb3JjZWRPZmZzZXRQYXJlbnRFbDtcblx0XHRpZiAoIW9mZnNldFBhcmVudEVsICYmIHRoaXMuZWxzLmxlbmd0aCA+IDApIHtcblx0XHRcdG9mZnNldFBhcmVudEVsID0gdGhpcy5lbHMuZXEoMCkub2Zmc2V0UGFyZW50KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vcmlnaW4gPSBvZmZzZXRQYXJlbnRFbCA/XG5cdFx0XHRvZmZzZXRQYXJlbnRFbC5vZmZzZXQoKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0dGhpcy5ib3VuZGluZ1JlY3QgPSB0aGlzLnF1ZXJ5Qm91bmRpbmdSZWN0KCk7XG5cblx0XHRpZiAodGhpcy5pc0hvcml6b250YWwpIHtcblx0XHRcdHRoaXMuYnVpbGRFbEhvcml6b250YWxzKCk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmlzVmVydGljYWwpIHtcblx0XHRcdHRoaXMuYnVpbGRFbFZlcnRpY2FscygpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIERlc3Ryb3lzIGFsbCBpbnRlcm5hbCBkYXRhIGFib3V0IGNvb3JkaW5hdGVzLCBmcmVlaW5nIG1lbW9yeVxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5vcmlnaW4gPSBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdSZWN0ID0gbnVsbDtcblx0XHR0aGlzLmxlZnRzID0gbnVsbDtcblx0XHR0aGlzLnJpZ2h0cyA9IG51bGw7XG5cdFx0dGhpcy50b3BzID0gbnVsbDtcblx0XHR0aGlzLmJvdHRvbXMgPSBudWxsO1xuXHR9LFxuXG5cblx0Ly8gV2hlbiBjYWxsZWQsIGlmIGNvb3JkIGNhY2hlcyBhcmVuJ3QgYnVpbHQsIGJ1aWxkcyB0aGVtXG5cdGVuc3VyZUJ1aWx0OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMub3JpZ2luKSB7XG5cdFx0XHR0aGlzLmJ1aWxkKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG5cdGJ1aWxkRWxIb3Jpem9udGFsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxlZnRzID0gW107XG5cdFx0dmFyIHJpZ2h0cyA9IFtdO1xuXG5cdFx0dGhpcy5lbHMuZWFjaChmdW5jdGlvbihpLCBub2RlKSB7XG5cdFx0XHR2YXIgZWwgPSAkKG5vZGUpO1xuXHRcdFx0dmFyIGxlZnQgPSBlbC5vZmZzZXQoKS5sZWZ0O1xuXHRcdFx0dmFyIHdpZHRoID0gZWwub3V0ZXJXaWR0aCgpO1xuXG5cdFx0XHRsZWZ0cy5wdXNoKGxlZnQpO1xuXHRcdFx0cmlnaHRzLnB1c2gobGVmdCArIHdpZHRoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMubGVmdHMgPSBsZWZ0cztcblx0XHR0aGlzLnJpZ2h0cyA9IHJpZ2h0cztcblx0fSxcblxuXG5cdC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuXHRidWlsZEVsVmVydGljYWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdG9wcyA9IFtdO1xuXHRcdHZhciBib3R0b21zID0gW107XG5cblx0XHR0aGlzLmVscy5lYWNoKGZ1bmN0aW9uKGksIG5vZGUpIHtcblx0XHRcdHZhciBlbCA9ICQobm9kZSk7XG5cdFx0XHR2YXIgdG9wID0gZWwub2Zmc2V0KCkudG9wO1xuXHRcdFx0dmFyIGhlaWdodCA9IGVsLm91dGVySGVpZ2h0KCk7XG5cblx0XHRcdHRvcHMucHVzaCh0b3ApO1xuXHRcdFx0Ym90dG9tcy5wdXNoKHRvcCArIGhlaWdodCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnRvcHMgPSB0b3BzO1xuXHRcdHRoaXMuYm90dG9tcyA9IGJvdHRvbXM7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0cy5cblx0Ly8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxuXHRnZXRIb3Jpem9udGFsSW5kZXg6IGZ1bmN0aW9uKGxlZnRPZmZzZXQpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cblx0XHR2YXIgbGVmdHMgPSB0aGlzLmxlZnRzO1xuXHRcdHZhciByaWdodHMgPSB0aGlzLnJpZ2h0cztcblx0XHR2YXIgbGVuID0gbGVmdHMubGVuZ3RoO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAobGVmdE9mZnNldCA+PSBsZWZ0c1tpXSAmJiBsZWZ0T2Zmc2V0IDwgcmlnaHRzW2ldKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIEdpdmVuIGEgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCB2ZXJ0aWNhbGx5IGludGVyc2VjdHMuXG5cdC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cblx0Z2V0VmVydGljYWxJbmRleDogZnVuY3Rpb24odG9wT2Zmc2V0KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXG5cdFx0dmFyIHRvcHMgPSB0aGlzLnRvcHM7XG5cdFx0dmFyIGJvdHRvbXMgPSB0aGlzLmJvdHRvbXM7XG5cdFx0dmFyIGxlbiA9IHRvcHMubGVuZ3RoO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAodG9wT2Zmc2V0ID49IHRvcHNbaV0gJiYgdG9wT2Zmc2V0IDwgYm90dG9tc1tpXSkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0Z2V0TGVmdE9mZnNldDogZnVuY3Rpb24obGVmdEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLmxlZnRzW2xlZnRJbmRleF07XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSBsZWZ0IHBvc2l0aW9uIChmcm9tIG9mZnNldFBhcmVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0Z2V0TGVmdFBvc2l0aW9uOiBmdW5jdGlvbihsZWZ0SW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMubGVmdHNbbGVmdEluZGV4XSAtIHRoaXMub3JpZ2luLmxlZnQ7XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSByaWdodCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQncyByaWdodCBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcInJpZ2h0XCIgd291bGQgYmUuXG5cdGdldFJpZ2h0T2Zmc2V0OiBmdW5jdGlvbihsZWZ0SW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF07XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSByaWdodCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgb2Zmc2V0UGFyZW50J3MgcmlnaHQgZWRnZSwgbGlrZSB0aGUgQ1NTIGNvbmNlcHQgb2YgXCJyaWdodFwiIHdvdWxkIGJlLlxuXHRnZXRSaWdodFBvc2l0aW9uOiBmdW5jdGlvbihsZWZ0SW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLm9yaWdpbi5sZWZ0O1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG5cdGdldFdpZHRoOiBmdW5jdGlvbihsZWZ0SW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLmxlZnRzW2xlZnRJbmRleF07XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSB0b3Agb2Zmc2V0IChmcm9tIGRvY3VtZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG5cdGdldFRvcE9mZnNldDogZnVuY3Rpb24odG9wSW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMudG9wc1t0b3BJbmRleF07XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSB0b3AgcG9zaXRpb24gKGZyb20gb2Zmc2V0UGFyZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG5cdGdldFRvcFBvc2l0aW9uOiBmdW5jdGlvbih0b3BJbmRleCkge1xuXHRcdHRoaXMuZW5zdXJlQnVpbHQoKTtcblx0XHRyZXR1cm4gdGhpcy50b3BzW3RvcEluZGV4XSAtIHRoaXMub3JpZ2luLnRvcDtcblx0fSxcblxuXHQvLyBHZXRzIHRoZSBib3R0b20gb2Zmc2V0IChmcm9tIHRoZSBkb2N1bWVudCB0b3ApIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleC5cblx0Ly8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIG9mZnNldFBhcmVudCdzIGJvdHRvbSBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcImJvdHRvbVwiIHdvdWxkIGJlLlxuXHRnZXRCb3R0b21PZmZzZXQ6IGZ1bmN0aW9uKHRvcEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdO1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgYm90dG9tIHBvc2l0aW9uIChmcm9tIHRoZSBvZmZzZXRQYXJlbnQgdG9wKSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5cdC8vIFRoaXMgdmFsdWUgaXMgTk9UIHJlbGF0aXZlIHRvIHRoZSBvZmZzZXRQYXJlbnQncyBib3R0b20gZWRnZSwgbGlrZSB0aGUgQ1NTIGNvbmNlcHQgb2YgXCJib3R0b21cIiB3b3VsZCBiZS5cblx0Z2V0Qm90dG9tUG9zaXRpb246IGZ1bmN0aW9uKHRvcEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy5vcmlnaW4udG9wO1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuXHRnZXRIZWlnaHQ6IGZ1bmN0aW9uKHRvcEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy50b3BzW3RvcEluZGV4XTtcblx0fSxcblxuXG5cdC8vIEJvdW5kaW5nIFJlY3Rcblx0Ly8gVE9ETzogZGVjb3VwbGUgdGhpcyBmcm9tIENvb3JkQ2FjaGVcblxuXHQvLyBDb21wdXRlIGFuZCByZXR1cm4gd2hhdCB0aGUgZWxlbWVudHMnIGJvdW5kaW5nIHJlY3RhbmdsZSBpcywgZnJvbSB0aGUgdXNlcidzIHBlcnNwZWN0aXZlLlxuXHQvLyBSaWdodCBub3csIG9ubHkgcmV0dXJucyBhIHJlY3RhbmdsZSBpZiBjb25zdHJhaW5lZCBieSBhbiBvdmVyZmxvdzpzY3JvbGwgZWxlbWVudC5cblx0Ly8gUmV0dXJucyBudWxsIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50c1xuXHRxdWVyeUJvdW5kaW5nUmVjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjcm9sbFBhcmVudEVsO1xuXG5cdFx0aWYgKHRoaXMuZWxzLmxlbmd0aCA+IDApIHtcblx0XHRcdHNjcm9sbFBhcmVudEVsID0gZ2V0U2Nyb2xsUGFyZW50KHRoaXMuZWxzLmVxKDApKTtcblxuXHRcdFx0aWYgKCFzY3JvbGxQYXJlbnRFbC5pcyhkb2N1bWVudCkpIHtcblx0XHRcdFx0cmV0dXJuIGdldENsaWVudFJlY3Qoc2Nyb2xsUGFyZW50RWwpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGlzUG9pbnRJbkJvdW5kczogZnVuY3Rpb24obGVmdE9mZnNldCwgdG9wT2Zmc2V0KSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNMZWZ0SW5Cb3VuZHMobGVmdE9mZnNldCkgJiYgdGhpcy5pc1RvcEluQm91bmRzKHRvcE9mZnNldCk7XG5cdH0sXG5cblx0aXNMZWZ0SW5Cb3VuZHM6IGZ1bmN0aW9uKGxlZnRPZmZzZXQpIHtcblx0XHRyZXR1cm4gIXRoaXMuYm91bmRpbmdSZWN0IHx8IChsZWZ0T2Zmc2V0ID49IHRoaXMuYm91bmRpbmdSZWN0LmxlZnQgJiYgbGVmdE9mZnNldCA8IHRoaXMuYm91bmRpbmdSZWN0LnJpZ2h0KTtcblx0fSxcblxuXHRpc1RvcEluQm91bmRzOiBmdW5jdGlvbih0b3BPZmZzZXQpIHtcblx0XHRyZXR1cm4gIXRoaXMuYm91bmRpbmdSZWN0IHx8ICh0b3BPZmZzZXQgPj0gdGhpcy5ib3VuZGluZ1JlY3QudG9wICYmIHRvcE9mZnNldCA8IHRoaXMuYm91bmRpbmdSZWN0LmJvdHRvbSk7XG5cdH1cblxufSk7XG5cbjs7XG5cbi8qIFRyYWNrcyBhIGRyYWcncyBtb3VzZSBtb3ZlbWVudCwgZmlyaW5nIHZhcmlvdXMgaGFuZGxlcnNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gVE9ETzogdXNlIEVtaXR0ZXJcblxudmFyIERyYWdMaXN0ZW5lciA9IEZDLkRyYWdMaXN0ZW5lciA9IENsYXNzLmV4dGVuZChMaXN0ZW5lck1peGluLCB7XG5cblx0b3B0aW9uczogbnVsbCxcblx0c3ViamVjdEVsOiBudWxsLFxuXG5cdC8vIGNvb3JkaW5hdGVzIG9mIHRoZSBpbml0aWFsIG1vdXNlZG93blxuXHRvcmlnaW5YOiBudWxsLFxuXHRvcmlnaW5ZOiBudWxsLFxuXG5cdC8vIHRoZSB3cmFwcGluZyBlbGVtZW50IHRoYXQgc2Nyb2xscywgb3IgTUlHSFQgc2Nyb2xsIGlmIHRoZXJlJ3Mgb3ZlcmZsb3cuXG5cdC8vIFRPRE86IGRvIHRoaXMgZm9yIHdyYXBwZXJzIHRoYXQgaGF2ZSBvdmVyZmxvdzpoaWRkZW4gYXMgd2VsbC5cblx0c2Nyb2xsRWw6IG51bGwsXG5cblx0aXNJbnRlcmFjdGluZzogZmFsc2UsXG5cdGlzRGlzdGFuY2VTdXJwYXNzZWQ6IGZhbHNlLFxuXHRpc0RlbGF5RW5kZWQ6IGZhbHNlLFxuXHRpc0RyYWdnaW5nOiBmYWxzZSxcblx0aXNUb3VjaDogZmFsc2UsXG5cdGlzR2VuZXJpYzogZmFsc2UsIC8vIGluaXRpYXRlZCBieSAnZHJhZ3N0YXJ0JyAoanF1aSlcblxuXHRkZWxheTogbnVsbCxcblx0ZGVsYXlUaW1lb3V0SWQ6IG51bGwsXG5cdG1pbkRpc3RhbmNlOiBudWxsLFxuXG5cdHNob3VsZENhbmNlbFRvdWNoU2Nyb2xsOiB0cnVlLFxuXHRzY3JvbGxBbHdheXNLaWxsczogZmFsc2UsXG5cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdH0sXG5cblxuXHQvLyBJbnRlcmFjdGlvbiAoaGlnaC1sZXZlbClcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdHN0YXJ0SW50ZXJhY3Rpb246IGZ1bmN0aW9uKGV2LCBleHRyYU9wdGlvbnMpIHtcblxuXHRcdGlmIChldi50eXBlID09PSAnbW91c2Vkb3duJykge1xuXHRcdFx0aWYgKEdsb2JhbEVtaXR0ZXIuZ2V0KCkuc2hvdWxkSWdub3JlTW91c2UoKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICghaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRldi5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50cyBuYXRpdmUgc2VsZWN0aW9uIGluIG1vc3QgYnJvd3NlcnNcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaXNJbnRlcmFjdGluZykge1xuXG5cdFx0XHQvLyBwcm9jZXNzIG9wdGlvbnNcblx0XHRcdGV4dHJhT3B0aW9ucyA9IGV4dHJhT3B0aW9ucyB8fCB7fTtcblx0XHRcdHRoaXMuZGVsYXkgPSBmaXJzdERlZmluZWQoZXh0cmFPcHRpb25zLmRlbGF5LCB0aGlzLm9wdGlvbnMuZGVsYXksIDApO1xuXHRcdFx0dGhpcy5taW5EaXN0YW5jZSA9IGZpcnN0RGVmaW5lZChleHRyYU9wdGlvbnMuZGlzdGFuY2UsIHRoaXMub3B0aW9ucy5kaXN0YW5jZSwgMCk7XG5cdFx0XHR0aGlzLnN1YmplY3RFbCA9IHRoaXMub3B0aW9ucy5zdWJqZWN0RWw7XG5cblx0XHRcdHByZXZlbnRTZWxlY3Rpb24oJCgnYm9keScpKTtcblxuXHRcdFx0dGhpcy5pc0ludGVyYWN0aW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMuaXNUb3VjaCA9IGdldEV2SXNUb3VjaChldik7XG5cdFx0XHR0aGlzLmlzR2VuZXJpYyA9IGV2LnR5cGUgPT09ICdkcmFnc3RhcnQnO1xuXHRcdFx0dGhpcy5pc0RlbGF5RW5kZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xuXG5cdFx0XHR0aGlzLm9yaWdpblggPSBnZXRFdlgoZXYpO1xuXHRcdFx0dGhpcy5vcmlnaW5ZID0gZ2V0RXZZKGV2KTtcblx0XHRcdHRoaXMuc2Nyb2xsRWwgPSBnZXRTY3JvbGxQYXJlbnQoJChldi50YXJnZXQpKTtcblxuXHRcdFx0dGhpcy5iaW5kSGFuZGxlcnMoKTtcblx0XHRcdHRoaXMuaW5pdEF1dG9TY3JvbGwoKTtcblx0XHRcdHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25TdGFydChldik7XG5cdFx0XHR0aGlzLnN0YXJ0RGVsYXkoZXYpO1xuXG5cdFx0XHRpZiAoIXRoaXMubWluRGlzdGFuY2UpIHtcblx0XHRcdFx0dGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0aGFuZGxlSW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ2ludGVyYWN0aW9uU3RhcnQnLCBldik7XG5cdH0sXG5cblxuXHRlbmRJbnRlcmFjdGlvbjogZnVuY3Rpb24oZXYsIGlzQ2FuY2VsbGVkKSB7XG5cdFx0aWYgKHRoaXMuaXNJbnRlcmFjdGluZykge1xuXHRcdFx0dGhpcy5lbmREcmFnKGV2KTtcblxuXHRcdFx0aWYgKHRoaXMuZGVsYXlUaW1lb3V0SWQpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lb3V0SWQpO1xuXHRcdFx0XHR0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5kZXN0cm95QXV0b1Njcm9sbCgpO1xuXHRcdFx0dGhpcy51bmJpbmRIYW5kbGVycygpO1xuXG5cdFx0XHR0aGlzLmlzSW50ZXJhY3RpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25FbmQoZXYsIGlzQ2FuY2VsbGVkKTtcblxuXHRcdFx0YWxsb3dTZWxlY3Rpb24oJCgnYm9keScpKTtcblx0XHR9XG5cdH0sXG5cblxuXHRoYW5kbGVJbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24oZXYsIGlzQ2FuY2VsbGVkKSB7XG5cdFx0dGhpcy50cmlnZ2VyKCdpbnRlcmFjdGlvbkVuZCcsIGV2LCBpc0NhbmNlbGxlZCB8fCBmYWxzZSk7XG5cdH0sXG5cblxuXHQvLyBCaW5kaW5nIFRvIERPTVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0YmluZEhhbmRsZXJzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzb21lIGJyb3dzZXJzIChTYWZhcmkgaW4gaU9TIDEwKSBkb24ndCBhbGxvdyBwcmV2ZW50RGVmYXVsdCBvbiB0b3VjaCBldmVudHMgdGhhdCBhcmUgYm91bmQgYWZ0ZXIgdG91Y2hzdGFydCxcblx0XHQvLyBzbyBsaXN0ZW4gdG8gdGhlIEdsb2JhbEVtaXR0ZXIgc2luZ2xldG9uLCB3aGljaCBpcyBhbHdheXMgYm91bmQsIGluc3RlYWQgb2YgdGhlIGRvY3VtZW50IGRpcmVjdGx5LlxuXHRcdHZhciBnbG9iYWxFbWl0dGVyID0gR2xvYmFsRW1pdHRlci5nZXQoKTtcblxuXHRcdGlmICh0aGlzLmlzR2VuZXJpYykge1xuXHRcdFx0dGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwgeyAvLyBtaWdodCBvbmx5IHdvcmsgb24gaU9TIGJlY2F1c2Ugb2YgR2xvYmFsRW1pdHRlcidzIGJpbmQgOihcblx0XHRcdFx0ZHJhZzogdGhpcy5oYW5kbGVNb3ZlLFxuXHRcdFx0XHRkcmFnc3RvcDogdGhpcy5lbmRJbnRlcmFjdGlvblxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuaXNUb3VjaCkge1xuXHRcdFx0dGhpcy5saXN0ZW5UbyhnbG9iYWxFbWl0dGVyLCB7XG5cdFx0XHRcdHRvdWNobW92ZTogdGhpcy5oYW5kbGVUb3VjaE1vdmUsXG5cdFx0XHRcdHRvdWNoZW5kOiB0aGlzLmVuZEludGVyYWN0aW9uLFxuXHRcdFx0XHRzY3JvbGw6IHRoaXMuaGFuZGxlVG91Y2hTY3JvbGxcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMubGlzdGVuVG8oZ2xvYmFsRW1pdHRlciwge1xuXHRcdFx0XHRtb3VzZW1vdmU6IHRoaXMuaGFuZGxlTW91c2VNb3ZlLFxuXHRcdFx0XHRtb3VzZXVwOiB0aGlzLmVuZEludGVyYWN0aW9uXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLmxpc3RlblRvKGdsb2JhbEVtaXR0ZXIsIHtcblx0XHRcdHNlbGVjdHN0YXJ0OiBwcmV2ZW50RGVmYXVsdCwgLy8gZG9uJ3QgYWxsb3cgc2VsZWN0aW9uIHdoaWxlIGRyYWdnaW5nXG5cdFx0XHRjb250ZXh0bWVudTogcHJldmVudERlZmF1bHQgLy8gbG9uZyB0YXBzIHdvdWxkIG9wZW4gbWVudSBvbiBDaHJvbWUgZGV2IHRvb2xzXG5cdFx0fSk7XG5cdH0sXG5cblxuXHR1bmJpbmRIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8oR2xvYmFsRW1pdHRlci5nZXQoKSk7XG5cdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpOyAvLyBmb3IgaXNHZW5lcmljXG5cdH0sXG5cblxuXHQvLyBEcmFnIChoaWdoLWxldmVsKVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gZXh0cmFPcHRpb25zIGlnbm9yZWQgaWYgZHJhZyBhbHJlYWR5IHN0YXJ0ZWRcblx0c3RhcnREcmFnOiBmdW5jdGlvbihldiwgZXh0cmFPcHRpb25zKSB7XG5cdFx0dGhpcy5zdGFydEludGVyYWN0aW9uKGV2LCBleHRyYU9wdGlvbnMpOyAvLyBlbnN1cmUgaW50ZXJhY3Rpb24gYmVnYW5cblxuXHRcdGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XG5cdFx0XHR0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy5oYW5kbGVEcmFnU3RhcnQoZXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdGhhbmRsZURyYWdTdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ2RyYWdTdGFydCcsIGV2KTtcblx0fSxcblxuXG5cdGhhbmRsZU1vdmU6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIGR4ID0gZ2V0RXZYKGV2KSAtIHRoaXMub3JpZ2luWDtcblx0XHR2YXIgZHkgPSBnZXRFdlkoZXYpIC0gdGhpcy5vcmlnaW5ZO1xuXHRcdHZhciBtaW5EaXN0YW5jZSA9IHRoaXMubWluRGlzdGFuY2U7XG5cdFx0dmFyIGRpc3RhbmNlU3E7IC8vIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luLCBzcXVhcmVkXG5cblx0XHRpZiAoIXRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xuXHRcdFx0ZGlzdGFuY2VTcSA9IGR4ICogZHggKyBkeSAqIGR5O1xuXHRcdFx0aWYgKGRpc3RhbmNlU3EgPj0gbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSkgeyAvLyB1c2UgcHl0aGFnb3JlYW4gdGhlb3JlbVxuXHRcdFx0XHR0aGlzLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG5cdFx0XHR0aGlzLmhhbmRsZURyYWcoZHgsIGR5LCBldik7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoaWxlIHRoZSBtb3VzZSBpcyBiZWluZyBtb3ZlZCBhbmQgd2hlbiB3ZSBrbm93IGEgbGVnaXRpbWF0ZSBkcmFnIGlzIHRha2luZyBwbGFjZVxuXHRoYW5kbGVEcmFnOiBmdW5jdGlvbihkeCwgZHksIGV2KSB7XG5cdFx0dGhpcy50cmlnZ2VyKCdkcmFnJywgZHgsIGR5LCBldik7XG5cdFx0dGhpcy51cGRhdGVBdXRvU2Nyb2xsKGV2KTsgLy8gd2lsbCBwb3NzaWJseSBjYXVzZSBzY3JvbGxpbmdcblx0fSxcblxuXG5cdGVuZERyYWc6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0aWYgKHRoaXMuaXNEcmFnZ2luZykge1xuXHRcdFx0dGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLmhhbmRsZURyYWdFbmQoZXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdGhhbmRsZURyYWdFbmQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy50cmlnZ2VyKCdkcmFnRW5kJywgZXYpO1xuXHR9LFxuXG5cblx0Ly8gRGVsYXlcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdHN0YXJ0RGVsYXk6IGZ1bmN0aW9uKGluaXRpYWxFdikge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHRpZiAodGhpcy5kZWxheSkge1xuXHRcdFx0dGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF90aGlzLmhhbmRsZURlbGF5RW5kKGluaXRpYWxFdik7XG5cdFx0XHR9LCB0aGlzLmRlbGF5KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLmhhbmRsZURlbGF5RW5kKGluaXRpYWxFdik7XG5cdFx0fVxuXHR9LFxuXG5cblx0aGFuZGxlRGVsYXlFbmQ6IGZ1bmN0aW9uKGluaXRpYWxFdikge1xuXHRcdHRoaXMuaXNEZWxheUVuZGVkID0gdHJ1ZTtcblxuXHRcdGlmICh0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcblx0XHRcdHRoaXMuc3RhcnREcmFnKGluaXRpYWxFdik7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gRGlzdGFuY2Vcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdGhhbmRsZURpc3RhbmNlU3VycGFzc2VkOiBmdW5jdGlvbihldikge1xuXHRcdHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IHRydWU7XG5cblx0XHRpZiAodGhpcy5pc0RlbGF5RW5kZWQpIHtcblx0XHRcdHRoaXMuc3RhcnREcmFnKGV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBNb3VzZSAvIFRvdWNoXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRoYW5kbGVUb3VjaE1vdmU6IGZ1bmN0aW9uKGV2KSB7XG5cblx0XHQvLyBwcmV2ZW50IGluZXJ0aWEgYW5kIHRvdWNobW92ZS1zY3JvbGxpbmcgd2hpbGUgZHJhZ2dpbmdcblx0XHRpZiAodGhpcy5pc0RyYWdnaW5nICYmIHRoaXMuc2hvdWxkQ2FuY2VsVG91Y2hTY3JvbGwpIHtcblx0XHRcdGV2LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5oYW5kbGVNb3ZlKGV2KTtcblx0fSxcblxuXG5cdGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLmhhbmRsZU1vdmUoZXYpO1xuXHR9LFxuXG5cblx0Ly8gU2Nyb2xsaW5nICh1bnJlbGF0ZWQgdG8gYXV0by1zY3JvbGwpXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRoYW5kbGVUb3VjaFNjcm9sbDogZnVuY3Rpb24oZXYpIHtcblx0XHQvLyBpZiB0aGUgZHJhZyBpcyBiZWluZyBpbml0aWF0ZWQgYnkgdG91Y2gsIGJ1dCBhIHNjcm9sbCBoYXBwZW5zIGJlZm9yZVxuXHRcdC8vIHRoZSBkcmFnLWluaXRpYXRpbmcgZGVsYXkgaXMgb3ZlciwgY2FuY2VsIHRoZSBkcmFnXG5cdFx0aWYgKCF0aGlzLmlzRHJhZ2dpbmcgfHwgdGhpcy5zY3JvbGxBbHdheXNLaWxscykge1xuXHRcdFx0dGhpcy5lbmRJbnRlcmFjdGlvbihldiwgdHJ1ZSk7IC8vIGlzQ2FuY2VsbGVkPXRydWVcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBVdGlsc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gVHJpZ2dlcnMgYSBjYWxsYmFjay4gQ2FsbHMgYSBmdW5jdGlvbiBpbiB0aGUgb3B0aW9uIGhhc2ggb2YgdGhlIHNhbWUgbmFtZS5cblx0Ly8gQXJndW1lbnRzIGJleW9uZCB0aGUgZmlyc3QgYG5hbWVgIGFyZSBmb3J3YXJkZWQgb24uXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnNbbmFtZV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0fVxuXHRcdC8vIG1ha2VzIF9tZXRob2RzIGNhbGxhYmxlIGJ5IGV2ZW50IG5hbWUuIFRPRE86IGtpbGwgdGhpc1xuXHRcdGlmICh0aGlzWydfJyArIG5hbWVdKSB7XG5cdFx0XHR0aGlzWydfJyArIG5hbWVdLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuXHRcdH1cblx0fVxuXG5cbn0pO1xuXG47O1xuLypcbnRoaXMuc2Nyb2xsRWwgaXMgc2V0IGluIERyYWdMaXN0ZW5lclxuKi9cbkRyYWdMaXN0ZW5lci5taXhpbih7XG5cblx0aXNBdXRvU2Nyb2xsOiBmYWxzZSxcblxuXHRzY3JvbGxCb3VuZHM6IG51bGwsIC8vIHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH1cblx0c2Nyb2xsVG9wVmVsOiBudWxsLCAvLyBwaXhlbHMgcGVyIHNlY29uZFxuXHRzY3JvbGxMZWZ0VmVsOiBudWxsLCAvLyBwaXhlbHMgcGVyIHNlY29uZFxuXHRzY3JvbGxJbnRlcnZhbElkOiBudWxsLCAvLyBJRCBvZiBzZXRUaW1lb3V0IGZvciBzY3JvbGxpbmcgYW5pbWF0aW9uIGxvb3BcblxuXHQvLyBkZWZhdWx0c1xuXHRzY3JvbGxTZW5zaXRpdml0eTogMzAsIC8vIHBpeGVscyBmcm9tIGVkZ2UgZm9yIHNjcm9sbGluZyB0byBzdGFydFxuXHRzY3JvbGxTcGVlZDogMjAwLCAvLyBwaXhlbHMgcGVyIHNlY29uZCwgYXQgbWF4aW11bSBzcGVlZFxuXHRzY3JvbGxJbnRlcnZhbE1zOiA1MCwgLy8gbWlsbGlzZWNvbmQgd2FpdCBiZXR3ZWVuIHNjcm9sbCBpbmNyZW1lbnRcblxuXG5cdGluaXRBdXRvU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2Nyb2xsRWwgPSB0aGlzLnNjcm9sbEVsO1xuXG5cdFx0dGhpcy5pc0F1dG9TY3JvbGwgPVxuXHRcdFx0dGhpcy5vcHRpb25zLnNjcm9sbCAmJlxuXHRcdFx0c2Nyb2xsRWwgJiZcblx0XHRcdCFzY3JvbGxFbC5pcyh3aW5kb3cpICYmXG5cdFx0XHQhc2Nyb2xsRWwuaXMoZG9jdW1lbnQpO1xuXG5cdFx0aWYgKHRoaXMuaXNBdXRvU2Nyb2xsKSB7XG5cdFx0XHQvLyBkZWJvdW5jZSBtYWtlcyBzdXJlIHJhcGlkIGNhbGxzIGRvbid0IGhhcHBlblxuXHRcdFx0dGhpcy5saXN0ZW5UbyhzY3JvbGxFbCwgJ3Njcm9sbCcsIGRlYm91bmNlKHRoaXMuaGFuZGxlRGVib3VuY2VkU2Nyb2xsLCAxMDApKTtcblx0XHR9XG5cdH0sXG5cblxuXHRkZXN0cm95QXV0b1Njcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbmRBdXRvU2Nyb2xsKCk7IC8vIGtpbGwgYW55IGFuaW1hdGlvbiBsb29wXG5cblx0XHQvLyByZW1vdmUgdGhlIHNjcm9sbCBoYW5kbGVyIGlmIHRoZXJlIGlzIGEgc2Nyb2xsRWxcblx0XHRpZiAodGhpcy5pc0F1dG9TY3JvbGwpIHtcblx0XHRcdHRoaXMuc3RvcExpc3RlbmluZ1RvKHRoaXMuc2Nyb2xsRWwsICdzY3JvbGwnKTsgLy8gd2lsbCBwcm9iYWJseSBnZXQgcmVtb3ZlZCBieSB1bmJpbmRIYW5kbGVycyB0b28gOihcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyBhbmQgc3RvcmVzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgb2Ygc2Nyb2xsRWxcblx0Y29tcHV0ZVNjcm9sbEJvdW5kczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaXNBdXRvU2Nyb2xsKSB7XG5cdFx0XHR0aGlzLnNjcm9sbEJvdW5kcyA9IGdldE91dGVyUmVjdCh0aGlzLnNjcm9sbEVsKTtcblx0XHRcdC8vIFRPRE86IHVzZSBnZXRDbGllbnRSZWN0IGluIGZ1dHVyZS4gYnV0IHByZXZlbnRzIGF1dG8gc2Nyb2xsaW5nIHdoZW4gb24gdG9wIG9mIHNjcm9sbGJhcnNcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgZHJhZ2dpbmcgaXMgaW4gcHJvZ3Jlc3MgYW5kIHNjcm9sbGluZyBzaG91bGQgYmUgdXBkYXRlZFxuXHR1cGRhdGVBdXRvU2Nyb2xsOiBmdW5jdGlvbihldikge1xuXHRcdHZhciBzZW5zaXRpdml0eSA9IHRoaXMuc2Nyb2xsU2Vuc2l0aXZpdHk7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuc2Nyb2xsQm91bmRzO1xuXHRcdHZhciB0b3BDbG9zZW5lc3MsIGJvdHRvbUNsb3NlbmVzcztcblx0XHR2YXIgbGVmdENsb3NlbmVzcywgcmlnaHRDbG9zZW5lc3M7XG5cdFx0dmFyIHRvcFZlbCA9IDA7XG5cdFx0dmFyIGxlZnRWZWwgPSAwO1xuXG5cdFx0aWYgKGJvdW5kcykgeyAvLyBvbmx5IHNjcm9sbCBpZiBzY3JvbGxFbCBleGlzdHNcblxuXHRcdFx0Ly8gY29tcHV0ZSBjbG9zZW5lc3MgdG8gZWRnZXMuIHZhbGlkIHJhbmdlIGlzIGZyb20gMC4wIC0gMS4wXG5cdFx0XHR0b3BDbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAoZ2V0RXZZKGV2KSAtIGJvdW5kcy50b3ApKSAvIHNlbnNpdGl2aXR5O1xuXHRcdFx0Ym90dG9tQ2xvc2VuZXNzID0gKHNlbnNpdGl2aXR5IC0gKGJvdW5kcy5ib3R0b20gLSBnZXRFdlkoZXYpKSkgLyBzZW5zaXRpdml0eTtcblx0XHRcdGxlZnRDbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAoZ2V0RXZYKGV2KSAtIGJvdW5kcy5sZWZ0KSkgLyBzZW5zaXRpdml0eTtcblx0XHRcdHJpZ2h0Q2xvc2VuZXNzID0gKHNlbnNpdGl2aXR5IC0gKGJvdW5kcy5yaWdodCAtIGdldEV2WChldikpKSAvIHNlbnNpdGl2aXR5O1xuXG5cdFx0XHQvLyB0cmFuc2xhdGUgdmVydGljYWwgY2xvc2VuZXNzIGludG8gdmVsb2NpdHkuXG5cdFx0XHQvLyBtb3VzZSBtdXN0IGJlIGNvbXBsZXRlbHkgaW4gYm91bmRzIGZvciB2ZWxvY2l0eSB0byBoYXBwZW4uXG5cdFx0XHRpZiAodG9wQ2xvc2VuZXNzID49IDAgJiYgdG9wQ2xvc2VuZXNzIDw9IDEpIHtcblx0XHRcdFx0dG9wVmVsID0gdG9wQ2xvc2VuZXNzICogdGhpcy5zY3JvbGxTcGVlZCAqIC0xOyAvLyBuZWdhdGl2ZS4gZm9yIHNjcm9sbGluZyB1cFxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoYm90dG9tQ2xvc2VuZXNzID49IDAgJiYgYm90dG9tQ2xvc2VuZXNzIDw9IDEpIHtcblx0XHRcdFx0dG9wVmVsID0gYm90dG9tQ2xvc2VuZXNzICogdGhpcy5zY3JvbGxTcGVlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdHJhbnNsYXRlIGhvcml6b250YWwgY2xvc2VuZXNzIGludG8gdmVsb2NpdHlcblx0XHRcdGlmIChsZWZ0Q2xvc2VuZXNzID49IDAgJiYgbGVmdENsb3NlbmVzcyA8PSAxKSB7XG5cdFx0XHRcdGxlZnRWZWwgPSBsZWZ0Q2xvc2VuZXNzICogdGhpcy5zY3JvbGxTcGVlZCAqIC0xOyAvLyBuZWdhdGl2ZS4gZm9yIHNjcm9sbGluZyBsZWZ0XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChyaWdodENsb3NlbmVzcyA+PSAwICYmIHJpZ2h0Q2xvc2VuZXNzIDw9IDEpIHtcblx0XHRcdFx0bGVmdFZlbCA9IHJpZ2h0Q2xvc2VuZXNzICogdGhpcy5zY3JvbGxTcGVlZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnNldFNjcm9sbFZlbCh0b3BWZWwsIGxlZnRWZWwpO1xuXHR9LFxuXG5cblx0Ly8gU2V0cyB0aGUgc3BlZWQtb2Ytc2Nyb2xsaW5nIGZvciB0aGUgc2Nyb2xsRWxcblx0c2V0U2Nyb2xsVmVsOiBmdW5jdGlvbih0b3BWZWwsIGxlZnRWZWwpIHtcblxuXHRcdHRoaXMuc2Nyb2xsVG9wVmVsID0gdG9wVmVsO1xuXHRcdHRoaXMuc2Nyb2xsTGVmdFZlbCA9IGxlZnRWZWw7XG5cblx0XHR0aGlzLmNvbnN0cmFpblNjcm9sbFZlbCgpOyAvLyBtYXNzYWdlcyBpbnRvIHJlYWxpc3RpYyB2YWx1ZXNcblxuXHRcdC8vIGlmIHRoZXJlIGlzIG5vbi16ZXJvIHZlbG9jaXR5LCBhbmQgYW4gYW5pbWF0aW9uIGxvb3AgaGFzbid0IGFscmVhZHkgc3RhcnRlZCwgdGhlbiBTVEFSVFxuXHRcdGlmICgodGhpcy5zY3JvbGxUb3BWZWwgfHwgdGhpcy5zY3JvbGxMZWZ0VmVsKSAmJiAhdGhpcy5zY3JvbGxJbnRlcnZhbElkKSB7XG5cdFx0XHR0aGlzLnNjcm9sbEludGVydmFsSWQgPSBzZXRJbnRlcnZhbChcblx0XHRcdFx0cHJveHkodGhpcywgJ3Njcm9sbEludGVydmFsRnVuYycpLCAvLyBzY29wZSB0byBgdGhpc2Bcblx0XHRcdFx0dGhpcy5zY3JvbGxJbnRlcnZhbE1zXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEZvcmNlcyBzY3JvbGxUb3BWZWwgYW5kIHNjcm9sbExlZnRWZWwgdG8gYmUgemVybyBpZiBzY3JvbGxpbmcgaGFzIGFscmVhZHkgZ29uZSBhbGwgdGhlIHdheVxuXHRjb25zdHJhaW5TY3JvbGxWZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbCA9IHRoaXMuc2Nyb2xsRWw7XG5cblx0XHRpZiAodGhpcy5zY3JvbGxUb3BWZWwgPCAwKSB7IC8vIHNjcm9sbGluZyB1cD9cblx0XHRcdGlmIChlbC5zY3JvbGxUb3AoKSA8PSAwKSB7IC8vIGFscmVhZHkgc2Nyb2xsZWQgYWxsIHRoZSB3YXkgdXA/XG5cdFx0XHRcdHRoaXMuc2Nyb2xsVG9wVmVsID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAodGhpcy5zY3JvbGxUb3BWZWwgPiAwKSB7IC8vIHNjcm9sbGluZyBkb3duP1xuXHRcdFx0aWYgKGVsLnNjcm9sbFRvcCgpICsgZWxbMF0uY2xpZW50SGVpZ2h0ID49IGVsWzBdLnNjcm9sbEhlaWdodCkgeyAvLyBhbHJlYWR5IHNjcm9sbGVkIGFsbCB0aGUgd2F5IGRvd24/XG5cdFx0XHRcdHRoaXMuc2Nyb2xsVG9wVmVsID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5zY3JvbGxMZWZ0VmVsIDwgMCkgeyAvLyBzY3JvbGxpbmcgbGVmdD9cblx0XHRcdGlmIChlbC5zY3JvbGxMZWZ0KCkgPD0gMCkgeyAvLyBhbHJlYWR5IHNjcm9sbGVkIGFsbCB0aGUgbGVmdD9cblx0XHRcdFx0dGhpcy5zY3JvbGxMZWZ0VmVsID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAodGhpcy5zY3JvbGxMZWZ0VmVsID4gMCkgeyAvLyBzY3JvbGxpbmcgcmlnaHQ/XG5cdFx0XHRpZiAoZWwuc2Nyb2xsTGVmdCgpICsgZWxbMF0uY2xpZW50V2lkdGggPj0gZWxbMF0uc2Nyb2xsV2lkdGgpIHsgLy8gYWxyZWFkeSBzY3JvbGxlZCBhbGwgdGhlIHdheSByaWdodD9cblx0XHRcdFx0dGhpcy5zY3JvbGxMZWZ0VmVsID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBUaGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGR1cmluZyBldmVyeSBpdGVyYXRpb24gb2YgdGhlIHNjcm9sbGluZyBhbmltYXRpb24gbG9vcFxuXHRzY3JvbGxJbnRlcnZhbEZ1bmM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbCA9IHRoaXMuc2Nyb2xsRWw7XG5cdFx0dmFyIGZyYWMgPSB0aGlzLnNjcm9sbEludGVydmFsTXMgLyAxMDAwOyAvLyBjb25zaWRlcmluZyBhbmltYXRpb24gZnJlcXVlbmN5LCB3aGF0IHRoZSB2ZWwgc2hvdWxkIGJlIG11bHQnZCBieVxuXG5cdFx0Ly8gY2hhbmdlIHRoZSB2YWx1ZSBvZiBzY3JvbGxFbCdzIHNjcm9sbFxuXHRcdGlmICh0aGlzLnNjcm9sbFRvcFZlbCkge1xuXHRcdFx0ZWwuc2Nyb2xsVG9wKGVsLnNjcm9sbFRvcCgpICsgdGhpcy5zY3JvbGxUb3BWZWwgKiBmcmFjKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuc2Nyb2xsTGVmdFZlbCkge1xuXHRcdFx0ZWwuc2Nyb2xsTGVmdChlbC5zY3JvbGxMZWZ0KCkgKyB0aGlzLnNjcm9sbExlZnRWZWwgKiBmcmFjKTtcblx0XHR9XG5cblx0XHR0aGlzLmNvbnN0cmFpblNjcm9sbFZlbCgpOyAvLyBzaW5jZSB0aGUgc2Nyb2xsIHZhbHVlcyBjaGFuZ2VkLCByZWNvbXB1dGUgdGhlIHZlbG9jaXRpZXNcblxuXHRcdC8vIGlmIHNjcm9sbGVkIGFsbCB0aGUgd2F5LCB3aGljaCBjYXVzZXMgdGhlIHZlbHMgdG8gYmUgemVybywgc3RvcCB0aGUgYW5pbWF0aW9uIGxvb3Bcblx0XHRpZiAoIXRoaXMuc2Nyb2xsVG9wVmVsICYmICF0aGlzLnNjcm9sbExlZnRWZWwpIHtcblx0XHRcdHRoaXMuZW5kQXV0b1Njcm9sbCgpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEtpbGxzIGFueSBleGlzdGluZyBzY3JvbGxpbmcgYW5pbWF0aW9uIGxvb3Bcblx0ZW5kQXV0b1Njcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCkge1xuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnNjcm9sbEludGVydmFsSWQpO1xuXHRcdFx0dGhpcy5zY3JvbGxJbnRlcnZhbElkID0gbnVsbDtcblxuXHRcdFx0dGhpcy5oYW5kbGVTY3JvbGxFbmQoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHZXQgY2FsbGVkIHdoZW4gdGhlIHNjcm9sbEVsIGlzIHNjcm9sbGVkIChOT1RFOiB0aGlzIGlzIGRlbGF5ZWQgdmlhIGRlYm91bmNlKVxuXHRoYW5kbGVEZWJvdW5jZWRTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHJlY29tcHV0ZSBhbGwgY29vcmRpbmF0ZXMsIGJ1dCAqb25seSogaWYgdGhpcyBpcyAqbm90KiBwYXJ0IG9mIG91ciBzY3JvbGxpbmcgYW5pbWF0aW9uXG5cdFx0aWYgKCF0aGlzLnNjcm9sbEludGVydmFsSWQpIHtcblx0XHRcdHRoaXMuaGFuZGxlU2Nyb2xsRW5kKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gc2Nyb2xsaW5nIGhhcyBzdG9wcGVkLCB3aGV0aGVyIHRocm91Z2ggYXV0byBzY3JvbGwsIG9yIHRoZSB1c2VyIHNjcm9sbGluZ1xuXHRoYW5kbGVTY3JvbGxFbmQ6IGZ1bmN0aW9uKCkge1xuXHR9XG5cbn0pO1xuOztcblxuLyogVHJhY2tzIG1vdXNlIG1vdmVtZW50cyBvdmVyIGEgY29tcG9uZW50IGFuZCByYWlzZXMgZXZlbnRzIGFib3V0IHdoaWNoIGhpdCB0aGUgbW91c2UgaXMgb3Zlci5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxub3B0aW9uczpcbi0gc3ViamVjdEVsXG4tIHN1YmplY3RDZW50ZXJcbiovXG5cbnZhciBIaXREcmFnTGlzdGVuZXIgPSBEcmFnTGlzdGVuZXIuZXh0ZW5kKHtcblxuXHRjb21wb25lbnQ6IG51bGwsIC8vIGNvbnZlcnRzIGNvb3JkaW5hdGVzIHRvIGhpdHNcblx0XHQvLyBtZXRob2RzOiBoaXRzTmVlZGVkLCBoaXRzTm90TmVlZGVkLCBxdWVyeUhpdFxuXG5cdG9yaWdIaXQ6IG51bGwsIC8vIHRoZSBoaXQgdGhlIG1vdXNlIHdhcyBvdmVyIHdoZW4gbGlzdGVuaW5nIHN0YXJ0ZWRcblx0aGl0OiBudWxsLCAvLyB0aGUgaGl0IHRoZSBtb3VzZSBpcyBvdmVyXG5cdGNvb3JkQWRqdXN0OiBudWxsLCAvLyBkZWx0YSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1vdXNlIGNvb3JkaW5hdGVzIHdoZW4gY29tcHV0aW5nIGNvbGxpc2lvbnNcblxuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbihjb21wb25lbnQsIG9wdGlvbnMpIHtcblx0XHREcmFnTGlzdGVuZXIuY2FsbCh0aGlzLCBvcHRpb25zKTsgLy8gY2FsbCB0aGUgc3VwZXItY29uc3RydWN0b3JcblxuXHRcdHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gZHJhZyBsaXN0ZW5pbmcgc3RhcnRzIChidXQgYSByZWFsIGRyYWcgaGFzIG5vdCBuZWNlc3NhcmlseSBiZWdhbikuXG5cdC8vIGV2IG1pZ2h0IGJlIHVuZGVmaW5lZCBpZiBkcmFnZ2luZyB3YXMgc3RhcnRlZCBtYW51YWxseS5cblx0aGFuZGxlSW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHR2YXIgc3ViamVjdEVsID0gdGhpcy5zdWJqZWN0RWw7XG5cdFx0dmFyIHN1YmplY3RSZWN0O1xuXHRcdHZhciBvcmlnUG9pbnQ7XG5cdFx0dmFyIHBvaW50O1xuXG5cdFx0dGhpcy5jb21wb25lbnQuaGl0c05lZWRlZCgpO1xuXHRcdHRoaXMuY29tcHV0ZVNjcm9sbEJvdW5kcygpOyAvLyBmb3IgYXV0b3Njcm9sbFxuXG5cdFx0aWYgKGV2KSB7XG5cdFx0XHRvcmlnUG9pbnQgPSB7IGxlZnQ6IGdldEV2WChldiksIHRvcDogZ2V0RXZZKGV2KSB9O1xuXHRcdFx0cG9pbnQgPSBvcmlnUG9pbnQ7XG5cblx0XHRcdC8vIGNvbnN0cmFpbiB0aGUgcG9pbnQgdG8gYm91bmRzIG9mIHRoZSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcblx0XHRcdGlmIChzdWJqZWN0RWwpIHtcblx0XHRcdFx0c3ViamVjdFJlY3QgPSBnZXRPdXRlclJlY3Qoc3ViamVjdEVsKTsgLy8gdXNlZCBmb3IgY2VudGVyaW5nIGFzIHdlbGxcblx0XHRcdFx0cG9pbnQgPSBjb25zdHJhaW5Qb2ludChwb2ludCwgc3ViamVjdFJlY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9yaWdIaXQgPSB0aGlzLnF1ZXJ5SGl0KHBvaW50LmxlZnQsIHBvaW50LnRvcCk7XG5cblx0XHRcdC8vIHRyZWF0IHRoZSBjZW50ZXIgb2YgdGhlIHN1YmplY3QgYXMgdGhlIGNvbGxpc2lvbiBwb2ludD9cblx0XHRcdGlmIChzdWJqZWN0RWwgJiYgdGhpcy5vcHRpb25zLnN1YmplY3RDZW50ZXIpIHtcblxuXHRcdFx0XHQvLyBvbmx5IGNvbnNpZGVyIHRoZSBhcmVhIHRoZSBzdWJqZWN0IG92ZXJsYXBzIHRoZSBoaXQuIGJlc3QgZm9yIGxhcmdlIHN1YmplY3RzLlxuXHRcdFx0XHQvLyBUT0RPOiBza2lwIHRoaXMgaWYgaGl0IGRpZG4ndCBzdXBwbHkgbGVmdC9yaWdodC90b3AvYm90dG9tXG5cdFx0XHRcdGlmICh0aGlzLm9yaWdIaXQpIHtcblx0XHRcdFx0XHRzdWJqZWN0UmVjdCA9IGludGVyc2VjdFJlY3RzKHRoaXMub3JpZ0hpdCwgc3ViamVjdFJlY3QpIHx8XG5cdFx0XHRcdFx0XHRzdWJqZWN0UmVjdDsgLy8gaW4gY2FzZSB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb25cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBvaW50ID0gZ2V0UmVjdENlbnRlcihzdWJqZWN0UmVjdCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY29vcmRBZGp1c3QgPSBkaWZmUG9pbnRzKHBvaW50LCBvcmlnUG9pbnQpOyAvLyBwb2ludCAtIG9yaWdQb2ludFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMub3JpZ0hpdCA9IG51bGw7XG5cdFx0XHR0aGlzLmNvb3JkQWRqdXN0ID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBjYWxsIHRoZSBzdXBlci1tZXRob2QuIGRvIGl0IGFmdGVyIG9yaWdIaXQgaGFzIGJlZW4gY29tcHV0ZWRcblx0XHREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUludGVyYWN0aW9uU3RhcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBhY3R1YWwgZHJhZyBoYXMgc3RhcnRlZFxuXHRoYW5kbGVEcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIGhpdDtcblxuXHRcdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ1N0YXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGNhbGwgdGhlIHN1cGVyLW1ldGhvZFxuXG5cdFx0Ly8gbWlnaHQgYmUgZGlmZmVyZW50IGZyb20gdGhpcy5vcmlnSGl0IGlmIHRoZSBtaW4tZGlzdGFuY2UgaXMgbGFyZ2Vcblx0XHRoaXQgPSB0aGlzLnF1ZXJ5SGl0KGdldEV2WChldiksIGdldEV2WShldikpO1xuXG5cdFx0Ly8gcmVwb3J0IHRoZSBpbml0aWFsIGhpdCB0aGUgbW91c2UgaXMgb3ZlclxuXHRcdC8vIGVzcGVjaWFsbHkgaW1wb3J0YW50IGlmIG5vIG1pbi1kaXN0YW5jZSBhbmQgZHJhZyBzdGFydHMgaW1tZWRpYXRlbHlcblx0XHRpZiAoaGl0KSB7XG5cdFx0XHR0aGlzLmhhbmRsZUhpdE92ZXIoaGl0KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgZHJhZyBtb3Zlc1xuXHRoYW5kbGVEcmFnOiBmdW5jdGlvbihkeCwgZHksIGV2KSB7XG5cdFx0dmFyIGhpdDtcblxuXHRcdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2RcblxuXHRcdGhpdCA9IHRoaXMucXVlcnlIaXQoZ2V0RXZYKGV2KSwgZ2V0RXZZKGV2KSk7XG5cblx0XHRpZiAoIWlzSGl0c0VxdWFsKGhpdCwgdGhpcy5oaXQpKSB7IC8vIGEgZGlmZmVyZW50IGhpdCB0aGFuIGJlZm9yZT9cblx0XHRcdGlmICh0aGlzLmhpdCkge1xuXHRcdFx0XHR0aGlzLmhhbmRsZUhpdE91dCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhpdCkge1xuXHRcdFx0XHR0aGlzLmhhbmRsZUhpdE92ZXIoaGl0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiBkcmFnZ2luZyBoYXMgYmVlbiBzdG9wcGVkXG5cdGhhbmRsZURyYWdFbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGFuZGxlSGl0RG9uZSgpO1xuXHRcdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ0VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2Rcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIGEgdGhlIG1vdXNlIGhhcyBqdXN0IG1vdmVkIG92ZXIgYSBuZXcgaGl0XG5cdGhhbmRsZUhpdE92ZXI6IGZ1bmN0aW9uKGhpdCkge1xuXHRcdHZhciBpc09yaWcgPSBpc0hpdHNFcXVhbChoaXQsIHRoaXMub3JpZ0hpdCk7XG5cblx0XHR0aGlzLmhpdCA9IGhpdDtcblxuXHRcdHRoaXMudHJpZ2dlcignaGl0T3ZlcicsIHRoaXMuaGl0LCBpc09yaWcsIHRoaXMub3JpZ0hpdCk7XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgbW91c2UgaGFzIGp1c3QgbW92ZWQgb3V0IG9mIGEgaGl0XG5cdGhhbmRsZUhpdE91dDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaGl0KSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2hpdE91dCcsIHRoaXMuaGl0KTtcblx0XHRcdHRoaXMuaGFuZGxlSGl0RG9uZSgpO1xuXHRcdFx0dGhpcy5oaXQgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIENhbGxlZCBhZnRlciBhIGhpdE91dC4gQWxzbyBjYWxsZWQgYmVmb3JlIGEgZHJhZ1N0b3Bcblx0aGFuZGxlSGl0RG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaGl0KSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2hpdERvbmUnLCB0aGlzLmhpdCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGludGVyYWN0aW9uIGVuZHMsIHdoZXRoZXIgdGhlcmUgd2FzIGEgcmVhbCBkcmFnIG9yIG5vdFxuXHRoYW5kbGVJbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24oKSB7XG5cdFx0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvbkVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2RcblxuXHRcdHRoaXMub3JpZ0hpdCA9IG51bGw7XG5cdFx0dGhpcy5oaXQgPSBudWxsO1xuXG5cdFx0dGhpcy5jb21wb25lbnQuaGl0c05vdE5lZWRlZCgpO1xuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gc2Nyb2xsaW5nIGhhcyBzdG9wcGVkLCB3aGV0aGVyIHRocm91Z2ggYXV0byBzY3JvbGwsIG9yIHRoZSB1c2VyIHNjcm9sbGluZ1xuXHRoYW5kbGVTY3JvbGxFbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsRW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGNhbGwgdGhlIHN1cGVyLW1ldGhvZFxuXG5cdFx0Ly8gaGl0cycgYWJzb2x1dGUgcG9zaXRpb25zIHdpbGwgYmUgaW4gbmV3IHBsYWNlcyBhZnRlciBhIHVzZXIncyBzY3JvbGwuXG5cdFx0Ly8gSEFDSyBmb3IgcmVjb21wdXRpbmcuXG5cdFx0aWYgKHRoaXMuaXNEcmFnZ2luZykge1xuXHRcdFx0dGhpcy5jb21wb25lbnQucmVsZWFzZUhpdHMoKTtcblx0XHRcdHRoaXMuY29tcG9uZW50LnByZXBhcmVIaXRzKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgaGl0IHVuZGVybmVhdGggdGhlIGNvb3JkaW5hdGVzIGZvciB0aGUgZ2l2ZW4gbW91c2UgZXZlbnRcblx0cXVlcnlIaXQ6IGZ1bmN0aW9uKGxlZnQsIHRvcCkge1xuXG5cdFx0aWYgKHRoaXMuY29vcmRBZGp1c3QpIHtcblx0XHRcdGxlZnQgKz0gdGhpcy5jb29yZEFkanVzdC5sZWZ0O1xuXHRcdFx0dG9wICs9IHRoaXMuY29vcmRBZGp1c3QudG9wO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmNvbXBvbmVudC5xdWVyeUhpdChsZWZ0LCB0b3ApO1xuXHR9XG5cbn0pO1xuXG5cbi8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoaXRzIGFyZSBpZGVudGljYWxseSBlcXVhbC4gYGZhbHNlYCBvdGhlcndpc2UuIE11c3QgYmUgZnJvbSB0aGUgc2FtZSBjb21wb25lbnQuXG4vLyBUd28gbnVsbCB2YWx1ZXMgd2lsbCBiZSBjb25zaWRlcmVkIGVxdWFsLCBhcyB0d28gXCJvdXQgb2YgdGhlIGNvbXBvbmVudFwiIHN0YXRlcyBhcmUgdGhlIHNhbWUuXG5mdW5jdGlvbiBpc0hpdHNFcXVhbChoaXQwLCBoaXQxKSB7XG5cblx0aWYgKCFoaXQwICYmICFoaXQxKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoaGl0MCAmJiBoaXQxKSB7XG5cdFx0cmV0dXJuIGhpdDAuY29tcG9uZW50ID09PSBoaXQxLmNvbXBvbmVudCAmJlxuXHRcdFx0aXNIaXRQcm9wc1dpdGhpbihoaXQwLCBoaXQxKSAmJlxuXHRcdFx0aXNIaXRQcm9wc1dpdGhpbihoaXQxLCBoaXQwKTsgLy8gZW5zdXJlcyBhbGwgcHJvcHMgYXJlIGlkZW50aWNhbFxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBhbGwgb2Ygc3ViSGl0J3Mgbm9uLXN0YW5kYXJkIHByb3BlcnRpZXMgYXJlIHdpdGhpbiBzdXBlckhpdFxuZnVuY3Rpb24gaXNIaXRQcm9wc1dpdGhpbihzdWJIaXQsIHN1cGVySGl0KSB7XG5cdGZvciAodmFyIHByb3BOYW1lIGluIHN1YkhpdCkge1xuXHRcdGlmICghL14oY29tcG9uZW50fGxlZnR8cmlnaHR8dG9wfGJvdHRvbSkkLy50ZXN0KHByb3BOYW1lKSkge1xuXHRcdFx0aWYgKHN1YkhpdFtwcm9wTmFtZV0gIT09IHN1cGVySGl0W3Byb3BOYW1lXSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuXG47O1xuXG4vKlxuTGlzdGVucyB0byBkb2N1bWVudCBhbmQgd2luZG93LWxldmVsIHVzZXItaW50ZXJhY3Rpb24gZXZlbnRzLCBsaWtlIHRvdWNoIGV2ZW50cyBhbmQgbW91c2UgZXZlbnRzLFxuYW5kIGZpcmVzIHRoZXNlIGV2ZW50cyBhcy1pcyB0byB3aG9ldmVyIGlzIG9ic2VydmluZyBhIEdsb2JhbEVtaXR0ZXIuXG5CZXN0IHdoZW4gdXNlZCBhcyBhIHNpbmdsZXRvbiB2aWEgR2xvYmFsRW1pdHRlci5nZXQoKVxuXG5Ob3JtYWxpemVzIG1vdXNlL3RvdWNoIGV2ZW50cy4gRm9yIGV4YW1wbGVzOlxuLSBpZ25vcmVzIHRoZSB0aGUgc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyB0aGF0IGhhcHBlbiBhZnRlciBhIHF1aWNrIHRhcDogbW91c2Vtb3ZlK21vdXNlZG93bittb3VzZXVwK2NsaWNrXG4tIGNvbXBlbnNhdGVzIGZvciB2YXJpb3VzIGJ1Z2d5IHNjZW5hcmlvcyB3aGVyZSBhIHRvdWNoZW5kIGRvZXMgbm90IGZpcmVcbiovXG5cbkZDLnRvdWNoTW91c2VJZ25vcmVXYWl0ID0gNTAwO1xuXG52YXIgR2xvYmFsRW1pdHRlciA9IENsYXNzLmV4dGVuZChMaXN0ZW5lck1peGluLCBFbWl0dGVyTWl4aW4sIHtcblxuXHRpc1RvdWNoaW5nOiBmYWxzZSxcblx0bW91c2VJZ25vcmVEZXB0aDogMCxcblx0aGFuZGxlU2Nyb2xsUHJveHk6IG51bGwsXG5cblxuXHRiaW5kOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0dGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwge1xuXHRcdFx0dG91Y2hzdGFydDogdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LFxuXHRcdFx0dG91Y2hjYW5jZWw6IHRoaXMuaGFuZGxlVG91Y2hDYW5jZWwsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5oYW5kbGVUb3VjaEVuZCxcblx0XHRcdG1vdXNlZG93bjogdGhpcy5oYW5kbGVNb3VzZURvd24sXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuaGFuZGxlTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5oYW5kbGVNb3VzZVVwLFxuXHRcdFx0Y2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2ssXG5cdFx0XHRzZWxlY3RzdGFydDogdGhpcy5oYW5kbGVTZWxlY3RTdGFydCxcblx0XHRcdGNvbnRleHRtZW51OiB0aGlzLmhhbmRsZUNvbnRleHRNZW51XG5cdFx0fSk7XG5cblx0XHQvLyBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCBwcmV2ZW50RGVmYXVsdFxuXHRcdC8vIGJlY2F1c2UgaHR0cHM6Ly93d3cuY2hyb21lc3RhdHVzLmNvbS9mZWF0dXJlcy81MDkzNTY2MDA3MjE0MDgwXG5cdFx0Ly8gVE9ETzogaW52ZXN0aWdhdGUgcGVyZm9ybWFuY2UgYmVjYXVzZSB0aGlzIGlzIGEgZ2xvYmFsIGhhbmRsZXJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcblx0XHRcdCd0b3VjaG1vdmUnLFxuXHRcdFx0dGhpcy5oYW5kbGVUb3VjaE1vdmVQcm94eSA9IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdF90aGlzLmhhbmRsZVRvdWNoTW92ZSgkLkV2ZW50KGV2KSk7XG5cdFx0XHR9LFxuXHRcdFx0eyBwYXNzaXZlOiBmYWxzZSB9IC8vIGFsbG93cyBwcmV2ZW50RGVmYXVsdCgpXG5cdFx0KTtcblxuXHRcdC8vIGF0dGFjaCBhIGhhbmRsZXIgdG8gZ2V0IGNhbGxlZCB3aGVuIEFOWSBzY3JvbGwgYWN0aW9uIGhhcHBlbnMgb24gdGhlIHBhZ2UuXG5cdFx0Ly8gdGhpcyB3YXMgaW1wb3NzaWJsZSB0byBkbyB3aXRoIG5vcm1hbCBvbi9vZmYgYmVjYXVzZSAnc2Nyb2xsJyBkb2Vzbid0IGJ1YmJsZS5cblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMjk1NDU2NS85NjM0MlxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuXHRcdFx0J3Njcm9sbCcsXG5cdFx0XHR0aGlzLmhhbmRsZVNjcm9sbFByb3h5ID0gZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0X3RoaXMuaGFuZGxlU2Nyb2xsKCQuRXZlbnQoZXYpKTtcblx0XHRcdH0sXG5cdFx0XHR0cnVlIC8vIHVzZUNhcHR1cmVcblx0XHQpO1xuXHR9LFxuXG5cdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpO1xuXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG5cdFx0XHQndG91Y2htb3ZlJyxcblx0XHRcdHRoaXMuaGFuZGxlVG91Y2hNb3ZlUHJveHlcblx0XHQpO1xuXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG5cdFx0XHQnc2Nyb2xsJyxcblx0XHRcdHRoaXMuaGFuZGxlU2Nyb2xsUHJveHksXG5cdFx0XHR0cnVlIC8vIHVzZUNhcHR1cmVcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gVG91Y2ggSGFuZGxlcnNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRoYW5kbGVUb3VjaFN0YXJ0OiBmdW5jdGlvbihldikge1xuXG5cdFx0Ly8gaWYgYSBwcmV2aW91cyB0b3VjaCBpbnRlcmFjdGlvbiBuZXZlciBlbmRlZCB3aXRoIGEgdG91Y2hlbmQsIHRoZW4gaW1wbGljaXRseSBlbmQgaXQsXG5cdFx0Ly8gYnV0IHNpbmNlIGEgbmV3IHRvdWNoIGludGVyYWN0aW9uIGlzIGFib3V0IHRvIGJlZ2luLCBkb24ndCBzdGFydCB0aGUgbW91c2UgaWdub3JlIHBlcmlvZC5cblx0XHR0aGlzLnN0b3BUb3VjaChldiwgdHJ1ZSk7IC8vIHNraXBNb3VzZUlnbm9yZT10cnVlXG5cblx0XHR0aGlzLmlzVG91Y2hpbmcgPSB0cnVlO1xuXHRcdHRoaXMudHJpZ2dlcigndG91Y2hzdGFydCcsIGV2KTtcblx0fSxcblxuXHRoYW5kbGVUb3VjaE1vdmU6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0aWYgKHRoaXMuaXNUb3VjaGluZykge1xuXHRcdFx0dGhpcy50cmlnZ2VyKCd0b3VjaG1vdmUnLCBldik7XG5cdFx0fVxuXHR9LFxuXG5cdGhhbmRsZVRvdWNoQ2FuY2VsOiBmdW5jdGlvbihldikge1xuXHRcdGlmICh0aGlzLmlzVG91Y2hpbmcpIHtcblx0XHRcdHRoaXMudHJpZ2dlcigndG91Y2hjYW5jZWwnLCBldik7XG5cblx0XHRcdC8vIEhhdmUgdG91Y2hjYW5jZWwgZmlyZSBhbiBhcnRpZmljaWFsIHRvdWNoZW5kLiBUaGF0IHdheSwgaGFuZGxlcnMgd29uJ3QgbmVlZCB0byBsaXN0ZW4gdG8gYm90aC5cblx0XHRcdC8vIElmIHRvdWNoZW5kIGZpcmVzIGxhdGVyLCBpdCB3b24ndCBoYXZlIGFueSBlZmZlY3QgYi9jIGlzVG91Y2hpbmcgd2lsbCBiZSBmYWxzZS5cblx0XHRcdHRoaXMuc3RvcFRvdWNoKGV2KTtcblx0XHR9XG5cdH0sXG5cblx0aGFuZGxlVG91Y2hFbmQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy5zdG9wVG91Y2goZXYpO1xuXHR9LFxuXG5cblx0Ly8gTW91c2UgSGFuZGxlcnNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGV2KSB7XG5cdFx0aWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdXNlKCkpIHtcblx0XHRcdHRoaXMudHJpZ2dlcignbW91c2Vkb3duJywgZXYpO1xuXHRcdH1cblx0fSxcblxuXHRoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0aWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdXNlKCkpIHtcblx0XHRcdHRoaXMudHJpZ2dlcignbW91c2Vtb3ZlJywgZXYpO1xuXHRcdH1cblx0fSxcblxuXHRoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihldikge1xuXHRcdGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ21vdXNldXAnLCBldik7XG5cdFx0fVxuXHR9LFxuXG5cdGhhbmRsZUNsaWNrOiBmdW5jdGlvbihldikge1xuXHRcdGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2NsaWNrJywgZXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIE1pc2MgSGFuZGxlcnNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRoYW5kbGVTZWxlY3RTdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ3NlbGVjdHN0YXJ0JywgZXYpO1xuXHR9LFxuXG5cdGhhbmRsZUNvbnRleHRNZW51OiBmdW5jdGlvbihldikge1xuXHRcdHRoaXMudHJpZ2dlcignY29udGV4dG1lbnUnLCBldik7XG5cdH0sXG5cblx0aGFuZGxlU2Nyb2xsOiBmdW5jdGlvbihldikge1xuXHRcdHRoaXMudHJpZ2dlcignc2Nyb2xsJywgZXYpO1xuXHR9LFxuXG5cblx0Ly8gVXRpbHNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRzdG9wVG91Y2g6IGZ1bmN0aW9uKGV2LCBza2lwTW91c2VJZ25vcmUpIHtcblx0XHRpZiAodGhpcy5pc1RvdWNoaW5nKSB7XG5cdFx0XHR0aGlzLmlzVG91Y2hpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMudHJpZ2dlcigndG91Y2hlbmQnLCBldik7XG5cblx0XHRcdGlmICghc2tpcE1vdXNlSWdub3JlKSB7XG5cdFx0XHRcdHRoaXMuc3RhcnRUb3VjaE1vdXNlSWdub3JlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHN0YXJ0VG91Y2hNb3VzZUlnbm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgd2FpdCA9IEZDLnRvdWNoTW91c2VJZ25vcmVXYWl0O1xuXG5cdFx0aWYgKHdhaXQpIHtcblx0XHRcdHRoaXMubW91c2VJZ25vcmVEZXB0aCsrO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0X3RoaXMubW91c2VJZ25vcmVEZXB0aC0tO1xuXHRcdFx0fSwgd2FpdCk7XG5cdFx0fVxuXHR9LFxuXG5cdHNob3VsZElnbm9yZU1vdXNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1RvdWNoaW5nIHx8IEJvb2xlYW4odGhpcy5tb3VzZUlnbm9yZURlcHRoKTtcblx0fVxuXG59KTtcblxuXG4vLyBTaW5nbGV0b25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBnbG9iYWxFbWl0dGVyID0gbnVsbDtcblx0dmFyIG5lZWRlZENvdW50ID0gMDtcblxuXG5cdC8vIGdldHMgdGhlIHNpbmdsZXRvblxuXHRHbG9iYWxFbWl0dGVyLmdldCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYgKCFnbG9iYWxFbWl0dGVyKSB7XG5cdFx0XHRnbG9iYWxFbWl0dGVyID0gbmV3IEdsb2JhbEVtaXR0ZXIoKTtcblx0XHRcdGdsb2JhbEVtaXR0ZXIuYmluZCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiBnbG9iYWxFbWl0dGVyO1xuXHR9O1xuXG5cblx0Ly8gY2FsbGVkIHdoZW4gYW4gb2JqZWN0IGtub3dzIGl0IHdpbGwgbmVlZCBhIEdsb2JhbEVtaXR0ZXIgaW4gdGhlIG5lYXIgZnV0dXJlLlxuXHRHbG9iYWxFbWl0dGVyLm5lZWRlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdEdsb2JhbEVtaXR0ZXIuZ2V0KCk7IC8vIGVuc3VyZXMgZ2xvYmFsRW1pdHRlclxuXHRcdG5lZWRlZENvdW50Kys7XG5cdH07XG5cblxuXHQvLyBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0IHRoYXQgb3JpZ2luYWxseSBjYWxsZWQgbmVlZGVkKCkgZG9lc24ndCBuZWVkIGEgR2xvYmFsRW1pdHRlciBhbnltb3JlLlxuXHRHbG9iYWxFbWl0dGVyLnVubmVlZGVkID0gZnVuY3Rpb24oKSB7XG5cdFx0bmVlZGVkQ291bnQtLTtcblxuXHRcdGlmICghbmVlZGVkQ291bnQpIHsgLy8gbm9ib2R5IGVsc2UgbmVlZHMgaXRcblx0XHRcdGdsb2JhbEVtaXR0ZXIudW5iaW5kKCk7XG5cdFx0XHRnbG9iYWxFbWl0dGVyID0gbnVsbDtcblx0XHR9XG5cdH07XG5cbn0pKCk7XG5cbjs7XG5cbi8qIENyZWF0ZXMgYSBjbG9uZSBvZiBhbiBlbGVtZW50IGFuZCBsZXRzIGl0IHRyYWNrIHRoZSBtb3VzZSBhcyBpdCBtb3Zlc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbnZhciBNb3VzZUZvbGxvd2VyID0gQ2xhc3MuZXh0ZW5kKExpc3RlbmVyTWl4aW4sIHtcblxuXHRvcHRpb25zOiBudWxsLFxuXG5cdHNvdXJjZUVsOiBudWxsLCAvLyB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgY2xvbmVkIGFuZCBtYWRlIHRvIGxvb2sgbGlrZSBpdCBpcyBkcmFnZ2luZ1xuXHRlbDogbnVsbCwgLy8gdGhlIGNsb25lIG9mIGBzb3VyY2VFbGAgdGhhdCB3aWxsIHRyYWNrIHRoZSBtb3VzZVxuXHRwYXJlbnRFbDogbnVsbCwgLy8gdGhlIGVsZW1lbnQgdGhhdCBgZWxgICh0aGUgY2xvbmUpIHdpbGwgYmUgYXR0YWNoZWQgdG9cblxuXHQvLyB0aGUgaW5pdGlhbCBwb3NpdGlvbiBvZiBlbCwgcmVsYXRpdmUgdG8gdGhlIG9mZnNldCBwYXJlbnQuIG1hZGUgdG8gbWF0Y2ggdGhlIGluaXRpYWwgb2Zmc2V0IG9mIHNvdXJjZUVsXG5cdHRvcDA6IG51bGwsXG5cdGxlZnQwOiBudWxsLFxuXG5cdC8vIHRoZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBvZiB0aGUgaW5pdGlhdGluZyB0b3VjaC9tb3VzZSBhY3Rpb25cblx0eTA6IG51bGwsXG5cdHgwOiBudWxsLFxuXG5cdC8vIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoZSBtb3VzZSBoYXMgbW92ZWQgZnJvbSBpdHMgaW5pdGlhbCBwb3NpdGlvblxuXHR0b3BEZWx0YTogbnVsbCxcblx0bGVmdERlbHRhOiBudWxsLFxuXG5cdGlzRm9sbG93aW5nOiBmYWxzZSxcblx0aXNIaWRkZW46IGZhbHNlLFxuXHRpc0FuaW1hdGluZzogZmFsc2UsIC8vIGRvaW5nIHRoZSByZXZlcnQgYW5pbWF0aW9uP1xuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbihzb3VyY2VFbCwgb3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdHRoaXMuc291cmNlRWwgPSBzb3VyY2VFbDtcblx0XHR0aGlzLnBhcmVudEVsID0gb3B0aW9ucy5wYXJlbnRFbCA/ICQob3B0aW9ucy5wYXJlbnRFbCkgOiBzb3VyY2VFbC5wYXJlbnQoKTsgLy8gZGVmYXVsdCB0byBzb3VyY2VFbCdzIHBhcmVudFxuXHR9LFxuXG5cblx0Ly8gQ2F1c2VzIHRoZSBlbGVtZW50IHRvIHN0YXJ0IGZvbGxvd2luZyB0aGUgbW91c2Vcblx0c3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0aWYgKCF0aGlzLmlzRm9sbG93aW5nKSB7XG5cdFx0XHR0aGlzLmlzRm9sbG93aW5nID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy55MCA9IGdldEV2WShldik7XG5cdFx0XHR0aGlzLngwID0gZ2V0RXZYKGV2KTtcblx0XHRcdHRoaXMudG9wRGVsdGEgPSAwO1xuXHRcdFx0dGhpcy5sZWZ0RGVsdGEgPSAwO1xuXG5cdFx0XHRpZiAoIXRoaXMuaXNIaWRkZW4pIHtcblx0XHRcdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZ2V0RXZJc1RvdWNoKGV2KSkge1xuXHRcdFx0XHR0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3ZlKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3ZlKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYXVzZXMgdGhlIGVsZW1lbnQgdG8gc3RvcCBmb2xsb3dpbmcgdGhlIG1vdXNlLiBJZiBzaG91bGRSZXZlcnQgaXMgdHJ1ZSwgd2lsbCBhbmltYXRlIGJhY2sgdG8gb3JpZ2luYWwgcG9zaXRpb24uXG5cdC8vIGBjYWxsYmFja2AgZ2V0cyBpbnZva2VkIHdoZW4gdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS4gSWYgbm8gYW5pbWF0aW9uLCBpdCBpcyBpbnZva2VkIGltbWVkaWF0ZWx5LlxuXHRzdG9wOiBmdW5jdGlvbihzaG91bGRSZXZlcnQsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgcmV2ZXJ0RHVyYXRpb24gPSB0aGlzLm9wdGlvbnMucmV2ZXJ0RHVyYXRpb247XG5cblx0XHRmdW5jdGlvbiBjb21wbGV0ZSgpIHsgLy8gbWlnaHQgYmUgY2FsbGVkIGJ5IC5hbmltYXRlKCksIHdoaWNoIG1pZ2h0IGNoYW5nZSBgdGhpc2AgY29udGV4dFxuXHRcdFx0X3RoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdF90aGlzLnJlbW92ZUVsZW1lbnQoKTtcblxuXHRcdFx0X3RoaXMudG9wMCA9IF90aGlzLmxlZnQwID0gbnVsbDsgLy8gcmVzZXQgc3RhdGUgZm9yIGZ1dHVyZSB1cGRhdGVQb3NpdGlvbiBjYWxsc1xuXG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5pc0ZvbGxvd2luZyAmJiAhdGhpcy5pc0FuaW1hdGluZykgeyAvLyBkaXNhbGxvdyBtb3JlIHRoYW4gb25lIHN0b3AgYW5pbWF0aW9uIGF0IGEgdGltZVxuXHRcdFx0dGhpcy5pc0ZvbGxvd2luZyA9IGZhbHNlO1xuXG5cdFx0XHR0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7XG5cblx0XHRcdGlmIChzaG91bGRSZXZlcnQgJiYgcmV2ZXJ0RHVyYXRpb24gJiYgIXRoaXMuaXNIaWRkZW4pIHsgLy8gZG8gYSByZXZlcnQgYW5pbWF0aW9uP1xuXHRcdFx0XHR0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5lbC5hbmltYXRlKHtcblx0XHRcdFx0XHR0b3A6IHRoaXMudG9wMCxcblx0XHRcdFx0XHRsZWZ0OiB0aGlzLmxlZnQwXG5cdFx0XHRcdH0sIHtcblx0XHRcdFx0XHRkdXJhdGlvbjogcmV2ZXJ0RHVyYXRpb24sXG5cdFx0XHRcdFx0Y29tcGxldGU6IGNvbXBsZXRlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGNvbXBsZXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgdHJhY2tpbmcgZWxlbWVudC4gQ3JlYXRlIGl0IGlmIG5lY2Vzc2FyeVxuXHRnZXRFbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsID0gdGhpcy5lbDtcblxuXHRcdGlmICghZWwpIHtcblx0XHRcdGVsID0gdGhpcy5lbCA9IHRoaXMuc291cmNlRWwuY2xvbmUoKVxuXHRcdFx0XHQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFkZGl0aW9uYWxDbGFzcyB8fCAnJylcblx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdFx0dmlzaWJpbGl0eTogJycsIC8vIGluIGNhc2Ugb3JpZ2luYWwgZWxlbWVudCB3YXMgaGlkZGVuIChjb21tb25seSB0aHJvdWdoIGhpZGVFdmVudHMoKSlcblx0XHRcdFx0XHRkaXNwbGF5OiB0aGlzLmlzSGlkZGVuID8gJ25vbmUnIDogJycsIC8vIGZvciB3aGVuIGluaXRpYWxseSBoaWRkZW5cblx0XHRcdFx0XHRtYXJnaW46IDAsXG5cdFx0XHRcdFx0cmlnaHQ6ICdhdXRvJywgLy8gZXJhc2UgYW5kIHNldCB3aWR0aCBpbnN0ZWFkXG5cdFx0XHRcdFx0Ym90dG9tOiAnYXV0bycsIC8vIGVyYXNlIGFuZCBzZXQgaGVpZ2h0IGluc3RlYWRcblx0XHRcdFx0XHR3aWR0aDogdGhpcy5zb3VyY2VFbC53aWR0aCgpLCAvLyBleHBsaWNpdCBoZWlnaHQgaW4gY2FzZSB0aGVyZSB3YXMgYSAncmlnaHQnIHZhbHVlXG5cdFx0XHRcdFx0aGVpZ2h0OiB0aGlzLnNvdXJjZUVsLmhlaWdodCgpLCAvLyBleHBsaWNpdCB3aWR0aCBpbiBjYXNlIHRoZXJlIHdhcyBhICdib3R0b20nIHZhbHVlXG5cdFx0XHRcdFx0b3BhY2l0eTogdGhpcy5vcHRpb25zLm9wYWNpdHkgfHwgJycsXG5cdFx0XHRcdFx0ekluZGV4OiB0aGlzLm9wdGlvbnMuekluZGV4XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyB3ZSBkb24ndCB3YW50IGxvbmcgdGFwcyBvciBhbnkgbW91c2UgaW50ZXJhY3Rpb24gY2F1c2luZyBzZWxlY3Rpb24vbWVudXMuXG5cdFx0XHQvLyB3b3VsZCB1c2UgcHJldmVudFNlbGVjdGlvbigpLCBidXQgdGhhdCBwcmV2ZW50cyBzZWxlY3RzdGFydCwgY2F1c2luZyBwcm9ibGVtcy5cblx0XHRcdGVsLmFkZENsYXNzKCdmYy11bnNlbGVjdGFibGUnKTtcblxuXHRcdFx0ZWwuYXBwZW5kVG8odGhpcy5wYXJlbnRFbCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsO1xuXHR9LFxuXG5cblx0Ly8gUmVtb3ZlcyB0aGUgdHJhY2tpbmcgZWxlbWVudCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcblx0cmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuZWwpIHtcblx0XHRcdHRoaXMuZWwucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLmVsID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBVcGRhdGUgdGhlIENTUyBwb3NpdGlvbiBvZiB0aGUgdHJhY2tpbmcgZWxlbWVudFxuXHR1cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNvdXJjZU9mZnNldDtcblx0XHR2YXIgb3JpZ2luO1xuXG5cdFx0dGhpcy5nZXRFbCgpOyAvLyBlbnN1cmUgdGhpcy5lbFxuXG5cdFx0Ly8gbWFrZSBzdXJlIG9yaWdpbiBpbmZvIHdhcyBjb21wdXRlZFxuXHRcdGlmICh0aGlzLnRvcDAgPT09IG51bGwpIHtcblx0XHRcdHNvdXJjZU9mZnNldCA9IHRoaXMuc291cmNlRWwub2Zmc2V0KCk7XG5cdFx0XHRvcmlnaW4gPSB0aGlzLmVsLm9mZnNldFBhcmVudCgpLm9mZnNldCgpO1xuXHRcdFx0dGhpcy50b3AwID0gc291cmNlT2Zmc2V0LnRvcCAtIG9yaWdpbi50b3A7XG5cdFx0XHR0aGlzLmxlZnQwID0gc291cmNlT2Zmc2V0LmxlZnQgLSBvcmlnaW4ubGVmdDtcblx0XHR9XG5cblx0XHR0aGlzLmVsLmNzcyh7XG5cdFx0XHR0b3A6IHRoaXMudG9wMCArIHRoaXMudG9wRGVsdGEsXG5cdFx0XHRsZWZ0OiB0aGlzLmxlZnQwICsgdGhpcy5sZWZ0RGVsdGFcblx0XHR9KTtcblx0fSxcblxuXG5cdC8vIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgbW92ZXMgdGhlIG1vdXNlXG5cdGhhbmRsZU1vdmU6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy50b3BEZWx0YSA9IGdldEV2WShldikgLSB0aGlzLnkwO1xuXHRcdHRoaXMubGVmdERlbHRhID0gZ2V0RXZYKGV2KSAtIHRoaXMueDA7XG5cblx0XHRpZiAoIXRoaXMuaXNIaWRkZW4pIHtcblx0XHRcdHRoaXMudXBkYXRlUG9zaXRpb24oKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBUZW1wb3JhcmlseSBtYWtlcyB0aGUgdHJhY2tpbmcgZWxlbWVudCBpbnZpc2libGUuIENhbiBiZSBjYWxsZWQgYmVmb3JlIGZvbGxvd2luZyBzdGFydHNcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzSGlkZGVuKSB7XG5cdFx0XHR0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcblx0XHRcdGlmICh0aGlzLmVsKSB7XG5cdFx0XHRcdHRoaXMuZWwuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIFNob3cgdGhlIHRyYWNraW5nIGVsZW1lbnQgYWZ0ZXIgaXQgaGFzIGJlZW4gdGVtcG9yYXJpbHkgaGlkZGVuXG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmlzSGlkZGVuKSB7XG5cdFx0XHR0aGlzLmlzSGlkZGVuID0gZmFsc2U7XG5cdFx0XHR0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG5cdFx0XHR0aGlzLmdldEVsKCkuc2hvdygpO1xuXHRcdH1cblx0fVxuXG59KTtcblxuOztcblxuLyogQW4gYWJzdHJhY3QgY2xhc3MgY29tcHJpc2VkIG9mIGEgXCJncmlkXCIgb2YgYXJlYXMgdGhhdCBlYWNoIHJlcHJlc2VudCBhIHNwZWNpZmljIGRhdGV0aW1lXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxudmFyIEdyaWQgPSBGQy5HcmlkID0gQ2xhc3MuZXh0ZW5kKExpc3RlbmVyTWl4aW4sIHtcblxuXHQvLyBzZWxmLWNvbmZpZywgb3ZlcnJpZGFibGUgYnkgc3ViY2xhc3Nlc1xuXHRoYXNEYXlJbnRlcmFjdGlvbnM6IHRydWUsIC8vIGNhbiB1c2VyIGNsaWNrL3NlbGVjdCByYW5nZXMgb2YgdGltZT9cblxuXHR2aWV3OiBudWxsLCAvLyBhIFZpZXcgb2JqZWN0XG5cdGlzUlRMOiBudWxsLCAvLyBzaG9ydGN1dCB0byB0aGUgdmlldydzIGlzUlRMIG9wdGlvblxuXG5cdHN0YXJ0OiBudWxsLFxuXHRlbmQ6IG51bGwsXG5cblx0ZWw6IG51bGwsIC8vIHRoZSBjb250YWluaW5nIGVsZW1lbnRcblx0ZWxzQnlGaWxsOiBudWxsLCAvLyBhIGhhc2ggb2YgalF1ZXJ5IGVsZW1lbnQgc2V0cyB1c2VkIGZvciByZW5kZXJpbmcgZWFjaCBmaWxsLiBLZXllZCBieSBmaWxsIG5hbWUuXG5cblx0Ly8gZGVyaXZlZCBmcm9tIG9wdGlvbnNcblx0ZXZlbnRUaW1lRm9ybWF0OiBudWxsLFxuXHRkaXNwbGF5RXZlbnRUaW1lOiBudWxsLFxuXHRkaXNwbGF5RXZlbnRFbmQ6IG51bGwsXG5cblx0bWluUmVzaXplRHVyYXRpb246IG51bGwsIC8vIFRPRE86IGhhY2suIHNldCBieSBzdWJjbGFzc2VzLiBtaW51bXVtIGV2ZW50IHJlc2l6ZSBkdXJhdGlvblxuXG5cdC8vIGlmIGRlZmluZWQsIGhvbGRzIHRoZSB1bml0IGlkZW50aWZpZWQgKGV4OiBcInllYXJcIiBvciBcIm1vbnRoXCIpIHRoYXQgZGV0ZXJtaW5lcyB0aGUgbGV2ZWwgb2YgZ3JhbnVsYXJpdHlcblx0Ly8gb2YgdGhlIGRhdGUgYXJlYXMuIGlmIG5vdCBkZWZpbmVkLCBhc3N1bWVzIHRvIGJlIGRheSBhbmQgdGltZSBncmFudWxhcml0eS5cblx0Ly8gVE9ETzogcG9ydCBpc1RpbWVTY2FsZSBpbnRvIHNhbWUgc3lzdGVtP1xuXHRsYXJnZVVuaXQ6IG51bGwsXG5cblx0ZGF5Q2xpY2tMaXN0ZW5lcjogbnVsbCxcblx0ZGF5U2VsZWN0TGlzdGVuZXI6IG51bGwsXG5cdHNlZ0RyYWdMaXN0ZW5lcjogbnVsbCxcblx0c2VnUmVzaXplTGlzdGVuZXI6IG51bGwsXG5cdGV4dGVybmFsRHJhZ0xpc3RlbmVyOiBudWxsLFxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKHZpZXcpIHtcblx0XHR0aGlzLnZpZXcgPSB2aWV3O1xuXHRcdHRoaXMuaXNSVEwgPSB2aWV3Lm9wdCgnaXNSVEwnKTtcblx0XHR0aGlzLmVsc0J5RmlsbCA9IHt9O1xuXG5cdFx0dGhpcy5kYXlDbGlja0xpc3RlbmVyID0gdGhpcy5idWlsZERheUNsaWNrTGlzdGVuZXIoKTtcblx0XHR0aGlzLmRheVNlbGVjdExpc3RlbmVyID0gdGhpcy5idWlsZERheVNlbGVjdExpc3RlbmVyKCk7XG5cdH0sXG5cblxuXHQvKiBPcHRpb25zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIGZvcm1hdCBzdHJpbmcgdXNlZCBmb3IgZXZlbnQgdGltZSB0ZXh0LCBpZiBub3QgZXhwbGljaXRseSBkZWZpbmVkIGJ5ICd0aW1lRm9ybWF0J1xuXHRjb21wdXRlRXZlbnRUaW1lRm9ybWF0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy52aWV3Lm9wdCgnc21hbGxUaW1lRm9ybWF0Jyk7XG5cdH0sXG5cblxuXHQvLyBEZXRlcm1pbmVzIHdoZXRoZXIgZXZlbnRzIHNob3VsZCBoYXZlIHRoZWlyIGVuZCB0aW1lcyBkaXNwbGF5ZWQsIGlmIG5vdCBleHBsaWNpdGx5IGRlZmluZWQgYnkgJ2Rpc3BsYXlFdmVudFRpbWUnLlxuXHQvLyBPbmx5IGFwcGxpZXMgdG8gbm9uLWFsbC1kYXkgZXZlbnRzLlxuXHRjb21wdXRlRGlzcGxheUV2ZW50VGltZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblxuXHQvLyBEZXRlcm1pbmVzIHdoZXRoZXIgZXZlbnRzIHNob3VsZCBoYXZlIHRoZWlyIGVuZCB0aW1lcyBkaXNwbGF5ZWQsIGlmIG5vdCBleHBsaWNpdGx5IGRlZmluZWQgYnkgJ2Rpc3BsYXlFdmVudEVuZCdcblx0Y29tcHV0ZURpc3BsYXlFdmVudEVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblxuXHQvKiBEYXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gVGVsbHMgdGhlIGdyaWQgYWJvdXQgd2hhdCBwZXJpb2Qgb2YgdGltZSB0byBkaXNwbGF5LlxuXHQvLyBBbnkgZGF0ZS1yZWxhdGVkIGludGVybmFsIGRhdGEgc2hvdWxkIGJlIGdlbmVyYXRlZC5cblx0c2V0UmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG5cdFx0dGhpcy5zdGFydCA9IHJhbmdlLnN0YXJ0LmNsb25lKCk7XG5cdFx0dGhpcy5lbmQgPSByYW5nZS5lbmQuY2xvbmUoKTtcblxuXHRcdHRoaXMucmFuZ2VVcGRhdGVkKCk7XG5cdFx0dGhpcy5wcm9jZXNzUmFuZ2VPcHRpb25zKCk7XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiBpbnRlcm5hbCB2YXJpYWJsZXMgdGhhdCByZWx5IG9uIHRoZSByYW5nZSBzaG91bGQgYmUgdXBkYXRlZFxuXHRyYW5nZVVwZGF0ZWQ6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cblx0Ly8gVXBkYXRlcyB2YWx1ZXMgdGhhdCByZWx5IG9uIG9wdGlvbnMgYW5kIGFsc28gcmVsYXRlIHRvIHJhbmdlXG5cdHByb2Nlc3NSYW5nZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBkaXNwbGF5RXZlbnRUaW1lO1xuXHRcdHZhciBkaXNwbGF5RXZlbnRFbmQ7XG5cblx0XHR0aGlzLmV2ZW50VGltZUZvcm1hdCA9XG5cdFx0XHR2aWV3Lm9wdCgnZXZlbnRUaW1lRm9ybWF0JykgfHxcblx0XHRcdHZpZXcub3B0KCd0aW1lRm9ybWF0JykgfHwgLy8gZGVwcmVjYXRlZFxuXHRcdFx0dGhpcy5jb21wdXRlRXZlbnRUaW1lRm9ybWF0KCk7XG5cblx0XHRkaXNwbGF5RXZlbnRUaW1lID0gdmlldy5vcHQoJ2Rpc3BsYXlFdmVudFRpbWUnKTtcblx0XHRpZiAoZGlzcGxheUV2ZW50VGltZSA9PSBudWxsKSB7XG5cdFx0XHRkaXNwbGF5RXZlbnRUaW1lID0gdGhpcy5jb21wdXRlRGlzcGxheUV2ZW50VGltZSgpOyAvLyBtaWdodCBiZSBiYXNlZCBvZmYgb2YgcmFuZ2Vcblx0XHR9XG5cblx0XHRkaXNwbGF5RXZlbnRFbmQgPSB2aWV3Lm9wdCgnZGlzcGxheUV2ZW50RW5kJyk7XG5cdFx0aWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7XG5cdFx0XHRkaXNwbGF5RXZlbnRFbmQgPSB0aGlzLmNvbXB1dGVEaXNwbGF5RXZlbnRFbmQoKTsgLy8gbWlnaHQgYmUgYmFzZWQgb2ZmIG9mIHJhbmdlXG5cdFx0fVxuXG5cdFx0dGhpcy5kaXNwbGF5RXZlbnRUaW1lID0gZGlzcGxheUV2ZW50VGltZTtcblx0XHR0aGlzLmRpc3BsYXlFdmVudEVuZCA9IGRpc3BsYXlFdmVudEVuZDtcblx0fSxcblxuXG5cdC8vIENvbnZlcnRzIGEgc3BhbiAoaGFzIHVuem9uZWQgc3RhcnQvZW5kIGFuZCBhbnkgb3RoZXIgZ3JpZC1zcGVjaWZpYyBsb2NhdGlvbiBpbmZvcm1hdGlvbilcblx0Ly8gaW50byBhbiBhcnJheSBvZiBzZWdtZW50cyAocGllY2VzIG9mIGV2ZW50cyB3aG9zZSBmb3JtYXQgaXMgZGVjaWRlZCBieSB0aGUgZ3JpZCkuXG5cdHNwYW5Ub1NlZ3M6IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBEaWZmcyB0aGUgdHdvIGRhdGVzLCByZXR1cm5pbmcgYSBkdXJhdGlvbiwgYmFzZWQgb24gZ3JhbnVsYXJpdHkgb2YgdGhlIGdyaWRcblx0Ly8gVE9ETzogcG9ydCBpc1RpbWVTY2FsZSBpbnRvIHRoaXMgc3lzdGVtP1xuXHRkaWZmRGF0ZXM6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRpZiAodGhpcy5sYXJnZVVuaXQpIHtcblx0XHRcdHJldHVybiBkaWZmQnlVbml0KGEsIGIsIHRoaXMubGFyZ2VVbml0KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gZGlmZkRheVRpbWUoYSwgYik7XG5cdFx0fVxuXHR9LFxuXG5cblx0LyogSGl0IEFyZWFcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRoaXRzTmVlZGVkRGVwdGg6IDAsIC8vIG5lY2Vzc2FyeSBiZWNhdXNlIG11bHRpcGxlIGNhbGxlcnMgbWlnaHQgbmVlZCB0aGUgc2FtZSBoaXRzXG5cblx0aGl0c05lZWRlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCEodGhpcy5oaXRzTmVlZGVkRGVwdGgrKykpIHtcblx0XHRcdHRoaXMucHJlcGFyZUhpdHMoKTtcblx0XHR9XG5cdH0sXG5cblx0aGl0c05vdE5lZWRlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaGl0c05lZWRlZERlcHRoICYmICEoLS10aGlzLmhpdHNOZWVkZWREZXB0aCkpIHtcblx0XHRcdHRoaXMucmVsZWFzZUhpdHMoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgYmVmb3JlIG9uZSBvciBtb3JlIHF1ZXJ5SGl0IGNhbGxzIG1pZ2h0IGhhcHBlbi4gU2hvdWxkIHByZXBhcmUgYW55IGNhY2hlZCBjb29yZGluYXRlcyBmb3IgcXVlcnlIaXRcblx0cHJlcGFyZUhpdHM6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gcXVlcnlIaXQgY2FsbHMgaGF2ZSBzdWJzaWRlZC4gR29vZCBwbGFjZSB0byBjbGVhciBhbnkgY29vcmRpbmF0ZSBjYWNoZXMuXG5cdHJlbGVhc2VIaXRzOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdC8vIEdpdmVuIGNvb3JkaW5hdGVzIGZyb20gdGhlIHRvcGxlZnQgb2YgdGhlIGRvY3VtZW50LCByZXR1cm4gZGF0YSBhYm91dCB0aGUgZGF0ZS1yZWxhdGVkIGFyZWEgdW5kZXJuZWF0aC5cblx0Ly8gQ2FuIHJldHVybiBhbiBvYmplY3Qgd2l0aCBhcmJpdHJhcnkgcHJvcGVydGllcyAoYWx0aG91Z2ggdG9wL3JpZ2h0L2xlZnQvYm90dG9tIGFyZSBlbmNvdXJhZ2VkKS5cblx0Ly8gTXVzdCBoYXZlIGEgYGdyaWRgIHByb3BlcnR5LCBhIHJlZmVyZW5jZSB0byB0aGlzIGN1cnJlbnQgZ3JpZC4gVE9ETzogYXZvaWQgdGhpc1xuXHQvLyBUaGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IGdldEhpdFNwYW4gYW5kIGdldEhpdEVsLlxuXHRxdWVyeUhpdDogZnVuY3Rpb24obGVmdE9mZnNldCwgdG9wT2Zmc2V0KSB7XG5cdH0sXG5cblxuXHQvLyBsaWtlIGdldEhpdFNwYW4sIGJ1dCByZXR1cm5zIG51bGwgaWYgdGhlIHJlc3VsdGluZyBzcGFuJ3MgcmFuZ2UgaXMgaW52YWxpZFxuXHRnZXRTYWZlSGl0U3BhbjogZnVuY3Rpb24oaGl0KSB7XG5cdFx0dmFyIGhpdFNwYW4gPSB0aGlzLmdldEhpdFNwYW4oaGl0KTtcblxuXHRcdGlmICghaXNSYW5nZVdpdGhpblJhbmdlKGhpdFNwYW4sIHRoaXMudmlldy5hY3RpdmVSYW5nZSkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiBoaXRTcGFuO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gcG9zaXRpb24tbGV2ZWwgaW5mb3JtYXRpb24gYWJvdXQgYSBkYXRlLXJlbGF0ZWQgYXJlYSB3aXRoaW4gdGhlIGdyaWQsXG5cdC8vIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IHdpdGggYXQgbGVhc3QgYSBzdGFydC9lbmQgZGF0ZS4gQ2FuIHByb3ZpZGUgb3RoZXIgaW5mb3JtYXRpb24gYXMgd2VsbC5cblx0Z2V0SGl0U3BhbjogZnVuY3Rpb24oaGl0KSB7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBwb3NpdGlvbi1sZXZlbCBpbmZvcm1hdGlvbiBhYm91dCBhIGRhdGUtcmVsYXRlZCBhcmVhIHdpdGhpbiB0aGUgZ3JpZCxcblx0Ly8gc2hvdWxkIHJldHVybiBhIGpRdWVyeSBlbGVtZW50IHRoYXQgYmVzdCByZXByZXNlbnRzIGl0LiBwYXNzZWQgdG8gZGF5Q2xpY2sgY2FsbGJhY2suXG5cdGdldEhpdEVsOiBmdW5jdGlvbihoaXQpIHtcblx0fSxcblxuXG5cdC8qIFJlbmRlcmluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gU2V0cyB0aGUgY29udGFpbmVyIGVsZW1lbnQgdGhhdCB0aGUgZ3JpZCBzaG91bGQgcmVuZGVyIGluc2lkZSBvZi5cblx0Ly8gRG9lcyBvdGhlciBET00tcmVsYXRlZCBpbml0aWFsaXphdGlvbnMuXG5cdHNldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0dGhpcy5lbCA9IGVsO1xuXG5cdFx0aWYgKHRoaXMuaGFzRGF5SW50ZXJhY3Rpb25zKSB7XG5cdFx0XHRwcmV2ZW50U2VsZWN0aW9uKGVsKTtcblxuXHRcdFx0dGhpcy5iaW5kRGF5SGFuZGxlcigndG91Y2hzdGFydCcsIHRoaXMuZGF5VG91Y2hTdGFydCk7XG5cdFx0XHR0aGlzLmJpbmREYXlIYW5kbGVyKCdtb3VzZWRvd24nLCB0aGlzLmRheU1vdXNlZG93bik7XG5cdFx0fVxuXG5cdFx0Ly8gYXR0YWNoIGV2ZW50LWVsZW1lbnQtcmVsYXRlZCBoYW5kbGVycy4gaW4gR3JpZC5ldmVudHNcblx0XHQvLyBzYW1lIGdhcmJhZ2UgY29sbGVjdGlvbiBub3RlIGFzIGFib3ZlLlxuXHRcdHRoaXMuYmluZFNlZ0hhbmRsZXJzKCk7XG5cblx0XHR0aGlzLmJpbmRHbG9iYWxIYW5kbGVycygpO1xuXHR9LFxuXG5cblx0YmluZERheUhhbmRsZXI6IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0Ly8gYXR0YWNoIGEgaGFuZGxlciB0byB0aGUgZ3JpZCdzIHJvb3QgZWxlbWVudC5cblx0XHQvLyBqUXVlcnkgd2lsbCB0YWtlIGNhcmUgb2YgdW5yZWdpc3RlcmluZyB0aGVtIHdoZW4gcmVtb3ZlRWxlbWVudCBnZXRzIGNhbGxlZC5cblx0XHR0aGlzLmVsLm9uKG5hbWUsIGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCEkKGV2LnRhcmdldCkuaXMoXG5cdFx0XHRcdFx0X3RoaXMuc2VnU2VsZWN0b3IgKyAnLCcgKyAvLyBkaXJlY3RseSBvbiBhbiBldmVudCBlbGVtZW50XG5cdFx0XHRcdFx0X3RoaXMuc2VnU2VsZWN0b3IgKyAnICosJyArIC8vIHdpdGhpbiBhbiBldmVudCBlbGVtZW50XG5cdFx0XHRcdFx0Jy5mYy1tb3JlLCcgKyAvLyBhIFwibW9yZS4uXCIgbGlua1xuXHRcdFx0XHRcdCdhW2RhdGEtZ290b10nIC8vIGEgY2xpY2thYmxlIG5hdiBsaW5rXG5cdFx0XHRcdClcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gaGFuZGxlci5jYWxsKF90aGlzLCBldik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvLyBSZW1vdmVzIHRoZSBncmlkJ3MgY29udGFpbmVyIGVsZW1lbnQgZnJvbSB0aGUgRE9NLiBVbmRvZXMgYW55IG90aGVyIERPTS1yZWxhdGVkIGF0dGFjaG1lbnRzLlxuXHQvLyBET0VTIE5PVCByZW1vdmUgYW55IGNvbnRlbnQgYmVmb3JlaGFuZCAoZG9lc24ndCBjbGVhciBldmVudHMgb3IgY2FsbCB1bnJlbmRlckRhdGVzKSwgdW5saWtlIFZpZXdcblx0cmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bmJpbmRHbG9iYWxIYW5kbGVycygpO1xuXHRcdHRoaXMuY2xlYXJEcmFnTGlzdGVuZXJzKCk7XG5cblx0XHR0aGlzLmVsLnJlbW92ZSgpO1xuXG5cdFx0Ly8gTk9URTogd2UgZG9uJ3QgbnVsbC1vdXQgdGhpcy5lbCBmb3IgdGhlIHNhbWUgcmVhc29ucyB3ZSBkb24ndCBkbyBpdCB3aXRoaW4gVmlldzo6cmVtb3ZlRWxlbWVudFxuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgYmFzaWMgc3RydWN0dXJlIG9mIGdyaWQgdmlldyBiZWZvcmUgYW55IGNvbnRlbnQgaXMgcmVuZGVyZWRcblx0cmVuZGVyU2tlbGV0b246IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgZ3JpZCdzIGRhdGUtcmVsYXRlZCBjb250ZW50IChsaWtlIGFyZWFzIHRoYXQgcmVwcmVzZW50IGRheXMvdGltZXMpLlxuXHQvLyBBc3N1bWVzIHNldFJhbmdlIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkIGFuZCB0aGUgc2tlbGV0b24gaGFzIGFscmVhZHkgYmVlbiByZW5kZXJlZC5cblx0cmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIHRoZSBncmlkJ3MgZGF0ZS1yZWxhdGVkIGNvbnRlbnRcblx0dW5yZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvKiBIYW5kbGVyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQmluZHMgRE9NIGhhbmRsZXJzIHRvIGVsZW1lbnRzIHRoYXQgcmVzaWRlIG91dHNpZGUgdGhlIGdyaWQsIHN1Y2ggYXMgdGhlIGRvY3VtZW50XG5cdGJpbmRHbG9iYWxIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwge1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLmV4dGVybmFsRHJhZ1N0YXJ0LCAvLyBqcXVpXG5cdFx0XHRzb3J0c3RhcnQ6IHRoaXMuZXh0ZXJuYWxEcmFnU3RhcnQgLy8ganF1aVxuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gVW5iaW5kcyBET00gaGFuZGxlcnMgZnJvbSBlbGVtZW50cyB0aGF0IHJlc2lkZSBvdXRzaWRlIHRoZSBncmlkXG5cdHVuYmluZEdsb2JhbEhhbmRsZXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7XG5cdH0sXG5cblxuXHQvLyBQcm9jZXNzIGEgbW91c2Vkb3duIG9uIGFuIGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIGEgZGF5LiBGb3IgZGF5IGNsaWNraW5nIGFuZCBzZWxlY3RpbmcuXG5cdGRheU1vdXNlZG93bjogZnVuY3Rpb24oZXYpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdC8vIEhBQ0tcblx0XHQvLyBUaGlzIHdpbGwgc3RpbGwgd29yayBldmVuIHRob3VnaCBiaW5kRGF5SGFuZGxlciBkb2Vzbid0IHVzZSBHbG9iYWxFbWl0dGVyLlxuXHRcdGlmIChHbG9iYWxFbWl0dGVyLmdldCgpLnNob3VsZElnbm9yZU1vdXNlKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmRheUNsaWNrTGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldik7XG5cblx0XHRpZiAodmlldy5vcHQoJ3NlbGVjdGFibGUnKSkge1xuXHRcdFx0dGhpcy5kYXlTZWxlY3RMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2LCB7XG5cdFx0XHRcdGRpc3RhbmNlOiB2aWV3Lm9wdCgnc2VsZWN0TWluRGlzdGFuY2UnKVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cblx0ZGF5VG91Y2hTdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgc2VsZWN0TG9uZ1ByZXNzRGVsYXk7XG5cblx0XHQvLyBPbiBpT1MgKGFuZCBBbmRyb2lkPykgd2hlbiBhIG5ldyBzZWxlY3Rpb24gaXMgaW5pdGlhdGVkIG92ZXJ0b3AgYW5vdGhlciBzZWxlY3Rpb24sXG5cdFx0Ly8gdGhlIHRvdWNoZW5kIG5ldmVyIGZpcmVzIGJlY2F1c2UgdGhlIGVsZW1lbnRzIGdldHMgcmVtb3ZlZCBtaWQtdG91Y2gtaW50ZXJhY3Rpb24gKG15IHRoZW9yeSkuXG5cdFx0Ly8gSEFDSzogc2ltcGx5IGRvbid0IGFsbG93IHRoaXMgdG8gaGFwcGVuLlxuXHRcdC8vIEFMU086IHByZXZlbnQgc2VsZWN0aW9uIHdoZW4gYW4gKmV2ZW50KiBpcyBhbHJlYWR5IHJhaXNlZC5cblx0XHRpZiAodmlldy5pc1NlbGVjdGVkIHx8IHZpZXcuc2VsZWN0ZWRFdmVudCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHNlbGVjdExvbmdQcmVzc0RlbGF5ID0gdmlldy5vcHQoJ3NlbGVjdExvbmdQcmVzc0RlbGF5Jyk7XG5cdFx0aWYgKHNlbGVjdExvbmdQcmVzc0RlbGF5ID09IG51bGwpIHtcblx0XHRcdHNlbGVjdExvbmdQcmVzc0RlbGF5ID0gdmlldy5vcHQoJ2xvbmdQcmVzc0RlbGF5Jyk7IC8vIGZhbGxiYWNrXG5cdFx0fVxuXG5cdFx0dGhpcy5kYXlDbGlja0xpc3RlbmVyLnN0YXJ0SW50ZXJhY3Rpb24oZXYpO1xuXG5cdFx0aWYgKHZpZXcub3B0KCdzZWxlY3RhYmxlJykpIHtcblx0XHRcdHRoaXMuZGF5U2VsZWN0TGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldiwge1xuXHRcdFx0XHRkZWxheTogc2VsZWN0TG9uZ1ByZXNzRGVsYXlcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIENyZWF0ZXMgYSBsaXN0ZW5lciB0aGF0IHRyYWNrcyB0aGUgdXNlcidzIGRyYWcgYWNyb3NzIGRheSBlbGVtZW50cywgZm9yIGRheSBjbGlja2luZy5cblx0YnVpbGREYXlDbGlja0xpc3RlbmVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBkYXlDbGlja0hpdDsgLy8gbnVsbCBpZiBpbnZhbGlkIGRheUNsaWNrXG5cblx0XHR2YXIgZHJhZ0xpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcih0aGlzLCB7XG5cdFx0XHRzY3JvbGw6IHZpZXcub3B0KCdkcmFnU2Nyb2xsJyksXG5cdFx0XHRpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF5Q2xpY2tIaXQgPSBkcmFnTGlzdGVuZXIub3JpZ0hpdDtcblx0XHRcdH0sXG5cdFx0XHRoaXRPdmVyOiBmdW5jdGlvbihoaXQsIGlzT3JpZywgb3JpZ0hpdCkge1xuXHRcdFx0XHQvLyBpZiB1c2VyIGRyYWdnZWQgdG8gYW5vdGhlciBjZWxsIGF0IGFueSBwb2ludCwgaXQgY2FuIG5vIGxvbmdlciBiZSBhIGRheUNsaWNrXG5cdFx0XHRcdGlmICghaXNPcmlnKSB7XG5cdFx0XHRcdFx0ZGF5Q2xpY2tIaXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aGl0T3V0OiBmdW5jdGlvbigpIHsgLy8gY2FsbGVkIGJlZm9yZSBtb3VzZSBtb3ZlcyB0byBhIGRpZmZlcmVudCBoaXQgT1IgbW92ZWQgb3V0IG9mIGFsbCBoaXRzXG5cdFx0XHRcdGRheUNsaWNrSGl0ID0gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHRpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24oZXYsIGlzQ2FuY2VsbGVkKSB7XG5cdFx0XHRcdHZhciBoaXRTcGFuO1xuXG5cdFx0XHRcdGlmICghaXNDYW5jZWxsZWQgJiYgZGF5Q2xpY2tIaXQpIHtcblx0XHRcdFx0XHRoaXRTcGFuID0gX3RoaXMuZ2V0U2FmZUhpdFNwYW4oZGF5Q2xpY2tIaXQpO1xuXG5cdFx0XHRcdFx0aWYgKGhpdFNwYW4pIHtcblx0XHRcdFx0XHRcdHZpZXcudHJpZ2dlckRheUNsaWNrKGhpdFNwYW4sIF90aGlzLmdldEhpdEVsKGRheUNsaWNrSGl0KSwgZXYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gYmVjYXVzZSBkYXlDbGlja0xpc3RlbmVyIHdvbid0IGJlIGNhbGxlZCB3aXRoIGFueSB0aW1lIGRlbGF5LCBcImRyYWdnaW5nXCIgd2lsbCBiZWdpbiBpbW1lZGlhdGVseSxcblx0XHQvLyB3aGljaCB3aWxsIGtpbGwgYW55IHRvdWNobW92aW5nL3Njcm9sbGluZy4gUHJldmVudCB0aGlzLlxuXHRcdGRyYWdMaXN0ZW5lci5zaG91bGRDYW5jZWxUb3VjaFNjcm9sbCA9IGZhbHNlO1xuXG5cdFx0ZHJhZ0xpc3RlbmVyLnNjcm9sbEFsd2F5c0tpbGxzID0gdHJ1ZTtcblxuXHRcdHJldHVybiBkcmFnTGlzdGVuZXI7XG5cdH0sXG5cblxuXHQvLyBDcmVhdGVzIGEgbGlzdGVuZXIgdGhhdCB0cmFja3MgdGhlIHVzZXIncyBkcmFnIGFjcm9zcyBkYXkgZWxlbWVudHMsIGZvciBkYXkgc2VsZWN0aW5nLlxuXHRidWlsZERheVNlbGVjdExpc3RlbmVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBzZWxlY3Rpb25TcGFuOyAvLyBudWxsIGlmIGludmFsaWQgc2VsZWN0aW9uXG5cblx0XHR2YXIgZHJhZ0xpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcih0aGlzLCB7XG5cdFx0XHRzY3JvbGw6IHZpZXcub3B0KCdkcmFnU2Nyb2xsJyksXG5cdFx0XHRpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZWN0aW9uU3BhbiA9IG51bGw7XG5cdFx0XHR9LFxuXHRcdFx0ZHJhZ1N0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmlldy51bnNlbGVjdCgpOyAvLyBzaW5jZSB3ZSBjb3VsZCBiZSByZW5kZXJpbmcgYSBuZXcgc2VsZWN0aW9uLCB3ZSB3YW50IHRvIGNsZWFyIGFueSBvbGQgb25lXG5cdFx0XHR9LFxuXHRcdFx0aGl0T3ZlcjogZnVuY3Rpb24oaGl0LCBpc09yaWcsIG9yaWdIaXQpIHtcblx0XHRcdFx0dmFyIG9yaWdIaXRTcGFuO1xuXHRcdFx0XHR2YXIgaGl0U3BhbjtcblxuXHRcdFx0XHRpZiAob3JpZ0hpdCkgeyAvLyBjbGljayBuZWVkcyB0byBoYXZlIHN0YXJ0ZWQgb24gYSBoaXRcblxuXHRcdFx0XHRcdG9yaWdIaXRTcGFuID0gX3RoaXMuZ2V0U2FmZUhpdFNwYW4ob3JpZ0hpdCk7XG5cdFx0XHRcdFx0aGl0U3BhbiA9IF90aGlzLmdldFNhZmVIaXRTcGFuKGhpdCk7XG5cblx0XHRcdFx0XHRpZiAob3JpZ0hpdFNwYW4gJiYgaGl0U3Bhbikge1xuXHRcdFx0XHRcdFx0c2VsZWN0aW9uU3BhbiA9IF90aGlzLmNvbXB1dGVTZWxlY3Rpb24ob3JpZ0hpdFNwYW4sIGhpdFNwYW4pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGVjdGlvblNwYW4gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChzZWxlY3Rpb25TcGFuKSB7XG5cdFx0XHRcdFx0XHRfdGhpcy5yZW5kZXJTZWxlY3Rpb24oc2VsZWN0aW9uU3Bhbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKHNlbGVjdGlvblNwYW4gPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRkaXNhYmxlQ3Vyc29yKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aGl0T3V0OiBmdW5jdGlvbigpIHsgLy8gY2FsbGVkIGJlZm9yZSBtb3VzZSBtb3ZlcyB0byBhIGRpZmZlcmVudCBoaXQgT1IgbW92ZWQgb3V0IG9mIGFsbCBoaXRzXG5cdFx0XHRcdHNlbGVjdGlvblNwYW4gPSBudWxsO1xuXHRcdFx0XHRfdGhpcy51bnJlbmRlclNlbGVjdGlvbigpO1xuXHRcdFx0fSxcblx0XHRcdGhpdERvbmU6IGZ1bmN0aW9uKCkgeyAvLyBjYWxsZWQgYWZ0ZXIgYSBoaXRPdXQgT1IgYmVmb3JlIGEgZHJhZ0VuZFxuXHRcdFx0XHRlbmFibGVDdXJzb3IoKTtcblx0XHRcdH0sXG5cdFx0XHRpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24oZXYsIGlzQ2FuY2VsbGVkKSB7XG5cdFx0XHRcdGlmICghaXNDYW5jZWxsZWQgJiYgc2VsZWN0aW9uU3Bhbikge1xuXHRcdFx0XHRcdC8vIHRoZSBzZWxlY3Rpb24gd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiByZW5kZXJlZC4ganVzdCByZXBvcnQgaXRcblx0XHRcdFx0XHR2aWV3LnJlcG9ydFNlbGVjdGlvbihzZWxlY3Rpb25TcGFuLCBldik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBkcmFnTGlzdGVuZXI7XG5cdH0sXG5cblxuXHQvLyBLaWxscyBhbGwgaW4tcHJvZ3Jlc3MgZHJhZ2dpbmcuXG5cdC8vIFVzZWZ1bCBmb3Igd2hlbiBwdWJsaWMgQVBJIG1ldGhvZHMgdGhhdCByZXN1bHQgaW4gcmUtcmVuZGVyaW5nIGFyZSBpbnZva2VkIGR1cmluZyBhIGRyYWcuXG5cdC8vIEFsc28gdXNlZnVsIGZvciB3aGVuIHRvdWNoIGRldmljZXMgbWlzYmVoYXZlIGFuZCBkb24ndCBmaXJlIHRoZWlyIHRvdWNoZW5kLlxuXHRjbGVhckRyYWdMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5Q2xpY2tMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xuXHRcdHRoaXMuZGF5U2VsZWN0TGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTtcblxuXHRcdGlmICh0aGlzLnNlZ0RyYWdMaXN0ZW5lcikge1xuXHRcdFx0dGhpcy5zZWdEcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTsgLy8gd2lsbCBjbGVhciB0aGlzLnNlZ0RyYWdMaXN0ZW5lclxuXHRcdH1cblx0XHRpZiAodGhpcy5zZWdSZXNpemVMaXN0ZW5lcikge1xuXHRcdFx0dGhpcy5zZWdSZXNpemVMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpOyAvLyB3aWxsIGNsZWFyIHRoaXMuc2VnUmVzaXplTGlzdGVuZXJcblx0XHR9XG5cdFx0aWYgKHRoaXMuZXh0ZXJuYWxEcmFnTGlzdGVuZXIpIHtcblx0XHRcdHRoaXMuZXh0ZXJuYWxEcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTsgLy8gd2lsbCBjbGVhciB0aGlzLmV4dGVybmFsRHJhZ0xpc3RlbmVyXG5cdFx0fVxuXHR9LFxuXG5cblx0LyogRXZlbnQgSGVscGVyXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdC8vIFRPRE86IHNob3VsZCBwcm9iYWJseSBtb3ZlIHRoaXMgdG8gR3JpZC5ldmVudHMsIGxpa2Ugd2UgZGlkIGV2ZW50IGRyYWdnaW5nIC8gcmVzaXppbmdcblxuXG5cdC8vIFJlbmRlcnMgYSBtb2NrIGV2ZW50IGF0IHRoZSBnaXZlbiBldmVudCBsb2NhdGlvbiwgd2hpY2ggY29udGFpbnMgem9uZWQgc3RhcnQvZW5kIHByb3BlcnRpZXMuXG5cdC8vIFJldHVybnMgYWxsIG1vY2sgZXZlbnQgZWxlbWVudHMuXG5cdHJlbmRlckV2ZW50TG9jYXRpb25IZWxwZXI6IGZ1bmN0aW9uKGV2ZW50TG9jYXRpb24sIHNvdXJjZVNlZykge1xuXHRcdHZhciBmYWtlRXZlbnQgPSB0aGlzLmZhYnJpY2F0ZUhlbHBlckV2ZW50KGV2ZW50TG9jYXRpb24sIHNvdXJjZVNlZyk7XG5cblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJIZWxwZXIoZmFrZUV2ZW50LCBzb3VyY2VTZWcpOyAvLyBkbyB0aGUgYWN0dWFsIHJlbmRlcmluZ1xuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIGEgZmFrZSBldmVudCBnaXZlbiB6b25lZCBldmVudCBkYXRlIHByb3BlcnRpZXMgYW5kIGEgc2VnbWVudCBpcyBzaG91bGQgYmUgaW5zcGlyZWQgZnJvbS5cblx0Ly8gVGhlIHJhbmdlJ3MgZW5kIGNhbiBiZSBudWxsLCBpbiB3aGljaCBjYXNlIHRoZSBtb2NrIGV2ZW50IHRoYXQgaXMgcmVuZGVyZWQgd2lsbCBoYXZlIGEgbnVsbCBlbmQgdGltZS5cblx0Ly8gYHNvdXJjZVNlZ2AgaXMgdGhlIGludGVybmFsIHNlZ21lbnQgb2JqZWN0IGludm9sdmVkIGluIHRoZSBkcmFnLiBJZiBudWxsLCBzb21ldGhpbmcgZXh0ZXJuYWwgaXMgZHJhZ2dpbmcuXG5cdGZhYnJpY2F0ZUhlbHBlckV2ZW50OiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBzb3VyY2VTZWcpIHtcblx0XHR2YXIgZmFrZUV2ZW50ID0gc291cmNlU2VnID8gY3JlYXRlT2JqZWN0KHNvdXJjZVNlZy5ldmVudCkgOiB7fTsgLy8gbWFzayB0aGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0IGlmIHBvc3NpYmxlXG5cblx0XHRmYWtlRXZlbnQuc3RhcnQgPSBldmVudExvY2F0aW9uLnN0YXJ0LmNsb25lKCk7XG5cdFx0ZmFrZUV2ZW50LmVuZCA9IGV2ZW50TG9jYXRpb24uZW5kID8gZXZlbnRMb2NhdGlvbi5lbmQuY2xvbmUoKSA6IG51bGw7XG5cdFx0ZmFrZUV2ZW50LmFsbERheSA9IG51bGw7IC8vIGZvcmNlIGl0IHRvIGJlIGZyZXNobHkgY29tcHV0ZWQgYnkgbm9ybWFsaXplRXZlbnREYXRlc1xuXHRcdHRoaXMudmlldy5jYWxlbmRhci5ub3JtYWxpemVFdmVudERhdGVzKGZha2VFdmVudCk7XG5cblx0XHQvLyB0aGlzIGV4dHJhIGNsYXNzTmFtZSB3aWxsIGJlIHVzZWZ1bCBmb3IgZGlmZmVyZW50aWF0aW5nIHJlYWwgZXZlbnRzIGZyb20gbW9jayBldmVudHMgaW4gQ1NTXG5cdFx0ZmFrZUV2ZW50LmNsYXNzTmFtZSA9IChmYWtlRXZlbnQuY2xhc3NOYW1lIHx8IFtdKS5jb25jYXQoJ2ZjLWhlbHBlcicpO1xuXG5cdFx0Ly8gaWYgc29tZXRoaW5nIGV4dGVybmFsIGlzIGJlaW5nIGRyYWdnZWQgaW4sIGRvbid0IHJlbmRlciBhIHJlc2l6ZXJcblx0XHRpZiAoIXNvdXJjZVNlZykge1xuXHRcdFx0ZmFrZUV2ZW50LmVkaXRhYmxlID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZha2VFdmVudDtcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgYSBtb2NrIGV2ZW50LiBHaXZlbiB6b25lZCBldmVudCBkYXRlIHByb3BlcnRpZXMuXG5cdC8vIE11c3QgcmV0dXJuIGFsbCBtb2NrIGV2ZW50IGVsZW1lbnRzLlxuXHRyZW5kZXJIZWxwZXI6IGZ1bmN0aW9uKGV2ZW50TG9jYXRpb24sIHNvdXJjZVNlZykge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIG1vY2sgZXZlbnRcblx0dW5yZW5kZXJIZWxwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8qIFNlbGVjdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgc2VsZWN0aW9uLiBXaWxsIGhpZ2hsaWdodCBieSBkZWZhdWx0IGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuXHQvLyBHaXZlbiBhIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIGFuZCBvdGhlciBtaXNjIGRhdGEpXG5cdHJlbmRlclNlbGVjdGlvbjogZnVuY3Rpb24oc3Bhbikge1xuXHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0KHNwYW4pO1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbnMgb2YgYSBzZWxlY3Rpb24uIFdpbGwgdW5yZW5kZXIgYSBoaWdobGlnaHQgYnkgZGVmYXVsdC5cblx0dW5yZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIaWdobGlnaHQoKTtcblx0fSxcblxuXG5cdC8vIEdpdmVuIHRoZSBmaXJzdCBhbmQgbGFzdCBkYXRlLXNwYW5zIG9mIGEgc2VsZWN0aW9uLCByZXR1cm5zIGFub3RoZXIgZGF0ZS1zcGFuIG9iamVjdC5cblx0Ly8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgYW5kIHByb3ZpZGUgYWRkaXRpb25hbCBkYXRhIGluIHRoZSBzcGFuIG9iamVjdC4gV2lsbCBiZSBwYXNzZWQgdG8gcmVuZGVyU2VsZWN0aW9uKCkuXG5cdC8vIFdpbGwgcmV0dXJuIGZhbHNlIGlmIHRoZSBzZWxlY3Rpb24gaXMgaW52YWxpZCBhbmQgdGhpcyBzaG91bGQgYmUgaW5kaWNhdGVkIHRvIHRoZSB1c2VyLlxuXHQvLyBXaWxsIHJldHVybiBudWxsL3VuZGVmaW5lZCBpZiBhIHNlbGVjdGlvbiBpbnZhbGlkIGJ1dCBubyBlcnJvciBzaG91bGQgYmUgcmVwb3J0ZWQuXG5cdGNvbXB1dGVTZWxlY3Rpb246IGZ1bmN0aW9uKHNwYW4wLCBzcGFuMSkge1xuXHRcdHZhciBzcGFuID0gdGhpcy5jb21wdXRlU2VsZWN0aW9uU3BhbihzcGFuMCwgc3BhbjEpO1xuXG5cdFx0aWYgKHNwYW4gJiYgIXRoaXMudmlldy5jYWxlbmRhci5pc1NlbGVjdGlvblNwYW5BbGxvd2VkKHNwYW4pKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNwYW47XG5cdH0sXG5cblxuXHQvLyBHaXZlbiB0d28gc3BhbnMsIG11c3QgcmV0dXJuIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgdHdvLlxuXHQvLyBUT0RPOiBkbyB0aGlzIHNlcGFyYXRpb24gb2YgY29uY2VybnMgKGNvbWJpbmluZyBWUyB2YWxpZGF0aW9uKSBmb3IgZXZlbnQgZG5kL3Jlc2l6ZSB0b28uXG5cdGNvbXB1dGVTZWxlY3Rpb25TcGFuOiBmdW5jdGlvbihzcGFuMCwgc3BhbjEpIHtcblx0XHR2YXIgZGF0ZXMgPSBbIHNwYW4wLnN0YXJ0LCBzcGFuMC5lbmQsIHNwYW4xLnN0YXJ0LCBzcGFuMS5lbmQgXTtcblxuXHRcdGRhdGVzLnNvcnQoY29tcGFyZU51bWJlcnMpOyAvLyBzb3J0cyBjaHJvbm9sb2dpY2FsbHkuIHdvcmtzIHdpdGggTW9tZW50c1xuXG5cdFx0cmV0dXJuIHsgc3RhcnQ6IGRhdGVzWzBdLmNsb25lKCksIGVuZDogZGF0ZXNbM10uY2xvbmUoKSB9O1xuXHR9LFxuXG5cblx0LyogSGlnaGxpZ2h0XG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGFuIGVtcGhhc2lzIG9uIHRoZSBnaXZlbiBkYXRlIHJhbmdlLiBHaXZlbiBhIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIGFuZCBvdGhlciBtaXNjIGRhdGEpXG5cdHJlbmRlckhpZ2hsaWdodDogZnVuY3Rpb24oc3Bhbikge1xuXHRcdHRoaXMucmVuZGVyRmlsbCgnaGlnaGxpZ2h0JywgdGhpcy5zcGFuVG9TZWdzKHNwYW4pKTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyB0aGUgZW1waGFzaXMgb24gYSBkYXRlIHJhbmdlXG5cdHVucmVuZGVySGlnaGxpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVyRmlsbCgnaGlnaGxpZ2h0Jyk7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgYW4gYXJyYXkgb2YgY2xhc3NOYW1lcyBmb3IgcmVuZGVyaW5nIHRoZSBoaWdobGlnaHQuIFVzZWQgYnkgdGhlIGZpbGwgc3lzdGVtLlxuXHRoaWdobGlnaHRTZWdDbGFzc2VzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gWyAnZmMtaGlnaGxpZ2h0JyBdO1xuXHR9LFxuXG5cblx0LyogQnVzaW5lc3MgSG91cnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cblx0dW5yZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdC8qIE5vdyBJbmRpY2F0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdGdldE5vd0luZGljYXRvclVuaXQ6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cblx0cmVuZGVyTm93SW5kaWNhdG9yOiBmdW5jdGlvbihkYXRlKSB7XG5cdH0sXG5cblxuXHR1bnJlbmRlck5vd0luZGljYXRvcjogZnVuY3Rpb24oKSB7XG5cdH0sXG5cblxuXHQvKiBGaWxsIFN5c3RlbSAoaGlnaGxpZ2h0LCBiYWNrZ3JvdW5kIGV2ZW50cywgYnVzaW5lc3MgaG91cnMpXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFRPRE86IHJlbW92ZSB0aGlzIHN5c3RlbS4gbGlrZSB3ZSBkaWQgaW4gVGltZUdyaWRcblx0Ki9cblxuXG5cdC8vIFJlbmRlcnMgYSBzZXQgb2YgcmVjdGFuZ2xlcyBvdmVyIHRoZSBnaXZlbiBzZWdtZW50cyBvZiB0aW1lLlxuXHQvLyBNVVNUIFJFVFVSTiBhIHN1YnNldCBvZiBzZWdzLCB0aGUgc2VncyB0aGF0IHdlcmUgYWN0dWFsbHkgcmVuZGVyZWQuXG5cdC8vIFJlc3BvbnNpYmxlIGZvciBwb3B1bGF0aW5nIHRoaXMuZWxzQnlGaWxsLiBUT0RPOiBiZXR0ZXIgQVBJIGZvciBleHByZXNzaW5nIHRoaXMgcmVxdWlyZW1lbnRcblx0cmVuZGVyRmlsbDogZnVuY3Rpb24odHlwZSwgc2Vncykge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIHNwZWNpZmljIHR5cGUgb2YgZmlsbCB0aGF0IGlzIGN1cnJlbnRseSByZW5kZXJlZCBvbiB0aGUgZ3JpZFxuXHR1bnJlbmRlckZpbGw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHR2YXIgZWwgPSB0aGlzLmVsc0J5RmlsbFt0eXBlXTtcblxuXHRcdGlmIChlbCkge1xuXHRcdFx0ZWwucmVtb3ZlKCk7XG5cdFx0XHRkZWxldGUgdGhpcy5lbHNCeUZpbGxbdHlwZV07XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyBhbmQgYXNzaWducyBhbiBgZWxgIHByb3BlcnR5IGZvciBlYWNoIGZpbGwgc2VnbWVudC4gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGRpZmZlcmVudCB0eXBlcy5cblx0Ly8gT25seSByZXR1cm5zIHNlZ21lbnRzIHRoYXQgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkLlxuXHQvLyBUbyBiZSBoYXJuZXNzZWQgYnkgcmVuZGVyRmlsbCAoaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcykuXG5cdC8vIEFuYWxhZ291cyB0byByZW5kZXJGZ1NlZ0Vscy5cblx0cmVuZGVyRmlsbFNlZ0VsczogZnVuY3Rpb24odHlwZSwgc2Vncykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHNlZ0VsTWV0aG9kID0gdGhpc1t0eXBlICsgJ1NlZ0VsJ107XG5cdFx0dmFyIGh0bWwgPSAnJztcblx0XHR2YXIgcmVuZGVyZWRTZWdzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoc2Vncy5sZW5ndGgpIHtcblxuXHRcdFx0Ly8gYnVpbGQgYSBsYXJnZSBjb25jYXRlbmF0aW9uIG9mIHNlZ21lbnQgSFRNTFxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aHRtbCArPSB0aGlzLmZpbGxTZWdIdG1sKHR5cGUsIHNlZ3NbaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBHcmFiIGluZGl2aWR1YWwgZWxlbWVudHMgZnJvbSB0aGUgY29tYmluZWQgSFRNTCBzdHJpbmcuIFVzZSBlYWNoIGFzIHRoZSBkZWZhdWx0IHJlbmRlcmluZy5cblx0XHRcdC8vIFRoZW4sIGNvbXB1dGUgdGhlICdlbCcgZm9yIGVhY2ggc2VnbWVudC5cblx0XHRcdCQoaHRtbCkuZWFjaChmdW5jdGlvbihpLCBub2RlKSB7XG5cdFx0XHRcdHZhciBzZWcgPSBzZWdzW2ldO1xuXHRcdFx0XHR2YXIgZWwgPSAkKG5vZGUpO1xuXG5cdFx0XHRcdC8vIGFsbG93IGN1c3RvbSBmaWx0ZXIgbWV0aG9kcyBwZXItdHlwZVxuXHRcdFx0XHRpZiAoc2VnRWxNZXRob2QpIHtcblx0XHRcdFx0XHRlbCA9IHNlZ0VsTWV0aG9kLmNhbGwoX3RoaXMsIHNlZywgZWwpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGVsKSB7IC8vIGN1c3RvbSBmaWx0ZXJzIGRpZCBub3QgY2FuY2VsIHRoZSByZW5kZXJcblx0XHRcdFx0XHRlbCA9ICQoZWwpOyAvLyBhbGxvdyBjdXN0b20gZmlsdGVyIHRvIHJldHVybiByYXcgRE9NIG5vZGVcblxuXHRcdFx0XHRcdC8vIGNvcnJlY3QgZWxlbWVudCB0eXBlPyAod291bGQgYmUgYmFkIGlmIGEgbm9uLVREIHdlcmUgaW5zZXJ0ZWQgaW50byBhIHRhYmxlIGZvciBleGFtcGxlKVxuXHRcdFx0XHRcdGlmIChlbC5pcyhfdGhpcy5maWxsU2VnVGFnKSkge1xuXHRcdFx0XHRcdFx0c2VnLmVsID0gZWw7XG5cdFx0XHRcdFx0XHRyZW5kZXJlZFNlZ3MucHVzaChzZWcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlbmRlcmVkU2Vncztcblx0fSxcblxuXG5cdGZpbGxTZWdUYWc6ICdkaXYnLCAvLyBzdWJjbGFzc2VzIGNhbiBvdmVycmlkZVxuXG5cblx0Ly8gQnVpbGRzIHRoZSBIVE1MIG5lZWRlZCBmb3Igb25lIGZpbGwgc2VnbWVudC4gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGRpZmZlcmVudCB0eXBlcy5cblx0ZmlsbFNlZ0h0bWw6IGZ1bmN0aW9uKHR5cGUsIHNlZykge1xuXG5cdFx0Ly8gY3VzdG9tIGhvb2tzIHBlci10eXBlXG5cdFx0dmFyIGNsYXNzZXNNZXRob2QgPSB0aGlzW3R5cGUgKyAnU2VnQ2xhc3NlcyddO1xuXHRcdHZhciBjc3NNZXRob2QgPSB0aGlzW3R5cGUgKyAnU2VnQ3NzJ107XG5cblx0XHR2YXIgY2xhc3NlcyA9IGNsYXNzZXNNZXRob2QgPyBjbGFzc2VzTWV0aG9kLmNhbGwodGhpcywgc2VnKSA6IFtdO1xuXHRcdHZhciBjc3MgPSBjc3NUb1N0cihjc3NNZXRob2QgPyBjc3NNZXRob2QuY2FsbCh0aGlzLCBzZWcpIDoge30pO1xuXG5cdFx0cmV0dXJuICc8JyArIHRoaXMuZmlsbFNlZ1RhZyArXG5cdFx0XHQoY2xhc3Nlcy5sZW5ndGggPyAnIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyA6ICcnKSArXG5cdFx0XHQoY3NzID8gJyBzdHlsZT1cIicgKyBjc3MgKyAnXCInIDogJycpICtcblx0XHRcdCcgLz4nO1xuXHR9LFxuXG5cblxuXHQvKiBHZW5lcmljIHJlbmRlcmluZyB1dGlsaXRpZXMgZm9yIHN1YmNsYXNzZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIENvbXB1dGVzIEhUTUwgY2xhc3NOYW1lcyBmb3IgYSBzaW5nbGUtZGF5IGVsZW1lbnRcblx0Z2V0RGF5Q2xhc3NlczogZnVuY3Rpb24oZGF0ZSwgbm9UaGVtZUhpZ2hsaWdodCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cdFx0dmFyIHRvZGF5O1xuXG5cdFx0aWYgKCFpc0RhdGVXaXRoaW5SYW5nZShkYXRlLCB2aWV3LmFjdGl2ZVJhbmdlKSkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmYy1kaXNhYmxlZC1kYXknKTsgLy8gVE9ETzogalF1ZXJ5IFVJIHRoZW1lP1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGNsYXNzZXMucHVzaCgnZmMtJyArIGRheUlEc1tkYXRlLmRheSgpXSk7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0dmlldy5jdXJyZW50UmFuZ2VBcygnbW9udGhzJykgPT0gMSAmJiAvLyBUT0RPOiBzb21laG93IGdldCBpbnRvIE1vbnRoVmlld1xuXHRcdFx0XHRkYXRlLm1vbnRoKCkgIT0gdmlldy5jdXJyZW50UmFuZ2Uuc3RhcnQubW9udGgoKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaCgnZmMtb3RoZXItbW9udGgnKTtcblx0XHRcdH1cblxuXHRcdFx0dG9kYXkgPSB2aWV3LmNhbGVuZGFyLmdldE5vdygpO1xuXG5cdFx0XHRpZiAoZGF0ZS5pc1NhbWUodG9kYXksICdkYXknKSkge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goJ2ZjLXRvZGF5Jyk7XG5cblx0XHRcdFx0aWYgKG5vVGhlbWVIaWdobGlnaHQgIT09IHRydWUpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2godmlldy5oaWdobGlnaHRTdGF0ZUNsYXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoZGF0ZSA8IHRvZGF5KSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaCgnZmMtcGFzdCcpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaCgnZmMtZnV0dXJlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXM7XG5cdH1cblxufSk7XG5cbjs7XG5cbi8qIEV2ZW50LXJlbmRlcmluZyBhbmQgZXZlbnQtaW50ZXJhY3Rpb24gbWV0aG9kcyBmb3IgdGhlIGFic3RyYWN0IEdyaWQgY2xhc3Ncbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuRGF0YSBUeXBlczpcblx0ZXZlbnQgLSB7IHRpdGxlLCBpZCwgc3RhcnQsIChlbmQpLCB3aGF0ZXZlciB9XG5cdGxvY2F0aW9uIC0geyBzdGFydCwgKGVuZCksIGFsbERheSB9XG5cdHJhd0V2ZW50UmFuZ2UgLSB7IHN0YXJ0LCBlbmQgfVxuXHRldmVudFJhbmdlIC0geyBzdGFydCwgZW5kLCBpc1N0YXJ0LCBpc0VuZCB9XG5cdGV2ZW50U3BhbiAtIHsgc3RhcnQsIGVuZCwgaXNTdGFydCwgaXNFbmQsIHdoYXRldmVyIH1cblx0ZXZlbnRTZWcgLSB7IGV2ZW50LCB3aGF0ZXZlciB9XG5cdHNlZyAtIHsgd2hhdGV2ZXIgfVxuKi9cblxuR3JpZC5taXhpbih7XG5cblx0Ly8gc2VsZi1jb25maWcsIG92ZXJyaWRhYmxlIGJ5IHN1YmNsYXNzZXNcblx0c2VnU2VsZWN0b3I6ICcuZmMtZXZlbnQtY29udGFpbmVyID4gKicsIC8vIHdoYXQgY29uc3RpdHV0ZXMgYW4gZXZlbnQgZWxlbWVudD9cblxuXHRtb3VzZWRPdmVyU2VnOiBudWxsLCAvLyB0aGUgc2VnbWVudCBvYmplY3QgdGhlIHVzZXIncyBtb3VzZSBpcyBvdmVyLiBudWxsIGlmIG92ZXIgbm90aGluZ1xuXHRpc0RyYWdnaW5nU2VnOiBmYWxzZSwgLy8gaXMgYSBzZWdtZW50IGJlaW5nIGRyYWdnZWQ/IGJvb2xlYW5cblx0aXNSZXNpemluZ1NlZzogZmFsc2UsIC8vIGlzIGEgc2VnbWVudCBiZWluZyByZXNpemVkPyBib29sZWFuXG5cdGlzRHJhZ2dpbmdFeHRlcm5hbDogZmFsc2UsIC8vIGpxdWktZHJhZ2dpbmcgYW4gZXh0ZXJuYWwgZWxlbWVudD8gYm9vbGVhblxuXHRzZWdzOiBudWxsLCAvLyB0aGUgKmV2ZW50KiBzZWdtZW50cyBjdXJyZW50bHkgcmVuZGVyZWQgaW4gdGhlIGdyaWQuIFRPRE86IHJlbmFtZSB0byBgZXZlbnRTZWdzYFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgZ2l2ZW4gZXZlbnRzIG9udG8gdGhlIGdyaWRcblx0cmVuZGVyRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcblx0XHR2YXIgYmdFdmVudHMgPSBbXTtcblx0XHR2YXIgZmdFdmVudHMgPSBbXTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdChpc0JnRXZlbnQoZXZlbnRzW2ldKSA/IGJnRXZlbnRzIDogZmdFdmVudHMpLnB1c2goZXZlbnRzW2ldKTtcblx0XHR9XG5cblx0XHR0aGlzLnNlZ3MgPSBbXS5jb25jYXQoIC8vIHJlY29yZCBhbGwgc2Vnc1xuXHRcdFx0dGhpcy5yZW5kZXJCZ0V2ZW50cyhiZ0V2ZW50cyksXG5cdFx0XHR0aGlzLnJlbmRlckZnRXZlbnRzKGZnRXZlbnRzKVxuXHRcdCk7XG5cdH0sXG5cblxuXHRyZW5kZXJCZ0V2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0dmFyIHNlZ3MgPSB0aGlzLmV2ZW50c1RvU2VncyhldmVudHMpO1xuXG5cdFx0Ly8gcmVuZGVyQmdTZWdzIG1pZ2h0IHJldHVybiBhIHN1YnNldCBvZiBzZWdzLCBzZWdzIHRoYXQgd2VyZSBhY3R1YWxseSByZW5kZXJlZFxuXHRcdHJldHVybiB0aGlzLnJlbmRlckJnU2VncyhzZWdzKSB8fCBzZWdzO1xuXHR9LFxuXG5cblx0cmVuZGVyRmdFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdHZhciBzZWdzID0gdGhpcy5ldmVudHNUb1NlZ3MoZXZlbnRzKTtcblxuXHRcdC8vIHJlbmRlckZnU2VncyBtaWdodCByZXR1cm4gYSBzdWJzZXQgb2Ygc2Vncywgc2VncyB0aGF0IHdlcmUgYWN0dWFsbHkgcmVuZGVyZWRcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJGZ1NlZ3Moc2VncykgfHwgc2Vncztcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbGwgZXZlbnRzIGN1cnJlbnRseSByZW5kZXJlZCBvbiB0aGUgZ3JpZFxuXHR1bnJlbmRlckV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oYW5kbGVTZWdNb3VzZW91dCgpOyAvLyB0cmlnZ2VyIGFuIGV2ZW50TW91c2VvdXQgaWYgdXNlcidzIG1vdXNlIGlzIG92ZXIgYW4gZXZlbnRcblx0XHR0aGlzLmNsZWFyRHJhZ0xpc3RlbmVycygpO1xuXG5cdFx0dGhpcy51bnJlbmRlckZnU2VncygpO1xuXHRcdHRoaXMudW5yZW5kZXJCZ1NlZ3MoKTtcblxuXHRcdHRoaXMuc2VncyA9IG51bGw7XG5cdH0sXG5cblxuXHQvLyBSZXRyaWV2ZXMgYWxsIHJlbmRlcmVkIHNlZ21lbnQgb2JqZWN0cyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcblx0Z2V0RXZlbnRTZWdzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5zZWdzIHx8IFtdO1xuXHR9LFxuXG5cblx0LyogRm9yZWdyb3VuZCBTZWdtZW50IFJlbmRlcmluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIG9udG8gdGhlIGdyaWQuIE1heSByZXR1cm4gYSBzdWJzZXQgb2Ygc2VncyB0aGF0IHdlcmUgcmVuZGVyZWQuXG5cdHJlbmRlckZnU2VnczogZnVuY3Rpb24oc2Vncykge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbGwgY3VycmVudGx5IHJlbmRlcmVkIGZvcmVncm91bmQgc2VnbWVudHNcblx0dW5yZW5kZXJGZ1NlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgYW5kIGFzc2lnbnMgYW4gYGVsYCBwcm9wZXJ0eSBmb3IgZWFjaCBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnQuXG5cdC8vIE9ubHkgcmV0dXJucyBzZWdtZW50cyB0aGF0IHN1Y2Nlc3NmdWxseSByZW5kZXJlZC5cblx0Ly8gQSB1dGlsaXR5IHRoYXQgc3ViY2xhc3NlcyBtYXkgdXNlLlxuXHRyZW5kZXJGZ1NlZ0VsczogZnVuY3Rpb24oc2VncywgZGlzYWJsZVJlc2l6aW5nKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGh0bWwgPSAnJztcblx0XHR2YXIgcmVuZGVyZWRTZWdzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoc2Vncy5sZW5ndGgpIHsgLy8gZG9uJ3QgYnVpbGQgYW4gZW1wdHkgaHRtbCBzdHJpbmdcblxuXHRcdFx0Ly8gYnVpbGQgYSBsYXJnZSBjb25jYXRlbmF0aW9uIG9mIGV2ZW50IHNlZ21lbnQgSFRNTFxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aHRtbCArPSB0aGlzLmZnU2VnSHRtbChzZWdzW2ldLCBkaXNhYmxlUmVzaXppbmcpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBHcmFiIGluZGl2aWR1YWwgZWxlbWVudHMgZnJvbSB0aGUgY29tYmluZWQgSFRNTCBzdHJpbmcuIFVzZSBlYWNoIGFzIHRoZSBkZWZhdWx0IHJlbmRlcmluZy5cblx0XHRcdC8vIFRoZW4sIGNvbXB1dGUgdGhlICdlbCcgZm9yIGVhY2ggc2VnbWVudC4gQW4gZWwgbWlnaHQgYmUgbnVsbCBpZiB0aGUgZXZlbnRSZW5kZXIgY2FsbGJhY2sgcmV0dXJuZWQgZmFsc2UuXG5cdFx0XHQkKGh0bWwpLmVhY2goZnVuY3Rpb24oaSwgbm9kZSkge1xuXHRcdFx0XHR2YXIgc2VnID0gc2Vnc1tpXTtcblx0XHRcdFx0dmFyIGVsID0gdmlldy5yZXNvbHZlRXZlbnRFbChzZWcuZXZlbnQsICQobm9kZSkpO1xuXG5cdFx0XHRcdGlmIChlbCkge1xuXHRcdFx0XHRcdGVsLmRhdGEoJ2ZjLXNlZycsIHNlZyk7IC8vIHVzZWQgYnkgaGFuZGxlcnNcblx0XHRcdFx0XHRzZWcuZWwgPSBlbDtcblx0XHRcdFx0XHRyZW5kZXJlZFNlZ3MucHVzaChzZWcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVuZGVyZWRTZWdzO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgZGVmYXVsdCByZW5kZXJpbmcgb2YgYSBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnQuIFVzZWQgYnkgcmVuZGVyRmdTZWdFbHMoKVxuXHRmZ1NlZ0h0bWw6IGZ1bmN0aW9uKHNlZywgZGlzYWJsZVJlc2l6aW5nKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvKiBCYWNrZ3JvdW5kIFNlZ21lbnQgUmVuZGVyaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBnaXZlbiBiYWNrZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIG9udG8gdGhlIGdyaWQuXG5cdC8vIFJldHVybnMgYSBzdWJzZXQgb2YgdGhlIHNlZ3MgdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkLlxuXHRyZW5kZXJCZ1NlZ3M6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJGaWxsKCdiZ0V2ZW50Jywgc2Vncyk7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYWxsIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgYmFja2dyb3VuZCBldmVudCBzZWdtZW50c1xuXHR1bnJlbmRlckJnU2VnczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckZpbGwoJ2JnRXZlbnQnKTtcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgYSBiYWNrZ3JvdW5kIGV2ZW50IGVsZW1lbnQsIGdpdmVuIHRoZSBkZWZhdWx0IHJlbmRlcmluZy4gQ2FsbGVkIGJ5IHRoZSBmaWxsIHN5c3RlbS5cblx0YmdFdmVudFNlZ0VsOiBmdW5jdGlvbihzZWcsIGVsKSB7XG5cdFx0cmV0dXJuIHRoaXMudmlldy5yZXNvbHZlRXZlbnRFbChzZWcuZXZlbnQsIGVsKTsgLy8gd2lsbCBmaWx0ZXIgdGhyb3VnaCBldmVudFJlbmRlclxuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIGFuIGFycmF5IG9mIGNsYXNzTmFtZXMgdG8gYmUgdXNlZCBmb3IgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIG9mIGEgYmFja2dyb3VuZCBldmVudC5cblx0Ly8gQ2FsbGVkIGJ5IGZpbGxTZWdIdG1sLlxuXHRiZ0V2ZW50U2VnQ2xhc3NlczogZnVuY3Rpb24oc2VnKSB7XG5cdFx0dmFyIGV2ZW50ID0gc2VnLmV2ZW50O1xuXHRcdHZhciBzb3VyY2UgPSBldmVudC5zb3VyY2UgfHwge307XG5cblx0XHRyZXR1cm4gWyAnZmMtYmdldmVudCcgXS5jb25jYXQoXG5cdFx0XHRldmVudC5jbGFzc05hbWUsXG5cdFx0XHRzb3VyY2UuY2xhc3NOYW1lIHx8IFtdXG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyBhIHNlbWljb2xvbi1zZXBhcmF0ZWQgQ1NTIHN0cmluZyB0byBiZSB1c2VkIGZvciB0aGUgZGVmYXVsdCByZW5kZXJpbmcgb2YgYSBiYWNrZ3JvdW5kIGV2ZW50LlxuXHQvLyBDYWxsZWQgYnkgZmlsbFNlZ0h0bWwuXG5cdGJnRXZlbnRTZWdDc3M6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHJldHVybiB7XG5cdFx0XHQnYmFja2dyb3VuZC1jb2xvcic6IHRoaXMuZ2V0U2VnU2tpbkNzcyhzZWcpWydiYWNrZ3JvdW5kLWNvbG9yJ11cblx0XHR9O1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIGFuIGFycmF5IG9mIGNsYXNzTmFtZXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlbmRlcmluZyBidXNpbmVzcyBob3VycyBvdmVybGF5LiBDYWxsZWQgYnkgdGhlIGZpbGwgc3lzdGVtLlxuXHQvLyBDYWxsZWQgYnkgZmlsbFNlZ0h0bWwuXG5cdGJ1c2luZXNzSG91cnNTZWdDbGFzc2VzOiBmdW5jdGlvbihzZWcpIHtcblx0XHRyZXR1cm4gWyAnZmMtbm9uYnVzaW5lc3MnLCAnZmMtYmdldmVudCcgXTtcblx0fSxcblxuXG5cdC8qIEJ1c2luZXNzIEhvdXJzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBDb21wdXRlIGJ1c2luZXNzIGhvdXIgc2VncyBmb3IgdGhlIGdyaWQncyBjdXJyZW50IGRhdGUgcmFuZ2UuXG5cdC8vIENhbGxlciBtdXN0IGFzayBpZiB3aG9sZS1kYXkgYnVzaW5lc3MgaG91cnMgYXJlIG5lZWRlZC5cblx0Ly8gSWYgbm8gYGJ1c2luZXNzSG91cnNgIGNvbmZpZ3VyYXRpb24gdmFsdWUgaXMgc3BlY2lmaWVkLCBhc3N1bWVzIHRoZSBjYWxlbmRhciBkZWZhdWx0LlxuXHRidWlsZEJ1c2luZXNzSG91clNlZ3M6IGZ1bmN0aW9uKHdob2xlRGF5LCBidXNpbmVzc0hvdXJzKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXZlbnRzVG9TZWdzKFxuXHRcdFx0dGhpcy5idWlsZEJ1c2luZXNzSG91ckV2ZW50cyh3aG9sZURheSwgYnVzaW5lc3NIb3Vycylcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZSBidXNpbmVzcyBob3VyICpldmVudHMqIGZvciB0aGUgZ3JpZCdzIGN1cnJlbnQgZGF0ZSByYW5nZS5cblx0Ly8gQ2FsbGVyIG11c3QgYXNrIGlmIHdob2xlLWRheSBidXNpbmVzcyBob3VycyBhcmUgbmVlZGVkLlxuXHQvLyBJZiBubyBgYnVzaW5lc3NIb3Vyc2AgY29uZmlndXJhdGlvbiB2YWx1ZSBpcyBzcGVjaWZpZWQsIGFzc3VtZXMgdGhlIGNhbGVuZGFyIGRlZmF1bHQuXG5cdGJ1aWxkQnVzaW5lc3NIb3VyRXZlbnRzOiBmdW5jdGlvbih3aG9sZURheSwgYnVzaW5lc3NIb3Vycykge1xuXHRcdHZhciBjYWxlbmRhciA9IHRoaXMudmlldy5jYWxlbmRhcjtcblx0XHR2YXIgZXZlbnRzO1xuXG5cdFx0aWYgKGJ1c2luZXNzSG91cnMgPT0gbnVsbCkge1xuXHRcdFx0Ly8gZmFsbGJhY2tcblx0XHRcdC8vIGFjY2VzcyBmcm9tIGNhbGVuZGF3ci4gZG9uJ3QgYWNjZXNzIGZyb20gdmlldy4gZG9lc24ndCB1cGRhdGUgd2l0aCBkeW5hbWljIG9wdGlvbnMuXG5cdFx0XHRidXNpbmVzc0hvdXJzID0gY2FsZW5kYXIub3B0KCdidXNpbmVzc0hvdXJzJyk7XG5cdFx0fVxuXG5cdFx0ZXZlbnRzID0gY2FsZW5kYXIuY29tcHV0ZUJ1c2luZXNzSG91ckV2ZW50cyh3aG9sZURheSwgYnVzaW5lc3NIb3Vycyk7XG5cblx0XHQvLyBIQUNLLiBFdmVudHVhbGx5IHJlZmFjdG9yIGJ1c2luZXNzIGhvdXJzIFwiZXZlbnRzXCIgc3lzdGVtLlxuXHRcdC8vIElmIG5vIGV2ZW50cyBhcmUgZ2l2ZW4sIGJ1dCBidXNpbmVzc0hvdXJzIGlzIGFjdGl2YXRlZCwgdGhpcyBtZWFucyB0aGUgZW50aXJlIHZpc2libGUgcmFuZ2Ugc2hvdWxkIGJlXG5cdFx0Ly8gbWFya2VkIGFzICpub3QqIGJ1c2luZXNzLWhvdXJzLCB2aWEgaW52ZXJzZS1iYWNrZ3JvdW5kIHJlbmRlcmluZy5cblx0XHRpZiAoIWV2ZW50cy5sZW5ndGggJiYgYnVzaW5lc3NIb3Vycykge1xuXHRcdFx0ZXZlbnRzID0gW1xuXHRcdFx0XHQkLmV4dGVuZCh7fSwgQlVTSU5FU1NfSE9VUl9FVkVOVF9ERUZBVUxUUywge1xuXHRcdFx0XHRcdHN0YXJ0OiB0aGlzLnZpZXcuYWN0aXZlUmFuZ2UuZW5kLCAvLyBndWFyYW50ZWVkIG91dC1vZi1yYW5nZVxuXHRcdFx0XHRcdGVuZDogdGhpcy52aWV3LmFjdGl2ZVJhbmdlLmVuZCwgICAvLyBcIlxuXHRcdFx0XHRcdGRvdzogbnVsbFxuXHRcdFx0XHR9KVxuXHRcdFx0XTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cblx0LyogSGFuZGxlcnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEF0dGFjaGVzIGV2ZW50LWVsZW1lbnQtcmVsYXRlZCBoYW5kbGVycyBmb3IgKmFsbCogcmVuZGVyZWQgZXZlbnQgc2VnbWVudHMgb2YgdGhlIHZpZXcuXG5cdGJpbmRTZWdIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5iaW5kU2VnSGFuZGxlcnNUb0VsKHRoaXMuZWwpO1xuXHR9LFxuXG5cblx0Ly8gQXR0YWNoZXMgZXZlbnQtZWxlbWVudC1yZWxhdGVkIGhhbmRsZXJzIHRvIGFuIGFyYml0cmFyeSBjb250YWluZXIgZWxlbWVudC4gbGV2ZXJhZ2VzIGJ1YmJsaW5nLlxuXHRiaW5kU2VnSGFuZGxlcnNUb0VsOiBmdW5jdGlvbihlbCkge1xuXHRcdHRoaXMuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlU2VnVG91Y2hTdGFydCk7XG5cdFx0dGhpcy5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICdtb3VzZWVudGVyJywgdGhpcy5oYW5kbGVTZWdNb3VzZW92ZXIpO1xuXHRcdHRoaXMuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnbW91c2VsZWF2ZScsIHRoaXMuaGFuZGxlU2VnTW91c2VvdXQpO1xuXHRcdHRoaXMuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnbW91c2Vkb3duJywgdGhpcy5oYW5kbGVTZWdNb3VzZWRvd24pO1xuXHRcdHRoaXMuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnY2xpY2snLCB0aGlzLmhhbmRsZVNlZ0NsaWNrKTtcblx0fSxcblxuXG5cdC8vIEV4ZWN1dGVzIGEgaGFuZGxlciBmb3IgYW55IGEgdXNlci1pbnRlcmFjdGlvbiBvbiBhIHNlZ21lbnQuXG5cdC8vIEhhbmRsZXIgZ2V0cyBjYWxsZWQgd2l0aCAoc2VnLCBldiksIGFuZCB3aXRoIHRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgR3JpZFxuXHRiaW5kU2VnSGFuZGxlclRvRWw6IGZ1bmN0aW9uKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdGVsLm9uKG5hbWUsIHRoaXMuc2VnU2VsZWN0b3IsIGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHR2YXIgc2VnID0gJCh0aGlzKS5kYXRhKCdmYy1zZWcnKTsgLy8gZ3JhYiBzZWdtZW50IGRhdGEuIHB1dCB0aGVyZSBieSBWaWV3OjpyZW5kZXJFdmVudHNcblxuXHRcdFx0Ly8gb25seSBjYWxsIHRoZSBoYW5kbGVycyBpZiB0aGVyZSBpcyBub3QgYSBkcmFnL3Jlc2l6ZSBpbiBwcm9ncmVzc1xuXHRcdFx0aWYgKHNlZyAmJiAhX3RoaXMuaXNEcmFnZ2luZ1NlZyAmJiAhX3RoaXMuaXNSZXNpemluZ1NlZykge1xuXHRcdFx0XHRyZXR1cm4gaGFuZGxlci5jYWxsKF90aGlzLCBzZWcsIGV2KTsgLy8gY29udGV4dCB3aWxsIGJlIHRoZSBHcmlkXG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblxuXHRoYW5kbGVTZWdDbGljazogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdHZhciByZXMgPSB0aGlzLnZpZXcucHVibGljbHlUcmlnZ2VyKCdldmVudENsaWNrJywgc2VnLmVsWzBdLCBzZWcuZXZlbnQsIGV2KTsgLy8gY2FuIHJldHVybiBgZmFsc2VgIHRvIGNhbmNlbFxuXHRcdGlmIChyZXMgPT09IGZhbHNlKSB7XG5cdFx0XHRldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGhhbmRsZXJzIGZvciB3aGVuIGFuIGV2ZW50IGVsZW1lbnQgaXMgbW91c2VkIG92ZXJcblx0aGFuZGxlU2VnTW91c2VvdmVyOiBmdW5jdGlvbihzZWcsIGV2KSB7XG5cdFx0aWYgKFxuXHRcdFx0IUdsb2JhbEVtaXR0ZXIuZ2V0KCkuc2hvdWxkSWdub3JlTW91c2UoKSAmJlxuXHRcdFx0IXRoaXMubW91c2VkT3ZlclNlZ1xuXHRcdCkge1xuXHRcdFx0dGhpcy5tb3VzZWRPdmVyU2VnID0gc2VnO1xuXHRcdFx0aWYgKHRoaXMudmlldy5pc0V2ZW50UmVzaXphYmxlKHNlZy5ldmVudCkpIHtcblx0XHRcdFx0c2VnLmVsLmFkZENsYXNzKCdmYy1hbGxvdy1tb3VzZS1yZXNpemUnKTtcblx0XHRcdH1cblx0XHRcdHRoaXMudmlldy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50TW91c2VvdmVyJywgc2VnLmVsWzBdLCBzZWcuZXZlbnQsIGV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBVcGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycyBmb3Igd2hlbiBhbiBldmVudCBlbGVtZW50IGlzIG1vdXNlZCBvdXQuXG5cdC8vIENhbiBiZSBnaXZlbiBubyBhcmd1bWVudHMsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBtb3VzZW91dCB0aGUgc2VnbWVudCB0aGF0IHdhcyBwcmV2aW91c2x5IG1vdXNlZCBvdmVyLlxuXHRoYW5kbGVTZWdNb3VzZW91dDogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdGV2ID0gZXYgfHwge307IC8vIGlmIGdpdmVuIG5vIGFyZ3MsIG1ha2UgYSBtb2NrIG1vdXNlIGV2ZW50XG5cblx0XHRpZiAodGhpcy5tb3VzZWRPdmVyU2VnKSB7XG5cdFx0XHRzZWcgPSBzZWcgfHwgdGhpcy5tb3VzZWRPdmVyU2VnOyAvLyBpZiBnaXZlbiBubyBhcmdzLCB1c2UgdGhlIGN1cnJlbnRseSBtb3VzZWQtb3ZlciBzZWdtZW50XG5cdFx0XHR0aGlzLm1vdXNlZE92ZXJTZWcgPSBudWxsO1xuXHRcdFx0aWYgKHRoaXMudmlldy5pc0V2ZW50UmVzaXphYmxlKHNlZy5ldmVudCkpIHtcblx0XHRcdFx0c2VnLmVsLnJlbW92ZUNsYXNzKCdmYy1hbGxvdy1tb3VzZS1yZXNpemUnKTtcblx0XHRcdH1cblx0XHRcdHRoaXMudmlldy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50TW91c2VvdXQnLCBzZWcuZWxbMF0sIHNlZy5ldmVudCwgZXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdGhhbmRsZVNlZ01vdXNlZG93bjogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdHZhciBpc1Jlc2l6aW5nID0gdGhpcy5zdGFydFNlZ1Jlc2l6ZShzZWcsIGV2LCB7IGRpc3RhbmNlOiA1IH0pO1xuXG5cdFx0aWYgKCFpc1Jlc2l6aW5nICYmIHRoaXMudmlldy5pc0V2ZW50RHJhZ2dhYmxlKHNlZy5ldmVudCkpIHtcblx0XHRcdHRoaXMuYnVpbGRTZWdEcmFnTGlzdGVuZXIoc2VnKVxuXHRcdFx0XHQuc3RhcnRJbnRlcmFjdGlvbihldiwge1xuXHRcdFx0XHRcdGRpc3RhbmNlOiA1XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXG5cdGhhbmRsZVNlZ1RvdWNoU3RhcnQ6IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgZXZlbnQgPSBzZWcuZXZlbnQ7XG5cdFx0dmFyIGlzU2VsZWN0ZWQgPSB2aWV3LmlzRXZlbnRTZWxlY3RlZChldmVudCk7XG5cdFx0dmFyIGlzRHJhZ2dhYmxlID0gdmlldy5pc0V2ZW50RHJhZ2dhYmxlKGV2ZW50KTtcblx0XHR2YXIgaXNSZXNpemFibGUgPSB2aWV3LmlzRXZlbnRSZXNpemFibGUoZXZlbnQpO1xuXHRcdHZhciBpc1Jlc2l6aW5nID0gZmFsc2U7XG5cdFx0dmFyIGRyYWdMaXN0ZW5lcjtcblx0XHR2YXIgZXZlbnRMb25nUHJlc3NEZWxheTtcblxuXHRcdGlmIChpc1NlbGVjdGVkICYmIGlzUmVzaXphYmxlKSB7XG5cdFx0XHQvLyBvbmx5IGFsbG93IHJlc2l6aW5nIG9mIHRoZSBldmVudCBpcyBzZWxlY3RlZFxuXHRcdFx0aXNSZXNpemluZyA9IHRoaXMuc3RhcnRTZWdSZXNpemUoc2VnLCBldik7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc1Jlc2l6aW5nICYmIChpc0RyYWdnYWJsZSB8fCBpc1Jlc2l6YWJsZSkpIHsgLy8gYWxsb3dlZCB0byBiZSBzZWxlY3RlZD9cblxuXHRcdFx0ZXZlbnRMb25nUHJlc3NEZWxheSA9IHZpZXcub3B0KCdldmVudExvbmdQcmVzc0RlbGF5Jyk7XG5cdFx0XHRpZiAoZXZlbnRMb25nUHJlc3NEZWxheSA9PSBudWxsKSB7XG5cdFx0XHRcdGV2ZW50TG9uZ1ByZXNzRGVsYXkgPSB2aWV3Lm9wdCgnbG9uZ1ByZXNzRGVsYXknKTsgLy8gZmFsbGJhY2tcblx0XHRcdH1cblxuXHRcdFx0ZHJhZ0xpc3RlbmVyID0gaXNEcmFnZ2FibGUgP1xuXHRcdFx0XHR0aGlzLmJ1aWxkU2VnRHJhZ0xpc3RlbmVyKHNlZykgOlxuXHRcdFx0XHR0aGlzLmJ1aWxkU2VnU2VsZWN0TGlzdGVuZXIoc2VnKTsgLy8gc2VnIGlzbid0IGRyYWdnYWJsZSwgYnV0IHN0aWxsIG5lZWRzIHRvIGJlIHNlbGVjdGVkXG5cblx0XHRcdGRyYWdMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2LCB7IC8vIHdvbid0IHN0YXJ0IGlmIGFscmVhZHkgc3RhcnRlZFxuXHRcdFx0XHRkZWxheTogaXNTZWxlY3RlZCA/IDAgOiBldmVudExvbmdQcmVzc0RlbGF5IC8vIGRvIGRlbGF5IGlmIG5vdCBhbHJlYWR5IHNlbGVjdGVkXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyByZXR1cm5zIGJvb2xlYW4gd2hldGhlciByZXNpemluZyBhY3R1YWxseSBzdGFydGVkIG9yIG5vdC5cblx0Ly8gYXNzdW1lcyB0aGUgc2VnIGFsbG93cyByZXNpemluZy5cblx0Ly8gYGRyYWdPcHRpb25zYCBhcmUgb3B0aW9uYWwuXG5cdHN0YXJ0U2VnUmVzaXplOiBmdW5jdGlvbihzZWcsIGV2LCBkcmFnT3B0aW9ucykge1xuXHRcdGlmICgkKGV2LnRhcmdldCkuaXMoJy5mYy1yZXNpemVyJykpIHtcblx0XHRcdHRoaXMuYnVpbGRTZWdSZXNpemVMaXN0ZW5lcihzZWcsICQoZXYudGFyZ2V0KS5pcygnLmZjLXN0YXJ0LXJlc2l6ZXInKSlcblx0XHRcdFx0LnN0YXJ0SW50ZXJhY3Rpb24oZXYsIGRyYWdPcHRpb25zKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblxuXG5cdC8qIEV2ZW50IERyYWdnaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBCdWlsZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgdHJhY2sgdXNlci1kcmFnZ2luZyBvbiBhbiBldmVudCBzZWdtZW50LlxuXHQvLyBHZW5lcmljIGVub3VnaCB0byB3b3JrIHdpdGggYW55IHR5cGUgb2YgR3JpZC5cblx0Ly8gSGFzIHNpZGUgZWZmZWN0IG9mIHNldHRpbmcvdW5zZXR0aW5nIGBzZWdEcmFnTGlzdGVuZXJgXG5cdGJ1aWxkU2VnRHJhZ0xpc3RlbmVyOiBmdW5jdGlvbihzZWcpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBlbCA9IHNlZy5lbDtcblx0XHR2YXIgZXZlbnQgPSBzZWcuZXZlbnQ7XG5cdFx0dmFyIGlzRHJhZ2dpbmc7XG5cdFx0dmFyIG1vdXNlRm9sbG93ZXI7IC8vIEEgY2xvbmUgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdGhhdCB3aWxsIG1vdmUgd2l0aCB0aGUgbW91c2Vcblx0XHR2YXIgZHJvcExvY2F0aW9uOyAvLyB6b25lZCBldmVudCBkYXRlIHByb3BlcnRpZXNcblxuXHRcdGlmICh0aGlzLnNlZ0RyYWdMaXN0ZW5lcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2VnRHJhZ0xpc3RlbmVyO1xuXHRcdH1cblxuXHRcdC8vIFRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIHRoZSAqdmlldydzKiBjb29yZGluYXRlIG1hcC4gQWxsb3dzIGRyYWdnaW5nIGFuZCBkcm9wcGluZyBiZXR3ZWVuIHN1YmNvbXBvbmVudHNcblx0XHQvLyBvZiB0aGUgdmlldy5cblx0XHR2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5zZWdEcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyKHZpZXcsIHtcblx0XHRcdHNjcm9sbDogdmlldy5vcHQoJ2RyYWdTY3JvbGwnKSxcblx0XHRcdHN1YmplY3RFbDogZWwsXG5cdFx0XHRzdWJqZWN0Q2VudGVyOiB0cnVlLFxuXHRcdFx0aW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0c2VnLmNvbXBvbmVudCA9IF90aGlzOyAvLyBmb3IgcmVuZGVyRHJhZ1xuXHRcdFx0XHRpc0RyYWdnaW5nID0gZmFsc2U7XG5cdFx0XHRcdG1vdXNlRm9sbG93ZXIgPSBuZXcgTW91c2VGb2xsb3dlcihzZWcuZWwsIHtcblx0XHRcdFx0XHRhZGRpdGlvbmFsQ2xhc3M6ICdmYy1kcmFnZ2luZycsXG5cdFx0XHRcdFx0cGFyZW50RWw6IHZpZXcuZWwsXG5cdFx0XHRcdFx0b3BhY2l0eTogZHJhZ0xpc3RlbmVyLmlzVG91Y2ggPyBudWxsIDogdmlldy5vcHQoJ2RyYWdPcGFjaXR5JyksXG5cdFx0XHRcdFx0cmV2ZXJ0RHVyYXRpb246IHZpZXcub3B0KCdkcmFnUmV2ZXJ0RHVyYXRpb24nKSxcblx0XHRcdFx0XHR6SW5kZXg6IDIgLy8gb25lIGFib3ZlIHRoZSAuZmMtdmlld1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0bW91c2VGb2xsb3dlci5oaWRlKCk7IC8vIGRvbid0IHNob3cgdW50aWwgd2Uga25vdyB0aGlzIGlzIGEgcmVhbCBkcmFnXG5cdFx0XHRcdG1vdXNlRm9sbG93ZXIuc3RhcnQoZXYpO1xuXHRcdFx0fSxcblx0XHRcdGRyYWdTdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0aWYgKGRyYWdMaXN0ZW5lci5pc1RvdWNoICYmICF2aWV3LmlzRXZlbnRTZWxlY3RlZChldmVudCkpIHtcblx0XHRcdFx0XHQvLyBpZiBub3QgcHJldmlvdXNseSBzZWxlY3RlZCwgd2lsbCBmaXJlIGFmdGVyIGEgZGVsYXkuIHRoZW4sIHNlbGVjdCB0aGUgZXZlbnRcblx0XHRcdFx0XHR2aWV3LnNlbGVjdEV2ZW50KGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpc0RyYWdnaW5nID0gdHJ1ZTtcblx0XHRcdFx0X3RoaXMuaGFuZGxlU2VnTW91c2VvdXQoc2VnLCBldik7IC8vIGVuc3VyZSBhIG1vdXNlb3V0IG9uIHRoZSBtYW5pcHVsYXRlZCBldmVudCBoYXMgYmVlbiByZXBvcnRlZFxuXHRcdFx0XHRfdGhpcy5zZWdEcmFnU3RhcnQoc2VnLCBldik7XG5cdFx0XHRcdHZpZXcuaGlkZUV2ZW50KGV2ZW50KTsgLy8gaGlkZSBhbGwgZXZlbnQgc2VnbWVudHMuIG91ciBtb3VzZUZvbGxvd2VyIHdpbGwgdGFrZSBvdmVyXG5cdFx0XHR9LFxuXHRcdFx0aGl0T3ZlcjogZnVuY3Rpb24oaGl0LCBpc09yaWcsIG9yaWdIaXQpIHtcblx0XHRcdFx0dmFyIGlzQWxsb3dlZCA9IHRydWU7XG5cdFx0XHRcdHZhciBvcmlnSGl0U3Bhbjtcblx0XHRcdFx0dmFyIGhpdFNwYW47XG5cdFx0XHRcdHZhciBkcmFnSGVscGVyRWxzO1xuXG5cdFx0XHRcdC8vIHN0YXJ0aW5nIGhpdCBjb3VsZCBiZSBmb3JjZWQgKERheUdyaWQubGltaXQpXG5cdFx0XHRcdGlmIChzZWcuaGl0KSB7XG5cdFx0XHRcdFx0b3JpZ0hpdCA9IHNlZy5oaXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBoaXQgbWlnaHQgbm90IGJlbG9uZyB0byB0aGlzIGdyaWQsIHNvIHF1ZXJ5IG9yaWdpbiBncmlkXG5cdFx0XHRcdG9yaWdIaXRTcGFuID0gb3JpZ0hpdC5jb21wb25lbnQuZ2V0U2FmZUhpdFNwYW4ob3JpZ0hpdCk7XG5cdFx0XHRcdGhpdFNwYW4gPSBoaXQuY29tcG9uZW50LmdldFNhZmVIaXRTcGFuKGhpdCk7XG5cblx0XHRcdFx0aWYgKG9yaWdIaXRTcGFuICYmIGhpdFNwYW4pIHtcblx0XHRcdFx0XHRkcm9wTG9jYXRpb24gPSBfdGhpcy5jb21wdXRlRXZlbnREcm9wKG9yaWdIaXRTcGFuLCBoaXRTcGFuLCBldmVudCk7XG5cdFx0XHRcdFx0aXNBbGxvd2VkID0gZHJvcExvY2F0aW9uICYmIF90aGlzLmlzRXZlbnRMb2NhdGlvbkFsbG93ZWQoZHJvcExvY2F0aW9uLCBldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aXNBbGxvd2VkID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWlzQWxsb3dlZCkge1xuXHRcdFx0XHRcdGRyb3BMb2NhdGlvbiA9IG51bGw7XG5cdFx0XHRcdFx0ZGlzYWJsZUN1cnNvcigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgYSB2YWxpZCBkcm9wIGxvY2F0aW9uLCBoYXZlIHRoZSBzdWJjbGFzcyByZW5kZXIgYSB2aXN1YWwgaW5kaWNhdGlvblxuXHRcdFx0XHRpZiAoZHJvcExvY2F0aW9uICYmIChkcmFnSGVscGVyRWxzID0gdmlldy5yZW5kZXJEcmFnKGRyb3BMb2NhdGlvbiwgc2VnKSkpIHtcblxuXHRcdFx0XHRcdGRyYWdIZWxwZXJFbHMuYWRkQ2xhc3MoJ2ZjLWRyYWdnaW5nJyk7XG5cdFx0XHRcdFx0aWYgKCFkcmFnTGlzdGVuZXIuaXNUb3VjaCkge1xuXHRcdFx0XHRcdFx0X3RoaXMuYXBwbHlEcmFnT3BhY2l0eShkcmFnSGVscGVyRWxzKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtb3VzZUZvbGxvd2VyLmhpZGUoKTsgLy8gaWYgdGhlIHN1YmNsYXNzIGlzIGFscmVhZHkgdXNpbmcgYSBtb2NrIGV2ZW50IFwiaGVscGVyXCIsIGhpZGUgb3VyIG93blxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG1vdXNlRm9sbG93ZXIuc2hvdygpOyAvLyBvdGhlcndpc2UsIGhhdmUgdGhlIGhlbHBlciBmb2xsb3cgdGhlIG1vdXNlIChubyBzbmFwcGluZylcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc09yaWcpIHtcblx0XHRcdFx0XHRkcm9wTG9jYXRpb24gPSBudWxsOyAvLyBuZWVkcyB0byBoYXZlIG1vdmVkIGhpdHMgdG8gYmUgYSB2YWxpZCBkcm9wXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRoaXRPdXQ6IGZ1bmN0aW9uKCkgeyAvLyBjYWxsZWQgYmVmb3JlIG1vdXNlIG1vdmVzIHRvIGEgZGlmZmVyZW50IGhpdCBPUiBtb3ZlZCBvdXQgb2YgYWxsIGhpdHNcblx0XHRcdFx0dmlldy51bnJlbmRlckRyYWcoKTsgLy8gdW5yZW5kZXIgd2hhdGV2ZXIgd2FzIGRvbmUgaW4gcmVuZGVyRHJhZ1xuXHRcdFx0XHRtb3VzZUZvbGxvd2VyLnNob3coKTsgLy8gc2hvdyBpbiBjYXNlIHdlIGFyZSBtb3Zpbmcgb3V0IG9mIGFsbCBoaXRzXG5cdFx0XHRcdGRyb3BMb2NhdGlvbiA9IG51bGw7XG5cdFx0XHR9LFxuXHRcdFx0aGl0RG9uZTogZnVuY3Rpb24oKSB7IC8vIENhbGxlZCBhZnRlciBhIGhpdE91dCBPUiBiZWZvcmUgYSBkcmFnRW5kXG5cdFx0XHRcdGVuYWJsZUN1cnNvcigpO1xuXHRcdFx0fSxcblx0XHRcdGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbihldikge1xuXHRcdFx0XHRkZWxldGUgc2VnLmNvbXBvbmVudDsgLy8gcHJldmVudCBzaWRlIGVmZmVjdHNcblxuXHRcdFx0XHQvLyBkbyByZXZlcnQgYW5pbWF0aW9uIGlmIGhhc24ndCBjaGFuZ2VkLiBjYWxscyBhIGNhbGxiYWNrIHdoZW4gZmluaXNoZWQgKHdoZXRoZXIgYW5pbWF0aW9uIG9yIG5vdClcblx0XHRcdFx0bW91c2VGb2xsb3dlci5zdG9wKCFkcm9wTG9jYXRpb24sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmIChpc0RyYWdnaW5nKSB7XG5cdFx0XHRcdFx0XHR2aWV3LnVucmVuZGVyRHJhZygpO1xuXHRcdFx0XHRcdFx0X3RoaXMuc2VnRHJhZ1N0b3Aoc2VnLCBldik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGRyb3BMb2NhdGlvbikge1xuXHRcdFx0XHRcdFx0Ly8gbm8gbmVlZCB0byByZS1zaG93IG9yaWdpbmFsLCB3aWxsIHJlcmVuZGVyIGFsbCBhbnl3YXlzLiBlc3AgaW1wb3J0YW50IGlmIGV2ZW50UmVuZGVyV2FpdFxuXHRcdFx0XHRcdFx0dmlldy5yZXBvcnRTZWdEcm9wKHNlZywgZHJvcExvY2F0aW9uLCBfdGhpcy5sYXJnZVVuaXQsIGVsLCBldik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0dmlldy5zaG93RXZlbnQoZXZlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdF90aGlzLnNlZ0RyYWdMaXN0ZW5lciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZHJhZ0xpc3RlbmVyO1xuXHR9LFxuXG5cblx0Ly8gc2VnIGlzbid0IGRyYWdnYWJsZSwgYnV0IGxldCdzIHVzZSBhIGdlbmVyaWMgRHJhZ0xpc3RlbmVyXG5cdC8vIHNpbXBseSBmb3IgdGhlIGRlbGF5LCBzbyBpdCBjYW4gYmUgc2VsZWN0ZWQuXG5cdC8vIEhhcyBzaWRlIGVmZmVjdCBvZiBzZXR0aW5nL3Vuc2V0dGluZyBgc2VnRHJhZ0xpc3RlbmVyYFxuXHRidWlsZFNlZ1NlbGVjdExpc3RlbmVyOiBmdW5jdGlvbihzZWcpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBldmVudCA9IHNlZy5ldmVudDtcblxuXHRcdGlmICh0aGlzLnNlZ0RyYWdMaXN0ZW5lcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2VnRHJhZ0xpc3RlbmVyO1xuXHRcdH1cblxuXHRcdHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLnNlZ0RyYWdMaXN0ZW5lciA9IG5ldyBEcmFnTGlzdGVuZXIoe1xuXHRcdFx0ZHJhZ1N0YXJ0OiBmdW5jdGlvbihldikge1xuXHRcdFx0XHRpZiAoZHJhZ0xpc3RlbmVyLmlzVG91Y2ggJiYgIXZpZXcuaXNFdmVudFNlbGVjdGVkKGV2ZW50KSkge1xuXHRcdFx0XHRcdC8vIGlmIG5vdCBwcmV2aW91c2x5IHNlbGVjdGVkLCB3aWxsIGZpcmUgYWZ0ZXIgYSBkZWxheS4gdGhlbiwgc2VsZWN0IHRoZSBldmVudFxuXHRcdFx0XHRcdHZpZXcuc2VsZWN0RXZlbnQoZXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdF90aGlzLnNlZ0RyYWdMaXN0ZW5lciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZHJhZ0xpc3RlbmVyO1xuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIGJlZm9yZSBldmVudCBzZWdtZW50IGRyYWdnaW5nIHN0YXJ0c1xuXHRzZWdEcmFnU3RhcnQ6IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHR0aGlzLmlzRHJhZ2dpbmdTZWcgPSB0cnVlO1xuXHRcdHRoaXMudmlldy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RHJhZ1N0YXJ0Jywgc2VnLmVsWzBdLCBzZWcuZXZlbnQsIGV2LCB7fSk7IC8vIGxhc3QgYXJndW1lbnQgaXMganF1aSBkdW1teVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIGFmdGVyIGV2ZW50IHNlZ21lbnQgZHJhZ2dpbmcgc3RvcHNcblx0c2VnRHJhZ1N0b3A6IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHR0aGlzLmlzRHJhZ2dpbmdTZWcgPSBmYWxzZTtcblx0XHR0aGlzLnZpZXcucHVibGljbHlUcmlnZ2VyKCdldmVudERyYWdTdG9wJywgc2VnLmVsWzBdLCBzZWcuZXZlbnQsIGV2LCB7fSk7IC8vIGxhc3QgYXJndW1lbnQgaXMganF1aSBkdW1teVxuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gdGhlIHNwYW5zIGFuIGV2ZW50IGRyYWcgYmVnYW4sIGFuZCB0aGUgc3BhbiBldmVudCB3YXMgZHJvcHBlZCwgY2FsY3VsYXRlcyB0aGUgbmV3IHpvbmVkIHN0YXJ0L2VuZC9hbGxEYXlcblx0Ly8gdmFsdWVzIGZvciB0aGUgZXZlbnQuIFN1YmNsYXNzZXMgbWF5IG92ZXJyaWRlIGFuZCBzZXQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGJlIHVzZWQgYnkgcmVuZGVyRHJhZy5cblx0Ly8gQSBmYWxzeSByZXR1cm5lZCB2YWx1ZSBpbmRpY2F0ZXMgYW4gaW52YWxpZCBkcm9wLlxuXHQvLyBET0VTIE5PVCBjb25zaWRlciBvdmVybGFwL2NvbnN0cmFpbnQuXG5cdGNvbXB1dGVFdmVudERyb3A6IGZ1bmN0aW9uKHN0YXJ0U3BhbiwgZW5kU3BhbiwgZXZlbnQpIHtcblx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XG5cdFx0dmFyIGRyYWdTdGFydCA9IHN0YXJ0U3Bhbi5zdGFydDtcblx0XHR2YXIgZHJhZ0VuZCA9IGVuZFNwYW4uc3RhcnQ7XG5cdFx0dmFyIGRlbHRhO1xuXHRcdHZhciBkcm9wTG9jYXRpb247IC8vIHpvbmVkIGV2ZW50IGRhdGUgcHJvcGVydGllc1xuXG5cdFx0aWYgKGRyYWdTdGFydC5oYXNUaW1lKCkgPT09IGRyYWdFbmQuaGFzVGltZSgpKSB7XG5cdFx0XHRkZWx0YSA9IHRoaXMuZGlmZkRhdGVzKGRyYWdFbmQsIGRyYWdTdGFydCk7XG5cblx0XHRcdC8vIGlmIGFuIGFsbC1kYXkgZXZlbnQgd2FzIGluIGEgdGltZWQgYXJlYSBhbmQgaXQgd2FzIGRyYWdnZWQgdG8gYSBkaWZmZXJlbnQgdGltZSxcblx0XHRcdC8vIGd1YXJhbnRlZSBhbiBlbmQgYW5kIGFkanVzdCBzdGFydC9lbmQgdG8gaGF2ZSB0aW1lc1xuXHRcdFx0aWYgKGV2ZW50LmFsbERheSAmJiBkdXJhdGlvbkhhc1RpbWUoZGVsdGEpKSB7XG5cdFx0XHRcdGRyb3BMb2NhdGlvbiA9IHtcblx0XHRcdFx0XHRzdGFydDogZXZlbnQuc3RhcnQuY2xvbmUoKSxcblx0XHRcdFx0XHRlbmQ6IGNhbGVuZGFyLmdldEV2ZW50RW5kKGV2ZW50KSwgLy8gd2lsbCBiZSBhbiBhbWJpZyBkYXlcblx0XHRcdFx0XHRhbGxEYXk6IGZhbHNlIC8vIGZvciBub3JtYWxpemVFdmVudFRpbWVzXG5cdFx0XHRcdH07XG5cdFx0XHRcdGNhbGVuZGFyLm5vcm1hbGl6ZUV2ZW50VGltZXMoZHJvcExvY2F0aW9uKTtcblx0XHRcdH1cblx0XHRcdC8vIG90aGV3aXNlLCB3b3JrIG9mZiBleGlzdGluZyB2YWx1ZXNcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRkcm9wTG9jYXRpb24gPSBwbHVja0V2ZW50RGF0ZVByb3BzKGV2ZW50KTtcblx0XHRcdH1cblxuXHRcdFx0ZHJvcExvY2F0aW9uLnN0YXJ0LmFkZChkZWx0YSk7XG5cdFx0XHRpZiAoZHJvcExvY2F0aW9uLmVuZCkge1xuXHRcdFx0XHRkcm9wTG9jYXRpb24uZW5kLmFkZChkZWx0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gaWYgc3dpdGNoaW5nIGZyb20gZGF5IDwtPiB0aW1lZCwgc3RhcnQgc2hvdWxkIGJlIHJlc2V0IHRvIHRoZSBkcm9wcGVkIGRhdGUsIGFuZCB0aGUgZW5kIGNsZWFyZWRcblx0XHRcdGRyb3BMb2NhdGlvbiA9IHtcblx0XHRcdFx0c3RhcnQ6IGRyYWdFbmQuY2xvbmUoKSxcblx0XHRcdFx0ZW5kOiBudWxsLCAvLyBlbmQgc2hvdWxkIGJlIGNsZWFyZWRcblx0XHRcdFx0YWxsRGF5OiAhZHJhZ0VuZC5oYXNUaW1lKClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRyb3BMb2NhdGlvbjtcblx0fSxcblxuXG5cdC8vIFV0aWxpdHkgZm9yIGFwcGx5IGRyYWdPcGFjaXR5IHRvIGEgalF1ZXJ5IHNldFxuXHRhcHBseURyYWdPcGFjaXR5OiBmdW5jdGlvbihlbHMpIHtcblx0XHR2YXIgb3BhY2l0eSA9IHRoaXMudmlldy5vcHQoJ2RyYWdPcGFjaXR5Jyk7XG5cblx0XHRpZiAob3BhY2l0eSAhPSBudWxsKSB7XG5cdFx0XHRlbHMuY3NzKCdvcGFjaXR5Jywgb3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cblx0LyogRXh0ZXJuYWwgRWxlbWVudCBEcmFnZ2luZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gYSBqUXVlcnkgVUkgZHJhZyBpcyBpbml0aWF0ZWQgYW55d2hlcmUgaW4gdGhlIERPTVxuXHRleHRlcm5hbERyYWdTdGFydDogZnVuY3Rpb24oZXYsIHVpKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGVsO1xuXHRcdHZhciBhY2NlcHQ7XG5cblx0XHRpZiAodmlldy5vcHQoJ2Ryb3BwYWJsZScpKSB7IC8vIG9ubHkgbGlzdGVuIGlmIHRoaXMgc2V0dGluZyBpcyBvblxuXHRcdFx0ZWwgPSAkKCh1aSA/IHVpLml0ZW0gOiBudWxsKSB8fCBldi50YXJnZXQpO1xuXG5cdFx0XHQvLyBUZXN0IHRoYXQgdGhlIGRyYWdnZWQgZWxlbWVudCBwYXNzZXMgdGhlIGRyb3BBY2NlcHQgc2VsZWN0b3Igb3IgZmlsdGVyIGZ1bmN0aW9uLlxuXHRcdFx0Ly8gRllJLCB0aGUgZGVmYXVsdCBpcyBcIipcIiAobWF0Y2hlcyBhbGwpXG5cdFx0XHRhY2NlcHQgPSB2aWV3Lm9wdCgnZHJvcEFjY2VwdCcpO1xuXHRcdFx0aWYgKCQuaXNGdW5jdGlvbihhY2NlcHQpID8gYWNjZXB0LmNhbGwoZWxbMF0sIGVsKSA6IGVsLmlzKGFjY2VwdCkpIHtcblx0XHRcdFx0aWYgKCF0aGlzLmlzRHJhZ2dpbmdFeHRlcm5hbCkgeyAvLyBwcmV2ZW50IGRvdWJsZS1saXN0ZW5pbmcgaWYgZmlyZWQgdHdpY2Vcblx0XHRcdFx0XHR0aGlzLmxpc3RlblRvRXh0ZXJuYWxEcmFnKGVsLCBldiwgdWkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gYSBqUXVlcnkgVUkgZHJhZyBzdGFydHMgYW5kIGl0IG5lZWRzIHRvIGJlIG1vbml0b3JlZCBmb3IgZHJvcHBpbmdcblx0bGlzdGVuVG9FeHRlcm5hbERyYWc6IGZ1bmN0aW9uKGVsLCBldiwgdWkpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBtZXRhID0gZ2V0RHJhZ2dlZEVsTWV0YShlbCk7IC8vIGV4dHJhIGRhdGEgYWJvdXQgZXZlbnQgZHJvcCwgaW5jbHVkaW5nIHBvc3NpYmxlIGV2ZW50IHRvIGNyZWF0ZVxuXHRcdHZhciBkcm9wTG9jYXRpb247IC8vIGEgbnVsbCB2YWx1ZSBzaWduYWxzIGFuIHVuc3VjY2Vzc2Z1bCBkcmFnXG5cblx0XHQvLyBsaXN0ZW5lciB0aGF0IHRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIGRhdGUtYXNzb2NpYXRlZCBwaXhlbCByZWdpb25zXG5cdFx0dmFyIGRyYWdMaXN0ZW5lciA9IF90aGlzLmV4dGVybmFsRHJhZ0xpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcih0aGlzLCB7XG5cdFx0XHRpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0X3RoaXMuaXNEcmFnZ2luZ0V4dGVybmFsID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRoaXRPdmVyOiBmdW5jdGlvbihoaXQpIHtcblx0XHRcdFx0dmFyIGlzQWxsb3dlZCA9IHRydWU7XG5cdFx0XHRcdHZhciBoaXRTcGFuID0gaGl0LmNvbXBvbmVudC5nZXRTYWZlSGl0U3BhbihoaXQpOyAvLyBoaXQgbWlnaHQgbm90IGJlbG9uZyB0byB0aGlzIGdyaWRcblxuXHRcdFx0XHRpZiAoaGl0U3Bhbikge1xuXHRcdFx0XHRcdGRyb3BMb2NhdGlvbiA9IF90aGlzLmNvbXB1dGVFeHRlcm5hbERyb3AoaGl0U3BhbiwgbWV0YSk7XG5cdFx0XHRcdFx0aXNBbGxvd2VkID0gZHJvcExvY2F0aW9uICYmIF90aGlzLmlzRXh0ZXJuYWxMb2NhdGlvbkFsbG93ZWQoZHJvcExvY2F0aW9uLCBtZXRhLmV2ZW50UHJvcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlzQWxsb3dlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFpc0FsbG93ZWQpIHtcblx0XHRcdFx0XHRkcm9wTG9jYXRpb24gPSBudWxsO1xuXHRcdFx0XHRcdGRpc2FibGVDdXJzb3IoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkcm9wTG9jYXRpb24pIHtcblx0XHRcdFx0XHRfdGhpcy5yZW5kZXJEcmFnKGRyb3BMb2NhdGlvbik7IC8vIGNhbGxlZCB3aXRob3V0IGEgc2VnIHBhcmFtZXRlclxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aGl0T3V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZHJvcExvY2F0aW9uID0gbnVsbDsgLy8gc2lnbmFsIHVuc3VjY2Vzc2Z1bFxuXHRcdFx0fSxcblx0XHRcdGhpdERvbmU6IGZ1bmN0aW9uKCkgeyAvLyBDYWxsZWQgYWZ0ZXIgYSBoaXRPdXQgT1IgYmVmb3JlIGEgZHJhZ0VuZFxuXHRcdFx0XHRlbmFibGVDdXJzb3IoKTtcblx0XHRcdFx0X3RoaXMudW5yZW5kZXJEcmFnKCk7XG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdGlmIChkcm9wTG9jYXRpb24pIHsgLy8gZWxlbWVudCB3YXMgZHJvcHBlZCBvbiBhIHZhbGlkIGhpdFxuXHRcdFx0XHRcdHZpZXcucmVwb3J0RXh0ZXJuYWxEcm9wKG1ldGEsIGRyb3BMb2NhdGlvbiwgZWwsIGV2LCB1aSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3RoaXMuaXNEcmFnZ2luZ0V4dGVybmFsID0gZmFsc2U7XG5cdFx0XHRcdF90aGlzLmV4dGVybmFsRHJhZ0xpc3RlbmVyID0gbnVsbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGRyYWdMaXN0ZW5lci5zdGFydERyYWcoZXYpOyAvLyBzdGFydCBsaXN0ZW5pbmcgaW1tZWRpYXRlbHlcblx0fSxcblxuXG5cdC8vIEdpdmVuIGEgaGl0IHRvIGJlIGRyb3BwZWQgdXBvbiwgYW5kIG1pc2MgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGpxdWkgZHJhZyAoZ3VhcmFudGVlZCB0byBiZSBhIHBsYWluIG9iamVjdCksXG5cdC8vIHJldHVybnMgdGhlIHpvbmVkIHN0YXJ0L2VuZCBkYXRlcyBmb3IgdGhlIGV2ZW50IHRoYXQgd291bGQgcmVzdWx0IGZyb20gdGhlIGh5cG90aGV0aWNhbCBkcm9wLiBlbmQgbWlnaHQgYmUgbnVsbC5cblx0Ly8gUmV0dXJuaW5nIGEgbnVsbCB2YWx1ZSBzaWduYWxzIGFuIGludmFsaWQgZHJvcCBoaXQuXG5cdC8vIERPRVMgTk9UIGNvbnNpZGVyIG92ZXJsYXAvY29uc3RyYWludC5cblx0Y29tcHV0ZUV4dGVybmFsRHJvcDogZnVuY3Rpb24oc3BhbiwgbWV0YSkge1xuXHRcdHZhciBjYWxlbmRhciA9IHRoaXMudmlldy5jYWxlbmRhcjtcblx0XHR2YXIgZHJvcExvY2F0aW9uID0ge1xuXHRcdFx0c3RhcnQ6IGNhbGVuZGFyLmFwcGx5VGltZXpvbmUoc3Bhbi5zdGFydCksIC8vIHNpbXVsYXRlIGEgem9uZWQgZXZlbnQgc3RhcnQgZGF0ZVxuXHRcdFx0ZW5kOiBudWxsXG5cdFx0fTtcblxuXHRcdC8vIGlmIGRyb3BwZWQgb24gYW4gYWxsLWRheSBzcGFuLCBhbmQgZWxlbWVudCdzIG1ldGFkYXRhIHNwZWNpZmllZCBhIHRpbWUsIHNldCBpdFxuXHRcdGlmIChtZXRhLnN0YXJ0VGltZSAmJiAhZHJvcExvY2F0aW9uLnN0YXJ0Lmhhc1RpbWUoKSkge1xuXHRcdFx0ZHJvcExvY2F0aW9uLnN0YXJ0LnRpbWUobWV0YS5zdGFydFRpbWUpO1xuXHRcdH1cblxuXHRcdGlmIChtZXRhLmR1cmF0aW9uKSB7XG5cdFx0XHRkcm9wTG9jYXRpb24uZW5kID0gZHJvcExvY2F0aW9uLnN0YXJ0LmNsb25lKCkuYWRkKG1ldGEuZHVyYXRpb24pO1xuXHRcdH1cblxuXHRcdHJldHVybiBkcm9wTG9jYXRpb247XG5cdH0sXG5cblxuXG5cdC8qIERyYWcgUmVuZGVyaW5nIChmb3IgYm90aCBldmVudHMgYW5kIGFuIGV4dGVybmFsIGVsZW1lbnRzKVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IG9yIGV4dGVybmFsIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZC5cblx0Ly8gYGRyb3BMb2NhdGlvbmAgY29udGFpbnMgaHlwb3RoZXRpY2FsIHN0YXJ0L2VuZC9hbGxEYXkgdmFsdWVzIHRoZSBldmVudCB3b3VsZCBoYXZlIGlmIGRyb3BwZWQuIGVuZCBjYW4gYmUgbnVsbC5cblx0Ly8gYHNlZ2AgaXMgdGhlIGludGVybmFsIHNlZ21lbnQgb2JqZWN0IHRoYXQgaXMgYmVpbmcgZHJhZ2dlZC4gSWYgZHJhZ2dpbmcgYW4gZXh0ZXJuYWwgZWxlbWVudCwgYHNlZ2AgaXMgbnVsbC5cblx0Ly8gQSB0cnV0aHkgcmV0dXJuZWQgdmFsdWUgaW5kaWNhdGVzIHRoaXMgbWV0aG9kIGhhcyByZW5kZXJlZCBhIGhlbHBlciBlbGVtZW50LlxuXHQvLyBNdXN0IHJldHVybiBlbGVtZW50cyB1c2VkIGZvciBhbnkgbW9jayBldmVudHMuXG5cdHJlbmRlckRyYWc6IGZ1bmN0aW9uKGRyb3BMb2NhdGlvbiwgc2VnKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgb3IgZXh0ZXJuYWwgZWxlbWVudCBiZWluZyBkcmFnZ2VkXG5cdHVucmVuZGVyRHJhZzogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogUmVzaXppbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIENyZWF0ZXMgYSBsaXN0ZW5lciB0aGF0IHRyYWNrcyB0aGUgdXNlciBhcyB0aGV5IHJlc2l6ZSBhbiBldmVudCBzZWdtZW50LlxuXHQvLyBHZW5lcmljIGVub3VnaCB0byB3b3JrIHdpdGggYW55IHR5cGUgb2YgR3JpZC5cblx0YnVpbGRTZWdSZXNpemVMaXN0ZW5lcjogZnVuY3Rpb24oc2VnLCBpc1N0YXJ0KSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xuXHRcdHZhciBlbCA9IHNlZy5lbDtcblx0XHR2YXIgZXZlbnQgPSBzZWcuZXZlbnQ7XG5cdFx0dmFyIGV2ZW50RW5kID0gY2FsZW5kYXIuZ2V0RXZlbnRFbmQoZXZlbnQpO1xuXHRcdHZhciBpc0RyYWdnaW5nO1xuXHRcdHZhciByZXNpemVMb2NhdGlvbjsgLy8gem9uZWQgZXZlbnQgZGF0ZSBwcm9wZXJ0aWVzLiBmYWxzeSBpZiBpbnZhbGlkIHJlc2l6ZVxuXG5cdFx0Ly8gVHJhY2tzIG1vdXNlIG1vdmVtZW50IG92ZXIgdGhlICpncmlkJ3MqIGNvb3JkaW5hdGUgbWFwXG5cdFx0dmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuc2VnUmVzaXplTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyKHRoaXMsIHtcblx0XHRcdHNjcm9sbDogdmlldy5vcHQoJ2RyYWdTY3JvbGwnKSxcblx0XHRcdHN1YmplY3RFbDogZWwsXG5cdFx0XHRpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aXNEcmFnZ2luZyA9IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdGRyYWdTdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0aXNEcmFnZ2luZyA9IHRydWU7XG5cdFx0XHRcdF90aGlzLmhhbmRsZVNlZ01vdXNlb3V0KHNlZywgZXYpOyAvLyBlbnN1cmUgYSBtb3VzZW91dCBvbiB0aGUgbWFuaXB1bGF0ZWQgZXZlbnQgaGFzIGJlZW4gcmVwb3J0ZWRcblx0XHRcdFx0X3RoaXMuc2VnUmVzaXplU3RhcnQoc2VnLCBldik7XG5cdFx0XHR9LFxuXHRcdFx0aGl0T3ZlcjogZnVuY3Rpb24oaGl0LCBpc09yaWcsIG9yaWdIaXQpIHtcblx0XHRcdFx0dmFyIGlzQWxsb3dlZCA9IHRydWU7XG5cdFx0XHRcdHZhciBvcmlnSGl0U3BhbiA9IF90aGlzLmdldFNhZmVIaXRTcGFuKG9yaWdIaXQpO1xuXHRcdFx0XHR2YXIgaGl0U3BhbiA9IF90aGlzLmdldFNhZmVIaXRTcGFuKGhpdCk7XG5cblx0XHRcdFx0aWYgKG9yaWdIaXRTcGFuICYmIGhpdFNwYW4pIHtcblx0XHRcdFx0XHRyZXNpemVMb2NhdGlvbiA9IGlzU3RhcnQgP1xuXHRcdFx0XHRcdFx0X3RoaXMuY29tcHV0ZUV2ZW50U3RhcnRSZXNpemUob3JpZ0hpdFNwYW4sIGhpdFNwYW4sIGV2ZW50KSA6XG5cdFx0XHRcdFx0XHRfdGhpcy5jb21wdXRlRXZlbnRFbmRSZXNpemUob3JpZ0hpdFNwYW4sIGhpdFNwYW4sIGV2ZW50KTtcblxuXHRcdFx0XHRcdGlzQWxsb3dlZCA9IHJlc2l6ZUxvY2F0aW9uICYmIF90aGlzLmlzRXZlbnRMb2NhdGlvbkFsbG93ZWQocmVzaXplTG9jYXRpb24sIGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpc0FsbG93ZWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghaXNBbGxvd2VkKSB7XG5cdFx0XHRcdFx0cmVzaXplTG9jYXRpb24gPSBudWxsO1xuXHRcdFx0XHRcdGRpc2FibGVDdXJzb3IoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRyZXNpemVMb2NhdGlvbi5zdGFydC5pc1NhbWUoZXZlbnQuc3RhcnQuY2xvbmUoKS5zdHJpcFpvbmUoKSkgJiZcblx0XHRcdFx0XHRcdHJlc2l6ZUxvY2F0aW9uLmVuZC5pc1NhbWUoZXZlbnRFbmQuY2xvbmUoKS5zdHJpcFpvbmUoKSlcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdC8vIG5vIGNoYW5nZS4gKEZZSSwgZXZlbnQgZGF0ZXMgbWlnaHQgaGF2ZSB6b25lcylcblx0XHRcdFx0XHRcdHJlc2l6ZUxvY2F0aW9uID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocmVzaXplTG9jYXRpb24pIHtcblx0XHRcdFx0XHR2aWV3LmhpZGVFdmVudChldmVudCk7XG5cdFx0XHRcdFx0X3RoaXMucmVuZGVyRXZlbnRSZXNpemUocmVzaXplTG9jYXRpb24sIHNlZyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRoaXRPdXQ6IGZ1bmN0aW9uKCkgeyAvLyBjYWxsZWQgYmVmb3JlIG1vdXNlIG1vdmVzIHRvIGEgZGlmZmVyZW50IGhpdCBPUiBtb3ZlZCBvdXQgb2YgYWxsIGhpdHNcblx0XHRcdFx0cmVzaXplTG9jYXRpb24gPSBudWxsO1xuXHRcdFx0XHR2aWV3LnNob3dFdmVudChldmVudCk7IC8vIGZvciB3aGVuIG91dC1vZi1ib3VuZHMuIHNob3cgb3JpZ2luYWxcblx0XHRcdH0sXG5cdFx0XHRoaXREb25lOiBmdW5jdGlvbigpIHsgLy8gcmVzZXRzIHRoZSByZW5kZXJpbmcgdG8gc2hvdyB0aGUgb3JpZ2luYWwgZXZlbnRcblx0XHRcdFx0X3RoaXMudW5yZW5kZXJFdmVudFJlc2l6ZSgpO1xuXHRcdFx0XHRlbmFibGVDdXJzb3IoKTtcblx0XHRcdH0sXG5cdFx0XHRpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0aWYgKGlzRHJhZ2dpbmcpIHtcblx0XHRcdFx0XHRfdGhpcy5zZWdSZXNpemVTdG9wKHNlZywgZXYpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHJlc2l6ZUxvY2F0aW9uKSB7IC8vIHZhbGlkIGRhdGUgdG8gcmVzaXplIHRvP1xuXHRcdFx0XHRcdC8vIG5vIG5lZWQgdG8gcmUtc2hvdyBvcmlnaW5hbCwgd2lsbCByZXJlbmRlciBhbGwgYW55d2F5cy4gZXNwIGltcG9ydGFudCBpZiBldmVudFJlbmRlcldhaXRcblx0XHRcdFx0XHR2aWV3LnJlcG9ydFNlZ1Jlc2l6ZShzZWcsIHJlc2l6ZUxvY2F0aW9uLCBfdGhpcy5sYXJnZVVuaXQsIGVsLCBldik7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmlldy5zaG93RXZlbnQoZXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF90aGlzLnNlZ1Jlc2l6ZUxpc3RlbmVyID0gbnVsbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBkcmFnTGlzdGVuZXI7XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgYmVmb3JlIGV2ZW50IHNlZ21lbnQgcmVzaXppbmcgc3RhcnRzXG5cdHNlZ1Jlc2l6ZVN0YXJ0OiBmdW5jdGlvbihzZWcsIGV2KSB7XG5cdFx0dGhpcy5pc1Jlc2l6aW5nU2VnID0gdHJ1ZTtcblx0XHR0aGlzLnZpZXcucHVibGljbHlUcmlnZ2VyKCdldmVudFJlc2l6ZVN0YXJ0Jywgc2VnLmVsWzBdLCBzZWcuZXZlbnQsIGV2LCB7fSk7IC8vIGxhc3QgYXJndW1lbnQgaXMganF1aSBkdW1teVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIGFmdGVyIGV2ZW50IHNlZ21lbnQgcmVzaXppbmcgc3RvcHNcblx0c2VnUmVzaXplU3RvcDogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdHRoaXMuaXNSZXNpemluZ1NlZyA9IGZhbHNlO1xuXHRcdHRoaXMudmlldy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVzaXplU3RvcCcsIHNlZy5lbFswXSwgc2VnLmV2ZW50LCBldiwge30pOyAvLyBsYXN0IGFyZ3VtZW50IGlzIGpxdWkgZHVtbXlcblx0fSxcblxuXG5cdC8vIFJldHVybnMgbmV3IGRhdGUtaW5mb3JtYXRpb24gZm9yIGFuIGV2ZW50IHNlZ21lbnQgYmVpbmcgcmVzaXplZCBmcm9tIGl0cyBzdGFydFxuXHRjb21wdXRlRXZlbnRTdGFydFJlc2l6ZTogZnVuY3Rpb24oc3RhcnRTcGFuLCBlbmRTcGFuLCBldmVudCkge1xuXHRcdHJldHVybiB0aGlzLmNvbXB1dGVFdmVudFJlc2l6ZSgnc3RhcnQnLCBzdGFydFNwYW4sIGVuZFNwYW4sIGV2ZW50KTtcblx0fSxcblxuXG5cdC8vIFJldHVybnMgbmV3IGRhdGUtaW5mb3JtYXRpb24gZm9yIGFuIGV2ZW50IHNlZ21lbnQgYmVpbmcgcmVzaXplZCBmcm9tIGl0cyBlbmRcblx0Y29tcHV0ZUV2ZW50RW5kUmVzaXplOiBmdW5jdGlvbihzdGFydFNwYW4sIGVuZFNwYW4sIGV2ZW50KSB7XG5cdFx0cmV0dXJuIHRoaXMuY29tcHV0ZUV2ZW50UmVzaXplKCdlbmQnLCBzdGFydFNwYW4sIGVuZFNwYW4sIGV2ZW50KTtcblx0fSxcblxuXG5cdC8vIFJldHVybnMgbmV3IHpvbmVkIGRhdGUgaW5mb3JtYXRpb24gZm9yIGFuIGV2ZW50IHNlZ21lbnQgYmVpbmcgcmVzaXplZCBmcm9tIGl0cyBzdGFydCBPUiBlbmRcblx0Ly8gYHR5cGVgIGlzIGVpdGhlciAnc3RhcnQnIG9yICdlbmQnLlxuXHQvLyBET0VTIE5PVCBjb25zaWRlciBvdmVybGFwL2NvbnN0cmFpbnQuXG5cdGNvbXB1dGVFdmVudFJlc2l6ZTogZnVuY3Rpb24odHlwZSwgc3RhcnRTcGFuLCBlbmRTcGFuLCBldmVudCkge1xuXHRcdHZhciBjYWxlbmRhciA9IHRoaXMudmlldy5jYWxlbmRhcjtcblx0XHR2YXIgZGVsdGEgPSB0aGlzLmRpZmZEYXRlcyhlbmRTcGFuW3R5cGVdLCBzdGFydFNwYW5bdHlwZV0pO1xuXHRcdHZhciByZXNpemVMb2NhdGlvbjsgLy8gem9uZWQgZXZlbnQgZGF0ZSBwcm9wZXJ0aWVzXG5cdFx0dmFyIGRlZmF1bHREdXJhdGlvbjtcblxuXHRcdC8vIGJ1aWxkIG9yaWdpbmFsIHZhbHVlcyB0byB3b3JrIGZyb20sIGd1YXJhbnRlZWluZyBhIHN0YXJ0IGFuZCBlbmRcblx0XHRyZXNpemVMb2NhdGlvbiA9IHtcblx0XHRcdHN0YXJ0OiBldmVudC5zdGFydC5jbG9uZSgpLFxuXHRcdFx0ZW5kOiBjYWxlbmRhci5nZXRFdmVudEVuZChldmVudCksXG5cdFx0XHRhbGxEYXk6IGV2ZW50LmFsbERheVxuXHRcdH07XG5cblx0XHQvLyBpZiBhbiBhbGwtZGF5IGV2ZW50IHdhcyBpbiBhIHRpbWVkIGFyZWEgYW5kIHdhcyByZXNpemVkIHRvIGEgdGltZSwgYWRqdXN0IHN0YXJ0L2VuZCB0byBoYXZlIHRpbWVzXG5cdFx0aWYgKHJlc2l6ZUxvY2F0aW9uLmFsbERheSAmJiBkdXJhdGlvbkhhc1RpbWUoZGVsdGEpKSB7XG5cdFx0XHRyZXNpemVMb2NhdGlvbi5hbGxEYXkgPSBmYWxzZTtcblx0XHRcdGNhbGVuZGFyLm5vcm1hbGl6ZUV2ZW50VGltZXMocmVzaXplTG9jYXRpb24pO1xuXHRcdH1cblxuXHRcdHJlc2l6ZUxvY2F0aW9uW3R5cGVdLmFkZChkZWx0YSk7IC8vIGFwcGx5IGRlbHRhIHRvIHN0YXJ0IG9yIGVuZFxuXG5cdFx0Ly8gaWYgdGhlIGV2ZW50IHdhcyBjb21wcmVzc2VkIHRvbyBzbWFsbCwgZmluZCBhIG5ldyByZWFzb25hYmxlIGR1cmF0aW9uIGZvciBpdFxuXHRcdGlmICghcmVzaXplTG9jYXRpb24uc3RhcnQuaXNCZWZvcmUocmVzaXplTG9jYXRpb24uZW5kKSkge1xuXG5cdFx0XHRkZWZhdWx0RHVyYXRpb24gPVxuXHRcdFx0XHR0aGlzLm1pblJlc2l6ZUR1cmF0aW9uIHx8IC8vIFRPRE86IGhhY2tcblx0XHRcdFx0KGV2ZW50LmFsbERheSA/XG5cdFx0XHRcdFx0Y2FsZW5kYXIuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuXHRcdFx0XHRcdGNhbGVuZGFyLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuXG5cdFx0XHRpZiAodHlwZSA9PSAnc3RhcnQnKSB7IC8vIHJlc2l6aW5nIHRoZSBzdGFydD9cblx0XHRcdFx0cmVzaXplTG9jYXRpb24uc3RhcnQgPSByZXNpemVMb2NhdGlvbi5lbmQuY2xvbmUoKS5zdWJ0cmFjdChkZWZhdWx0RHVyYXRpb24pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IC8vIHJlc2l6aW5nIHRoZSBlbmQ/XG5cdFx0XHRcdHJlc2l6ZUxvY2F0aW9uLmVuZCA9IHJlc2l6ZUxvY2F0aW9uLnN0YXJ0LmNsb25lKCkuYWRkKGRlZmF1bHREdXJhdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc2l6ZUxvY2F0aW9uO1xuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWQuXG5cdC8vIGByYW5nZWAgaGFzIHRoZSB1cGRhdGVkIGRhdGVzIG9mIHRoZSBldmVudC4gYHNlZ2AgaXMgdGhlIG9yaWdpbmFsIHNlZ21lbnQgb2JqZWN0IGludm9sdmVkIGluIHRoZSBkcmFnLlxuXHQvLyBNdXN0IHJldHVybiBlbGVtZW50cyB1c2VkIGZvciBhbnkgbW9jayBldmVudHMuXG5cdHJlbmRlckV2ZW50UmVzaXplOiBmdW5jdGlvbihyYW5nZSwgc2VnKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZC5cblx0dW5yZW5kZXJFdmVudFJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogUmVuZGVyaW5nIFV0aWxzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBDb21wdXRlIHRoZSB0ZXh0IHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZCBvbiBhbiBldmVudCdzIGVsZW1lbnQuXG5cdC8vIGByYW5nZWAgY2FuIGJlIHRoZSBFdmVudCBvYmplY3QgaXRzZWxmLCBvciBzb21ldGhpbmcgcmFuZ2UtbGlrZSwgd2l0aCBhdCBsZWFzdCBhIGBzdGFydGAuXG5cdC8vIElmIGV2ZW50IHRpbWVzIGFyZSBkaXNhYmxlZCwgb3IgdGhlIGV2ZW50IGhhcyBubyB0aW1lLCB3aWxsIHJldHVybiBhIGJsYW5rIHN0cmluZy5cblx0Ly8gSWYgbm90IHNwZWNpZmllZCwgZm9ybWF0U3RyIHdpbGwgZGVmYXVsdCB0byB0aGUgZXZlbnRUaW1lRm9ybWF0IHNldHRpbmcsXG5cdC8vIGFuZCBkaXNwbGF5RW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgZGlzcGxheUV2ZW50RW5kIHNldHRpbmcuXG5cdGdldEV2ZW50VGltZVRleHQ6IGZ1bmN0aW9uKHJhbmdlLCBmb3JtYXRTdHIsIGRpc3BsYXlFbmQpIHtcblxuXHRcdGlmIChmb3JtYXRTdHIgPT0gbnVsbCkge1xuXHRcdFx0Zm9ybWF0U3RyID0gdGhpcy5ldmVudFRpbWVGb3JtYXQ7XG5cdFx0fVxuXG5cdFx0aWYgKGRpc3BsYXlFbmQgPT0gbnVsbCkge1xuXHRcdFx0ZGlzcGxheUVuZCA9IHRoaXMuZGlzcGxheUV2ZW50RW5kO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmRpc3BsYXlFdmVudFRpbWUgJiYgcmFuZ2Uuc3RhcnQuaGFzVGltZSgpKSB7XG5cdFx0XHRpZiAoZGlzcGxheUVuZCAmJiByYW5nZS5lbmQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudmlldy5mb3JtYXRSYW5nZShyYW5nZSwgZm9ybWF0U3RyKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcmFuZ2Uuc3RhcnQuZm9ybWF0KGZvcm1hdFN0cik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuICcnO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJpYyB1dGlsaXR5IGZvciBnZW5lcmF0aW5nIHRoZSBIVE1MIGNsYXNzTmFtZXMgZm9yIGFuIGV2ZW50IHNlZ21lbnQncyBlbGVtZW50XG5cdGdldFNlZ0NsYXNzZXM6IGZ1bmN0aW9uKHNlZywgaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXG5cdFx0XHQnZmMtZXZlbnQnLFxuXHRcdFx0c2VnLmlzU3RhcnQgPyAnZmMtc3RhcnQnIDogJ2ZjLW5vdC1zdGFydCcsXG5cdFx0XHRzZWcuaXNFbmQgPyAnZmMtZW5kJyA6ICdmYy1ub3QtZW5kJ1xuXHRcdF0uY29uY2F0KHRoaXMuZ2V0U2VnQ3VzdG9tQ2xhc3NlcyhzZWcpKTtcblxuXHRcdGlmIChpc0RyYWdnYWJsZSkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmYy1kcmFnZ2FibGUnKTtcblx0XHR9XG5cdFx0aWYgKGlzUmVzaXphYmxlKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2ZjLXJlc2l6YWJsZScpO1xuXHRcdH1cblxuXHRcdC8vIGV2ZW50IGlzIGN1cnJlbnRseSBzZWxlY3RlZD8gYXR0YWNoIGEgY2xhc3NOYW1lLlxuXHRcdGlmICh2aWV3LmlzRXZlbnRTZWxlY3RlZChzZWcuZXZlbnQpKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2ZjLXNlbGVjdGVkJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXM7XG5cdH0sXG5cblxuXHQvLyBMaXN0IG9mIGNsYXNzZXMgdGhhdCB3ZXJlIGRlZmluZWQgYnkgdGhlIGNhbGxlciBvZiB0aGUgQVBJIGluIHNvbWUgd2F5XG5cdGdldFNlZ0N1c3RvbUNsYXNzZXM6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHZhciBldmVudCA9IHNlZy5ldmVudDtcblxuXHRcdHJldHVybiBbXS5jb25jYXQoXG5cdFx0XHRldmVudC5jbGFzc05hbWUsIC8vIGd1YXJhbnRlZWQgdG8gYmUgYW4gYXJyYXlcblx0XHRcdGV2ZW50LnNvdXJjZSA/IGV2ZW50LnNvdXJjZS5jbGFzc05hbWUgOiBbXVxuXHRcdCk7XG5cdH0sXG5cblxuXHQvLyBVdGlsaXR5IGZvciBnZW5lcmF0aW5nIGV2ZW50IHNraW4tcmVsYXRlZCBDU1MgcHJvcGVydGllc1xuXHRnZXRTZWdTa2luQ3NzOiBmdW5jdGlvbihzZWcpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0J2JhY2tncm91bmQtY29sb3InOiB0aGlzLmdldFNlZ0JhY2tncm91bmRDb2xvcihzZWcpLFxuXHRcdFx0J2JvcmRlci1jb2xvcic6IHRoaXMuZ2V0U2VnQm9yZGVyQ29sb3Ioc2VnKSxcblx0XHRcdGNvbG9yOiB0aGlzLmdldFNlZ1RleHRDb2xvcihzZWcpXG5cdFx0fTtcblx0fSxcblxuXG5cdC8vIFF1ZXJpZXMgZm9yIGNhbGxlci1zcGVjaWZpZWQgY29sb3IsIHRoZW4gZmFsbHMgYmFjayB0byBkZWZhdWx0XG5cdGdldFNlZ0JhY2tncm91bmRDb2xvcjogZnVuY3Rpb24oc2VnKSB7XG5cdFx0cmV0dXJuIHNlZy5ldmVudC5iYWNrZ3JvdW5kQ29sb3IgfHxcblx0XHRcdHNlZy5ldmVudC5jb2xvciB8fFxuXHRcdFx0dGhpcy5nZXRTZWdEZWZhdWx0QmFja2dyb3VuZENvbG9yKHNlZyk7XG5cdH0sXG5cblxuXHRnZXRTZWdEZWZhdWx0QmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbihzZWcpIHtcblx0XHR2YXIgc291cmNlID0gc2VnLmV2ZW50LnNvdXJjZSB8fCB7fTtcblxuXHRcdHJldHVybiBzb3VyY2UuYmFja2dyb3VuZENvbG9yIHx8XG5cdFx0XHRzb3VyY2UuY29sb3IgfHxcblx0XHRcdHRoaXMudmlldy5vcHQoJ2V2ZW50QmFja2dyb3VuZENvbG9yJykgfHxcblx0XHRcdHRoaXMudmlldy5vcHQoJ2V2ZW50Q29sb3InKTtcblx0fSxcblxuXG5cdC8vIFF1ZXJpZXMgZm9yIGNhbGxlci1zcGVjaWZpZWQgY29sb3IsIHRoZW4gZmFsbHMgYmFjayB0byBkZWZhdWx0XG5cdGdldFNlZ0JvcmRlckNvbG9yOiBmdW5jdGlvbihzZWcpIHtcblx0XHRyZXR1cm4gc2VnLmV2ZW50LmJvcmRlckNvbG9yIHx8XG5cdFx0XHRzZWcuZXZlbnQuY29sb3IgfHxcblx0XHRcdHRoaXMuZ2V0U2VnRGVmYXVsdEJvcmRlckNvbG9yKHNlZyk7XG5cdH0sXG5cblxuXHRnZXRTZWdEZWZhdWx0Qm9yZGVyQ29sb3I6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHZhciBzb3VyY2UgPSBzZWcuZXZlbnQuc291cmNlIHx8IHt9O1xuXG5cdFx0cmV0dXJuIHNvdXJjZS5ib3JkZXJDb2xvciB8fFxuXHRcdFx0c291cmNlLmNvbG9yIHx8XG5cdFx0XHR0aGlzLnZpZXcub3B0KCdldmVudEJvcmRlckNvbG9yJykgfHxcblx0XHRcdHRoaXMudmlldy5vcHQoJ2V2ZW50Q29sb3InKTtcblx0fSxcblxuXG5cdC8vIFF1ZXJpZXMgZm9yIGNhbGxlci1zcGVjaWZpZWQgY29sb3IsIHRoZW4gZmFsbHMgYmFjayB0byBkZWZhdWx0XG5cdGdldFNlZ1RleHRDb2xvcjogZnVuY3Rpb24oc2VnKSB7XG5cdFx0cmV0dXJuIHNlZy5ldmVudC50ZXh0Q29sb3IgfHxcblx0XHRcdHRoaXMuZ2V0U2VnRGVmYXVsdFRleHRDb2xvcihzZWcpO1xuXHR9LFxuXG5cblx0Z2V0U2VnRGVmYXVsdFRleHRDb2xvcjogZnVuY3Rpb24oc2VnKSB7XG5cdFx0dmFyIHNvdXJjZSA9IHNlZy5ldmVudC5zb3VyY2UgfHwge307XG5cblx0XHRyZXR1cm4gc291cmNlLnRleHRDb2xvciB8fFxuXHRcdFx0dGhpcy52aWV3Lm9wdCgnZXZlbnRUZXh0Q29sb3InKTtcblx0fSxcblxuXG5cdC8qIEV2ZW50IExvY2F0aW9uIFZhbGlkYXRpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdGlzRXZlbnRMb2NhdGlvbkFsbG93ZWQ6IGZ1bmN0aW9uKGV2ZW50TG9jYXRpb24sIGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuaXNFdmVudExvY2F0aW9uSW5SYW5nZShldmVudExvY2F0aW9uKSkge1xuXHRcdFx0dmFyIGNhbGVuZGFyID0gdGhpcy52aWV3LmNhbGVuZGFyO1xuXHRcdFx0dmFyIGV2ZW50U3BhbnMgPSB0aGlzLmV2ZW50VG9TcGFucyhldmVudExvY2F0aW9uKTtcblx0XHRcdHZhciBpO1xuXG5cdFx0XHRpZiAoZXZlbnRTcGFucy5sZW5ndGgpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGV2ZW50U3BhbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoIWNhbGVuZGFyLmlzRXZlbnRTcGFuQWxsb3dlZChldmVudFNwYW5zW2ldLCBldmVudCkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblxuXHRpc0V4dGVybmFsTG9jYXRpb25BbGxvd2VkOiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBtZXRhUHJvcHMpIHsgLy8gRk9SIHRoZSBleHRlcm5hbCBlbGVtZW50XG5cdFx0aWYgKHRoaXMuaXNFdmVudExvY2F0aW9uSW5SYW5nZShldmVudExvY2F0aW9uKSkge1xuXHRcdFx0dmFyIGNhbGVuZGFyID0gdGhpcy52aWV3LmNhbGVuZGFyO1xuXHRcdFx0dmFyIGV2ZW50U3BhbnMgPSB0aGlzLmV2ZW50VG9TcGFucyhldmVudExvY2F0aW9uKTtcblx0XHRcdHZhciBpO1xuXG5cdFx0XHRpZiAoZXZlbnRTcGFucy5sZW5ndGgpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGV2ZW50U3BhbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoIWNhbGVuZGFyLmlzRXh0ZXJuYWxTcGFuQWxsb3dlZChldmVudFNwYW5zW2ldLCBldmVudExvY2F0aW9uLCBtZXRhUHJvcHMpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cblx0aXNFdmVudExvY2F0aW9uSW5SYW5nZTogZnVuY3Rpb24oZXZlbnRMb2NhdGlvbikge1xuXHRcdHJldHVybiBpc1JhbmdlV2l0aGluUmFuZ2UoXG5cdFx0XHR0aGlzLmV2ZW50VG9SYXdSYW5nZShldmVudExvY2F0aW9uKSxcblx0XHRcdHRoaXMudmlldy52YWxpZFJhbmdlXG5cdFx0KTtcblx0fSxcblxuXG5cdC8qIENvbnZlcnRpbmcgZXZlbnRzIC0+IGV2ZW50UmFuZ2UgLT4gZXZlbnRTcGFuIC0+IGV2ZW50U2Vnc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gR2VuZXJhdGVzIGFuIGFycmF5IG9mIHNlZ21lbnRzIGZvciB0aGUgZ2l2ZW4gc2luZ2xlIGV2ZW50XG5cdC8vIENhbiBhY2NlcHQgYW4gZXZlbnQgXCJsb2NhdGlvblwiIGFzIHdlbGwgKHdoaWNoIG9ubHkgaGFzIHN0YXJ0L2VuZCBhbmQgbm8gYWxsRGF5KVxuXHRldmVudFRvU2VnczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5ldmVudHNUb1NlZ3MoWyBldmVudCBdKTtcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyBzcGFucyAoYWx3YXlzIHVuem9uZWQpIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG5cdC8vIERvZXMgbm90IGRvIGFueSBpbnZlcnRpbmcgZm9yIGludmVyc2UtYmFja2dyb3VuZCBldmVudHMuXG5cdC8vIENhbiBhY2NlcHQgYW4gZXZlbnQgXCJsb2NhdGlvblwiIGFzIHdlbGwgKHdoaWNoIG9ubHkgaGFzIHN0YXJ0L2VuZCBhbmQgbm8gYWxsRGF5KVxuXHRldmVudFRvU3BhbnM6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGV2ZW50UmFuZ2UgPSB0aGlzLmV2ZW50VG9SYW5nZShldmVudCk7IC8vIHsgc3RhcnQsIGVuZCwgaXNTdGFydCwgaXNFbmQgfVxuXG5cdFx0aWYgKGV2ZW50UmFuZ2UpIHtcblx0XHRcdHJldHVybiB0aGlzLmV2ZW50UmFuZ2VUb1NwYW5zKGV2ZW50UmFuZ2UsIGV2ZW50KTtcblx0XHR9XG5cdFx0ZWxzZSB7IC8vIG91dCBvZiB2aWV3J3MgdmFsaWQgcmFuZ2Vcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdH0sXG5cblxuXG5cdC8vIENvbnZlcnRzIGFuIGFycmF5IG9mIGV2ZW50IG9iamVjdHMgaW50byBhbiBhcnJheSBvZiBldmVudCBzZWdtZW50IG9iamVjdHMuXG5cdC8vIEEgY3VzdG9tIGBzZWdTbGljZUZ1bmNgIG1heSBiZSBnaXZlbiBmb3IgYXJiaXRyYXJpbHkgc2xpY2luZyB1cCBldmVudHMuXG5cdC8vIERvZXNuJ3QgZ3VhcmFudGVlIGFuIG9yZGVyIGZvciB0aGUgcmVzdWx0aW5nIGFycmF5LlxuXHRldmVudHNUb1NlZ3M6IGZ1bmN0aW9uKGFsbEV2ZW50cywgc2VnU2xpY2VGdW5jKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgZXZlbnRzQnlJZCA9IGdyb3VwRXZlbnRzQnlJZChhbGxFdmVudHMpO1xuXHRcdHZhciBzZWdzID0gW107XG5cblx0XHQkLmVhY2goZXZlbnRzQnlJZCwgZnVuY3Rpb24oaWQsIGV2ZW50cykge1xuXHRcdFx0dmFyIHZpc2libGVFdmVudHMgPSBbXTtcblx0XHRcdHZhciBldmVudFJhbmdlcyA9IFtdO1xuXHRcdFx0dmFyIGV2ZW50UmFuZ2U7IC8vIHsgc3RhcnQsIGVuZCwgaXNTdGFydCwgaXNFbmQgfVxuXHRcdFx0dmFyIGk7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZXZlbnRSYW5nZSA9IF90aGlzLmV2ZW50VG9SYW5nZShldmVudHNbaV0pOyAvLyBtaWdodCBiZSBudWxsIGlmIGNvbXBsZXRlbHkgb3V0IG9mIHJhbmdlXG5cblx0XHRcdFx0aWYgKGV2ZW50UmFuZ2UpIHtcblx0XHRcdFx0XHRldmVudFJhbmdlcy5wdXNoKGV2ZW50UmFuZ2UpO1xuXHRcdFx0XHRcdHZpc2libGVFdmVudHMucHVzaChldmVudHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGludmVyc2UtYmFja2dyb3VuZCBldmVudHMgKHV0aWxpemUgb25seSB0aGUgZmlyc3QgZXZlbnQgaW4gY2FsY3VsYXRpb25zKVxuXHRcdFx0aWYgKGlzSW52ZXJzZUJnRXZlbnQoZXZlbnRzWzBdKSkge1xuXHRcdFx0XHRldmVudFJhbmdlcyA9IF90aGlzLmludmVydFJhbmdlcyhldmVudFJhbmdlcyk7IC8vIHdpbGwgbG9zZSBpc1N0YXJ0L2lzRW5kXG5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGV2ZW50UmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0c2Vncy5wdXNoLmFwcGx5KHNlZ3MsIC8vIGFwcGVuZCB0b1xuXHRcdFx0XHRcdFx0X3RoaXMuZXZlbnRSYW5nZVRvU2VncyhldmVudFJhbmdlc1tpXSwgZXZlbnRzWzBdLCBzZWdTbGljZUZ1bmMpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gbm9ybWFsIGV2ZW50IHJhbmdlc1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBldmVudFJhbmdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHNlZ3MucHVzaC5hcHBseShzZWdzLCAvLyBhcHBlbmQgdG9cblx0XHRcdFx0XHRcdF90aGlzLmV2ZW50UmFuZ2VUb1NlZ3MoZXZlbnRSYW5nZXNbaV0sIHZpc2libGVFdmVudHNbaV0sIHNlZ1NsaWNlRnVuYylcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgdW56b25lZCBzdGFydC9lbmQgZGF0ZXMgYW4gZXZlbnQgYXBwZWFycyB0byBvY2N1cHlcblx0Ly8gQ2FuIGFjY2VwdCBhbiBldmVudCBcImxvY2F0aW9uXCIgYXMgd2VsbCAod2hpY2ggb25seSBoYXMgc3RhcnQvZW5kIGFuZCBubyBhbGxEYXkpXG5cdC8vIHJldHVybnMgeyBzdGFydCwgZW5kLCBpc1N0YXJ0LCBpc0VuZCB9XG5cdC8vIElmIHRoZSBldmVudCBpcyBjb21wbGV0ZWx5IG91dHNpZGUgb2YgdGhlIGdyaWQncyB2YWxpZCByYW5nZSwgd2lsbCByZXR1cm4gdW5kZWZpbmVkLlxuXHRldmVudFRvUmFuZ2U6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIHRoaXMucmVmaW5lUmF3RXZlbnRSYW5nZShcblx0XHRcdHRoaXMuZXZlbnRUb1Jhd1JhbmdlKGV2ZW50KVxuXHRcdCk7XG5cdH0sXG5cblxuXHQvLyBFbnN1cmVzIHRoZSBnaXZlbiByYW5nZSBpcyB3aXRoaW4gdGhlIHZpZXcncyBhY3RpdmVSYW5nZSBhbmQgaXMgY29ycmVjdGx5IGxvY2FsaXplZC5cblx0Ly8gQWx3YXlzIHJldHVybnMgYSByZXN1bHRcblx0cmVmaW5lUmF3RXZlbnRSYW5nZTogZnVuY3Rpb24ocmF3UmFuZ2UpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xuXHRcdHZhciByYW5nZSA9IGludGVyc2VjdFJhbmdlcyhyYXdSYW5nZSwgdmlldy5hY3RpdmVSYW5nZSk7XG5cblx0XHRpZiAocmFuZ2UpIHsgLy8gb3RoZXJ3aXNlLCBldmVudCBkb2Vzbid0IGhhdmUgdmFsaWQgcmFuZ2VcblxuXHRcdFx0Ly8gaGFjazogZHluYW1pYyBsb2NhbGUgY2hhbmdlIGZvcmdldHMgdG8gdXBhdGUgc3RvcmVkIGV2ZW50IGxvY2FsZWRcblx0XHRcdGNhbGVuZGFyLmxvY2FsaXplTW9tZW50KHJhbmdlLnN0YXJ0KTtcblx0XHRcdGNhbGVuZGFyLmxvY2FsaXplTW9tZW50KHJhbmdlLmVuZCk7XG5cblx0XHRcdHJldHVybiByYW5nZTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBub3QgY29uc3RyYWluZWQgdG8gdmFsaWQgZGF0ZXNcblx0Ly8gbm90IGdpdmVuIGxvY2FsaXplTW9tZW50IGhhY2tcblx0ZXZlbnRUb1Jhd1JhbmdlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBjYWxlbmRhciA9IHRoaXMudmlldy5jYWxlbmRhcjtcblx0XHR2YXIgc3RhcnQgPSBldmVudC5zdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpO1xuXHRcdHZhciBlbmQgPSAoXG5cdFx0XHRcdGV2ZW50LmVuZCA/XG5cdFx0XHRcdFx0ZXZlbnQuZW5kLmNsb25lKCkgOlxuXHRcdFx0XHRcdC8vIGRlcml2ZSB0aGUgZW5kIGZyb20gdGhlIHN0YXJ0IGFuZCBhbGxEYXkuIGNvbXB1dGUgYWxsRGF5IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGNhbGVuZGFyLmdldERlZmF1bHRFdmVudEVuZChcblx0XHRcdFx0XHRcdGV2ZW50LmFsbERheSAhPSBudWxsID9cblx0XHRcdFx0XHRcdFx0ZXZlbnQuYWxsRGF5IDpcblx0XHRcdFx0XHRcdFx0IWV2ZW50LnN0YXJ0Lmhhc1RpbWUoKSxcblx0XHRcdFx0XHRcdGV2ZW50LnN0YXJ0XG5cdFx0XHRcdFx0KVxuXHRcdFx0KS5zdHJpcFpvbmUoKTtcblxuXHRcdHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcblx0fSxcblxuXG5cdC8vIEdpdmVuIGFuIGV2ZW50J3MgcmFuZ2UgKHVuem9uZWQgc3RhcnQvZW5kKSwgYW5kIHRoZSBldmVudCBpdHNlbGYsXG5cdC8vIHNsaWNlIGludG8gc2VnbWVudHMgKHVzaW5nIHRoZSBzZWdTbGljZUZ1bmMgZnVuY3Rpb24gaWYgc3BlY2lmaWVkKVxuXHQvLyBldmVudFJhbmdlIC0geyBzdGFydCwgZW5kLCBpc1N0YXJ0LCBpc0VuZCB9XG5cdGV2ZW50UmFuZ2VUb1NlZ3M6IGZ1bmN0aW9uKGV2ZW50UmFuZ2UsIGV2ZW50LCBzZWdTbGljZUZ1bmMpIHtcblx0XHR2YXIgZXZlbnRTcGFucyA9IHRoaXMuZXZlbnRSYW5nZVRvU3BhbnMoZXZlbnRSYW5nZSwgZXZlbnQpO1xuXHRcdHZhciBzZWdzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRTcGFucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2Vncy5wdXNoLmFwcGx5KHNlZ3MsIC8vIGFwcGVuZCB0b1xuXHRcdFx0XHR0aGlzLmV2ZW50U3BhblRvU2VncyhldmVudFNwYW5zW2ldLCBldmVudCwgc2VnU2xpY2VGdW5jKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8vIEdpdmVuIGFuIGV2ZW50J3MgdW56b25lZCBkYXRlIHJhbmdlLCByZXR1cm4gYW4gYXJyYXkgb2YgZXZlbnRTcGFuIG9iamVjdHMuXG5cdC8vIGV2ZW50U3BhbiAtIHsgc3RhcnQsIGVuZCwgaXNTdGFydCwgaXNFbmQsIG90aGVydGhpbmdzLi4uIH1cblx0Ly8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUuXG5cdC8vIFN1YmNsYXNzZXMgYXJlIG9ibGlnYXRlZCB0byBmb3J3YXJkIGV2ZW50UmFuZ2UuaXNTdGFydC9pc0VuZCB0byB0aGUgcmVzdWx0aW5nIHNwYW5zLlxuXHRldmVudFJhbmdlVG9TcGFuczogZnVuY3Rpb24oZXZlbnRSYW5nZSwgZXZlbnQpIHtcblx0XHRyZXR1cm4gWyAkLmV4dGVuZCh7fSwgZXZlbnRSYW5nZSkgXTsgLy8gY29weSBpbnRvIGEgc2luZ2xlLWl0ZW0gYXJyYXlcblx0fSxcblxuXG5cdC8vIEdpdmVuIGFuIGV2ZW50J3Mgc3BhbiAodW56b25lZCBzdGFydC9lbmQgYW5kIG90aGVyIG1pc2MgZGF0YSksIGFuZCB0aGUgZXZlbnQgaXRzZWxmLFxuXHQvLyBzbGljZXMgaW50byBzZWdtZW50cyBhbmQgYXR0YWNoZXMgZXZlbnQtZGVyaXZlZCBwcm9wZXJ0aWVzIHRvIHRoZW0uXG5cdC8vIGV2ZW50U3BhbiAtIHsgc3RhcnQsIGVuZCwgaXNTdGFydCwgaXNFbmQsIG90aGVydGhpbmdzLi4uIH1cblx0ZXZlbnRTcGFuVG9TZWdzOiBmdW5jdGlvbihldmVudFNwYW4sIGV2ZW50LCBzZWdTbGljZUZ1bmMpIHtcblx0XHR2YXIgc2VncyA9IHNlZ1NsaWNlRnVuYyA/IHNlZ1NsaWNlRnVuYyhldmVudFNwYW4pIDogdGhpcy5zcGFuVG9TZWdzKGV2ZW50U3Bhbik7XG5cdFx0dmFyIGksIHNlZztcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWcgPSBzZWdzW2ldO1xuXG5cdFx0XHQvLyB0aGUgZXZlbnRTcGFuJ3MgaXNTdGFydC9pc0VuZCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIHNlZydzXG5cdFx0XHRpZiAoIWV2ZW50U3Bhbi5pc1N0YXJ0KSB7XG5cdFx0XHRcdHNlZy5pc1N0YXJ0ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWV2ZW50U3Bhbi5pc0VuZCkge1xuXHRcdFx0XHRzZWcuaXNFbmQgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0c2VnLmV2ZW50ID0gZXZlbnQ7XG5cdFx0XHRzZWcuZXZlbnRTdGFydE1TID0gK2V2ZW50U3Bhbi5zdGFydDsgLy8gVE9ETzogbm90IHRoZSBiZXN0IG5hbWUgYWZ0ZXIgbWFraW5nIHNwYW5zIHVuem9uZWRcblx0XHRcdHNlZy5ldmVudER1cmF0aW9uTVMgPSBldmVudFNwYW4uZW5kIC0gZXZlbnRTcGFuLnN0YXJ0O1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0Ly8gUHJvZHVjZXMgYSBuZXcgYXJyYXkgb2YgcmFuZ2Ugb2JqZWN0cyB0aGF0IHdpbGwgY292ZXIgYWxsIHRoZSB0aW1lIE5PVCBjb3ZlcmVkIGJ5IHRoZSBnaXZlbiByYW5nZXMuXG5cdC8vIFNJREUgRUZGRUNUOiB3aWxsIG11dGF0ZSB0aGUgZ2l2ZW4gYXJyYXkgYW5kIHdpbGwgdXNlIGl0cyBkYXRlIHJlZmVyZW5jZXMuXG5cdGludmVydFJhbmdlczogZnVuY3Rpb24ocmFuZ2VzKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIHZpZXdTdGFydCA9IHZpZXcuYWN0aXZlUmFuZ2Uuc3RhcnQuY2xvbmUoKTsgLy8gbmVlZCBhIGNvcHlcblx0XHR2YXIgdmlld0VuZCA9IHZpZXcuYWN0aXZlUmFuZ2UuZW5kLmNsb25lKCk7IC8vIG5lZWQgYSBjb3B5XG5cdFx0dmFyIGludmVyc2VSYW5nZXMgPSBbXTtcblx0XHR2YXIgc3RhcnQgPSB2aWV3U3RhcnQ7IC8vIHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIHJhbmdlLiB0aGUgc3RhcnQgb2YgdGhlIG5ldyByYW5nZVxuXHRcdHZhciBpLCByYW5nZTtcblxuXHRcdC8vIHJhbmdlcyBuZWVkIHRvIGJlIGluIG9yZGVyLiByZXF1aXJlZCBmb3Igb3VyIGRhdGUtd2Fsa2luZyBhbGdvcml0aG1cblx0XHRyYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHJhbmdlID0gcmFuZ2VzW2ldO1xuXG5cdFx0XHQvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBiZWZvcmUgdGhlIGV2ZW50IChpZiB0aGVyZSBpcyBhbnkpXG5cdFx0XHRpZiAocmFuZ2Uuc3RhcnQgPiBzdGFydCkgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxuXHRcdFx0XHRpbnZlcnNlUmFuZ2VzLnB1c2goe1xuXHRcdFx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdFx0XHRlbmQ6IHJhbmdlLnN0YXJ0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmFuZ2UuZW5kID4gc3RhcnQpIHtcblx0XHRcdFx0c3RhcnQgPSByYW5nZS5lbmQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYWZ0ZXIgdGhlIGxhc3QgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcblx0XHRpZiAoc3RhcnQgPCB2aWV3RW5kKSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG5cdFx0XHRpbnZlcnNlUmFuZ2VzLnB1c2goe1xuXHRcdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRcdGVuZDogdmlld0VuZFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGludmVyc2VSYW5nZXM7XG5cdH0sXG5cblxuXHRzb3J0RXZlbnRTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0c2Vncy5zb3J0KHByb3h5KHRoaXMsICdjb21wYXJlRXZlbnRTZWdzJykpO1xuXHR9LFxuXG5cblx0Ly8gQSBjbXAgZnVuY3Rpb24gZm9yIGRldGVybWluaW5nIHdoaWNoIHNlZ21lbnRzIHNob3VsZCB0YWtlIHZpc3VhbCBwcmlvcml0eVxuXHRjb21wYXJlRXZlbnRTZWdzOiBmdW5jdGlvbihzZWcxLCBzZWcyKSB7XG5cdFx0cmV0dXJuIHNlZzEuZXZlbnRTdGFydE1TIC0gc2VnMi5ldmVudFN0YXJ0TVMgfHwgLy8gZWFybGllciBldmVudHMgZ28gZmlyc3Rcblx0XHRcdHNlZzIuZXZlbnREdXJhdGlvbk1TIC0gc2VnMS5ldmVudER1cmF0aW9uTVMgfHwgLy8gdGllPyBsb25nZXIgZXZlbnRzIGdvIGZpcnN0XG5cdFx0XHRzZWcyLmV2ZW50LmFsbERheSAtIHNlZzEuZXZlbnQuYWxsRGF5IHx8IC8vIHRpZT8gcHV0IGFsbC1kYXkgZXZlbnRzIGZpcnN0IChib29sZWFucyBjYXN0IHRvIDAvMSlcblx0XHRcdGNvbXBhcmVCeUZpZWxkU3BlY3Moc2VnMS5ldmVudCwgc2VnMi5ldmVudCwgdGhpcy52aWV3LmV2ZW50T3JkZXJTcGVjcyk7XG5cdH1cblxufSk7XG5cblxuLyogVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5mdW5jdGlvbiBwbHVja0V2ZW50RGF0ZVByb3BzKGV2ZW50KSB7XG5cdHJldHVybiB7XG5cdFx0c3RhcnQ6IGV2ZW50LnN0YXJ0LmNsb25lKCksXG5cdFx0ZW5kOiBldmVudC5lbmQgPyBldmVudC5lbmQuY2xvbmUoKSA6IG51bGwsXG5cdFx0YWxsRGF5OiBldmVudC5hbGxEYXkgLy8ga2VlcCBpdCB0aGUgc2FtZVxuXHR9O1xufVxuRkMucGx1Y2tFdmVudERhdGVQcm9wcyA9IHBsdWNrRXZlbnREYXRlUHJvcHM7XG5cblxuZnVuY3Rpb24gaXNCZ0V2ZW50KGV2ZW50KSB7IC8vIHJldHVybnMgdHJ1ZSBpZiBiYWNrZ3JvdW5kIE9SIGludmVyc2UtYmFja2dyb3VuZFxuXHR2YXIgcmVuZGVyaW5nID0gZ2V0RXZlbnRSZW5kZXJpbmcoZXZlbnQpO1xuXHRyZXR1cm4gcmVuZGVyaW5nID09PSAnYmFja2dyb3VuZCcgfHwgcmVuZGVyaW5nID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcbn1cbkZDLmlzQmdFdmVudCA9IGlzQmdFdmVudDsgLy8gZXhwb3J0XG5cblxuZnVuY3Rpb24gaXNJbnZlcnNlQmdFdmVudChldmVudCkge1xuXHRyZXR1cm4gZ2V0RXZlbnRSZW5kZXJpbmcoZXZlbnQpID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcbn1cblxuXG5mdW5jdGlvbiBnZXRFdmVudFJlbmRlcmluZyhldmVudCkge1xuXHRyZXR1cm4gZmlyc3REZWZpbmVkKChldmVudC5zb3VyY2UgfHwge30pLnJlbmRlcmluZywgZXZlbnQucmVuZGVyaW5nKTtcbn1cblxuXG5mdW5jdGlvbiBncm91cEV2ZW50c0J5SWQoZXZlbnRzKSB7XG5cdHZhciBldmVudHNCeUlkID0ge307XG5cdHZhciBpLCBldmVudDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZXZlbnQgPSBldmVudHNbaV07XG5cdFx0KGV2ZW50c0J5SWRbZXZlbnQuX2lkXSB8fCAoZXZlbnRzQnlJZFtldmVudC5faWRdID0gW10pKS5wdXNoKGV2ZW50KTtcblx0fVxuXG5cdHJldHVybiBldmVudHNCeUlkO1xufVxuXG5cbi8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGljaCBub24taW52ZXJ0ZWQgXCJyYW5nZXNcIiAoc2VlIGFib3ZlKSBoYXBwZW4gZWFybGllclxuZnVuY3Rpb24gY29tcGFyZVJhbmdlcyhyYW5nZTEsIHJhbmdlMikge1xuXHRyZXR1cm4gcmFuZ2UxLnN0YXJ0IC0gcmFuZ2UyLnN0YXJ0OyAvLyBlYXJsaWVyIHJhbmdlcyBnbyBmaXJzdFxufVxuXG5cbi8qIEV4dGVybmFsLURyYWdnaW5nLUVsZW1lbnQgRGF0YVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vIFJlcXVpcmUgYWxsIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVzIHVzZWQgYnkgRnVsbENhbGVuZGFyIHRvIGhhdmUgdGhpcyBwcmVmaXguXG4vLyBBIHZhbHVlIG9mICcnIHdpbGwgcXVlcnkgYXR0cmlidXRlcyBsaWtlIGRhdGEtZXZlbnQuIEEgdmFsdWUgb2YgJ2ZjJyB3aWxsIHF1ZXJ5IGF0dHJpYnV0ZXMgbGlrZSBkYXRhLWZjLWV2ZW50LlxuRkMuZGF0YUF0dHJQcmVmaXggPSAnJztcblxuLy8gR2l2ZW4gYSBqUXVlcnkgZWxlbWVudCB0aGF0IG1pZ2h0IHJlcHJlc2VudCBhIGRyYWdnZWQgRnVsbENhbGVuZGFyIGV2ZW50LCByZXR1cm5zIGFuIGludGVybWVkaWF0ZSBkYXRhIHN0cnVjdHVyZVxuLy8gdG8gYmUgdXNlZCBmb3IgRXZlbnQgT2JqZWN0IGNyZWF0aW9uLlxuLy8gQSBkZWZpbmVkIGAuZXZlbnRQcm9wc2AsIGV2ZW4gd2hlbiBlbXB0eSwgaW5kaWNhdGVzIHRoYXQgYW4gZXZlbnQgc2hvdWxkIGJlIGNyZWF0ZWQuXG5mdW5jdGlvbiBnZXREcmFnZ2VkRWxNZXRhKGVsKSB7XG5cdHZhciBwcmVmaXggPSBGQy5kYXRhQXR0clByZWZpeDtcblx0dmFyIGV2ZW50UHJvcHM7IC8vIHByb3BlcnRpZXMgZm9yIGNyZWF0aW5nIHRoZSBldmVudCwgbm90IHJlbGF0ZWQgdG8gZGF0ZS90aW1lXG5cdHZhciBzdGFydFRpbWU7IC8vIGEgRHVyYXRpb25cblx0dmFyIGR1cmF0aW9uO1xuXHR2YXIgc3RpY2s7XG5cblx0aWYgKHByZWZpeCkgeyBwcmVmaXggKz0gJy0nOyB9XG5cdGV2ZW50UHJvcHMgPSBlbC5kYXRhKHByZWZpeCArICdldmVudCcpIHx8IG51bGw7XG5cblx0aWYgKGV2ZW50UHJvcHMpIHtcblx0XHRpZiAodHlwZW9mIGV2ZW50UHJvcHMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRldmVudFByb3BzID0gJC5leHRlbmQoe30sIGV2ZW50UHJvcHMpOyAvLyBtYWtlIGEgY29weVxuXHRcdH1cblx0XHRlbHNlIHsgLy8gc29tZXRoaW5nIGxpa2UgMSBvciB0cnVlLiBzdGlsbCBzaWduYWwgZXZlbnQgY3JlYXRpb25cblx0XHRcdGV2ZW50UHJvcHMgPSB7fTtcblx0XHR9XG5cblx0XHQvLyBwbHVjayBzcGVjaWFsLWNhc2VkIGRhdGUvdGltZSBwcm9wZXJ0aWVzXG5cdFx0c3RhcnRUaW1lID0gZXZlbnRQcm9wcy5zdGFydDtcblx0XHRpZiAoc3RhcnRUaW1lID09IG51bGwpIHsgc3RhcnRUaW1lID0gZXZlbnRQcm9wcy50aW1lOyB9IC8vIGFjY2VwdCAndGltZScgYXMgd2VsbFxuXHRcdGR1cmF0aW9uID0gZXZlbnRQcm9wcy5kdXJhdGlvbjtcblx0XHRzdGljayA9IGV2ZW50UHJvcHMuc3RpY2s7XG5cdFx0ZGVsZXRlIGV2ZW50UHJvcHMuc3RhcnQ7XG5cdFx0ZGVsZXRlIGV2ZW50UHJvcHMudGltZTtcblx0XHRkZWxldGUgZXZlbnRQcm9wcy5kdXJhdGlvbjtcblx0XHRkZWxldGUgZXZlbnRQcm9wcy5zdGljaztcblx0fVxuXG5cdC8vIGZhbGxiYWNrIHRvIHN0YW5kYWxvbmUgYXR0cmlidXRlIHZhbHVlcyBmb3IgZWFjaCBvZiB0aGUgZGF0ZS90aW1lIHByb3BlcnRpZXNcblx0aWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7IHN0YXJ0VGltZSA9IGVsLmRhdGEocHJlZml4ICsgJ3N0YXJ0Jyk7IH1cblx0aWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7IHN0YXJ0VGltZSA9IGVsLmRhdGEocHJlZml4ICsgJ3RpbWUnKTsgfSAvLyBhY2NlcHQgJ3RpbWUnIGFzIHdlbGxcblx0aWYgKGR1cmF0aW9uID09IG51bGwpIHsgZHVyYXRpb24gPSBlbC5kYXRhKHByZWZpeCArICdkdXJhdGlvbicpOyB9XG5cdGlmIChzdGljayA9PSBudWxsKSB7IHN0aWNrID0gZWwuZGF0YShwcmVmaXggKyAnc3RpY2snKTsgfVxuXG5cdC8vIG1hc3NhZ2UgaW50byBjb3JyZWN0IGRhdGEgdHlwZXNcblx0c3RhcnRUaW1lID0gc3RhcnRUaW1lICE9IG51bGwgPyBtb21lbnQuZHVyYXRpb24oc3RhcnRUaW1lKSA6IG51bGw7XG5cdGR1cmF0aW9uID0gZHVyYXRpb24gIT0gbnVsbCA/IG1vbWVudC5kdXJhdGlvbihkdXJhdGlvbikgOiBudWxsO1xuXHRzdGljayA9IEJvb2xlYW4oc3RpY2spO1xuXG5cdHJldHVybiB7IGV2ZW50UHJvcHM6IGV2ZW50UHJvcHMsIHN0YXJ0VGltZTogc3RhcnRUaW1lLCBkdXJhdGlvbjogZHVyYXRpb24sIHN0aWNrOiBzdGljayB9O1xufVxuXG5cbjs7XG5cbi8qXG5BIHNldCBvZiByZW5kZXJpbmcgYW5kIGRhdGUtcmVsYXRlZCBtZXRob2RzIGZvciBhIHZpc3VhbCBjb21wb25lbnQgY29tcHJpc2VkIG9mIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNvbHVtbnMuXG5QcmVyZXF1aXNpdGU6IHRoZSBvYmplY3QgYmVpbmcgbWl4ZWQgaW50byBuZWVkcyB0byBiZSBhICpHcmlkKlxuKi9cbnZhciBEYXlUYWJsZU1peGluID0gRkMuRGF5VGFibGVNaXhpbiA9IHtcblxuXHRicmVha09uV2Vla3M6IGZhbHNlLCAvLyBzaG91bGQgY3JlYXRlIGEgbmV3IHJvdyBmb3IgZWFjaCB3ZWVrP1xuXHRkYXlEYXRlczogbnVsbCwgLy8gd2hvbGUtZGF5IGRhdGVzIGZvciBlYWNoIGNvbHVtbi4gbGVmdCB0byByaWdodFxuXHRkYXlJbmRpY2VzOiBudWxsLCAvLyBmb3IgZWFjaCBkYXkgZnJvbSBzdGFydCwgdGhlIG9mZnNldFxuXHRkYXlzUGVyUm93OiBudWxsLFxuXHRyb3dDbnQ6IG51bGwsXG5cdGNvbENudDogbnVsbCxcblx0Y29sSGVhZEZvcm1hdDogbnVsbCxcblxuXG5cdC8vIFBvcHVsYXRlcyBpbnRlcm5hbCB2YXJpYWJsZXMgdXNlZCBmb3IgZGF0ZSBjYWxjdWxhdGlvbiBhbmQgcmVuZGVyaW5nXG5cdHVwZGF0ZURheVRhYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgZGF0ZSA9IHRoaXMuc3RhcnQuY2xvbmUoKTtcblx0XHR2YXIgZGF5SW5kZXggPSAtMTtcblx0XHR2YXIgZGF5SW5kaWNlcyA9IFtdO1xuXHRcdHZhciBkYXlEYXRlcyA9IFtdO1xuXHRcdHZhciBkYXlzUGVyUm93O1xuXHRcdHZhciBmaXJzdERheTtcblx0XHR2YXIgcm93Q250O1xuXG5cdFx0d2hpbGUgKGRhdGUuaXNCZWZvcmUodGhpcy5lbmQpKSB7IC8vIGxvb3AgZWFjaCBkYXkgZnJvbSBzdGFydCB0byBlbmRcblx0XHRcdGlmICh2aWV3LmlzSGlkZGVuRGF5KGRhdGUpKSB7XG5cdFx0XHRcdGRheUluZGljZXMucHVzaChkYXlJbmRleCArIDAuNSk7IC8vIG1hcmsgdGhhdCBpdCdzIGJldHdlZW4gaW5kaWNlc1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGRheUluZGV4Kys7XG5cdFx0XHRcdGRheUluZGljZXMucHVzaChkYXlJbmRleCk7XG5cdFx0XHRcdGRheURhdGVzLnB1c2goZGF0ZS5jbG9uZSgpKTtcblx0XHRcdH1cblx0XHRcdGRhdGUuYWRkKDEsICdkYXlzJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuYnJlYWtPbldlZWtzKSB7XG5cdFx0XHQvLyBjb3VudCBjb2x1bW5zIHVudGlsIHRoZSBkYXktb2Ytd2VlayByZXBlYXRzXG5cdFx0XHRmaXJzdERheSA9IGRheURhdGVzWzBdLmRheSgpO1xuXHRcdFx0Zm9yIChkYXlzUGVyUm93ID0gMTsgZGF5c1BlclJvdyA8IGRheURhdGVzLmxlbmd0aDsgZGF5c1BlclJvdysrKSB7XG5cdFx0XHRcdGlmIChkYXlEYXRlc1tkYXlzUGVyUm93XS5kYXkoKSA9PSBmaXJzdERheSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyb3dDbnQgPSBNYXRoLmNlaWwoZGF5RGF0ZXMubGVuZ3RoIC8gZGF5c1BlclJvdyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cm93Q250ID0gMTtcblx0XHRcdGRheXNQZXJSb3cgPSBkYXlEYXRlcy5sZW5ndGg7XG5cdFx0fVxuXG5cdFx0dGhpcy5kYXlEYXRlcyA9IGRheURhdGVzO1xuXHRcdHRoaXMuZGF5SW5kaWNlcyA9IGRheUluZGljZXM7XG5cdFx0dGhpcy5kYXlzUGVyUm93ID0gZGF5c1BlclJvdztcblx0XHR0aGlzLnJvd0NudCA9IHJvd0NudDtcblxuXHRcdHRoaXMudXBkYXRlRGF5VGFibGVDb2xzKCk7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyBhbmQgYXNzaWduZWQgdGhlIGNvbENudCBwcm9wZXJ0eSBhbmQgdXBkYXRlcyBhbnkgb3B0aW9ucyB0aGF0IG1heSBiZSBjb21wdXRlZCBmcm9tIGl0XG5cdHVwZGF0ZURheVRhYmxlQ29sczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jb2xDbnQgPSB0aGlzLmNvbXB1dGVDb2xDbnQoKTtcblx0XHR0aGlzLmNvbEhlYWRGb3JtYXQgPSB0aGlzLnZpZXcub3B0KCdjb2x1bW5Gb3JtYXQnKSB8fCB0aGlzLmNvbXB1dGVDb2xIZWFkRm9ybWF0KCk7XG5cdH0sXG5cblxuXHQvLyBEZXRlcm1pbmVzIGhvdyBtYW55IGNvbHVtbnMgdGhlcmUgc2hvdWxkIGJlIGluIHRoZSB0YWJsZVxuXHRjb21wdXRlQ29sQ250OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXlzUGVyUm93O1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgdGhlIGFtYmlndW91c2x5LXRpbWVkIG1vbWVudCBmb3IgdGhlIGdpdmVuIGNlbGxcblx0Z2V0Q2VsbERhdGU6IGZ1bmN0aW9uKHJvdywgY29sKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF5RGF0ZXNbXG5cdFx0XHRcdHRoaXMuZ2V0Q2VsbERheUluZGV4KHJvdywgY29sKVxuXHRcdFx0XS5jbG9uZSgpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgdGhlIGFtYmlndW91c2x5LXRpbWVkIGRhdGUgcmFuZ2UgZm9yIHRoZSBnaXZlbiBjZWxsXG5cdGdldENlbGxSYW5nZTogZnVuY3Rpb24ocm93LCBjb2wpIHtcblx0XHR2YXIgc3RhcnQgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKTtcblx0XHR2YXIgZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQoMSwgJ2RheXMnKTtcblxuXHRcdHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcblx0fSxcblxuXG5cdC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXkgY2VsbHMsIGNocm9ub2xvZ2ljYWxseSwgZnJvbSB0aGUgZmlyc3Qgb2YgdGhlIGdyaWQgKDAtYmFzZWQpXG5cdGdldENlbGxEYXlJbmRleDogZnVuY3Rpb24ocm93LCBjb2wpIHtcblx0XHRyZXR1cm4gcm93ICogdGhpcy5kYXlzUGVyUm93ICsgdGhpcy5nZXRDb2xEYXlJbmRleChjb2wpO1xuXHR9LFxuXG5cblx0Ly8gUmV0dXJucyB0aGUgbnVtbmVyIG9mIGRheSBjZWxscywgY2hyb25vbG9naWNhbGx5LCBmcm9tIHRoZSBmaXJzdCBjZWxsIGluICphbnkgZ2l2ZW4gcm93KlxuXHRnZXRDb2xEYXlJbmRleDogZnVuY3Rpb24oY29sKSB7XG5cdFx0aWYgKHRoaXMuaXNSVEwpIHtcblx0XHRcdHJldHVybiB0aGlzLmNvbENudCAtIDEgLSBjb2w7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuIGNvbDtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIGRhdGUsIHJldHVybnMgaXRzIGNocm9ub2xvY2lhbCBjZWxsLWluZGV4IGZyb20gdGhlIGZpcnN0IGNlbGwgb2YgdGhlIGdyaWQuXG5cdC8vIElmIHRoZSBkYXRlIGxpZXMgYmV0d2VlbiBjZWxscyAoYmVjYXVzZSBvZiBoaWRkZW5EYXlzKSwgcmV0dXJucyBhIGZsb2F0aW5nLXBvaW50IHZhbHVlIGJldHdlZW4gb2Zmc2V0cy5cblx0Ly8gSWYgYmVmb3JlIHRoZSBmaXJzdCBvZmZzZXQsIHJldHVybnMgYSBuZWdhdGl2ZSBudW1iZXIuXG5cdC8vIElmIGFmdGVyIHRoZSBsYXN0IG9mZnNldCwgcmV0dXJucyBhbiBvZmZzZXQgcGFzdCB0aGUgbGFzdCBjZWxsIG9mZnNldC5cblx0Ly8gT25seSB3b3JrcyBmb3IgKnN0YXJ0KiBkYXRlcyBvZiBjZWxscy4gV2lsbCBub3Qgd29yayBmb3IgZXhjbHVzaXZlIGVuZCBkYXRlcyBmb3IgY2VsbHMuXG5cdGdldERhdGVEYXlJbmRleDogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdHZhciBkYXlJbmRpY2VzID0gdGhpcy5kYXlJbmRpY2VzO1xuXHRcdHZhciBkYXlPZmZzZXQgPSBkYXRlLmRpZmYodGhpcy5zdGFydCwgJ2RheXMnKTtcblxuXHRcdGlmIChkYXlPZmZzZXQgPCAwKSB7XG5cdFx0XHRyZXR1cm4gZGF5SW5kaWNlc1swXSAtIDE7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGRheU9mZnNldCA+PSBkYXlJbmRpY2VzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGRheUluZGljZXNbZGF5SW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuIGRheUluZGljZXNbZGF5T2Zmc2V0XTtcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBPcHRpb25zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBDb21wdXRlcyBhIGRlZmF1bHQgY29sdW1uIGhlYWRlciBmb3JtYXR0aW5nIHN0cmluZyBpZiBgY29sRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXG5cdGNvbXB1dGVDb2xIZWFkRm9ybWF0OiBmdW5jdGlvbigpIHtcblx0XHQvLyBpZiBtb3JlIHRoYW4gb25lIHdlZWsgcm93LCBvciBpZiB0aGVyZSBhcmUgYSBsb3Qgb2YgY29sdW1ucyB3aXRoIG5vdCBtdWNoIHNwYWNlLFxuXHRcdC8vIHB1dCBqdXN0IHRoZSBkYXkgbnVtYmVycyB3aWxsIGJlIGluIGVhY2ggY2VsbFxuXHRcdGlmICh0aGlzLnJvd0NudCA+IDEgfHwgdGhpcy5jb2xDbnQgPiAxMCkge1xuXHRcdFx0cmV0dXJuICdkZGQnOyAvLyBcIlNhdFwiXG5cdFx0fVxuXHRcdC8vIG11bHRpcGxlIGRheXMsIHNvIGZ1bGwgc2luZ2xlIGRhdGUgc3RyaW5nIFdPTidUIGJlIGluIHRpdGxlIHRleHRcblx0XHRlbHNlIGlmICh0aGlzLmNvbENudCA+IDEpIHtcblx0XHRcdHJldHVybiB0aGlzLnZpZXcub3B0KCdkYXlPZk1vbnRoRm9ybWF0Jyk7IC8vIFwiU2F0IDEyLzEwXCJcblx0XHR9XG5cdFx0Ly8gc2luZ2xlIGRheSwgc28gZnVsbCBzaW5nbGUgZGF0ZSBzdHJpbmcgd2lsbCBwcm9iYWJseSBiZSBpbiB0aXRsZSB0ZXh0XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gJ2RkZGQnOyAvLyBcIlNhdHVyZGF5XCJcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBTbGljaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBTbGljZXMgdXAgYSBkYXRlIHJhbmdlIGludG8gYSBzZWdtZW50IGZvciBldmVyeSB3ZWVrLXJvdyBpdCBpbnRlcnNlY3RzIHdpdGhcblx0c2xpY2VSYW5nZUJ5Um93OiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdHZhciBkYXlzUGVyUm93ID0gdGhpcy5kYXlzUGVyUm93O1xuXHRcdHZhciBub3JtYWxSYW5nZSA9IHRoaXMudmlldy5jb21wdXRlRGF5UmFuZ2UocmFuZ2UpOyAvLyBtYWtlIHdob2xlLWRheSByYW5nZSwgY29uc2lkZXJpbmcgbmV4dERheVRocmVzaG9sZFxuXHRcdHZhciByYW5nZUZpcnN0ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgobm9ybWFsUmFuZ2Uuc3RhcnQpOyAvLyBpbmNsdXNpdmUgZmlyc3QgaW5kZXhcblx0XHR2YXIgcmFuZ2VMYXN0ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgobm9ybWFsUmFuZ2UuZW5kLmNsb25lKCkuc3VidHJhY3QoMSwgJ2RheXMnKSk7IC8vIGluY2x1c2l2ZSBsYXN0IGluZGV4XG5cdFx0dmFyIHNlZ3MgPSBbXTtcblx0XHR2YXIgcm93O1xuXHRcdHZhciByb3dGaXJzdCwgcm93TGFzdDsgLy8gaW5jbHVzaXZlIGRheS1pbmRleCByYW5nZSBmb3IgY3VycmVudCByb3dcblx0XHR2YXIgc2VnRmlyc3QsIHNlZ0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIHNlZ21lbnRcblxuXHRcdGZvciAocm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdysrKSB7XG5cdFx0XHRyb3dGaXJzdCA9IHJvdyAqIGRheXNQZXJSb3c7XG5cdFx0XHRyb3dMYXN0ID0gcm93Rmlyc3QgKyBkYXlzUGVyUm93IC0gMTtcblxuXHRcdFx0Ly8gaW50ZXJzZWN0IHNlZ21lbnQncyBvZmZzZXQgcmFuZ2Ugd2l0aCB0aGUgcm93J3Ncblx0XHRcdHNlZ0ZpcnN0ID0gTWF0aC5tYXgocmFuZ2VGaXJzdCwgcm93Rmlyc3QpO1xuXHRcdFx0c2VnTGFzdCA9IE1hdGgubWluKHJhbmdlTGFzdCwgcm93TGFzdCk7XG5cblx0XHRcdC8vIGRlYWwgd2l0aCBpbi1iZXR3ZWVuIGluZGljZXNcblx0XHRcdHNlZ0ZpcnN0ID0gTWF0aC5jZWlsKHNlZ0ZpcnN0KTsgLy8gaW4tYmV0d2VlbiBzdGFydHMgcm91bmQgdG8gbmV4dCBjZWxsXG5cdFx0XHRzZWdMYXN0ID0gTWF0aC5mbG9vcihzZWdMYXN0KTsgLy8gaW4tYmV0d2VlbiBlbmRzIHJvdW5kIHRvIHByZXYgY2VsbFxuXG5cdFx0XHRpZiAoc2VnRmlyc3QgPD0gc2VnTGFzdCkgeyAvLyB3YXMgdGhlcmUgYW55IGludGVyc2VjdGlvbiB3aXRoIHRoZSBjdXJyZW50IHJvdz9cblx0XHRcdFx0c2Vncy5wdXNoKHtcblx0XHRcdFx0XHRyb3c6IHJvdyxcblxuXHRcdFx0XHRcdC8vIG5vcm1hbGl6ZSB0byBzdGFydCBvZiByb3dcblx0XHRcdFx0XHRmaXJzdFJvd0RheUluZGV4OiBzZWdGaXJzdCAtIHJvd0ZpcnN0LFxuXHRcdFx0XHRcdGxhc3RSb3dEYXlJbmRleDogc2VnTGFzdCAtIHJvd0ZpcnN0LFxuXG5cdFx0XHRcdFx0Ly8gbXVzdCBiZSBtYXRjaGluZyBpbnRlZ2VycyB0byBiZSB0aGUgc2VnbWVudCdzIHN0YXJ0L2VuZFxuXHRcdFx0XHRcdGlzU3RhcnQ6IHNlZ0ZpcnN0ID09PSByYW5nZUZpcnN0LFxuXHRcdFx0XHRcdGlzRW5kOiBzZWdMYXN0ID09PSByYW5nZUxhc3Rcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblxuXHQvLyBTbGljZXMgdXAgYSBkYXRlIHJhbmdlIGludG8gYSBzZWdtZW50IGZvciBldmVyeSBkYXktY2VsbCBpdCBpbnRlcnNlY3RzIHdpdGguXG5cdC8vIFRPRE86IG1ha2UgbW9yZSBEUlkgd2l0aCBzbGljZVJhbmdlQnlSb3cgc29tZWhvdy5cblx0c2xpY2VSYW5nZUJ5RGF5OiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdHZhciBkYXlzUGVyUm93ID0gdGhpcy5kYXlzUGVyUm93O1xuXHRcdHZhciBub3JtYWxSYW5nZSA9IHRoaXMudmlldy5jb21wdXRlRGF5UmFuZ2UocmFuZ2UpOyAvLyBtYWtlIHdob2xlLWRheSByYW5nZSwgY29uc2lkZXJpbmcgbmV4dERheVRocmVzaG9sZFxuXHRcdHZhciByYW5nZUZpcnN0ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgobm9ybWFsUmFuZ2Uuc3RhcnQpOyAvLyBpbmNsdXNpdmUgZmlyc3QgaW5kZXhcblx0XHR2YXIgcmFuZ2VMYXN0ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgobm9ybWFsUmFuZ2UuZW5kLmNsb25lKCkuc3VidHJhY3QoMSwgJ2RheXMnKSk7IC8vIGluY2x1c2l2ZSBsYXN0IGluZGV4XG5cdFx0dmFyIHNlZ3MgPSBbXTtcblx0XHR2YXIgcm93O1xuXHRcdHZhciByb3dGaXJzdCwgcm93TGFzdDsgLy8gaW5jbHVzaXZlIGRheS1pbmRleCByYW5nZSBmb3IgY3VycmVudCByb3dcblx0XHR2YXIgaTtcblx0XHR2YXIgc2VnRmlyc3QsIHNlZ0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIHNlZ21lbnRcblxuXHRcdGZvciAocm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdysrKSB7XG5cdFx0XHRyb3dGaXJzdCA9IHJvdyAqIGRheXNQZXJSb3c7XG5cdFx0XHRyb3dMYXN0ID0gcm93Rmlyc3QgKyBkYXlzUGVyUm93IC0gMTtcblxuXHRcdFx0Zm9yIChpID0gcm93Rmlyc3Q7IGkgPD0gcm93TGFzdDsgaSsrKSB7XG5cblx0XHRcdFx0Ly8gaW50ZXJzZWN0IHNlZ21lbnQncyBvZmZzZXQgcmFuZ2Ugd2l0aCB0aGUgcm93J3Ncblx0XHRcdFx0c2VnRmlyc3QgPSBNYXRoLm1heChyYW5nZUZpcnN0LCBpKTtcblx0XHRcdFx0c2VnTGFzdCA9IE1hdGgubWluKHJhbmdlTGFzdCwgaSk7XG5cblx0XHRcdFx0Ly8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xuXHRcdFx0XHRzZWdGaXJzdCA9IE1hdGguY2VpbChzZWdGaXJzdCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxuXHRcdFx0XHRzZWdMYXN0ID0gTWF0aC5mbG9vcihzZWdMYXN0KTsgLy8gaW4tYmV0d2VlbiBlbmRzIHJvdW5kIHRvIHByZXYgY2VsbFxuXG5cdFx0XHRcdGlmIChzZWdGaXJzdCA8PSBzZWdMYXN0KSB7IC8vIHdhcyB0aGVyZSBhbnkgaW50ZXJzZWN0aW9uIHdpdGggdGhlIGN1cnJlbnQgcm93P1xuXHRcdFx0XHRcdHNlZ3MucHVzaCh7XG5cdFx0XHRcdFx0XHRyb3c6IHJvdyxcblxuXHRcdFx0XHRcdFx0Ly8gbm9ybWFsaXplIHRvIHN0YXJ0IG9mIHJvd1xuXHRcdFx0XHRcdFx0Zmlyc3RSb3dEYXlJbmRleDogc2VnRmlyc3QgLSByb3dGaXJzdCxcblx0XHRcdFx0XHRcdGxhc3RSb3dEYXlJbmRleDogc2VnTGFzdCAtIHJvd0ZpcnN0LFxuXG5cdFx0XHRcdFx0XHQvLyBtdXN0IGJlIG1hdGNoaW5nIGludGVnZXJzIHRvIGJlIHRoZSBzZWdtZW50J3Mgc3RhcnQvZW5kXG5cdFx0XHRcdFx0XHRpc1N0YXJ0OiBzZWdGaXJzdCA9PT0gcmFuZ2VGaXJzdCxcblx0XHRcdFx0XHRcdGlzRW5kOiBzZWdMYXN0ID09PSByYW5nZUxhc3Rcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0LyogSGVhZGVyIFJlbmRlcmluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVySGVhZEh0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0cmV0dXJuICcnICtcblx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtcm93ICcgKyB2aWV3LndpZGdldEhlYWRlckNsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHQnPHRhYmxlPicgK1xuXHRcdFx0XHRcdCc8dGhlYWQ+JyArXG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlckhlYWRUckh0bWwoKSArXG5cdFx0XHRcdFx0JzwvdGhlYWQ+JyArXG5cdFx0XHRcdCc8L3RhYmxlPicgK1xuXHRcdFx0JzwvZGl2Pic7XG5cdH0sXG5cblxuXHRyZW5kZXJIZWFkSW50cm9IdG1sOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJJbnRyb0h0bWwoKTsgLy8gZmFsbCBiYWNrIHRvIGdlbmVyaWNcblx0fSxcblxuXG5cdHJlbmRlckhlYWRUckh0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAnJyArXG5cdFx0XHQnPHRyPicgK1xuXHRcdFx0XHQodGhpcy5pc1JUTCA/ICcnIDogdGhpcy5yZW5kZXJIZWFkSW50cm9IdG1sKCkpICtcblx0XHRcdFx0dGhpcy5yZW5kZXJIZWFkRGF0ZUNlbGxzSHRtbCgpICtcblx0XHRcdFx0KHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlckhlYWRJbnRyb0h0bWwoKSA6ICcnKSArXG5cdFx0XHQnPC90cj4nO1xuXHR9LFxuXG5cblx0cmVuZGVySGVhZERhdGVDZWxsc0h0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBodG1scyA9IFtdO1xuXHRcdHZhciBjb2wsIGRhdGU7XG5cblx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xuXHRcdFx0ZGF0ZSA9IHRoaXMuZ2V0Q2VsbERhdGUoMCwgY29sKTtcblx0XHRcdGh0bWxzLnB1c2godGhpcy5yZW5kZXJIZWFkRGF0ZUNlbGxIdG1sKGRhdGUpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaHRtbHMuam9pbignJyk7XG5cdH0sXG5cblxuXHQvLyBUT0RPOiB3aGVuIGludGVybmFsQXBpVmVyc2lvbiwgYWNjZXB0IGFuIG9iamVjdCBmb3IgSFRNTCBhdHRyaWJ1dGVzXG5cdC8vIChjb2xzcGFuIHNob3VsZCBiZSBubyBkaWZmZXJlbnQpXG5cdHJlbmRlckhlYWREYXRlQ2VsbEh0bWw6IGZ1bmN0aW9uKGRhdGUsIGNvbHNwYW4sIG90aGVyQXR0cnMpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgaXNEYXRlVmFsaWQgPSBpc0RhdGVXaXRoaW5SYW5nZShkYXRlLCB2aWV3LmFjdGl2ZVJhbmdlKTsgLy8gVE9ETzogY2FsbGVkIHRvbyBmcmVxdWVudGx5LiBjYWNoZSBzb21laG93LlxuXHRcdHZhciBjbGFzc05hbWVzID0gW1xuXHRcdFx0J2ZjLWRheS1oZWFkZXInLFxuXHRcdFx0dmlldy53aWRnZXRIZWFkZXJDbGFzc1xuXHRcdF07XG5cdFx0dmFyIGlubmVySHRtbCA9IGh0bWxFc2NhcGUoZGF0ZS5mb3JtYXQodGhpcy5jb2xIZWFkRm9ybWF0KSk7XG5cblx0XHQvLyBpZiBvbmx5IG9uZSByb3cgb2YgZGF5cywgdGhlIGNsYXNzTmFtZXMgb24gdGhlIGhlYWRlciBjYW4gcmVwcmVzZW50IHRoZSBzcGVjaWZpYyBkYXlzIGJlbmVhdGhcblx0XHRpZiAodGhpcy5yb3dDbnQgPT09IDEpIHtcblx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzLmNvbmNhdChcblx0XHRcdFx0Ly8gaW5jbHVkZXMgdGhlIGRheS1vZi13ZWVrIGNsYXNzXG5cdFx0XHRcdC8vIG5vVGhlbWVIaWdobGlnaHQ9dHJ1ZSAoZG9uJ3QgaGlnaGxpZ2h0IHRoZSBoZWFkZXIpXG5cdFx0XHRcdHRoaXMuZ2V0RGF5Q2xhc3NlcyhkYXRlLCB0cnVlKVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRjbGFzc05hbWVzLnB1c2goJ2ZjLScgKyBkYXlJRHNbZGF0ZS5kYXkoKV0pOyAvLyBvbmx5IGFkZCB0aGUgZGF5LW9mLXdlZWsgY2xhc3Ncblx0XHR9XG5cblx0XHRyZXR1cm4gJycgK1xuICAgICAgICAgICAgJzx0aCBjbGFzcz1cIicgKyBjbGFzc05hbWVzLmpvaW4oJyAnKSArICdcIicgK1xuXHRcdFx0XHQoKGlzRGF0ZVZhbGlkICYmIHRoaXMucm93Q250KSA9PT0gMSA/XG5cdFx0XHRcdFx0JyBkYXRhLWRhdGU9XCInICsgZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSArICdcIicgOlxuXHRcdFx0XHRcdCcnKSArXG5cdFx0XHRcdChjb2xzcGFuID4gMSA/XG5cdFx0XHRcdFx0JyBjb2xzcGFuPVwiJyArIGNvbHNwYW4gKyAnXCInIDpcblx0XHRcdFx0XHQnJykgK1xuXHRcdFx0XHQob3RoZXJBdHRycyA/XG5cdFx0XHRcdFx0JyAnICsgb3RoZXJBdHRycyA6XG5cdFx0XHRcdFx0JycpICtcblx0XHRcdFx0Jz4nICtcblx0XHRcdFx0KGlzRGF0ZVZhbGlkID9cblx0XHRcdFx0XHQvLyBkb24ndCBtYWtlIGEgbGluayBpZiB0aGUgaGVhZGluZyBjb3VsZCByZXByZXNlbnQgbXVsdGlwbGUgZGF5cywgb3IgaWYgdGhlcmUncyBvbmx5IG9uZSBkYXkgKGZvcmNlT2ZmKVxuXHRcdFx0XHRcdHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbChcblx0XHRcdFx0XHRcdHsgZGF0ZTogZGF0ZSwgZm9yY2VPZmY6IHRoaXMucm93Q250ID4gMSB8fCB0aGlzLmNvbENudCA9PT0gMSB9LFxuXHRcdFx0XHRcdFx0aW5uZXJIdG1sXG5cdFx0XHRcdFx0KSA6XG5cdFx0XHRcdFx0Ly8gaWYgbm90IHZhbGlkLCBkaXNwbGF5IHRleHQsIGJ1dCBubyBsaW5rXG5cdFx0XHRcdFx0aW5uZXJIdG1sXG5cdFx0XHRcdCkgK1xuXHRcdFx0JzwvdGg+Jztcblx0fSxcblxuXG5cdC8qIEJhY2tncm91bmQgUmVuZGVyaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJCZ1RySHRtbDogZnVuY3Rpb24ocm93KSB7XG5cdFx0cmV0dXJuICcnICtcblx0XHRcdCc8dHI+JyArXG5cdFx0XHRcdCh0aGlzLmlzUlRMID8gJycgOiB0aGlzLnJlbmRlckJnSW50cm9IdG1sKHJvdykpICtcblx0XHRcdFx0dGhpcy5yZW5kZXJCZ0NlbGxzSHRtbChyb3cpICtcblx0XHRcdFx0KHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlckJnSW50cm9IdG1sKHJvdykgOiAnJykgK1xuXHRcdFx0JzwvdHI+Jztcblx0fSxcblxuXG5cdHJlbmRlckJnSW50cm9IdG1sOiBmdW5jdGlvbihyb3cpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJJbnRyb0h0bWwoKTsgLy8gZmFsbCBiYWNrIHRvIGdlbmVyaWNcblx0fSxcblxuXG5cdHJlbmRlckJnQ2VsbHNIdG1sOiBmdW5jdGlvbihyb3cpIHtcblx0XHR2YXIgaHRtbHMgPSBbXTtcblx0XHR2YXIgY29sLCBkYXRlO1xuXG5cdFx0Zm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcblx0XHRcdGRhdGUgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKTtcblx0XHRcdGh0bWxzLnB1c2godGhpcy5yZW5kZXJCZ0NlbGxIdG1sKGRhdGUpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaHRtbHMuam9pbignJyk7XG5cdH0sXG5cblxuXHRyZW5kZXJCZ0NlbGxIdG1sOiBmdW5jdGlvbihkYXRlLCBvdGhlckF0dHJzKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGlzRGF0ZVZhbGlkID0gaXNEYXRlV2l0aGluUmFuZ2UoZGF0ZSwgdmlldy5hY3RpdmVSYW5nZSk7IC8vIFRPRE86IGNhbGxlZCB0b28gZnJlcXVlbnRseS4gY2FjaGUgc29tZWhvdy5cblx0XHR2YXIgY2xhc3NlcyA9IHRoaXMuZ2V0RGF5Q2xhc3NlcyhkYXRlKTtcblxuXHRcdGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5Jywgdmlldy53aWRnZXRDb250ZW50Q2xhc3MpO1xuXG5cdFx0cmV0dXJuICc8dGQgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcblx0XHRcdChpc0RhdGVWYWxpZCA/XG5cdFx0XHRcdCcgZGF0YS1kYXRlPVwiJyArIGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykgKyAnXCInIDogLy8gaWYgZGF0ZSBoYXMgYSB0aW1lLCB3b24ndCBmb3JtYXQgaXRcblx0XHRcdFx0JycpICtcblx0XHRcdChvdGhlckF0dHJzID9cblx0XHRcdFx0JyAnICsgb3RoZXJBdHRycyA6XG5cdFx0XHRcdCcnKSArXG5cdFx0XHQnPjwvdGQ+Jztcblx0fSxcblxuXG5cdC8qIEdlbmVyaWNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgZGVmYXVsdCBIVE1MIGludHJvIGZvciBhbnkgcm93LiBVc2VyIGNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG5cdHJlbmRlckludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdH0sXG5cblxuXHQvLyBUT0RPOiBhIGdlbmVyaWMgbWV0aG9kIGZvciBkZWFsaW5nIHdpdGggPHRyPiwgUlRMLCBpbnRyb1xuXHQvLyB3aGVuIGluY3JlbWVudCBpbnRlcm5hbEFwaVZlcnNpb25cblx0Ly8gd3JhcFRyIChzY2hlZHVsZXIpXG5cblxuXHQvKiBVdGlsc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQXBwbGllcyB0aGUgZ2VuZXJpYyBcImludHJvXCIgYW5kIFwib3V0cm9cIiBIVE1MIHRvIHRoZSBnaXZlbiBjZWxscy5cblx0Ly8gSW50cm8gbWVhbnMgdGhlIGxlZnRtb3N0IGNlbGwgd2hlbiB0aGUgY2FsZW5kYXIgaXMgTFRSIGFuZCB0aGUgcmlnaHRtb3N0IGNlbGwgd2hlbiBSVEwuIFZpY2UtdmVyc2EgZm9yIG91dHJvLlxuXHRib29rZW5kQ2VsbHM6IGZ1bmN0aW9uKHRyRWwpIHtcblx0XHR2YXIgaW50cm9IdG1sID0gdGhpcy5yZW5kZXJJbnRyb0h0bWwoKTtcblxuXHRcdGlmIChpbnRyb0h0bWwpIHtcblx0XHRcdGlmICh0aGlzLmlzUlRMKSB7XG5cdFx0XHRcdHRyRWwuYXBwZW5kKGludHJvSHRtbCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dHJFbC5wcmVwZW5kKGludHJvSHRtbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbn07XG5cbjs7XG5cbi8qIEEgY29tcG9uZW50IHRoYXQgcmVuZGVycyBhIGdyaWQgb2Ygd2hvbGUtZGF5cyB0aGF0IHJ1bnMgaG9yaXpvbnRhbGx5LiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgcm93cywgb25lIHBlciB3ZWVrLlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbnZhciBEYXlHcmlkID0gRkMuRGF5R3JpZCA9IEdyaWQuZXh0ZW5kKERheVRhYmxlTWl4aW4sIHtcblxuXHRudW1iZXJzVmlzaWJsZTogZmFsc2UsIC8vIHNob3VsZCByZW5kZXIgYSByb3cgZm9yIGRheS93ZWVrIG51bWJlcnM/IHNldCBieSBvdXRzaWRlIHZpZXcuIFRPRE86IG1ha2UgaW50ZXJuYWxcblx0Ym90dG9tQ29vcmRQYWRkaW5nOiAwLCAvLyBoYWNrIGZvciBleHRlbmRpbmcgdGhlIGhpdCBhcmVhIGZvciB0aGUgbGFzdCByb3cgb2YgdGhlIGNvb3JkaW5hdGUgZ3JpZFxuXG5cdHJvd0VsczogbnVsbCwgLy8gc2V0IG9mIGZha2Ugcm93IGVsZW1lbnRzXG5cdGNlbGxFbHM6IG51bGwsIC8vIHNldCBvZiB3aG9sZS1kYXkgZWxlbWVudHMgY29tcHJpc2luZyB0aGUgcm93J3MgYmFja2dyb3VuZFxuXHRoZWxwZXJFbHM6IG51bGwsIC8vIHNldCBvZiBjZWxsIHNrZWxldG9uIGVsZW1lbnRzIGZvciByZW5kZXJpbmcgdGhlIG1vY2sgZXZlbnQgXCJoZWxwZXJcIlxuXG5cdHJvd0Nvb3JkQ2FjaGU6IG51bGwsXG5cdGNvbENvb3JkQ2FjaGU6IG51bGwsXG5cblxuXHQvLyBSZW5kZXJzIHRoZSByb3dzIGFuZCBjb2x1bW5zIGludG8gdGhlIGNvbXBvbmVudCdzIGB0aGlzLmVsYCwgd2hpY2ggc2hvdWxkIGFscmVhZHkgYmUgYXNzaWduZWQuXG5cdC8vIGlzUmlnaWQgZGV0ZXJtaW5zIHdoZXRoZXIgdGhlIGluZGl2aWR1YWwgcm93cyBzaG91bGQgaWdub3JlIHRoZSBjb250ZW50cyBhbmQgYmUgYSBjb25zdGFudCBoZWlnaHQuXG5cdC8vIFJlbGllcyBvbiB0aGUgdmlldydzIGNvbENudCBhbmQgcm93Q250LiBJbiB0aGUgZnV0dXJlLCB0aGlzIGNvbXBvbmVudCBzaG91bGQgcHJvYmFibHkgYmUgc2VsZi1zdWZmaWNpZW50LlxuXHRyZW5kZXJEYXRlczogZnVuY3Rpb24oaXNSaWdpZCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciByb3dDbnQgPSB0aGlzLnJvd0NudDtcblx0XHR2YXIgY29sQ250ID0gdGhpcy5jb2xDbnQ7XG5cdFx0dmFyIGh0bWwgPSAnJztcblx0XHR2YXIgcm93O1xuXHRcdHZhciBjb2w7XG5cblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd0NudDsgcm93KyspIHtcblx0XHRcdGh0bWwgKz0gdGhpcy5yZW5kZXJEYXlSb3dIdG1sKHJvdywgaXNSaWdpZCk7XG5cdFx0fVxuXHRcdHRoaXMuZWwuaHRtbChodG1sKTtcblxuXHRcdHRoaXMucm93RWxzID0gdGhpcy5lbC5maW5kKCcuZmMtcm93Jyk7XG5cdFx0dGhpcy5jZWxsRWxzID0gdGhpcy5lbC5maW5kKCcuZmMtZGF5LCAuZmMtZGlzYWJsZWQtZGF5Jyk7XG5cblx0XHR0aGlzLnJvd0Nvb3JkQ2FjaGUgPSBuZXcgQ29vcmRDYWNoZSh7XG5cdFx0XHRlbHM6IHRoaXMucm93RWxzLFxuXHRcdFx0aXNWZXJ0aWNhbDogdHJ1ZVxuXHRcdH0pO1xuXHRcdHRoaXMuY29sQ29vcmRDYWNoZSA9IG5ldyBDb29yZENhY2hlKHtcblx0XHRcdGVsczogdGhpcy5jZWxsRWxzLnNsaWNlKDAsIHRoaXMuY29sQ250KSwgLy8gb25seSB0aGUgZmlyc3Qgcm93XG5cdFx0XHRpc0hvcml6b250YWw6IHRydWVcblx0XHR9KTtcblxuXHRcdC8vIHRyaWdnZXIgZGF5UmVuZGVyIHdpdGggZWFjaCBjZWxsJ3MgZWxlbWVudFxuXHRcdGZvciAocm93ID0gMDsgcm93IDwgcm93Q250OyByb3crKykge1xuXHRcdFx0Zm9yIChjb2wgPSAwOyBjb2wgPCBjb2xDbnQ7IGNvbCsrKSB7XG5cdFx0XHRcdHZpZXcucHVibGljbHlUcmlnZ2VyKFxuXHRcdFx0XHRcdCdkYXlSZW5kZXInLFxuXHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0dGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCksXG5cdFx0XHRcdFx0dGhpcy5nZXRDZWxsRWwocm93LCBjb2wpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0dW5yZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW1vdmVTZWdQb3BvdmVyKCk7XG5cdH0sXG5cblxuXHRyZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VncyA9IHRoaXMuYnVpbGRCdXNpbmVzc0hvdXJTZWdzKHRydWUpOyAvLyB3aG9sZURheT10cnVlXG5cdFx0dGhpcy5yZW5kZXJGaWxsKCdidXNpbmVzc0hvdXJzJywgc2VncywgJ2JnZXZlbnQnKTtcblx0fSxcblxuXG5cdHVucmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckZpbGwoJ2J1c2luZXNzSG91cnMnKTtcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgYSBzaW5nbGUgcm93LCB3aGljaCBpcyBhIGRpdiB0aGF0IHdyYXBzIGEgdGFibGUuXG5cdC8vIGByb3dgIGlzIHRoZSByb3cgbnVtYmVyLlxuXHRyZW5kZXJEYXlSb3dIdG1sOiBmdW5jdGlvbihyb3csIGlzUmlnaWQpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgY2xhc3NlcyA9IFsgJ2ZjLXJvdycsICdmYy13ZWVrJywgdmlldy53aWRnZXRDb250ZW50Q2xhc3MgXTtcblxuXHRcdGlmIChpc1JpZ2lkKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2ZjLXJpZ2lkJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICcnICtcblx0XHRcdCc8ZGl2IGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiPicgK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWJnXCI+JyArXG5cdFx0XHRcdFx0Jzx0YWJsZT4nICtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyQmdUckh0bWwocm93KSArXG5cdFx0XHRcdFx0JzwvdGFibGU+JyArXG5cdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1jb250ZW50LXNrZWxldG9uXCI+JyArXG5cdFx0XHRcdFx0Jzx0YWJsZT4nICtcblx0XHRcdFx0XHRcdCh0aGlzLm51bWJlcnNWaXNpYmxlID9cblx0XHRcdFx0XHRcdFx0Jzx0aGVhZD4nICtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnJlbmRlck51bWJlclRySHRtbChyb3cpICtcblx0XHRcdFx0XHRcdFx0JzwvdGhlYWQ+JyA6XG5cdFx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHRcdCkgK1xuXHRcdFx0XHRcdCc8L3RhYmxlPicgK1xuXHRcdFx0XHQnPC9kaXY+JyArXG5cdFx0XHQnPC9kaXY+Jztcblx0fSxcblxuXG5cdC8qIEdyaWQgTnVtYmVyIFJlbmRlcmluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyTnVtYmVyVHJIdG1sOiBmdW5jdGlvbihyb3cpIHtcblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0Jzx0cj4nICtcblx0XHRcdFx0KHRoaXMuaXNSVEwgPyAnJyA6IHRoaXMucmVuZGVyTnVtYmVySW50cm9IdG1sKHJvdykpICtcblx0XHRcdFx0dGhpcy5yZW5kZXJOdW1iZXJDZWxsc0h0bWwocm93KSArXG5cdFx0XHRcdCh0aGlzLmlzUlRMID8gdGhpcy5yZW5kZXJOdW1iZXJJbnRyb0h0bWwocm93KSA6ICcnKSArXG5cdFx0XHQnPC90cj4nO1xuXHR9LFxuXG5cblx0cmVuZGVyTnVtYmVySW50cm9IdG1sOiBmdW5jdGlvbihyb3cpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJJbnRyb0h0bWwoKTtcblx0fSxcblxuXG5cdHJlbmRlck51bWJlckNlbGxzSHRtbDogZnVuY3Rpb24ocm93KSB7XG5cdFx0dmFyIGh0bWxzID0gW107XG5cdFx0dmFyIGNvbCwgZGF0ZTtcblxuXHRcdGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCsrKSB7XG5cdFx0XHRkYXRlID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XG5cdFx0XHRodG1scy5wdXNoKHRoaXMucmVuZGVyTnVtYmVyQ2VsbEh0bWwoZGF0ZSkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBodG1scy5qb2luKCcnKTtcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIDx0ZD5zIG9mIHRoZSBcIm51bWJlclwiIHJvdyBpbiB0aGUgRGF5R3JpZCdzIGNvbnRlbnQgc2tlbGV0b24uXG5cdC8vIFRoZSBudW1iZXIgcm93IHdpbGwgb25seSBleGlzdCBpZiBlaXRoZXIgZGF5IG51bWJlcnMgb3Igd2VlayBudW1iZXJzIGFyZSB0dXJuZWQgb24uXG5cdHJlbmRlck51bWJlckNlbGxIdG1sOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGh0bWwgPSAnJztcblx0XHR2YXIgaXNEYXRlVmFsaWQgPSBpc0RhdGVXaXRoaW5SYW5nZShkYXRlLCB2aWV3LmFjdGl2ZVJhbmdlKTsgLy8gVE9ETzogY2FsbGVkIHRvbyBmcmVxdWVudGx5LiBjYWNoZSBzb21laG93LlxuXHRcdHZhciBpc0RheU51bWJlclZpc2libGUgPSB2aWV3LmRheU51bWJlcnNWaXNpYmxlICYmIGlzRGF0ZVZhbGlkO1xuXHRcdHZhciBjbGFzc2VzO1xuXHRcdHZhciB3ZWVrQ2FsY0ZpcnN0RG9XO1xuXG5cdFx0aWYgKCFpc0RheU51bWJlclZpc2libGUgJiYgIXZpZXcuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xuXHRcdFx0Ly8gbm8gbnVtYmVycyBpbiBkYXkgY2VsbCAod2VlayBudW1iZXIgbXVzdCBiZSBhbG9uZyB0aGUgc2lkZSlcblx0XHRcdHJldHVybiAnPHRkLz4nOyAvLyAgd2lsbCBjcmVhdGUgYW4gZW1wdHkgc3BhY2UgYWJvdmUgZXZlbnRzIDooXG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IHRoaXMuZ2V0RGF5Q2xhc3NlcyhkYXRlKTtcblx0XHRjbGFzc2VzLnVuc2hpZnQoJ2ZjLWRheS10b3AnKTtcblxuXHRcdGlmICh2aWV3LmNlbGxXZWVrTnVtYmVyc1Zpc2libGUpIHtcblx0XHRcdC8vIFRvIGRldGVybWluZSB0aGUgZGF5IG9mIHdlZWsgbnVtYmVyIGNoYW5nZSB1bmRlciBJU08sIHdlIGNhbm5vdFxuXHRcdFx0Ly8gcmVseSBvbiBtb21lbnQuanMgbWV0aG9kcyBzdWNoIGFzIGZpcnN0RGF5T2ZXZWVrKCkgb3Igd2Vla2RheSgpLFxuXHRcdFx0Ly8gYmVjYXVzZSB0aGV5IHJlbHkgb24gdGhlIGxvY2FsZSdzIGRvdyAocG9zc2libHkgb3ZlcnJpZGRlbiBieVxuXHRcdFx0Ly8gb3VyIGZpcnN0RGF5IG9wdGlvbiksIHdoaWNoIG1heSBub3QgYmUgTW9uZGF5LiBXZSBjYW5ub3QgY2hhbmdlXG5cdFx0XHQvLyBkb3csIGJlY2F1c2UgdGhhdCB3b3VsZCBhZmZlY3QgdGhlIGNhbGVuZGFyIHN0YXJ0IGRheSBhcyB3ZWxsLlxuXHRcdFx0aWYgKGRhdGUuX2xvY2FsZS5fZnVsbENhbGVuZGFyX3dlZWtDYWxjID09PSAnSVNPJykge1xuXHRcdFx0XHR3ZWVrQ2FsY0ZpcnN0RG9XID0gMTsgIC8vIE1vbmRheSBieSBJU08gODYwMSBkZWZpbml0aW9uXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0d2Vla0NhbGNGaXJzdERvVyA9IGRhdGUuX2xvY2FsZS5maXJzdERheU9mV2VlaygpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGh0bWwgKz0gJzx0ZCBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xuXHRcdFx0KGlzRGF0ZVZhbGlkID9cblx0XHRcdFx0JyBkYXRhLWRhdGU9XCInICsgZGF0ZS5mb3JtYXQoKSArICdcIicgOlxuXHRcdFx0XHQnJ1xuXHRcdFx0XHQpICtcblx0XHRcdCc+JztcblxuXHRcdGlmICh2aWV3LmNlbGxXZWVrTnVtYmVyc1Zpc2libGUgJiYgKGRhdGUuZGF5KCkgPT0gd2Vla0NhbGNGaXJzdERvVykpIHtcblx0XHRcdGh0bWwgKz0gdmlldy5idWlsZEdvdG9BbmNob3JIdG1sKFxuXHRcdFx0XHR7IGRhdGU6IGRhdGUsIHR5cGU6ICd3ZWVrJyB9LFxuXHRcdFx0XHR7ICdjbGFzcyc6ICdmYy13ZWVrLW51bWJlcicgfSxcblx0XHRcdFx0ZGF0ZS5mb3JtYXQoJ3cnKSAvLyBpbm5lciBIVE1MXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChpc0RheU51bWJlclZpc2libGUpIHtcblx0XHRcdGh0bWwgKz0gdmlldy5idWlsZEdvdG9BbmNob3JIdG1sKFxuXHRcdFx0XHRkYXRlLFxuXHRcdFx0XHR7ICdjbGFzcyc6ICdmYy1kYXktbnVtYmVyJyB9LFxuXHRcdFx0XHRkYXRlLmRhdGUoKSAvLyBpbm5lciBIVE1MXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGh0bWwgKz0gJzwvdGQ+JztcblxuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cblx0LyogT3B0aW9uc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ29tcHV0ZXMgYSBkZWZhdWx0IGV2ZW50IHRpbWUgZm9ybWF0dGluZyBzdHJpbmcgaWYgYHRpbWVGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcblx0Y29tcHV0ZUV2ZW50VGltZUZvcm1hdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudmlldy5vcHQoJ2V4dHJhU21hbGxUaW1lRm9ybWF0Jyk7IC8vIGxpa2UgXCI2cFwiIG9yIFwiNjozMHBcIlxuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgYSBkZWZhdWx0IGBkaXNwbGF5RXZlbnRFbmRgIHZhbHVlIGlmIG9uZSBpcyBub3QgZXhwbGljbHR5IGRlZmluZWRcblx0Y29tcHV0ZURpc3BsYXlFdmVudEVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29sQ250ID09IDE7IC8vIHdlJ2xsIGxpa2VseSBoYXZlIHNwYWNlIGlmIHRoZXJlJ3Mgb25seSBvbmUgZGF5XG5cdH0sXG5cblxuXHQvKiBEYXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmFuZ2VVcGRhdGVkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVwZGF0ZURheVRhYmxlKCk7XG5cdH0sXG5cblxuXHQvLyBTbGljZXMgdXAgdGhlIGdpdmVuIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIHdpdGggb3RoZXIgbWlzYyBkYXRhKSBpbnRvIGFuIGFycmF5IG9mIHNlZ21lbnRzXG5cdHNwYW5Ub1NlZ3M6IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHR2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZUJ5Um93KHNwYW4pO1xuXHRcdHZhciBpLCBzZWc7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnID0gc2Vnc1tpXTtcblx0XHRcdGlmICh0aGlzLmlzUlRMKSB7XG5cdFx0XHRcdHNlZy5sZWZ0Q29sID0gdGhpcy5kYXlzUGVyUm93IC0gMSAtIHNlZy5sYXN0Um93RGF5SW5kZXg7XG5cdFx0XHRcdHNlZy5yaWdodENvbCA9IHRoaXMuZGF5c1BlclJvdyAtIDEgLSBzZWcuZmlyc3RSb3dEYXlJbmRleDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzZWcubGVmdENvbCA9IHNlZy5maXJzdFJvd0RheUluZGV4O1xuXHRcdFx0XHRzZWcucmlnaHRDb2wgPSBzZWcubGFzdFJvd0RheUluZGV4O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0LyogSGl0IFN5c3RlbVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cHJlcGFyZUhpdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29sQ29vcmRDYWNoZS5idWlsZCgpO1xuXHRcdHRoaXMucm93Q29vcmRDYWNoZS5idWlsZCgpO1xuXHRcdHRoaXMucm93Q29vcmRDYWNoZS5ib3R0b21zW3RoaXMucm93Q250IC0gMV0gKz0gdGhpcy5ib3R0b21Db29yZFBhZGRpbmc7IC8vIGhhY2tcblx0fSxcblxuXG5cdHJlbGVhc2VIaXRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNvbENvb3JkQ2FjaGUuY2xlYXIoKTtcblx0XHR0aGlzLnJvd0Nvb3JkQ2FjaGUuY2xlYXIoKTtcblx0fSxcblxuXG5cdHF1ZXJ5SGl0OiBmdW5jdGlvbihsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpIHtcblx0XHRpZiAodGhpcy5jb2xDb29yZENhY2hlLmlzTGVmdEluQm91bmRzKGxlZnRPZmZzZXQpICYmIHRoaXMucm93Q29vcmRDYWNoZS5pc1RvcEluQm91bmRzKHRvcE9mZnNldCkpIHtcblx0XHRcdHZhciBjb2wgPSB0aGlzLmNvbENvb3JkQ2FjaGUuZ2V0SG9yaXpvbnRhbEluZGV4KGxlZnRPZmZzZXQpO1xuXHRcdFx0dmFyIHJvdyA9IHRoaXMucm93Q29vcmRDYWNoZS5nZXRWZXJ0aWNhbEluZGV4KHRvcE9mZnNldCk7XG5cblx0XHRcdGlmIChyb3cgIT0gbnVsbCAmJiBjb2wgIT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRDZWxsSGl0KHJvdywgY29sKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHRnZXRIaXRTcGFuOiBmdW5jdGlvbihoaXQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDZWxsUmFuZ2UoaGl0LnJvdywgaGl0LmNvbCk7XG5cdH0sXG5cblxuXHRnZXRIaXRFbDogZnVuY3Rpb24oaGl0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2VsbEVsKGhpdC5yb3csIGhpdC5jb2wpO1xuXHR9LFxuXG5cblx0LyogQ2VsbCBTeXN0ZW1cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0Ly8gRllJOiB0aGUgZmlyc3QgY29sdW1uIGlzIHRoZSBsZWZ0bW9zdCBjb2x1bW4sIHJlZ2FyZGxlc3Mgb2YgZGF0ZVxuXG5cblx0Z2V0Q2VsbEhpdDogZnVuY3Rpb24ocm93LCBjb2wpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cm93OiByb3csXG5cdFx0XHRjb2w6IGNvbCxcblx0XHRcdGNvbXBvbmVudDogdGhpcywgLy8gbmVlZGVkIHVuZm9ydHVuYXRlbHkgOihcblx0XHRcdGxlZnQ6IHRoaXMuY29sQ29vcmRDYWNoZS5nZXRMZWZ0T2Zmc2V0KGNvbCksXG5cdFx0XHRyaWdodDogdGhpcy5jb2xDb29yZENhY2hlLmdldFJpZ2h0T2Zmc2V0KGNvbCksXG5cdFx0XHR0b3A6IHRoaXMucm93Q29vcmRDYWNoZS5nZXRUb3BPZmZzZXQocm93KSxcblx0XHRcdGJvdHRvbTogdGhpcy5yb3dDb29yZENhY2hlLmdldEJvdHRvbU9mZnNldChyb3cpXG5cdFx0fTtcblx0fSxcblxuXG5cdGdldENlbGxFbDogZnVuY3Rpb24ocm93LCBjb2wpIHtcblx0XHRyZXR1cm4gdGhpcy5jZWxsRWxzLmVxKHJvdyAqIHRoaXMuY29sQ250ICsgY29sKTtcblx0fSxcblxuXG5cdC8qIEV2ZW50IERyYWcgVmlzdWFsaXphdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQvLyBUT0RPOiBtb3ZlIHRvIERheUdyaWQuZXZlbnQsIHNpbWlsYXIgdG8gd2hhdCB3ZSBkaWQgd2l0aCBHcmlkJ3MgZHJhZyBtZXRob2RzXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgb3IgZXh0ZXJuYWwgZWxlbWVudCBiZWluZyBkcmFnZ2VkLlxuXHQvLyBgZXZlbnRMb2NhdGlvbmAgaGFzIHpvbmVkIHN0YXJ0IGFuZCBlbmQgKG9wdGlvbmFsKVxuXHRyZW5kZXJEcmFnOiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBzZWcpIHtcblx0XHR2YXIgZXZlbnRTcGFucyA9IHRoaXMuZXZlbnRUb1NwYW5zKGV2ZW50TG9jYXRpb24pO1xuXHRcdHZhciBpO1xuXG5cdFx0Ly8gYWx3YXlzIHJlbmRlciBhIGhpZ2hsaWdodCB1bmRlcm5lYXRoXG5cdFx0Zm9yIChpID0gMDsgaSA8IGV2ZW50U3BhbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0KGV2ZW50U3BhbnNbaV0pO1xuXHRcdH1cblxuXHRcdC8vIGlmIGEgc2VnbWVudCBmcm9tIHRoZSBzYW1lIGNhbGVuZGFyIGJ1dCBhbm90aGVyIGNvbXBvbmVudCBpcyBiZWluZyBkcmFnZ2VkLCByZW5kZXIgYSBoZWxwZXIgZXZlbnRcblx0XHRpZiAoc2VnICYmIHNlZy5jb21wb25lbnQgIT09IHRoaXMpIHtcblx0XHRcdHJldHVybiB0aGlzLnJlbmRlckV2ZW50TG9jYXRpb25IZWxwZXIoZXZlbnRMb2NhdGlvbiwgc2VnKTsgLy8gcmV0dXJucyBtb2NrIGV2ZW50IGVsZW1lbnRzXG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIGhvdmVyaW5nIGV2ZW50XG5cdHVucmVuZGVyRHJhZzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xuXHRcdHRoaXMudW5yZW5kZXJIZWxwZXIoKTtcblx0fSxcblxuXG5cdC8qIEV2ZW50IFJlc2l6ZSBWaXN1YWxpemF0aW9uXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZFxuXHRyZW5kZXJFdmVudFJlc2l6ZTogZnVuY3Rpb24oZXZlbnRMb2NhdGlvbiwgc2VnKSB7XG5cdFx0dmFyIGV2ZW50U3BhbnMgPSB0aGlzLmV2ZW50VG9TcGFucyhldmVudExvY2F0aW9uKTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBldmVudFNwYW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLnJlbmRlckhpZ2hsaWdodChldmVudFNwYW5zW2ldKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJFdmVudExvY2F0aW9uSGVscGVyKGV2ZW50TG9jYXRpb24sIHNlZyk7IC8vIHJldHVybnMgbW9jayBldmVudCBlbGVtZW50c1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZFxuXHR1bnJlbmRlckV2ZW50UmVzaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XG5cdFx0dGhpcy51bnJlbmRlckhlbHBlcigpO1xuXHR9LFxuXG5cblx0LyogRXZlbnQgSGVscGVyXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGEgbW9jayBcImhlbHBlclwiIGV2ZW50LiBgc291cmNlU2VnYCBpcyB0aGUgYXNzb2NpYXRlZCBpbnRlcm5hbCBzZWdtZW50IG9iamVjdC4gSXQgY2FuIGJlIG51bGwuXG5cdHJlbmRlckhlbHBlcjogZnVuY3Rpb24oZXZlbnQsIHNvdXJjZVNlZykge1xuXHRcdHZhciBoZWxwZXJOb2RlcyA9IFtdO1xuXHRcdHZhciBzZWdzID0gdGhpcy5ldmVudFRvU2VncyhldmVudCk7XG5cdFx0dmFyIHJvd1N0cnVjdHM7XG5cblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ0VscyhzZWdzKTsgLy8gYXNzaWducyBlYWNoIHNlZydzIGVsIGFuZCByZXR1cm5zIGEgc3Vic2V0IG9mIHNlZ3MgdGhhdCB3ZXJlIHJlbmRlcmVkXG5cdFx0cm93U3RydWN0cyA9IHRoaXMucmVuZGVyU2VnUm93cyhzZWdzKTtcblxuXHRcdC8vIGluamVjdCBlYWNoIG5ldyBldmVudCBza2VsZXRvbiBpbnRvIGVhY2ggYXNzb2NpYXRlZCByb3dcblx0XHR0aGlzLnJvd0Vscy5lYWNoKGZ1bmN0aW9uKHJvdywgcm93Tm9kZSkge1xuXHRcdFx0dmFyIHJvd0VsID0gJChyb3dOb2RlKTsgLy8gdGhlIC5mYy1yb3dcblx0XHRcdHZhciBza2VsZXRvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLWhlbHBlci1za2VsZXRvblwiPjx0YWJsZS8+PC9kaXY+Jyk7IC8vIHdpbGwgYmUgYWJzb2x1dGVseSBwb3NpdGlvbmVkXG5cdFx0XHR2YXIgc2tlbGV0b25Ub3A7XG5cblx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIG9yaWdpbmFsIHNlZ21lbnQsIG1hdGNoIHRoZSB0b3AgcG9zaXRpb24uIE90aGVyd2lzZSwgcHV0IGl0IGF0IHRoZSByb3cncyB0b3AgbGV2ZWxcblx0XHRcdGlmIChzb3VyY2VTZWcgJiYgc291cmNlU2VnLnJvdyA9PT0gcm93KSB7XG5cdFx0XHRcdHNrZWxldG9uVG9wID0gc291cmNlU2VnLmVsLnBvc2l0aW9uKCkudG9wO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNrZWxldG9uVG9wID0gcm93RWwuZmluZCgnLmZjLWNvbnRlbnQtc2tlbGV0b24gdGJvZHknKS5wb3NpdGlvbigpLnRvcDtcblx0XHRcdH1cblxuXHRcdFx0c2tlbGV0b25FbC5jc3MoJ3RvcCcsIHNrZWxldG9uVG9wKVxuXHRcdFx0XHQuZmluZCgndGFibGUnKVxuXHRcdFx0XHRcdC5hcHBlbmQocm93U3RydWN0c1tyb3ddLnRib2R5RWwpO1xuXG5cdFx0XHRyb3dFbC5hcHBlbmQoc2tlbGV0b25FbCk7XG5cdFx0XHRoZWxwZXJOb2Rlcy5wdXNoKHNrZWxldG9uRWxbMF0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuICggLy8gbXVzdCByZXR1cm4gdGhlIGVsZW1lbnRzIHJlbmRlcmVkXG5cdFx0XHR0aGlzLmhlbHBlckVscyA9ICQoaGVscGVyTm9kZXMpIC8vIGFycmF5IC0+IGpRdWVyeSBzZXRcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIG1vY2sgaGVscGVyIGV2ZW50XG5cdHVucmVuZGVySGVscGVyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5oZWxwZXJFbHMpIHtcblx0XHRcdHRoaXMuaGVscGVyRWxzLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5oZWxwZXJFbHMgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXG5cdC8qIEZpbGwgU3lzdGVtIChoaWdobGlnaHQsIGJhY2tncm91bmQgZXZlbnRzLCBidXNpbmVzcyBob3Vycylcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdGZpbGxTZWdUYWc6ICd0ZCcsIC8vIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHRhZyBuYW1lXG5cblxuXHQvLyBSZW5kZXJzIGEgc2V0IG9mIHJlY3RhbmdsZXMgb3ZlciB0aGUgZ2l2ZW4gc2VnbWVudHMgb2YgZGF5cy5cblx0Ly8gT25seSByZXR1cm5zIHNlZ21lbnRzIHRoYXQgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkLlxuXHRyZW5kZXJGaWxsOiBmdW5jdGlvbih0eXBlLCBzZWdzLCBjbGFzc05hbWUpIHtcblx0XHR2YXIgbm9kZXMgPSBbXTtcblx0XHR2YXIgaSwgc2VnO1xuXHRcdHZhciBza2VsZXRvbkVsO1xuXG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmlsbFNlZ0Vscyh0eXBlLCBzZWdzKTsgLy8gYXNzaWduZXMgYC5lbGAgdG8gZWFjaCBzZWcuIHJldHVybnMgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHNlZ3NcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWcgPSBzZWdzW2ldO1xuXHRcdFx0c2tlbGV0b25FbCA9IHRoaXMucmVuZGVyRmlsbFJvdyh0eXBlLCBzZWcsIGNsYXNzTmFtZSk7XG5cdFx0XHR0aGlzLnJvd0Vscy5lcShzZWcucm93KS5hcHBlbmQoc2tlbGV0b25FbCk7XG5cdFx0XHRub2Rlcy5wdXNoKHNrZWxldG9uRWxbMF0pO1xuXHRcdH1cblxuXHRcdHRoaXMuZWxzQnlGaWxsW3R5cGVdID0gJChub2Rlcyk7XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBuZWVkZWQgZm9yIG9uZSByb3cgb2YgYSBmaWxsLiBSZXF1aXJlcyB0aGUgc2VnJ3MgZWwgdG8gYmUgcmVuZGVyZWQuXG5cdHJlbmRlckZpbGxSb3c6IGZ1bmN0aW9uKHR5cGUsIHNlZywgY2xhc3NOYW1lKSB7XG5cdFx0dmFyIGNvbENudCA9IHRoaXMuY29sQ250O1xuXHRcdHZhciBzdGFydENvbCA9IHNlZy5sZWZ0Q29sO1xuXHRcdHZhciBlbmRDb2wgPSBzZWcucmlnaHRDb2wgKyAxO1xuXHRcdHZhciBza2VsZXRvbkVsO1xuXHRcdHZhciB0ckVsO1xuXG5cdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8IHR5cGUudG9Mb3dlckNhc2UoKTtcblxuXHRcdHNrZWxldG9uRWwgPSAkKFxuXHRcdFx0JzxkaXYgY2xhc3M9XCJmYy0nICsgY2xhc3NOYW1lICsgJy1za2VsZXRvblwiPicgK1xuXHRcdFx0XHQnPHRhYmxlPjx0ci8+PC90YWJsZT4nICtcblx0XHRcdCc8L2Rpdj4nXG5cdFx0KTtcblx0XHR0ckVsID0gc2tlbGV0b25FbC5maW5kKCd0cicpO1xuXG5cdFx0aWYgKHN0YXJ0Q29sID4gMCkge1xuXHRcdFx0dHJFbC5hcHBlbmQoJzx0ZCBjb2xzcGFuPVwiJyArIHN0YXJ0Q29sICsgJ1wiLz4nKTtcblx0XHR9XG5cblx0XHR0ckVsLmFwcGVuZChcblx0XHRcdHNlZy5lbC5hdHRyKCdjb2xzcGFuJywgZW5kQ29sIC0gc3RhcnRDb2wpXG5cdFx0KTtcblxuXHRcdGlmIChlbmRDb2wgPCBjb2xDbnQpIHtcblx0XHRcdHRyRWwuYXBwZW5kKCc8dGQgY29sc3Bhbj1cIicgKyAoY29sQ250IC0gZW5kQ29sKSArICdcIi8+Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5ib29rZW5kQ2VsbHModHJFbCk7XG5cblx0XHRyZXR1cm4gc2tlbGV0b25FbDtcblx0fVxuXG59KTtcblxuOztcblxuLyogRXZlbnQtcmVuZGVyaW5nIG1ldGhvZHMgZm9yIHRoZSBEYXlHcmlkIGNsYXNzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuRGF5R3JpZC5taXhpbih7XG5cblx0cm93U3RydWN0czogbnVsbCwgLy8gYW4gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBob2xkaW5nIGluZm9ybWF0aW9uIGFib3V0IGEgcm93J3MgZm9yZWdyb3VuZCBldmVudC1yZW5kZXJpbmdcblxuXG5cdC8vIFVucmVuZGVycyBhbGwgZXZlbnRzIGN1cnJlbnRseSByZW5kZXJlZCBvbiB0aGUgZ3JpZFxuXHR1bnJlbmRlckV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW1vdmVTZWdQb3BvdmVyKCk7IC8vIHJlbW92ZXMgdGhlIFwibW9yZS4uXCIgZXZlbnRzIHBvcG92ZXJcblx0XHRHcmlkLnByb3RvdHlwZS51bnJlbmRlckV2ZW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxscyB0aGUgc3VwZXItbWV0aG9kXG5cdH0sXG5cblxuXHQvLyBSZXRyaWV2ZXMgYWxsIHJlbmRlcmVkIHNlZ21lbnQgb2JqZWN0cyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcblx0Z2V0RXZlbnRTZWdzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gR3JpZC5wcm90b3R5cGUuZ2V0RXZlbnRTZWdzLmNhbGwodGhpcykgLy8gZ2V0IHRoZSBzZWdtZW50cyBmcm9tIHRoZSBzdXBlci1tZXRob2Rcblx0XHRcdC5jb25jYXQodGhpcy5wb3BvdmVyU2VncyB8fCBbXSk7IC8vIGFwcGVuZCB0aGUgc2VnbWVudHMgZnJvbSB0aGUgXCJtb3JlLi4uXCIgcG9wb3ZlclxuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgZ2l2ZW4gYmFja2dyb3VuZCBldmVudCBzZWdtZW50cyBvbnRvIHRoZSBncmlkXG5cdHJlbmRlckJnU2VnczogZnVuY3Rpb24oc2Vncykge1xuXG5cdFx0Ly8gZG9uJ3QgcmVuZGVyIHRpbWVkIGJhY2tncm91bmQgZXZlbnRzXG5cdFx0dmFyIGFsbERheVNlZ3MgPSAkLmdyZXAoc2VncywgZnVuY3Rpb24oc2VnKSB7XG5cdFx0XHRyZXR1cm4gc2VnLmV2ZW50LmFsbERheTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBHcmlkLnByb3RvdHlwZS5yZW5kZXJCZ1NlZ3MuY2FsbCh0aGlzLCBhbGxEYXlTZWdzKTsgLy8gY2FsbCB0aGUgc3VwZXItbWV0aG9kXG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBnaXZlbiBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIG9udG8gdGhlIGdyaWRcblx0cmVuZGVyRmdTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dmFyIHJvd1N0cnVjdHM7XG5cblx0XHQvLyByZW5kZXIgYW4gYC5lbGAgb24gZWFjaCBzZWdcblx0XHQvLyByZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBzZWdzLiBzZWdzIHRoYXQgd2VyZSBhY3R1YWxseSByZW5kZXJlZFxuXHRcdHNlZ3MgPSB0aGlzLnJlbmRlckZnU2VnRWxzKHNlZ3MpO1xuXG5cdFx0cm93U3RydWN0cyA9IHRoaXMucm93U3RydWN0cyA9IHRoaXMucmVuZGVyU2VnUm93cyhzZWdzKTtcblxuXHRcdC8vIGFwcGVuZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b25cblx0XHR0aGlzLnJvd0Vscy5lYWNoKGZ1bmN0aW9uKGksIHJvd05vZGUpIHtcblx0XHRcdCQocm93Tm9kZSkuZmluZCgnLmZjLWNvbnRlbnQtc2tlbGV0b24gPiB0YWJsZScpLmFwcGVuZChcblx0XHRcdFx0cm93U3RydWN0c1tpXS50Ym9keUVsXG5cdFx0XHQpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHNlZ3M7IC8vIHJldHVybiBvbmx5IHRoZSBzZWdzIHRoYXQgd2VyZSBhY3R1YWxseSByZW5kZXJlZFxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFsbCBjdXJyZW50bHkgcmVuZGVyZWQgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50c1xuXHR1bnJlbmRlckZnU2VnczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJvd1N0cnVjdHMgPSB0aGlzLnJvd1N0cnVjdHMgfHwgW107XG5cdFx0dmFyIHJvd1N0cnVjdDtcblxuXHRcdHdoaWxlICgocm93U3RydWN0ID0gcm93U3RydWN0cy5wb3AoKSkpIHtcblx0XHRcdHJvd1N0cnVjdC50Ym9keUVsLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMucm93U3RydWN0cyA9IG51bGw7XG5cdH0sXG5cblxuXHQvLyBVc2VzIHRoZSBnaXZlbiBldmVudHMgYXJyYXkgdG8gZ2VuZXJhdGUgPHRib2R5PiBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b24uXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2Ygcm93U3RydWN0IG9iamVjdHMgKHNlZSB0aGUgYm90dG9tIG9mIGByZW5kZXJTZWdSb3dgKS5cblx0Ly8gUFJFQ09ORElUSU9OOiBlYWNoIHNlZ21lbnQgc2hvdWQgYWxyZWFkeSBoYXZlIGEgcmVuZGVyZWQgYW5kIGFzc2lnbmVkIGAuZWxgXG5cdHJlbmRlclNlZ1Jvd3M6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR2YXIgcm93U3RydWN0cyA9IFtdO1xuXHRcdHZhciBzZWdSb3dzO1xuXHRcdHZhciByb3c7XG5cblx0XHRzZWdSb3dzID0gdGhpcy5ncm91cFNlZ1Jvd3Moc2Vncyk7IC8vIGdyb3VwIGludG8gbmVzdGVkIGFycmF5c1xuXG5cdFx0Ly8gaXRlcmF0ZSBlYWNoIHJvdyBvZiBzZWdtZW50IGdyb3VwaW5nc1xuXHRcdGZvciAocm93ID0gMDsgcm93IDwgc2VnUm93cy5sZW5ndGg7IHJvdysrKSB7XG5cdFx0XHRyb3dTdHJ1Y3RzLnB1c2goXG5cdFx0XHRcdHRoaXMucmVuZGVyU2VnUm93KHJvdywgc2VnUm93c1tyb3ddKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcm93U3RydWN0cztcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyB0aGUgSFRNTCB0byBiZSB1c2VkIGZvciB0aGUgZGVmYXVsdCBlbGVtZW50IGZvciBhbiBpbmRpdmlkdWFsIHNlZ21lbnRcblx0ZmdTZWdIdG1sOiBmdW5jdGlvbihzZWcsIGRpc2FibGVSZXNpemluZykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBldmVudCA9IHNlZy5ldmVudDtcblx0XHR2YXIgaXNEcmFnZ2FibGUgPSB2aWV3LmlzRXZlbnREcmFnZ2FibGUoZXZlbnQpO1xuXHRcdHZhciBpc1Jlc2l6YWJsZUZyb21TdGFydCA9ICFkaXNhYmxlUmVzaXppbmcgJiYgZXZlbnQuYWxsRGF5ICYmXG5cdFx0XHRzZWcuaXNTdGFydCAmJiB2aWV3LmlzRXZlbnRSZXNpemFibGVGcm9tU3RhcnQoZXZlbnQpO1xuXHRcdHZhciBpc1Jlc2l6YWJsZUZyb21FbmQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIGV2ZW50LmFsbERheSAmJlxuXHRcdFx0c2VnLmlzRW5kICYmIHZpZXcuaXNFdmVudFJlc2l6YWJsZUZyb21FbmQoZXZlbnQpO1xuXHRcdHZhciBjbGFzc2VzID0gdGhpcy5nZXRTZWdDbGFzc2VzKHNlZywgaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlRnJvbVN0YXJ0IHx8IGlzUmVzaXphYmxlRnJvbUVuZCk7XG5cdFx0dmFyIHNraW5Dc3MgPSBjc3NUb1N0cih0aGlzLmdldFNlZ1NraW5Dc3Moc2VnKSk7XG5cdFx0dmFyIHRpbWVIdG1sID0gJyc7XG5cdFx0dmFyIHRpbWVUZXh0O1xuXHRcdHZhciB0aXRsZUh0bWw7XG5cblx0XHRjbGFzc2VzLnVuc2hpZnQoJ2ZjLWRheS1ncmlkLWV2ZW50JywgJ2ZjLWgtZXZlbnQnKTtcblxuXHRcdC8vIE9ubHkgZGlzcGxheSBhIHRpbWVkIGV2ZW50cyB0aW1lIGlmIGl0IGlzIHRoZSBzdGFydGluZyBzZWdtZW50XG5cdFx0aWYgKHNlZy5pc1N0YXJ0KSB7XG5cdFx0XHR0aW1lVGV4dCA9IHRoaXMuZ2V0RXZlbnRUaW1lVGV4dChldmVudCk7XG5cdFx0XHRpZiAodGltZVRleHQpIHtcblx0XHRcdFx0dGltZUh0bWwgPSAnPHNwYW4gY2xhc3M9XCJmYy10aW1lXCI+JyArIGh0bWxFc2NhcGUodGltZVRleHQpICsgJzwvc3Bhbj4nO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRpdGxlSHRtbCA9XG5cdFx0XHQnPHNwYW4gY2xhc3M9XCJmYy10aXRsZVwiPicgK1xuXHRcdFx0XHQoaHRtbEVzY2FwZShldmVudC50aXRsZSB8fCAnJykgfHwgJyZuYnNwOycpICsgLy8gd2UgYWx3YXlzIHdhbnQgb25lIGxpbmUgb2YgaGVpZ2h0XG5cdFx0XHQnPC9zcGFuPic7XG5cdFx0XG5cdFx0cmV0dXJuICc8YSBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xuXHRcdFx0XHQoZXZlbnQudXJsID9cblx0XHRcdFx0XHQnIGhyZWY9XCInICsgaHRtbEVzY2FwZShldmVudC51cmwpICsgJ1wiJyA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0XHQpICtcblx0XHRcdFx0KHNraW5Dc3MgP1xuXHRcdFx0XHRcdCcgc3R5bGU9XCInICsgc2tpbkNzcyArICdcIicgOlxuXHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0KSArXG5cdFx0XHQnPicgK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnRcIj4nICtcblx0XHRcdFx0XHQodGhpcy5pc1JUTCA/XG5cdFx0XHRcdFx0XHR0aXRsZUh0bWwgKyAnICcgKyB0aW1lSHRtbCA6IC8vIHB1dCBhIG5hdHVyYWwgc3BhY2UgaW4gYmV0d2VlblxuXHRcdFx0XHRcdFx0dGltZUh0bWwgKyAnICcgKyB0aXRsZUh0bWwgICAvL1xuXHRcdFx0XHRcdFx0KSArXG5cdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdFx0KGlzUmVzaXphYmxlRnJvbVN0YXJ0ID9cblx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLXJlc2l6ZXIgZmMtc3RhcnQtcmVzaXplclwiIC8+JyA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0XHQpICtcblx0XHRcdFx0KGlzUmVzaXphYmxlRnJvbUVuZCA/XG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLWVuZC1yZXNpemVyXCIgLz4nIDpcblx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdCkgK1xuXHRcdFx0JzwvYT4nO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYSByb3cgIyBhbmQgYW4gYXJyYXkgb2Ygc2VnbWVudHMgYWxsIGluIHRoZSBzYW1lIHJvdywgcmVuZGVyIGEgPHRib2R5PiBlbGVtZW50LCBhIHNrZWxldG9uIHRoYXQgY29udGFpbnNcblx0Ly8gdGhlIHNlZ21lbnRzLiBSZXR1cm5zIG9iamVjdCB3aXRoIGEgYnVuY2ggb2YgaW50ZXJuYWwgZGF0YSBhYm91dCBob3cgdGhlIHJlbmRlciB3YXMgY2FsY3VsYXRlZC5cblx0Ly8gTk9URTogbW9kaWZpZXMgcm93U2Vnc1xuXHRyZW5kZXJTZWdSb3c6IGZ1bmN0aW9uKHJvdywgcm93U2Vncykge1xuXHRcdHZhciBjb2xDbnQgPSB0aGlzLmNvbENudDtcblx0XHR2YXIgc2VnTGV2ZWxzID0gdGhpcy5idWlsZFNlZ0xldmVscyhyb3dTZWdzKTsgLy8gZ3JvdXAgaW50byBzdWItYXJyYXlzIG9mIGxldmVsc1xuXHRcdHZhciBsZXZlbENudCA9IE1hdGgubWF4KDEsIHNlZ0xldmVscy5sZW5ndGgpOyAvLyBlbnN1cmUgYXQgbGVhc3Qgb25lIGxldmVsXG5cdFx0dmFyIHRib2R5ID0gJCgnPHRib2R5Lz4nKTtcblx0XHR2YXIgc2VnTWF0cml4ID0gW107IC8vIGxvb2t1cCBmb3Igd2hpY2ggc2VnbWVudHMgYXJlIHJlbmRlcmVkIGludG8gd2hpY2ggbGV2ZWwrY29sIGNlbGxzXG5cdFx0dmFyIGNlbGxNYXRyaXggPSBbXTsgLy8gbG9va3VwIGZvciBhbGwgPHRkPiBlbGVtZW50cyBvZiB0aGUgbGV2ZWwrY29sIG1hdHJpeFxuXHRcdHZhciBsb25lQ2VsbE1hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIDx0ZD4gZWxlbWVudHMgdGhhdCBvbmx5IHRha2UgdXAgYSBzaW5nbGUgY29sdW1uXG5cdFx0dmFyIGksIGxldmVsU2Vncztcblx0XHR2YXIgY29sO1xuXHRcdHZhciB0cjtcblx0XHR2YXIgaiwgc2VnO1xuXHRcdHZhciB0ZDtcblxuXHRcdC8vIHBvcHVsYXRlcyBlbXB0eSBjZWxscyBmcm9tIHRoZSBjdXJyZW50IGNvbHVtbiAoYGNvbGApIHRvIGBlbmRDb2xgXG5cdFx0ZnVuY3Rpb24gZW1wdHlDZWxsc1VudGlsKGVuZENvbCkge1xuXHRcdFx0d2hpbGUgKGNvbCA8IGVuZENvbCkge1xuXHRcdFx0XHQvLyB0cnkgdG8gZ3JhYiBhIGNlbGwgZnJvbSB0aGUgbGV2ZWwgYWJvdmUgYW5kIGV4dGVuZCBpdHMgcm93c3Bhbi4gb3RoZXJ3aXNlLCBjcmVhdGUgYSBmcmVzaCBjZWxsXG5cdFx0XHRcdHRkID0gKGxvbmVDZWxsTWF0cml4W2kgLSAxXSB8fCBbXSlbY29sXTtcblx0XHRcdFx0aWYgKHRkKSB7XG5cdFx0XHRcdFx0dGQuYXR0cihcblx0XHRcdFx0XHRcdCdyb3dzcGFuJyxcblx0XHRcdFx0XHRcdHBhcnNlSW50KHRkLmF0dHIoJ3Jvd3NwYW4nKSB8fCAxLCAxMCkgKyAxXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0ZCA9ICQoJzx0ZC8+Jyk7XG5cdFx0XHRcdFx0dHIuYXBwZW5kKHRkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcblx0XHRcdFx0bG9uZUNlbGxNYXRyaXhbaV1bY29sXSA9IHRkO1xuXHRcdFx0XHRjb2wrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGV2ZWxDbnQ7IGkrKykgeyAvLyBpdGVyYXRlIHRocm91Z2ggYWxsIGxldmVsc1xuXHRcdFx0bGV2ZWxTZWdzID0gc2VnTGV2ZWxzW2ldO1xuXHRcdFx0Y29sID0gMDtcblx0XHRcdHRyID0gJCgnPHRyLz4nKTtcblxuXHRcdFx0c2VnTWF0cml4LnB1c2goW10pO1xuXHRcdFx0Y2VsbE1hdHJpeC5wdXNoKFtdKTtcblx0XHRcdGxvbmVDZWxsTWF0cml4LnB1c2goW10pO1xuXG5cdFx0XHQvLyBsZXZlbENudCBtaWdodCBiZSAxIGV2ZW4gdGhvdWdoIHRoZXJlIGFyZSBubyBhY3R1YWwgbGV2ZWxzLiBwcm90ZWN0IGFnYWluc3QgdGhpcy5cblx0XHRcdC8vIHRoaXMgc2luZ2xlIGVtcHR5IHJvdyBpcyB1c2VmdWwgZm9yIHN0eWxpbmcuXG5cdFx0XHRpZiAobGV2ZWxTZWdzKSB7XG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsZXZlbFNlZ3MubGVuZ3RoOyBqKyspIHsgLy8gaXRlcmF0ZSB0aHJvdWdoIHNlZ21lbnRzIGluIGxldmVsXG5cdFx0XHRcdFx0c2VnID0gbGV2ZWxTZWdzW2pdO1xuXG5cdFx0XHRcdFx0ZW1wdHlDZWxsc1VudGlsKHNlZy5sZWZ0Q29sKTtcblxuXHRcdFx0XHRcdC8vIGNyZWF0ZSBhIGNvbnRhaW5lciB0aGF0IG9jY3VwaWVzIG9yIG1vcmUgY29sdW1ucy4gYXBwZW5kIHRoZSBldmVudCBlbGVtZW50LlxuXHRcdFx0XHRcdHRkID0gJCgnPHRkIGNsYXNzPVwiZmMtZXZlbnQtY29udGFpbmVyXCIvPicpLmFwcGVuZChzZWcuZWwpO1xuXHRcdFx0XHRcdGlmIChzZWcubGVmdENvbCAhPSBzZWcucmlnaHRDb2wpIHtcblx0XHRcdFx0XHRcdHRkLmF0dHIoJ2NvbHNwYW4nLCBzZWcucmlnaHRDb2wgLSBzZWcubGVmdENvbCArIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHsgLy8gYSBzaW5nbGUtY29sdW1uIHNlZ21lbnRcblx0XHRcdFx0XHRcdGxvbmVDZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR3aGlsZSAoY29sIDw9IHNlZy5yaWdodENvbCkge1xuXHRcdFx0XHRcdFx0Y2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XG5cdFx0XHRcdFx0XHRzZWdNYXRyaXhbaV1bY29sXSA9IHNlZztcblx0XHRcdFx0XHRcdGNvbCsrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRyLmFwcGVuZCh0ZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZW1wdHlDZWxsc1VudGlsKGNvbENudCk7IC8vIGZpbmlzaCBvZmYgdGhlIHJvd1xuXHRcdFx0dGhpcy5ib29rZW5kQ2VsbHModHIpO1xuXHRcdFx0dGJvZHkuYXBwZW5kKHRyKTtcblx0XHR9XG5cblx0XHRyZXR1cm4geyAvLyBhIFwicm93U3RydWN0XCJcblx0XHRcdHJvdzogcm93LCAvLyB0aGUgcm93IG51bWJlclxuXHRcdFx0dGJvZHlFbDogdGJvZHksXG5cdFx0XHRjZWxsTWF0cml4OiBjZWxsTWF0cml4LFxuXHRcdFx0c2VnTWF0cml4OiBzZWdNYXRyaXgsXG5cdFx0XHRzZWdMZXZlbHM6IHNlZ0xldmVscyxcblx0XHRcdHNlZ3M6IHJvd1NlZ3Ncblx0XHR9O1xuXHR9LFxuXG5cblx0Ly8gU3RhY2tzIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgd2hpY2ggYXJlIGFsbCBhc3N1bWVkIHRvIGJlIGluIHRoZSBzYW1lIHJvdywgaW50byBzdWJhcnJheXMgb2YgdmVydGljYWwgbGV2ZWxzLlxuXHQvLyBOT1RFOiBtb2RpZmllcyBzZWdzXG5cdGJ1aWxkU2VnTGV2ZWxzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dmFyIGxldmVscyA9IFtdO1xuXHRcdHZhciBpLCBzZWc7XG5cdFx0dmFyIGo7XG5cblx0XHQvLyBHaXZlIHByZWZlcmVuY2UgdG8gZWxlbWVudHMgd2l0aCBjZXJ0YWluIGNyaXRlcmlhLCBzbyB0aGV5IGhhdmVcblx0XHQvLyBhIGNoYW5jZSB0byBiZSBjbG9zZXIgdG8gdGhlIHRvcC5cblx0XHR0aGlzLnNvcnRFdmVudFNlZ3Moc2Vncyk7XG5cdFx0XG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZyA9IHNlZ3NbaV07XG5cblx0XHRcdC8vIGxvb3AgdGhyb3VnaCBsZXZlbHMsIHN0YXJ0aW5nIHdpdGggdGhlIHRvcG1vc3QsIHVudGlsIHRoZSBzZWdtZW50IGRvZXNuJ3QgY29sbGlkZSB3aXRoIG90aGVyIHNlZ21lbnRzXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmICghaXNEYXlTZWdDb2xsaXNpb24oc2VnLCBsZXZlbHNbal0pKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGBqYCBub3cgaG9sZHMgdGhlIGRlc2lyZWQgc3Vicm93IGluZGV4XG5cdFx0XHRzZWcubGV2ZWwgPSBqO1xuXG5cdFx0XHQvLyBjcmVhdGUgbmV3IGxldmVsIGFycmF5IGlmIG5lZWRlZCBhbmQgYXBwZW5kIHNlZ21lbnRcblx0XHRcdChsZXZlbHNbal0gfHwgKGxldmVsc1tqXSA9IFtdKSkucHVzaChzZWcpO1xuXHRcdH1cblxuXHRcdC8vIG9yZGVyIHNlZ21lbnRzIGxlZnQtdG8tcmlnaHQuIHZlcnkgaW1wb3J0YW50IGlmIGNhbGVuZGFyIGlzIFJUTFxuXHRcdGZvciAoaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdGxldmVsc1tqXS5zb3J0KGNvbXBhcmVEYXlTZWdDb2xzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGV2ZWxzO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYSBmbGF0IGFycmF5IG9mIHNlZ21lbnRzLCByZXR1cm4gYW4gYXJyYXkgb2Ygc3ViLWFycmF5cywgZ3JvdXBlZCBieSBlYWNoIHNlZ21lbnQncyByb3dcblx0Z3JvdXBTZWdSb3dzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dmFyIHNlZ1Jvd3MgPSBbXTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLnJvd0NudDsgaSsrKSB7XG5cdFx0XHRzZWdSb3dzLnB1c2goW10pO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWdSb3dzW3NlZ3NbaV0ucm93XS5wdXNoKHNlZ3NbaV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWdSb3dzO1xuXHR9XG5cbn0pO1xuXG5cbi8vIENvbXB1dGVzIHdoZXRoZXIgdHdvIHNlZ21lbnRzJyBjb2x1bW5zIGNvbGxpZGUuIFRoZXkgYXJlIGFzc3VtZWQgdG8gYmUgaW4gdGhlIHNhbWUgcm93LlxuZnVuY3Rpb24gaXNEYXlTZWdDb2xsaXNpb24oc2VnLCBvdGhlclNlZ3MpIHtcblx0dmFyIGksIG90aGVyU2VnO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBvdGhlclNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRvdGhlclNlZyA9IG90aGVyU2Vnc1tpXTtcblxuXHRcdGlmIChcblx0XHRcdG90aGVyU2VnLmxlZnRDb2wgPD0gc2VnLnJpZ2h0Q29sICYmXG5cdFx0XHRvdGhlclNlZy5yaWdodENvbCA+PSBzZWcubGVmdENvbFxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5cbi8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB0aGUgbGVmdG1vc3QgZXZlbnRcbmZ1bmN0aW9uIGNvbXBhcmVEYXlTZWdDb2xzKGEsIGIpIHtcblx0cmV0dXJuIGEubGVmdENvbCAtIGIubGVmdENvbDtcbn1cblxuOztcblxuLyogTWV0aG9kcyByZWxhdGUgdG8gbGltaXRpbmcgdGhlIG51bWJlciBldmVudHMgZm9yIGEgZ2l2ZW4gZGF5IG9uIGEgRGF5R3JpZFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBOT1RFOiBhbGwgdGhlIHNlZ3MgYmVpbmcgcGFzc2VkIGFyb3VuZCBpbiBoZXJlIGFyZSBmb3JlZ3JvdW5kIHNlZ3NcblxuRGF5R3JpZC5taXhpbih7XG5cblx0c2VnUG9wb3ZlcjogbnVsbCwgLy8gdGhlIFBvcG92ZXIgdGhhdCBob2xkcyBldmVudHMgdGhhdCBjYW4ndCBmaXQgaW4gYSBjZWxsLiBudWxsIHdoZW4gbm90IHZpc2libGVcblx0cG9wb3ZlclNlZ3M6IG51bGwsIC8vIGFuIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cyB0aGF0IHRoZSBzZWdQb3BvdmVyIGhvbGRzLiBudWxsIHdoZW4gbm90IHZpc2libGVcblxuXG5cdHJlbW92ZVNlZ1BvcG92ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLnNlZ1BvcG92ZXIpIHtcblx0XHRcdHRoaXMuc2VnUG9wb3Zlci5oaWRlKCk7IC8vIGluIGhhbmRsZXIsIHdpbGwgY2FsbCBzZWdQb3BvdmVyJ3MgcmVtb3ZlRWxlbWVudFxuXHRcdH1cblx0fSxcblxuXG5cdC8vIExpbWl0cyB0aGUgbnVtYmVyIG9mIFwibGV2ZWxzXCIgKHZlcnRpY2FsbHkgc3RhY2tpbmcgbGF5ZXJzIG9mIGV2ZW50cykgZm9yIGVhY2ggcm93IG9mIHRoZSBncmlkLlxuXHQvLyBgbGV2ZWxMaW1pdGAgY2FuIGJlIGZhbHNlIChkb24ndCBsaW1pdCksIGEgbnVtYmVyLCBvciB0cnVlIChzaG91bGQgYmUgY29tcHV0ZWQpLlxuXHRsaW1pdFJvd3M6IGZ1bmN0aW9uKGxldmVsTGltaXQpIHtcblx0XHR2YXIgcm93U3RydWN0cyA9IHRoaXMucm93U3RydWN0cyB8fCBbXTtcblx0XHR2YXIgcm93OyAvLyByb3cgI1xuXHRcdHZhciByb3dMZXZlbExpbWl0O1xuXG5cdFx0Zm9yIChyb3cgPSAwOyByb3cgPCByb3dTdHJ1Y3RzLmxlbmd0aDsgcm93KyspIHtcblx0XHRcdHRoaXMudW5saW1pdFJvdyhyb3cpO1xuXG5cdFx0XHRpZiAoIWxldmVsTGltaXQpIHtcblx0XHRcdFx0cm93TGV2ZWxMaW1pdCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIGxldmVsTGltaXQgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHJvd0xldmVsTGltaXQgPSBsZXZlbExpbWl0O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJvd0xldmVsTGltaXQgPSB0aGlzLmNvbXB1dGVSb3dMZXZlbExpbWl0KHJvdyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyb3dMZXZlbExpbWl0ICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLmxpbWl0Um93KHJvdywgcm93TGV2ZWxMaW1pdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgdGhlIG51bWJlciBvZiBsZXZlbHMgYSByb3cgd2lsbCBhY2NvbW9kYXRlIHdpdGhvdXQgZ29pbmcgb3V0c2lkZSBpdHMgYm91bmRzLlxuXHQvLyBBc3N1bWVzIHRoZSByb3cgaXMgXCJyaWdpZFwiIChtYWludGFpbnMgYSBjb25zdGFudCBoZWlnaHQgcmVnYXJkbGVzcyBvZiB3aGF0IGlzIGluc2lkZSkuXG5cdC8vIGByb3dgIGlzIHRoZSByb3cgbnVtYmVyLlxuXHRjb21wdXRlUm93TGV2ZWxMaW1pdDogZnVuY3Rpb24ocm93KSB7XG5cdFx0dmFyIHJvd0VsID0gdGhpcy5yb3dFbHMuZXEocm93KTsgLy8gdGhlIGNvbnRhaW5pbmcgXCJmYWtlXCIgcm93IGRpdlxuXHRcdHZhciByb3dIZWlnaHQgPSByb3dFbC5oZWlnaHQoKTsgLy8gVE9ETzogY2FjaGUgc29tZWhvdz9cblx0XHR2YXIgdHJFbHMgPSB0aGlzLnJvd1N0cnVjdHNbcm93XS50Ym9keUVsLmNoaWxkcmVuKCk7XG5cdFx0dmFyIGksIHRyRWw7XG5cdFx0dmFyIHRySGVpZ2h0O1xuXG5cdFx0ZnVuY3Rpb24gaXRlcklubmVySGVpZ2h0cyhpLCBjaGlsZE5vZGUpIHtcblx0XHRcdHRySGVpZ2h0ID0gTWF0aC5tYXgodHJIZWlnaHQsICQoY2hpbGROb2RlKS5vdXRlckhlaWdodCgpKTtcblx0XHR9XG5cblx0XHQvLyBSZXZlYWwgb25lIGxldmVsIDx0cj4gYXQgYSB0aW1lIGFuZCBzdG9wIHdoZW4gd2UgZmluZCBvbmUgb3V0IG9mIGJvdW5kc1xuXHRcdGZvciAoaSA9IDA7IGkgPCB0ckVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dHJFbCA9IHRyRWxzLmVxKGkpLnJlbW92ZUNsYXNzKCdmYy1saW1pdGVkJyk7IC8vIHJlc2V0IHRvIG9yaWdpbmFsIHN0YXRlIChyZXZlYWwpXG5cblx0XHRcdC8vIHdpdGggcm93c3BhbnM+MSBhbmQgSUU4LCB0ckVsLm91dGVySGVpZ2h0KCkgd291bGQgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIGxhcmdlc3QgY2VsbCxcblx0XHRcdC8vIHNvIGluc3RlYWQsIGZpbmQgdGhlIHRhbGxlc3QgaW5uZXIgY29udGVudCBlbGVtZW50LlxuXHRcdFx0dHJIZWlnaHQgPSAwO1xuXHRcdFx0dHJFbC5maW5kKCc+IHRkID4gOmZpcnN0LWNoaWxkJykuZWFjaChpdGVySW5uZXJIZWlnaHRzKTtcblxuXHRcdFx0aWYgKHRyRWwucG9zaXRpb24oKS50b3AgKyB0ckhlaWdodCA+IHJvd0hlaWdodCkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7IC8vIHNob3VsZCBub3QgbGltaXQgYXQgYWxsXG5cdH0sXG5cblxuXHQvLyBMaW1pdHMgdGhlIGdpdmVuIGdyaWQgcm93IHRvIHRoZSBtYXhpbXVtIG51bWJlciBvZiBsZXZlbHMgYW5kIGluamVjdHMgXCJtb3JlXCIgbGlua3MgaWYgbmVjZXNzYXJ5LlxuXHQvLyBgcm93YCBpcyB0aGUgcm93IG51bWJlci5cblx0Ly8gYGxldmVsTGltaXRgIGlzIGEgbnVtYmVyIGZvciB0aGUgbWF4aW11bSAoaW5jbHVzaXZlKSBudW1iZXIgb2YgbGV2ZWxzIGFsbG93ZWQuXG5cdGxpbWl0Um93OiBmdW5jdGlvbihyb3csIGxldmVsTGltaXQpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciByb3dTdHJ1Y3QgPSB0aGlzLnJvd1N0cnVjdHNbcm93XTtcblx0XHR2YXIgbW9yZU5vZGVzID0gW107IC8vIGFycmF5IG9mIFwibW9yZVwiIDxhPiBsaW5rcyBhbmQgPHRkPiBET00gbm9kZXNcblx0XHR2YXIgY29sID0gMDsgLy8gY29sICMsIGxlZnQtdG8tcmlnaHQgKG5vdCBjaHJvbm9sb2dpY2FsbHkpXG5cdFx0dmFyIGxldmVsU2VnczsgLy8gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzIGluIHRoZSBsYXN0IGFsbG93YWJsZSBsZXZlbCwgb3JkZXJlZCBsZWZ0LXRvLXJpZ2h0XG5cdFx0dmFyIGNlbGxNYXRyaXg7IC8vIGEgbWF0cml4IChieSBsZXZlbCwgdGhlbiBjb2x1bW4pIG9mIGFsbCA8dGQ+IGpRdWVyeSBlbGVtZW50cyBpbiB0aGUgcm93XG5cdFx0dmFyIGxpbWl0ZWROb2RlczsgLy8gYXJyYXkgb2YgdGVtcG9yYXJpbHkgaGlkZGVuIGxldmVsIDx0cj4gYW5kIHNlZ21lbnQgPHRkPiBET00gbm9kZXNcblx0XHR2YXIgaSwgc2VnO1xuXHRcdHZhciBzZWdzQmVsb3c7IC8vIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cyBiZWxvdyBgc2VnYCBpbiB0aGUgY3VycmVudCBgY29sYFxuXHRcdHZhciB0b3RhbFNlZ3NCZWxvdzsgLy8gdG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzIGJlbG93IGBzZWdgIGluIGFueSBvZiB0aGUgY29sdW1ucyBgc2VnYCBvY2N1cGllc1xuXHRcdHZhciBjb2xTZWdzQmVsb3c7IC8vIGFycmF5IG9mIHNlZ21lbnQgYXJyYXlzLCBiZWxvdyBzZWcsIG9uZSBmb3IgZWFjaCBjb2x1bW4gKG9mZnNldCBmcm9tIHNlZ3MncyBmaXJzdCBjb2x1bW4pXG5cdFx0dmFyIHRkLCByb3dzcGFuO1xuXHRcdHZhciBzZWdNb3JlTm9kZXM7IC8vIGFycmF5IG9mIFwibW9yZVwiIDx0ZD4gY2VsbHMgdGhhdCB3aWxsIHN0YW5kLWluIGZvciB0aGUgY3VycmVudCBzZWcncyBjZWxsXG5cdFx0dmFyIGo7XG5cdFx0dmFyIG1vcmVUZCwgbW9yZVdyYXAsIG1vcmVMaW5rO1xuXG5cdFx0Ly8gSXRlcmF0ZXMgdGhyb3VnaCBlbXB0eSBsZXZlbCBjZWxscyBhbmQgcGxhY2VzIFwibW9yZVwiIGxpbmtzIGluc2lkZSBpZiBuZWVkIGJlXG5cdFx0ZnVuY3Rpb24gZW1wdHlDZWxsc1VudGlsKGVuZENvbCkgeyAvLyBnb2VzIGZyb20gY3VycmVudCBgY29sYCB0byBgZW5kQ29sYFxuXHRcdFx0d2hpbGUgKGNvbCA8IGVuZENvbCkge1xuXHRcdFx0XHRzZWdzQmVsb3cgPSBfdGhpcy5nZXRDZWxsU2Vncyhyb3csIGNvbCwgbGV2ZWxMaW1pdCk7XG5cdFx0XHRcdGlmIChzZWdzQmVsb3cubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dGQgPSBjZWxsTWF0cml4W2xldmVsTGltaXQgLSAxXVtjb2xdO1xuXHRcdFx0XHRcdG1vcmVMaW5rID0gX3RoaXMucmVuZGVyTW9yZUxpbmsocm93LCBjb2wsIHNlZ3NCZWxvdyk7XG5cdFx0XHRcdFx0bW9yZVdyYXAgPSAkKCc8ZGl2Lz4nKS5hcHBlbmQobW9yZUxpbmspO1xuXHRcdFx0XHRcdHRkLmFwcGVuZChtb3JlV3JhcCk7XG5cdFx0XHRcdFx0bW9yZU5vZGVzLnB1c2gobW9yZVdyYXBbMF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbCsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChsZXZlbExpbWl0ICYmIGxldmVsTGltaXQgPCByb3dTdHJ1Y3Quc2VnTGV2ZWxzLmxlbmd0aCkgeyAvLyBpcyBpdCBhY3R1YWxseSBvdmVyIHRoZSBsaW1pdD9cblx0XHRcdGxldmVsU2VncyA9IHJvd1N0cnVjdC5zZWdMZXZlbHNbbGV2ZWxMaW1pdCAtIDFdO1xuXHRcdFx0Y2VsbE1hdHJpeCA9IHJvd1N0cnVjdC5jZWxsTWF0cml4O1xuXG5cdFx0XHRsaW1pdGVkTm9kZXMgPSByb3dTdHJ1Y3QudGJvZHlFbC5jaGlsZHJlbigpLnNsaWNlKGxldmVsTGltaXQpIC8vIGdldCBsZXZlbCA8dHI+IGVsZW1lbnRzIHBhc3QgdGhlIGxpbWl0XG5cdFx0XHRcdC5hZGRDbGFzcygnZmMtbGltaXRlZCcpLmdldCgpOyAvLyBoaWRlIGVsZW1lbnRzIGFuZCBnZXQgYSBzaW1wbGUgRE9NLW5vZGVzIGFycmF5XG5cblx0XHRcdC8vIGl0ZXJhdGUgdGhvdWdoIHNlZ21lbnRzIGluIHRoZSBsYXN0IGFsbG93YWJsZSBsZXZlbFxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxldmVsU2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzZWcgPSBsZXZlbFNlZ3NbaV07XG5cdFx0XHRcdGVtcHR5Q2VsbHNVbnRpbChzZWcubGVmdENvbCk7IC8vIHByb2Nlc3MgZW1wdHkgY2VsbHMgYmVmb3JlIHRoZSBzZWdtZW50XG5cblx0XHRcdFx0Ly8gZGV0ZXJtaW5lICphbGwqIHNlZ21lbnRzIGJlbG93IGBzZWdgIHRoYXQgb2NjdXB5IHRoZSBzYW1lIGNvbHVtbnNcblx0XHRcdFx0Y29sU2Vnc0JlbG93ID0gW107XG5cdFx0XHRcdHRvdGFsU2Vnc0JlbG93ID0gMDtcblx0XHRcdFx0d2hpbGUgKGNvbCA8PSBzZWcucmlnaHRDb2wpIHtcblx0XHRcdFx0XHRzZWdzQmVsb3cgPSB0aGlzLmdldENlbGxTZWdzKHJvdywgY29sLCBsZXZlbExpbWl0KTtcblx0XHRcdFx0XHRjb2xTZWdzQmVsb3cucHVzaChzZWdzQmVsb3cpO1xuXHRcdFx0XHRcdHRvdGFsU2Vnc0JlbG93ICs9IHNlZ3NCZWxvdy5sZW5ndGg7XG5cdFx0XHRcdFx0Y29sKys7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodG90YWxTZWdzQmVsb3cpIHsgLy8gZG8gd2UgbmVlZCB0byByZXBsYWNlIHRoaXMgc2VnbWVudCB3aXRoIG9uZSBvciBtYW55IFwibW9yZVwiIGxpbmtzP1xuXHRcdFx0XHRcdHRkID0gY2VsbE1hdHJpeFtsZXZlbExpbWl0IC0gMV1bc2VnLmxlZnRDb2xdOyAvLyB0aGUgc2VnbWVudCdzIHBhcmVudCBjZWxsXG5cdFx0XHRcdFx0cm93c3BhbiA9IHRkLmF0dHIoJ3Jvd3NwYW4nKSB8fCAxO1xuXHRcdFx0XHRcdHNlZ01vcmVOb2RlcyA9IFtdO1xuXG5cdFx0XHRcdFx0Ly8gbWFrZSBhIHJlcGxhY2VtZW50IDx0ZD4gZm9yIGVhY2ggY29sdW1uIHRoZSBzZWdtZW50IG9jY3VwaWVzLiB3aWxsIGJlIG9uZSBmb3IgZWFjaCBjb2xzcGFuXG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGNvbFNlZ3NCZWxvdy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0bW9yZVRkID0gJCgnPHRkIGNsYXNzPVwiZmMtbW9yZS1jZWxsXCIvPicpLmF0dHIoJ3Jvd3NwYW4nLCByb3dzcGFuKTtcblx0XHRcdFx0XHRcdHNlZ3NCZWxvdyA9IGNvbFNlZ3NCZWxvd1tqXTtcblx0XHRcdFx0XHRcdG1vcmVMaW5rID0gdGhpcy5yZW5kZXJNb3JlTGluayhcblx0XHRcdFx0XHRcdFx0cm93LFxuXHRcdFx0XHRcdFx0XHRzZWcubGVmdENvbCArIGosXG5cdFx0XHRcdFx0XHRcdFsgc2VnIF0uY29uY2F0KHNlZ3NCZWxvdykgLy8gY291bnQgc2VnIGFzIGhpZGRlbiB0b29cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRtb3JlV3JhcCA9ICQoJzxkaXYvPicpLmFwcGVuZChtb3JlTGluayk7XG5cdFx0XHRcdFx0XHRtb3JlVGQuYXBwZW5kKG1vcmVXcmFwKTtcblx0XHRcdFx0XHRcdHNlZ01vcmVOb2Rlcy5wdXNoKG1vcmVUZFswXSk7XG5cdFx0XHRcdFx0XHRtb3JlTm9kZXMucHVzaChtb3JlVGRbMF0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRkLmFkZENsYXNzKCdmYy1saW1pdGVkJykuYWZ0ZXIoJChzZWdNb3JlTm9kZXMpKTsgLy8gaGlkZSBvcmlnaW5hbCA8dGQ+IGFuZCBpbmplY3QgcmVwbGFjZW1lbnRzXG5cdFx0XHRcdFx0bGltaXRlZE5vZGVzLnB1c2godGRbMF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGVtcHR5Q2VsbHNVbnRpbCh0aGlzLmNvbENudCk7IC8vIGZpbmlzaCBvZmYgdGhlIGxldmVsXG5cdFx0XHRyb3dTdHJ1Y3QubW9yZUVscyA9ICQobW9yZU5vZGVzKTsgLy8gZm9yIGVhc3kgdW5kb2luZyBsYXRlclxuXHRcdFx0cm93U3RydWN0LmxpbWl0ZWRFbHMgPSAkKGxpbWl0ZWROb2Rlcyk7IC8vIGZvciBlYXN5IHVuZG9pbmcgbGF0ZXJcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBSZXZlYWxzIGFsbCBsZXZlbHMgYW5kIHJlbW92ZXMgYWxsIFwibW9yZVwiLXJlbGF0ZWQgZWxlbWVudHMgZm9yIGEgZ3JpZCdzIHJvdy5cblx0Ly8gYHJvd2AgaXMgYSByb3cgbnVtYmVyLlxuXHR1bmxpbWl0Um93OiBmdW5jdGlvbihyb3cpIHtcblx0XHR2YXIgcm93U3RydWN0ID0gdGhpcy5yb3dTdHJ1Y3RzW3Jvd107XG5cblx0XHRpZiAocm93U3RydWN0Lm1vcmVFbHMpIHtcblx0XHRcdHJvd1N0cnVjdC5tb3JlRWxzLnJlbW92ZSgpO1xuXHRcdFx0cm93U3RydWN0Lm1vcmVFbHMgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChyb3dTdHJ1Y3QubGltaXRlZEVscykge1xuXHRcdFx0cm93U3RydWN0LmxpbWl0ZWRFbHMucmVtb3ZlQ2xhc3MoJ2ZjLWxpbWl0ZWQnKTtcblx0XHRcdHJvd1N0cnVjdC5saW1pdGVkRWxzID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIGFuIDxhPiBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyBoaWRkZW4gZXZlbnQgZWxlbWVudCBmb3IgYSBjZWxsLlxuXHQvLyBSZXNwb25zaWJsZSBmb3IgYXR0YWNoaW5nIGNsaWNrIGhhbmRsZXIgYXMgd2VsbC5cblx0cmVuZGVyTW9yZUxpbms6IGZ1bmN0aW9uKHJvdywgY29sLCBoaWRkZW5TZWdzKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdHJldHVybiAkKCc8YSBjbGFzcz1cImZjLW1vcmVcIi8+Jylcblx0XHRcdC50ZXh0KFxuXHRcdFx0XHR0aGlzLmdldE1vcmVMaW5rVGV4dChoaWRkZW5TZWdzLmxlbmd0aClcblx0XHRcdClcblx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbihldikge1xuXHRcdFx0XHR2YXIgY2xpY2tPcHRpb24gPSB2aWV3Lm9wdCgnZXZlbnRMaW1pdENsaWNrJyk7XG5cdFx0XHRcdHZhciBkYXRlID0gX3RoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpO1xuXHRcdFx0XHR2YXIgbW9yZUVsID0gJCh0aGlzKTtcblx0XHRcdFx0dmFyIGRheUVsID0gX3RoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKTtcblx0XHRcdFx0dmFyIGFsbFNlZ3MgPSBfdGhpcy5nZXRDZWxsU2Vncyhyb3csIGNvbCk7XG5cblx0XHRcdFx0Ly8gcmVzY29wZSB0aGUgc2VnbWVudHMgdG8gYmUgd2l0aGluIHRoZSBjZWxsJ3MgZGF0ZVxuXHRcdFx0XHR2YXIgcmVzbGljZWRBbGxTZWdzID0gX3RoaXMucmVzbGljZURheVNlZ3MoYWxsU2VncywgZGF0ZSk7XG5cdFx0XHRcdHZhciByZXNsaWNlZEhpZGRlblNlZ3MgPSBfdGhpcy5yZXNsaWNlRGF5U2VncyhoaWRkZW5TZWdzLCBkYXRlKTtcblxuXHRcdFx0XHRpZiAodHlwZW9mIGNsaWNrT3B0aW9uID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Ly8gdGhlIHJldHVybmVkIHZhbHVlIGNhbiBiZSBhbiBhdG9taWMgb3B0aW9uXG5cdFx0XHRcdFx0Y2xpY2tPcHRpb24gPSB2aWV3LnB1YmxpY2x5VHJpZ2dlcignZXZlbnRMaW1pdENsaWNrJywgbnVsbCwge1xuXHRcdFx0XHRcdFx0ZGF0ZTogZGF0ZSxcblx0XHRcdFx0XHRcdGRheUVsOiBkYXlFbCxcblx0XHRcdFx0XHRcdG1vcmVFbDogbW9yZUVsLFxuXHRcdFx0XHRcdFx0c2VnczogcmVzbGljZWRBbGxTZWdzLFxuXHRcdFx0XHRcdFx0aGlkZGVuU2VnczogcmVzbGljZWRIaWRkZW5TZWdzXG5cdFx0XHRcdFx0fSwgZXYpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNsaWNrT3B0aW9uID09PSAncG9wb3ZlcicpIHtcblx0XHRcdFx0XHRfdGhpcy5zaG93U2VnUG9wb3Zlcihyb3csIGNvbCwgbW9yZUVsLCByZXNsaWNlZEFsbFNlZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBjbGlja09wdGlvbiA9PT0gJ3N0cmluZycpIHsgLy8gYSB2aWV3IG5hbWVcblx0XHRcdFx0XHR2aWV3LmNhbGVuZGFyLnpvb21UbyhkYXRlLCBjbGlja09wdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gUmV2ZWFscyB0aGUgcG9wb3ZlciB0aGF0IGRpc3BsYXlzIGFsbCBldmVudHMgd2l0aGluIGEgY2VsbFxuXHRzaG93U2VnUG9wb3ZlcjogZnVuY3Rpb24ocm93LCBjb2wsIG1vcmVMaW5rLCBzZWdzKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgbW9yZVdyYXAgPSBtb3JlTGluay5wYXJlbnQoKTsgLy8gdGhlIDxkaXY+IHdyYXBwZXIgYXJvdW5kIHRoZSA8YT5cblx0XHR2YXIgdG9wRWw7IC8vIHRoZSBlbGVtZW50IHdlIHdhbnQgdG8gbWF0Y2ggdGhlIHRvcCBjb29yZGluYXRlIG9mXG5cdFx0dmFyIG9wdGlvbnM7XG5cblx0XHRpZiAodGhpcy5yb3dDbnQgPT0gMSkge1xuXHRcdFx0dG9wRWwgPSB2aWV3LmVsOyAvLyB3aWxsIGNhdXNlIHRoZSBwb3BvdmVyIHRvIGNvdmVyIGFueSBzb3J0IG9mIGhlYWRlclxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRvcEVsID0gdGhpcy5yb3dFbHMuZXEocm93KTsgLy8gd2lsbCBhbGlnbiB3aXRoIHRvcCBvZiByb3dcblx0XHR9XG5cblx0XHRvcHRpb25zID0ge1xuXHRcdFx0Y2xhc3NOYW1lOiAnZmMtbW9yZS1wb3BvdmVyJyxcblx0XHRcdGNvbnRlbnQ6IHRoaXMucmVuZGVyU2VnUG9wb3ZlckNvbnRlbnQocm93LCBjb2wsIHNlZ3MpLFxuXHRcdFx0cGFyZW50RWw6IHRoaXMudmlldy5lbCwgLy8gYXR0YWNoIHRvIHJvb3Qgb2Ygdmlldy4gZ3VhcmFudGVlcyBvdXRzaWRlIG9mIHNjcm9sbGJhcnMuXG5cdFx0XHR0b3A6IHRvcEVsLm9mZnNldCgpLnRvcCxcblx0XHRcdGF1dG9IaWRlOiB0cnVlLCAvLyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBlbHNld2hlcmUsIGhpZGUgdGhlIHBvcG92ZXJcblx0XHRcdHZpZXdwb3J0Q29uc3RyYWluOiB2aWV3Lm9wdCgncG9wb3ZlclZpZXdwb3J0Q29uc3RyYWluJyksXG5cdFx0XHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8ga2lsbCBldmVyeXRoaW5nIHdoZW4gdGhlIHBvcG92ZXIgaXMgaGlkZGVuXG5cdFx0XHRcdC8vIG5vdGlmeSBldmVudHMgdG8gYmUgcmVtb3ZlZFxuXHRcdFx0XHRpZiAoX3RoaXMucG9wb3ZlclNlZ3MpIHtcblx0XHRcdFx0XHR2YXIgc2VnO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMucG9wb3ZlclNlZ3MubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRcdHNlZyA9IF90aGlzLnBvcG92ZXJTZWdzW2ldO1xuXHRcdFx0XHRcdFx0dmlldy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RGVzdHJveScsIHNlZy5ldmVudCwgc2VnLmV2ZW50LCBzZWcuZWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfdGhpcy5zZWdQb3BvdmVyLnJlbW92ZUVsZW1lbnQoKTtcblx0XHRcdFx0X3RoaXMuc2VnUG9wb3ZlciA9IG51bGw7XG5cdFx0XHRcdF90aGlzLnBvcG92ZXJTZWdzID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhvcml6b250YWwgY29vcmRpbmF0ZS5cblx0XHQvLyBXZSB1c2UgdGhlIG1vcmVXcmFwIGluc3RlYWQgb2YgdGhlIDx0ZD4gdG8gYXZvaWQgYm9yZGVyIGNvbmZ1c2lvbi5cblx0XHRpZiAodGhpcy5pc1JUTCkge1xuXHRcdFx0b3B0aW9ucy5yaWdodCA9IG1vcmVXcmFwLm9mZnNldCgpLmxlZnQgKyBtb3JlV3JhcC5vdXRlcldpZHRoKCkgKyAxOyAvLyArMSB0byBiZSBvdmVyIGNlbGwgYm9yZGVyXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0b3B0aW9ucy5sZWZ0ID0gbW9yZVdyYXAub2Zmc2V0KCkubGVmdCAtIDE7IC8vIC0xIHRvIGJlIG92ZXIgY2VsbCBib3JkZXJcblx0XHR9XG5cblx0XHR0aGlzLnNlZ1BvcG92ZXIgPSBuZXcgUG9wb3ZlcihvcHRpb25zKTtcblx0XHR0aGlzLnNlZ1BvcG92ZXIuc2hvdygpO1xuXG5cdFx0Ly8gdGhlIHBvcG92ZXIgZG9lc24ndCBsaXZlIHdpdGhpbiB0aGUgZ3JpZCdzIGNvbnRhaW5lciBlbGVtZW50LCBhbmQgdGh1cyB3b24ndCBnZXQgdGhlIGV2ZW50XG5cdFx0Ly8gZGVsZWdhdGVkLWhhbmRsZXJzIGZvciBmcmVlLiBhdHRhY2ggZXZlbnQtcmVsYXRlZCBoYW5kbGVycyB0byB0aGUgcG9wb3Zlci5cblx0XHR0aGlzLmJpbmRTZWdIYW5kbGVyc1RvRWwodGhpcy5zZWdQb3BvdmVyLmVsKTtcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyB0aGUgaW5uZXIgRE9NIGNvbnRlbnRzIG9mIHRoZSBzZWdtZW50IHBvcG92ZXJcblx0cmVuZGVyU2VnUG9wb3ZlckNvbnRlbnQ6IGZ1bmN0aW9uKHJvdywgY29sLCBzZWdzKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGlzVGhlbWUgPSB2aWV3Lm9wdCgndGhlbWUnKTtcblx0XHR2YXIgdGl0bGUgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKS5mb3JtYXQodmlldy5vcHQoJ2RheVBvcG92ZXJGb3JtYXQnKSk7XG5cdFx0dmFyIGNvbnRlbnQgPSAkKFxuXHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1oZWFkZXIgJyArIHZpZXcud2lkZ2V0SGVhZGVyQ2xhc3MgKyAnXCI+JyArXG5cdFx0XHRcdCc8c3BhbiBjbGFzcz1cImZjLWNsb3NlICcgK1xuXHRcdFx0XHRcdChpc1RoZW1lID8gJ3VpLWljb24gdWktaWNvbi1jbG9zZXRoaWNrJyA6ICdmYy1pY29uIGZjLWljb24teCcpICtcblx0XHRcdFx0J1wiPjwvc3Bhbj4nICtcblx0XHRcdFx0JzxzcGFuIGNsYXNzPVwiZmMtdGl0bGVcIj4nICtcblx0XHRcdFx0XHRodG1sRXNjYXBlKHRpdGxlKSArXG5cdFx0XHRcdCc8L3NwYW4+JyArXG5cdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtY2xlYXJcIi8+JyArXG5cdFx0XHQnPC9kaXY+JyArXG5cdFx0XHQnPGRpdiBjbGFzcz1cImZjLWJvZHkgJyArIHZpZXcud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiPjwvZGl2PicgK1xuXHRcdFx0JzwvZGl2Pidcblx0XHQpO1xuXHRcdHZhciBzZWdDb250YWluZXIgPSBjb250ZW50LmZpbmQoJy5mYy1ldmVudC1jb250YWluZXInKTtcblx0XHR2YXIgaTtcblxuXHRcdC8vIHJlbmRlciBlYWNoIHNlZydzIGBlbGAgYW5kIG9ubHkgcmV0dXJuIHRoZSB2aXNpYmxlIHNlZ3Ncblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ0VscyhzZWdzLCB0cnVlKTsgLy8gZGlzYWJsZVJlc2l6aW5nPXRydWVcblx0XHR0aGlzLnBvcG92ZXJTZWdzID0gc2VncztcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cblx0XHRcdC8vIGJlY2F1c2Ugc2VnbWVudHMgaW4gdGhlIHBvcG92ZXIgYXJlIG5vdCBwYXJ0IG9mIGEgZ3JpZCBjb29yZGluYXRlIHN5c3RlbSwgcHJvdmlkZSBhIGhpbnQgdG8gYW55XG5cdFx0XHQvLyBncmlkcyB0aGF0IHdhbnQgdG8gZG8gZHJhZy1uLWRyb3AgYWJvdXQgd2hpY2ggY2VsbCBpdCBjYW1lIGZyb21cblx0XHRcdHRoaXMuaGl0c05lZWRlZCgpO1xuXHRcdFx0c2Vnc1tpXS5oaXQgPSB0aGlzLmdldENlbGxIaXQocm93LCBjb2wpO1xuXHRcdFx0dGhpcy5oaXRzTm90TmVlZGVkKCk7XG5cblx0XHRcdHNlZ0NvbnRhaW5lci5hcHBlbmQoc2Vnc1tpXS5lbCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiB0aGUgZXZlbnRzIHdpdGhpbiBhbiBhcnJheSBvZiBzZWdtZW50IG9iamVjdHMsIHJlc2xpY2UgdGhlbSB0byBiZSBpbiBhIHNpbmdsZSBkYXlcblx0cmVzbGljZURheVNlZ3M6IGZ1bmN0aW9uKHNlZ3MsIGRheURhdGUpIHtcblxuXHRcdC8vIGJ1aWxkIGFuIGFycmF5IG9mIHRoZSBvcmlnaW5hbCBldmVudHNcblx0XHR2YXIgZXZlbnRzID0gJC5tYXAoc2VncywgZnVuY3Rpb24oc2VnKSB7XG5cdFx0XHRyZXR1cm4gc2VnLmV2ZW50O1xuXHRcdH0pO1xuXG5cdFx0dmFyIGRheVN0YXJ0ID0gZGF5RGF0ZS5jbG9uZSgpO1xuXHRcdHZhciBkYXlFbmQgPSBkYXlTdGFydC5jbG9uZSgpLmFkZCgxLCAnZGF5cycpO1xuXHRcdHZhciBkYXlSYW5nZSA9IHsgc3RhcnQ6IGRheVN0YXJ0LCBlbmQ6IGRheUVuZCB9O1xuXG5cdFx0Ly8gc2xpY2UgdGhlIGV2ZW50cyB3aXRoIGEgY3VzdG9tIHNsaWNpbmcgZnVuY3Rpb25cblx0XHRzZWdzID0gdGhpcy5ldmVudHNUb1NlZ3MoXG5cdFx0XHRldmVudHMsXG5cdFx0XHRmdW5jdGlvbihyYW5nZSkge1xuXHRcdFx0XHR2YXIgc2VnID0gaW50ZXJzZWN0UmFuZ2VzKHJhbmdlLCBkYXlSYW5nZSk7IC8vIHVuZGVmaW5kIGlmIG5vIGludGVyc2VjdGlvblxuXHRcdFx0XHRyZXR1cm4gc2VnID8gWyBzZWcgXSA6IFtdOyAvLyBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBzZWdtZW50c1xuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHQvLyBmb3JjZSBhbiBvcmRlciBiZWNhdXNlIGV2ZW50c1RvU2VncyBkb2Vzbid0IGd1YXJhbnRlZSBvbmVcblx0XHR0aGlzLnNvcnRFdmVudFNlZ3Moc2Vncyk7XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgdGV4dCB0aGF0IHNob3VsZCBiZSBpbnNpZGUgYSBcIm1vcmVcIiBsaW5rLCBnaXZlbiB0aGUgbnVtYmVyIG9mIGV2ZW50cyBpdCByZXByZXNlbnRzXG5cdGdldE1vcmVMaW5rVGV4dDogZnVuY3Rpb24obnVtKSB7XG5cdFx0dmFyIG9wdCA9IHRoaXMudmlldy5vcHQoJ2V2ZW50TGltaXRUZXh0Jyk7XG5cblx0XHRpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIG9wdChudW0pO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiAnKycgKyBudW0gKyAnICcgKyBvcHQ7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmV0dXJucyBzZWdtZW50cyB3aXRoaW4gYSBnaXZlbiBjZWxsLlxuXHQvLyBJZiBgc3RhcnRMZXZlbGAgaXMgc3BlY2lmaWVkLCByZXR1cm5zIG9ubHkgZXZlbnRzIGluY2x1ZGluZyBhbmQgYmVsb3cgdGhhdCBsZXZlbC4gT3RoZXJ3aXNlIHJldHVybnMgYWxsIHNlZ3MuXG5cdGdldENlbGxTZWdzOiBmdW5jdGlvbihyb3csIGNvbCwgc3RhcnRMZXZlbCkge1xuXHRcdHZhciBzZWdNYXRyaXggPSB0aGlzLnJvd1N0cnVjdHNbcm93XS5zZWdNYXRyaXg7XG5cdFx0dmFyIGxldmVsID0gc3RhcnRMZXZlbCB8fCAwO1xuXHRcdHZhciBzZWdzID0gW107XG5cdFx0dmFyIHNlZztcblxuXHRcdHdoaWxlIChsZXZlbCA8IHNlZ01hdHJpeC5sZW5ndGgpIHtcblx0XHRcdHNlZyA9IHNlZ01hdHJpeFtsZXZlbF1bY29sXTtcblx0XHRcdGlmIChzZWcpIHtcblx0XHRcdFx0c2Vncy5wdXNoKHNlZyk7XG5cdFx0XHR9XG5cdFx0XHRsZXZlbCsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9XG5cbn0pO1xuXG47O1xuXG4vKiBBIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgb25lIG9yIG1vcmUgY29sdW1ucyBvZiB2ZXJ0aWNhbCB0aW1lIHNsb3RzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIFdlIG1peGluIERheVRhYmxlLCBldmVuIHRob3VnaCB0aGVyZSBpcyBvbmx5IGEgc2luZ2xlIHJvdyBvZiBkYXlzXG5cbnZhciBUaW1lR3JpZCA9IEZDLlRpbWVHcmlkID0gR3JpZC5leHRlbmQoRGF5VGFibGVNaXhpbiwge1xuXG5cdHNsb3REdXJhdGlvbjogbnVsbCwgLy8gZHVyYXRpb24gb2YgYSBcInNsb3RcIiwgYSBkaXN0aW5jdCB0aW1lIHNlZ21lbnQgb24gZ2l2ZW4gZGF5LCB2aXN1YWxpemVkIGJ5IGxpbmVzXG5cdHNuYXBEdXJhdGlvbjogbnVsbCwgLy8gZ3JhbnVsYXJpdHkgb2YgdGltZSBmb3IgZHJhZ2dpbmcgYW5kIHNlbGVjdGluZ1xuXHRzbmFwc1BlclNsb3Q6IG51bGwsXG5cdGxhYmVsRm9ybWF0OiBudWxsLCAvLyBmb3JtYXR0aW5nIHN0cmluZyBmb3IgdGltZXMgcnVubmluZyBhbG9uZyB2ZXJ0aWNhbCBheGlzXG5cdGxhYmVsSW50ZXJ2YWw6IG51bGwsIC8vIGR1cmF0aW9uIG9mIGhvdyBvZnRlbiBhIGxhYmVsIHNob3VsZCBiZSBkaXNwbGF5ZWQgZm9yIGEgc2xvdFxuXG5cdGNvbEVsczogbnVsbCwgLy8gY2VsbHMgZWxlbWVudHMgaW4gdGhlIGRheS1yb3cgYmFja2dyb3VuZFxuXHRzbGF0Q29udGFpbmVyRWw6IG51bGwsIC8vIGRpdiB0aGF0IHdyYXBzIGFsbCB0aGUgc2xhdCByb3dzXG5cdHNsYXRFbHM6IG51bGwsIC8vIGVsZW1lbnRzIHJ1bm5pbmcgaG9yaXpvbnRhbGx5IGFjcm9zcyBhbGwgY29sdW1uc1xuXHRub3dJbmRpY2F0b3JFbHM6IG51bGwsXG5cblx0Y29sQ29vcmRDYWNoZTogbnVsbCxcblx0c2xhdENvb3JkQ2FjaGU6IG51bGwsXG5cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG5cdFx0R3JpZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1jb25zdHJ1Y3RvclxuXG5cdFx0dGhpcy5wcm9jZXNzT3B0aW9ucygpO1xuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgdGltZSBncmlkIGludG8gYHRoaXMuZWxgLCB3aGljaCBzaG91bGQgYWxyZWFkeSBiZSBhc3NpZ25lZC5cblx0Ly8gUmVsaWVzIG9uIHRoZSB2aWV3J3MgY29sQ250LiBJbiB0aGUgZnV0dXJlLCB0aGlzIGNvbXBvbmVudCBzaG91bGQgcHJvYmFibHkgYmUgc2VsZi1zdWZmaWNpZW50LlxuXHRyZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbC5odG1sKHRoaXMucmVuZGVySHRtbCgpKTtcblx0XHR0aGlzLmNvbEVscyA9IHRoaXMuZWwuZmluZCgnLmZjLWRheSwgLmZjLWRpc2FibGVkLWRheScpO1xuXHRcdHRoaXMuc2xhdENvbnRhaW5lckVsID0gdGhpcy5lbC5maW5kKCcuZmMtc2xhdHMnKTtcblx0XHR0aGlzLnNsYXRFbHMgPSB0aGlzLnNsYXRDb250YWluZXJFbC5maW5kKCd0cicpO1xuXG5cdFx0dGhpcy5jb2xDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGUoe1xuXHRcdFx0ZWxzOiB0aGlzLmNvbEVscyxcblx0XHRcdGlzSG9yaXpvbnRhbDogdHJ1ZVxuXHRcdH0pO1xuXHRcdHRoaXMuc2xhdENvb3JkQ2FjaGUgPSBuZXcgQ29vcmRDYWNoZSh7XG5cdFx0XHRlbHM6IHRoaXMuc2xhdEVscyxcblx0XHRcdGlzVmVydGljYWw6IHRydWVcblx0XHR9KTtcblxuXHRcdHRoaXMucmVuZGVyQ29udGVudFNrZWxldG9uKCk7XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBiYXNpYyBIVE1MIHNrZWxldG9uIGZvciB0aGUgZ3JpZFxuXHRyZW5kZXJIdG1sOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1iZ1wiPicgK1xuXHRcdFx0XHQnPHRhYmxlPicgK1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyQmdUckh0bWwoMCkgKyAvLyByb3c9MFxuXHRcdFx0XHQnPC90YWJsZT4nICtcblx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtc2xhdHNcIj4nICtcblx0XHRcdFx0Jzx0YWJsZT4nICtcblx0XHRcdFx0XHR0aGlzLnJlbmRlclNsYXRSb3dIdG1sKCkgK1xuXHRcdFx0XHQnPC90YWJsZT4nICtcblx0XHRcdCc8L2Rpdj4nO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgaG9yaXpvbnRhbCBcInNsYXRzXCIgdGhhdCBydW4gd2lkdGgtd2lzZS4gSGFzIGEgdGltZSBheGlzIG9uIGEgc2lkZS4gRGVwZW5kcyBvbiBSVEwuXG5cdHJlbmRlclNsYXRSb3dIdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgaXNSVEwgPSB0aGlzLmlzUlRMO1xuXHRcdHZhciBodG1sID0gJyc7XG5cdFx0dmFyIHNsb3RUaW1lID0gbW9tZW50LmR1cmF0aW9uKCt0aGlzLnZpZXcubWluVGltZSk7IC8vIHdpc2ggdGhlcmUgd2FzIC5jbG9uZSgpIGZvciBkdXJhdGlvbnNcblx0XHR2YXIgc2xvdERhdGU7IC8vIHdpbGwgYmUgb24gdGhlIHZpZXcncyBmaXJzdCBkYXksIGJ1dCB3ZSBvbmx5IGNhcmUgYWJvdXQgaXRzIHRpbWVcblx0XHR2YXIgaXNMYWJlbGVkO1xuXHRcdHZhciBheGlzSHRtbDtcblxuXHRcdC8vIENhbGN1bGF0ZSB0aGUgdGltZSBmb3IgZWFjaCBzbG90XG5cdFx0d2hpbGUgKHNsb3RUaW1lIDwgdGhpcy52aWV3Lm1heFRpbWUpIHtcblx0XHRcdHNsb3REYXRlID0gdGhpcy5zdGFydC5jbG9uZSgpLnRpbWUoc2xvdFRpbWUpO1xuXHRcdFx0aXNMYWJlbGVkID0gaXNJbnQoZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uKHNsb3RUaW1lLCB0aGlzLmxhYmVsSW50ZXJ2YWwpKTtcblxuXHRcdFx0YXhpc0h0bWwgPVxuXHRcdFx0XHQnPHRkIGNsYXNzPVwiZmMtYXhpcyBmYy10aW1lICcgKyB2aWV3LndpZGdldENvbnRlbnRDbGFzcyArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPicgK1xuXHRcdFx0XHRcdChpc0xhYmVsZWQgP1xuXHRcdFx0XHRcdFx0JzxzcGFuPicgKyAvLyBmb3IgbWF0Y2hDZWxsV2lkdGhzXG5cdFx0XHRcdFx0XHRcdGh0bWxFc2NhcGUoc2xvdERhdGUuZm9ybWF0KHRoaXMubGFiZWxGb3JtYXQpKSArXG5cdFx0XHRcdFx0XHQnPC9zcGFuPicgOlxuXHRcdFx0XHRcdFx0Jydcblx0XHRcdFx0XHRcdCkgK1xuXHRcdFx0XHQnPC90ZD4nO1xuXG5cdFx0XHRodG1sICs9XG5cdFx0XHRcdCc8dHIgZGF0YS10aW1lPVwiJyArIHNsb3REYXRlLmZvcm1hdCgnSEg6bW06c3MnKSArICdcIicgK1xuXHRcdFx0XHRcdChpc0xhYmVsZWQgPyAnJyA6ICcgY2xhc3M9XCJmYy1taW5vclwiJykgK1xuXHRcdFx0XHRcdCc+JyArXG5cdFx0XHRcdFx0KCFpc1JUTCA/IGF4aXNIdG1sIDogJycpICtcblx0XHRcdFx0XHQnPHRkIGNsYXNzPVwiJyArIHZpZXcud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiLz4nICtcblx0XHRcdFx0XHQoaXNSVEwgPyBheGlzSHRtbCA6ICcnKSArXG5cdFx0XHRcdFwiPC90cj5cIjtcblxuXHRcdFx0c2xvdFRpbWUuYWRkKHRoaXMuc2xvdER1cmF0aW9uKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXG5cdC8qIE9wdGlvbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFBhcnNlcyB2YXJpb3VzIG9wdGlvbnMgaW50byBwcm9wZXJ0aWVzIG9mIHRoaXMgb2JqZWN0XG5cdHByb2Nlc3NPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgc2xvdER1cmF0aW9uID0gdmlldy5vcHQoJ3Nsb3REdXJhdGlvbicpO1xuXHRcdHZhciBzbmFwRHVyYXRpb24gPSB2aWV3Lm9wdCgnc25hcER1cmF0aW9uJyk7XG5cdFx0dmFyIGlucHV0O1xuXG5cdFx0c2xvdER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKHNsb3REdXJhdGlvbik7XG5cdFx0c25hcER1cmF0aW9uID0gc25hcER1cmF0aW9uID8gbW9tZW50LmR1cmF0aW9uKHNuYXBEdXJhdGlvbikgOiBzbG90RHVyYXRpb247XG5cblx0XHR0aGlzLnNsb3REdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcblx0XHR0aGlzLnNuYXBEdXJhdGlvbiA9IHNuYXBEdXJhdGlvbjtcblx0XHR0aGlzLnNuYXBzUGVyU2xvdCA9IHNsb3REdXJhdGlvbiAvIHNuYXBEdXJhdGlvbjsgLy8gVE9ETzogZW5zdXJlIGFuIGludGVnZXIgbXVsdGlwbGU/XG5cblx0XHR0aGlzLm1pblJlc2l6ZUR1cmF0aW9uID0gc25hcER1cmF0aW9uOyAvLyBoYWNrXG5cblx0XHQvLyBtaWdodCBiZSBhbiBhcnJheSB2YWx1ZSAoZm9yIFRpbWVsaW5lVmlldykuXG5cdFx0Ly8gaWYgc28sIGdldHRpbmcgdGhlIG1vc3QgZ3JhbnVsYXIgZW50cnkgKHRoZSBsYXN0IG9uZSBwcm9iYWJseSkuXG5cdFx0aW5wdXQgPSB2aWV3Lm9wdCgnc2xvdExhYmVsRm9ybWF0Jyk7XG5cdFx0aWYgKCQuaXNBcnJheShpbnB1dCkpIHtcblx0XHRcdGlucHV0ID0gaW5wdXRbaW5wdXQubGVuZ3RoIC0gMV07XG5cdFx0fVxuXG5cdFx0dGhpcy5sYWJlbEZvcm1hdCA9XG5cdFx0XHRpbnB1dCB8fFxuXHRcdFx0dmlldy5vcHQoJ3NtYWxsVGltZUZvcm1hdCcpOyAvLyB0aGUgY29tcHV0ZWQgZGVmYXVsdFxuXG5cdFx0aW5wdXQgPSB2aWV3Lm9wdCgnc2xvdExhYmVsSW50ZXJ2YWwnKTtcblx0XHR0aGlzLmxhYmVsSW50ZXJ2YWwgPSBpbnB1dCA/XG5cdFx0XHRtb21lbnQuZHVyYXRpb24oaW5wdXQpIDpcblx0XHRcdHRoaXMuY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGFuIGF1dG9tYXRpYyB2YWx1ZSBmb3Igc2xvdExhYmVsSW50ZXJ2YWxcblx0Y29tcHV0ZUxhYmVsSW50ZXJ2YWw6IGZ1bmN0aW9uKHNsb3REdXJhdGlvbikge1xuXHRcdHZhciBpO1xuXHRcdHZhciBsYWJlbEludGVydmFsO1xuXHRcdHZhciBzbG90c1BlckxhYmVsO1xuXG5cdFx0Ly8gZmluZCB0aGUgc21hbGxlc3Qgc3RvY2sgbGFiZWwgaW50ZXJ2YWwgdGhhdCByZXN1bHRzIGluIG1vcmUgdGhhbiBvbmUgc2xvdHMtcGVyLWxhYmVsXG5cdFx0Zm9yIChpID0gQUdFTkRBX1NUT0NLX1NVQl9EVVJBVElPTlMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGxhYmVsSW50ZXJ2YWwgPSBtb21lbnQuZHVyYXRpb24oQUdFTkRBX1NUT0NLX1NVQl9EVVJBVElPTlNbaV0pO1xuXHRcdFx0c2xvdHNQZXJMYWJlbCA9IGRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbihsYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24pO1xuXHRcdFx0aWYgKGlzSW50KHNsb3RzUGVyTGFiZWwpICYmIHNsb3RzUGVyTGFiZWwgPiAxKSB7XG5cdFx0XHRcdHJldHVybiBsYWJlbEludGVydmFsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtb21lbnQuZHVyYXRpb24oc2xvdER1cmF0aW9uKTsgLy8gZmFsbCBiYWNrLiBjbG9uZVxuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgYSBkZWZhdWx0IGV2ZW50IHRpbWUgZm9ybWF0dGluZyBzdHJpbmcgaWYgYHRpbWVGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcblx0Y29tcHV0ZUV2ZW50VGltZUZvcm1hdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudmlldy5vcHQoJ25vTWVyaWRpZW1UaW1lRm9ybWF0Jyk7IC8vIGxpa2UgXCI2OjMwXCIgKG5vIEFNL1BNKVxuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgYSBkZWZhdWx0IGBkaXNwbGF5RXZlbnRFbmRgIHZhbHVlIGlmIG9uZSBpcyBub3QgZXhwbGljbHR5IGRlZmluZWRcblx0Y29tcHV0ZURpc3BsYXlFdmVudEVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblxuXHQvKiBIaXQgU3lzdGVtXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRwcmVwYXJlSGl0czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jb2xDb29yZENhY2hlLmJ1aWxkKCk7XG5cdFx0dGhpcy5zbGF0Q29vcmRDYWNoZS5idWlsZCgpO1xuXHR9LFxuXG5cblx0cmVsZWFzZUhpdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29sQ29vcmRDYWNoZS5jbGVhcigpO1xuXHRcdC8vIE5PVEU6IGRvbid0IGNsZWFyIHNsYXRDb29yZENhY2hlIGJlY2F1c2Ugd2UgcmVseSBvbiBpdCBmb3IgY29tcHV0ZVRpbWVUb3Bcblx0fSxcblxuXG5cdHF1ZXJ5SGl0OiBmdW5jdGlvbihsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpIHtcblx0XHR2YXIgc25hcHNQZXJTbG90ID0gdGhpcy5zbmFwc1BlclNsb3Q7XG5cdFx0dmFyIGNvbENvb3JkQ2FjaGUgPSB0aGlzLmNvbENvb3JkQ2FjaGU7XG5cdFx0dmFyIHNsYXRDb29yZENhY2hlID0gdGhpcy5zbGF0Q29vcmRDYWNoZTtcblxuXHRcdGlmIChjb2xDb29yZENhY2hlLmlzTGVmdEluQm91bmRzKGxlZnRPZmZzZXQpICYmIHNsYXRDb29yZENhY2hlLmlzVG9wSW5Cb3VuZHModG9wT2Zmc2V0KSkge1xuXHRcdFx0dmFyIGNvbEluZGV4ID0gY29sQ29vcmRDYWNoZS5nZXRIb3Jpem9udGFsSW5kZXgobGVmdE9mZnNldCk7XG5cdFx0XHR2YXIgc2xhdEluZGV4ID0gc2xhdENvb3JkQ2FjaGUuZ2V0VmVydGljYWxJbmRleCh0b3BPZmZzZXQpO1xuXG5cdFx0XHRpZiAoY29sSW5kZXggIT0gbnVsbCAmJiBzbGF0SW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgc2xhdFRvcCA9IHNsYXRDb29yZENhY2hlLmdldFRvcE9mZnNldChzbGF0SW5kZXgpO1xuXHRcdFx0XHR2YXIgc2xhdEhlaWdodCA9IHNsYXRDb29yZENhY2hlLmdldEhlaWdodChzbGF0SW5kZXgpO1xuXHRcdFx0XHR2YXIgcGFydGlhbCA9ICh0b3BPZmZzZXQgLSBzbGF0VG9wKSAvIHNsYXRIZWlnaHQ7IC8vIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcblx0XHRcdFx0dmFyIGxvY2FsU25hcEluZGV4ID0gTWF0aC5mbG9vcihwYXJ0aWFsICogc25hcHNQZXJTbG90KTsgLy8gdGhlIHNuYXAgIyByZWxhdGl2ZSB0byBzdGFydCBvZiBzbGF0XG5cdFx0XHRcdHZhciBzbmFwSW5kZXggPSBzbGF0SW5kZXggKiBzbmFwc1BlclNsb3QgKyBsb2NhbFNuYXBJbmRleDtcblx0XHRcdFx0dmFyIHNuYXBUb3AgPSBzbGF0VG9wICsgKGxvY2FsU25hcEluZGV4IC8gc25hcHNQZXJTbG90KSAqIHNsYXRIZWlnaHQ7XG5cdFx0XHRcdHZhciBzbmFwQm90dG9tID0gc2xhdFRvcCArICgobG9jYWxTbmFwSW5kZXggKyAxKSAvIHNuYXBzUGVyU2xvdCkgKiBzbGF0SGVpZ2h0O1xuXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Y29sOiBjb2xJbmRleCxcblx0XHRcdFx0XHRzbmFwOiBzbmFwSW5kZXgsXG5cdFx0XHRcdFx0Y29tcG9uZW50OiB0aGlzLCAvLyBuZWVkZWQgdW5mb3J0dW5hdGVseSA6KFxuXHRcdFx0XHRcdGxlZnQ6IGNvbENvb3JkQ2FjaGUuZ2V0TGVmdE9mZnNldChjb2xJbmRleCksXG5cdFx0XHRcdFx0cmlnaHQ6IGNvbENvb3JkQ2FjaGUuZ2V0UmlnaHRPZmZzZXQoY29sSW5kZXgpLFxuXHRcdFx0XHRcdHRvcDogc25hcFRvcCxcblx0XHRcdFx0XHRib3R0b206IHNuYXBCb3R0b21cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHRnZXRIaXRTcGFuOiBmdW5jdGlvbihoaXQpIHtcblx0XHR2YXIgc3RhcnQgPSB0aGlzLmdldENlbGxEYXRlKDAsIGhpdC5jb2wpOyAvLyByb3c9MFxuXHRcdHZhciB0aW1lID0gdGhpcy5jb21wdXRlU25hcFRpbWUoaGl0LnNuYXApOyAvLyBwYXNzIGluIHRoZSBzbmFwLWluZGV4XG5cdFx0dmFyIGVuZDtcblxuXHRcdHN0YXJ0LnRpbWUodGltZSk7XG5cdFx0ZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQodGhpcy5zbmFwRHVyYXRpb24pO1xuXG5cdFx0cmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuXHR9LFxuXG5cblx0Z2V0SGl0RWw6IGZ1bmN0aW9uKGhpdCkge1xuXHRcdHJldHVybiB0aGlzLmNvbEVscy5lcShoaXQuY29sKTtcblx0fSxcblxuXG5cdC8qIERhdGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyYW5nZVVwZGF0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlRGF5VGFibGUoKTtcblx0fSxcblxuXG5cdC8vIEdpdmVuIGEgcm93IG51bWJlciBvZiB0aGUgZ3JpZCwgcmVwcmVzZW50aW5nIGEgXCJzbmFwXCIsIHJldHVybnMgYSB0aW1lIChEdXJhdGlvbikgZnJvbSBpdHMgc3RhcnQtb2YtZGF5XG5cdGNvbXB1dGVTbmFwVGltZTogZnVuY3Rpb24oc25hcEluZGV4KSB7XG5cdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbih0aGlzLnZpZXcubWluVGltZSArIHRoaXMuc25hcER1cmF0aW9uICogc25hcEluZGV4KTtcblx0fSxcblxuXG5cdC8vIFNsaWNlcyB1cCB0aGUgZ2l2ZW4gc3BhbiAodW56b25lZCBzdGFydC9lbmQgd2l0aCBvdGhlciBtaXNjIGRhdGEpIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcblx0c3BhblRvU2VnczogZnVuY3Rpb24oc3Bhbikge1xuXHRcdHZhciBzZWdzID0gdGhpcy5zbGljZVJhbmdlQnlUaW1lcyhzcGFuKTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5pc1JUTCkge1xuXHRcdFx0XHRzZWdzW2ldLmNvbCA9IHRoaXMuZGF5c1BlclJvdyAtIDEgLSBzZWdzW2ldLmRheUluZGV4O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNlZ3NbaV0uY29sID0gc2Vnc1tpXS5kYXlJbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdHNsaWNlUmFuZ2VCeVRpbWVzOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdHZhciBzZWdzID0gW107XG5cdFx0dmFyIHNlZztcblx0XHR2YXIgZGF5SW5kZXg7XG5cdFx0dmFyIGRheURhdGU7XG5cdFx0dmFyIGRheVJhbmdlO1xuXG5cdFx0Zm9yIChkYXlJbmRleCA9IDA7IGRheUluZGV4IDwgdGhpcy5kYXlzUGVyUm93OyBkYXlJbmRleCsrKSB7XG5cdFx0XHRkYXlEYXRlID0gdGhpcy5kYXlEYXRlc1tkYXlJbmRleF0uY2xvbmUoKS50aW1lKDApOyAvLyBUT0RPOiBiZXR0ZXIgQVBJIGZvciB0aGlzP1xuXHRcdFx0ZGF5UmFuZ2UgPSB7XG5cdFx0XHRcdHN0YXJ0OiBkYXlEYXRlLmNsb25lKCkuYWRkKHRoaXMudmlldy5taW5UaW1lKSwgLy8gZG9uJ3QgdXNlIC50aW1lKCkgYmVjYXVzZSBpdCBzdXggd2l0aCBuZWdhdGl2ZXNcblx0XHRcdFx0ZW5kOiBkYXlEYXRlLmNsb25lKCkuYWRkKHRoaXMudmlldy5tYXhUaW1lKVxuXHRcdFx0fTtcblx0XHRcdHNlZyA9IGludGVyc2VjdFJhbmdlcyhyYW5nZSwgZGF5UmFuZ2UpOyAvLyBib3RoIHdpbGwgYmUgYW1iaWcgdGltZXpvbmVcblx0XHRcdGlmIChzZWcpIHtcblx0XHRcdFx0c2VnLmRheUluZGV4ID0gZGF5SW5kZXg7XG5cdFx0XHRcdHNlZ3MucHVzaChzZWcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0LyogQ29vcmRpbmF0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHVwZGF0ZVNpemU6IGZ1bmN0aW9uKGlzUmVzaXplKSB7IC8vIE5PVCBhIHN0YW5kYXJkIEdyaWQgbWV0aG9kXG5cdFx0dGhpcy5zbGF0Q29vcmRDYWNoZS5idWlsZCgpO1xuXG5cdFx0aWYgKGlzUmVzaXplKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVNlZ1ZlcnRpY2Fscyhcblx0XHRcdFx0W10uY29uY2F0KHRoaXMuZmdTZWdzIHx8IFtdLCB0aGlzLmJnU2VncyB8fCBbXSwgdGhpcy5idXNpbmVzc1NlZ3MgfHwgW10pXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblxuXG5cdGdldFRvdGFsU2xhdEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2xhdENvbnRhaW5lckVsLm91dGVySGVpZ2h0KCk7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiBkYXRlLlxuXHQvLyBBIGBzdGFydE9mRGF5RGF0ZWAgbXVzdCBiZSBnaXZlbiBmb3IgYXZvaWRpbmcgYW1iaWd1aXR5IG92ZXIgaG93IHRvIHRyZWF0IG1pZG5pZ2h0LlxuXHRjb21wdXRlRGF0ZVRvcDogZnVuY3Rpb24oZGF0ZSwgc3RhcnRPZkRheURhdGUpIHtcblx0XHRyZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChcblx0XHRcdG1vbWVudC5kdXJhdGlvbihcblx0XHRcdFx0ZGF0ZSAtIHN0YXJ0T2ZEYXlEYXRlLmNsb25lKCkuc3RyaXBUaW1lKClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gdGltZSAoYSBEdXJhdGlvbikuXG5cdGNvbXB1dGVUaW1lVG9wOiBmdW5jdGlvbih0aW1lKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMuc2xhdEVscy5sZW5ndGg7XG5cdFx0dmFyIHNsYXRDb3ZlcmFnZSA9ICh0aW1lIC0gdGhpcy52aWV3Lm1pblRpbWUpIC8gdGhpcy5zbG90RHVyYXRpb247IC8vIGZsb2F0aW5nLXBvaW50IHZhbHVlIG9mICMgb2Ygc2xvdHMgY292ZXJlZFxuXHRcdHZhciBzbGF0SW5kZXg7XG5cdFx0dmFyIHNsYXRSZW1haW5kZXI7XG5cblx0XHQvLyBjb21wdXRlIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGZvciBob3cgbWFueSBzbGF0cyBzaG91bGQgYmUgcHJvZ3Jlc3NlZCB0aHJvdWdoLlxuXHRcdC8vIGZyb20gMCB0byBudW1iZXIgb2Ygc2xhdHMgKGluY2x1c2l2ZSlcblx0XHQvLyBjb25zdHJhaW5lZCBiZWNhdXNlIG1pblRpbWUvbWF4VGltZSBtaWdodCBiZSBjdXN0b21pemVkLlxuXHRcdHNsYXRDb3ZlcmFnZSA9IE1hdGgubWF4KDAsIHNsYXRDb3ZlcmFnZSk7XG5cdFx0c2xhdENvdmVyYWdlID0gTWF0aC5taW4obGVuLCBzbGF0Q292ZXJhZ2UpO1xuXG5cdFx0Ly8gYW4gaW50ZWdlciBpbmRleCBvZiB0aGUgZnVydGhlc3Qgd2hvbGUgc2xhdFxuXHRcdC8vIGZyb20gMCB0byBudW1iZXIgc2xhdHMgKCpleGNsdXNpdmUqLCBzbyBsZW4tMSlcblx0XHRzbGF0SW5kZXggPSBNYXRoLmZsb29yKHNsYXRDb3ZlcmFnZSk7XG5cdFx0c2xhdEluZGV4ID0gTWF0aC5taW4oc2xhdEluZGV4LCBsZW4gLSAxKTtcblxuXHRcdC8vIGhvdyBtdWNoIGZ1cnRoZXIgdGhyb3VnaCB0aGUgc2xhdEluZGV4IHNsYXQgKGZyb20gMC4wLTEuMCkgbXVzdCBiZSBjb3ZlcmVkIGluIGFkZGl0aW9uLlxuXHRcdC8vIGNvdWxkIGJlIDEuMCBpZiBzbGF0Q292ZXJhZ2UgaXMgY292ZXJpbmcgKmFsbCogdGhlIHNsb3RzXG5cdFx0c2xhdFJlbWFpbmRlciA9IHNsYXRDb3ZlcmFnZSAtIHNsYXRJbmRleDtcblxuXHRcdHJldHVybiB0aGlzLnNsYXRDb29yZENhY2hlLmdldFRvcFBvc2l0aW9uKHNsYXRJbmRleCkgK1xuXHRcdFx0dGhpcy5zbGF0Q29vcmRDYWNoZS5nZXRIZWlnaHQoc2xhdEluZGV4KSAqIHNsYXRSZW1haW5kZXI7XG5cdH0sXG5cblxuXG5cdC8qIEV2ZW50IERyYWcgVmlzdWFsaXphdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIGRyYWdnZWQgb3ZlciB0aGUgc3BlY2lmaWVkIGRhdGUocykuXG5cdC8vIEEgcmV0dXJuZWQgdmFsdWUgb2YgYHRydWVgIHNpZ25hbHMgdGhhdCBhIG1vY2sgXCJoZWxwZXJcIiBldmVudCBoYXMgYmVlbiByZW5kZXJlZC5cblx0cmVuZGVyRHJhZzogZnVuY3Rpb24oZXZlbnRMb2NhdGlvbiwgc2VnKSB7XG5cdFx0dmFyIGV2ZW50U3BhbnM7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoc2VnKSB7IC8vIGlmIHRoZXJlIGlzIGV2ZW50IGluZm9ybWF0aW9uIGZvciB0aGlzIGRyYWcsIHJlbmRlciBhIGhlbHBlciBldmVudFxuXG5cdFx0XHQvLyByZXR1cm5zIG1vY2sgZXZlbnQgZWxlbWVudHNcblx0XHRcdC8vIHNpZ25hbCB0aGF0IGEgaGVscGVyIGhhcyBiZWVuIHJlbmRlcmVkXG5cdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXJFdmVudExvY2F0aW9uSGVscGVyKGV2ZW50TG9jYXRpb24sIHNlZyk7XG5cdFx0fVxuXHRcdGVsc2UgeyAvLyBvdGhlcndpc2UsIGp1c3QgcmVuZGVyIGEgaGlnaGxpZ2h0XG5cdFx0XHRldmVudFNwYW5zID0gdGhpcy5ldmVudFRvU3BhbnMoZXZlbnRMb2NhdGlvbik7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBldmVudFNwYW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0KGV2ZW50U3BhbnNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgZHJhZ2dlZFxuXHR1bnJlbmRlckRyYWc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIZWxwZXIoKTtcblx0XHR0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XG5cdH0sXG5cblxuXHQvKiBFdmVudCBSZXNpemUgVmlzdWFsaXphdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcblx0cmVuZGVyRXZlbnRSZXNpemU6IGZ1bmN0aW9uKGV2ZW50TG9jYXRpb24sIHNlZykge1xuXHRcdHJldHVybiB0aGlzLnJlbmRlckV2ZW50TG9jYXRpb25IZWxwZXIoZXZlbnRMb2NhdGlvbiwgc2VnKTsgLy8gcmV0dXJucyBtb2NrIGV2ZW50IGVsZW1lbnRzXG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcblx0dW5yZW5kZXJFdmVudFJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckhlbHBlcigpO1xuXHR9LFxuXG5cblx0LyogRXZlbnQgSGVscGVyXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGEgbW9jayBcImhlbHBlclwiIGV2ZW50LiBgc291cmNlU2VnYCBpcyB0aGUgb3JpZ2luYWwgc2VnbWVudCBvYmplY3QgYW5kIG1pZ2h0IGJlIG51bGwgKGFuIGV4dGVybmFsIGRyYWcpXG5cdHJlbmRlckhlbHBlcjogZnVuY3Rpb24oZXZlbnQsIHNvdXJjZVNlZykge1xuXHRcdHJldHVybiB0aGlzLnJlbmRlckhlbHBlclNlZ3ModGhpcy5ldmVudFRvU2VncyhldmVudCksIHNvdXJjZVNlZyk7IC8vIHJldHVybnMgbW9jayBldmVudCBlbGVtZW50c1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFueSBtb2NrIGhlbHBlciBldmVudFxuXHR1bnJlbmRlckhlbHBlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckhlbHBlclNlZ3MoKTtcblx0fSxcblxuXG5cdC8qIEJ1c2luZXNzIEhvdXJzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlbmRlckJ1c2luZXNzU2Vncyhcblx0XHRcdHRoaXMuYnVpbGRCdXNpbmVzc0hvdXJTZWdzKClcblx0XHQpO1xuXHR9LFxuXG5cblx0dW5yZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVyQnVzaW5lc3NTZWdzKCk7XG5cdH0sXG5cblxuXHQvKiBOb3cgSW5kaWNhdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRnZXROb3dJbmRpY2F0b3JVbml0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ21pbnV0ZSc7IC8vIHdpbGwgcmVmcmVzaCBvbiB0aGUgbWludXRlXG5cdH0sXG5cblxuXHRyZW5kZXJOb3dJbmRpY2F0b3I6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHQvLyBzZWcgc3lzdGVtIG1pZ2h0IGJlIG92ZXJraWxsLCBidXQgaXQgaGFuZGxlcyBzY2VuYXJpbyB3aGVyZSBsaW5lIG5lZWRzIHRvIGJlIHJlbmRlcmVkXG5cdFx0Ly8gIG1vcmUgdGhhbiBvbmNlIGJlY2F1c2Ugb2YgY29sdW1ucyB3aXRoIHRoZSBzYW1lIGRhdGUgKHJlc291cmNlcyBjb2x1bW5zIGZvciBleGFtcGxlKVxuXHRcdHZhciBzZWdzID0gdGhpcy5zcGFuVG9TZWdzKHsgc3RhcnQ6IGRhdGUsIGVuZDogZGF0ZSB9KTtcblx0XHR2YXIgdG9wID0gdGhpcy5jb21wdXRlRGF0ZVRvcChkYXRlLCBkYXRlKTtcblx0XHR2YXIgbm9kZXMgPSBbXTtcblx0XHR2YXIgaTtcblxuXHRcdC8vIHJlbmRlciBsaW5lcyB3aXRoaW4gdGhlIGNvbHVtbnNcblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0bm9kZXMucHVzaCgkKCc8ZGl2IGNsYXNzPVwiZmMtbm93LWluZGljYXRvciBmYy1ub3ctaW5kaWNhdG9yLWxpbmVcIj48L2Rpdj4nKVxuXHRcdFx0XHQuY3NzKCd0b3AnLCB0b3ApXG5cdFx0XHRcdC5hcHBlbmRUbyh0aGlzLmNvbENvbnRhaW5lckVscy5lcShzZWdzW2ldLmNvbCkpWzBdKTtcblx0XHR9XG5cblx0XHQvLyByZW5kZXIgYW4gYXJyb3cgb3ZlciB0aGUgYXhpc1xuXHRcdGlmIChzZWdzLmxlbmd0aCA+IDApIHsgLy8gaXMgdGhlIGN1cnJlbnQgdGltZSBpbiB2aWV3P1xuXHRcdFx0bm9kZXMucHVzaCgkKCc8ZGl2IGNsYXNzPVwiZmMtbm93LWluZGljYXRvciBmYy1ub3ctaW5kaWNhdG9yLWFycm93XCI+PC9kaXY+Jylcblx0XHRcdFx0LmNzcygndG9wJywgdG9wKVxuXHRcdFx0XHQuYXBwZW5kVG8odGhpcy5lbC5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbicpKVswXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5ub3dJbmRpY2F0b3JFbHMgPSAkKG5vZGVzKTtcblx0fSxcblxuXG5cdHVucmVuZGVyTm93SW5kaWNhdG9yOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5ub3dJbmRpY2F0b3JFbHMpIHtcblx0XHRcdHRoaXMubm93SW5kaWNhdG9yRWxzLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5ub3dJbmRpY2F0b3JFbHMgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXG5cdC8qIFNlbGVjdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgc2VsZWN0aW9uLiBPdmVycmlkZXMgdGhlIGRlZmF1bHQsIHdoaWNoIHdhcyB0byBzaW1wbHkgcmVuZGVyIGEgaGlnaGxpZ2h0LlxuXHRyZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHRpZiAodGhpcy52aWV3Lm9wdCgnc2VsZWN0SGVscGVyJykpIHsgLy8gdGhpcyBzZXR0aW5nIHNpZ25hbHMgdGhhdCBhIG1vY2sgaGVscGVyIGV2ZW50IHNob3VsZCBiZSByZW5kZXJlZFxuXG5cdFx0XHQvLyBub3JtYWxseSBhY2NlcHMgYW4gZXZlbnRMb2NhdGlvbiwgc3BhbiBoYXMgYSBzdGFydC9lbmQsIHdoaWNoIGlzIGdvb2QgZW5vdWdoXG5cdFx0XHR0aGlzLnJlbmRlckV2ZW50TG9jYXRpb25IZWxwZXIoc3Bhbik7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5yZW5kZXJIaWdobGlnaHQoc3Bhbik7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvblxuXHR1bnJlbmRlclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckhlbHBlcigpO1xuXHRcdHRoaXMudW5yZW5kZXJIaWdobGlnaHQoKTtcblx0fSxcblxuXG5cdC8qIEhpZ2hsaWdodFxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVySGlnaGxpZ2h0OiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0dGhpcy5yZW5kZXJIaWdobGlnaHRTZWdzKHRoaXMuc3BhblRvU2VncyhzcGFuKSk7XG5cdH0sXG5cblxuXHR1bnJlbmRlckhpZ2hsaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckhpZ2hsaWdodFNlZ3MoKTtcblx0fVxuXG59KTtcblxuOztcblxuLyogTWV0aG9kcyBmb3IgcmVuZGVyaW5nIFNFR01FTlRTLCBwaWVjZXMgb2YgY29udGVudCB0aGF0IGxpdmUgb24gdGhlIHZpZXdcbiAoIHRoaXMgZmlsZSBpcyBubyBsb25nZXIganVzdCBmb3IgZXZlbnRzIClcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5UaW1lR3JpZC5taXhpbih7XG5cblx0Y29sQ29udGFpbmVyRWxzOiBudWxsLCAvLyBjb250YWluZXJzIGZvciBlYWNoIGNvbHVtblxuXG5cdC8vIGlubmVyLWNvbnRhaW5lcnMgZm9yIGVhY2ggY29sdW1uIHdoZXJlIGRpZmZlcmVudCB0eXBlcyBvZiBzZWdzIGxpdmVcblx0ZmdDb250YWluZXJFbHM6IG51bGwsXG5cdGJnQ29udGFpbmVyRWxzOiBudWxsLFxuXHRoZWxwZXJDb250YWluZXJFbHM6IG51bGwsXG5cdGhpZ2hsaWdodENvbnRhaW5lckVsczogbnVsbCxcblx0YnVzaW5lc3NDb250YWluZXJFbHM6IG51bGwsXG5cblx0Ly8gYXJyYXlzIG9mIGRpZmZlcmVudCB0eXBlcyBvZiBkaXNwbGF5ZWQgc2VnbWVudHNcblx0ZmdTZWdzOiBudWxsLFxuXHRiZ1NlZ3M6IG51bGwsXG5cdGhlbHBlclNlZ3M6IG51bGwsXG5cdGhpZ2hsaWdodFNlZ3M6IG51bGwsXG5cdGJ1c2luZXNzU2VnczogbnVsbCxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIERPTSB0aGF0IHRoZSB2aWV3J3MgY29udGVudCB3aWxsIGxpdmUgaW5cblx0cmVuZGVyQ29udGVudFNrZWxldG9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2VsbEh0bWwgPSAnJztcblx0XHR2YXIgaTtcblx0XHR2YXIgc2tlbGV0b25FbDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbENudDsgaSsrKSB7XG5cdFx0XHRjZWxsSHRtbCArPVxuXHRcdFx0XHQnPHRkPicgK1xuXHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtY29udGVudC1jb2xcIj4nICtcblx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtZXZlbnQtY29udGFpbmVyIGZjLWhlbHBlci1jb250YWluZXJcIj48L2Rpdj4nICtcblx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtZXZlbnQtY29udGFpbmVyXCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWhpZ2hsaWdodC1jb250YWluZXJcIj48L2Rpdj4nICtcblx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtYmdldmVudC1jb250YWluZXJcIj48L2Rpdj4nICtcblx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtYnVzaW5lc3MtY29udGFpbmVyXCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0JzwvZGl2PicgK1xuXHRcdFx0XHQnPC90ZD4nO1xuXHRcdH1cblxuXHRcdHNrZWxldG9uRWwgPSAkKFxuXHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1jb250ZW50LXNrZWxldG9uXCI+JyArXG5cdFx0XHRcdCc8dGFibGU+JyArXG5cdFx0XHRcdFx0Jzx0cj4nICsgY2VsbEh0bWwgKyAnPC90cj4nICtcblx0XHRcdFx0JzwvdGFibGU+JyArXG5cdFx0XHQnPC9kaXY+J1xuXHRcdCk7XG5cblx0XHR0aGlzLmNvbENvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWNvbnRlbnQtY29sJyk7XG5cdFx0dGhpcy5oZWxwZXJDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1oZWxwZXItY29udGFpbmVyJyk7XG5cdFx0dGhpcy5mZ0NvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWV2ZW50LWNvbnRhaW5lcjpub3QoLmZjLWhlbHBlci1jb250YWluZXIpJyk7XG5cdFx0dGhpcy5iZ0NvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWJnZXZlbnQtY29udGFpbmVyJyk7XG5cdFx0dGhpcy5oaWdobGlnaHRDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1oaWdobGlnaHQtY29udGFpbmVyJyk7XG5cdFx0dGhpcy5idXNpbmVzc0NvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWJ1c2luZXNzLWNvbnRhaW5lcicpO1xuXG5cdFx0dGhpcy5ib29rZW5kQ2VsbHMoc2tlbGV0b25FbC5maW5kKCd0cicpKTsgLy8gVE9ETzogZG8gdGhpcyBvbiBzdHJpbmcgbGV2ZWxcblx0XHR0aGlzLmVsLmFwcGVuZChza2VsZXRvbkVsKTtcblx0fSxcblxuXG5cdC8qIEZvcmVncm91bmQgRXZlbnRzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJGZ1NlZ3M6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ3NJbnRvQ29udGFpbmVycyhzZWdzLCB0aGlzLmZnQ29udGFpbmVyRWxzKTtcblx0XHR0aGlzLmZnU2VncyA9IHNlZ3M7XG5cdFx0cmV0dXJuIHNlZ3M7IC8vIG5lZWRlZCBmb3IgR3JpZDo6cmVuZGVyRXZlbnRzXG5cdH0sXG5cblxuXHR1bnJlbmRlckZnU2VnczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlck5hbWVkU2VncygnZmdTZWdzJyk7XG5cdH0sXG5cblxuXHQvKiBGb3JlZ3JvdW5kIEhlbHBlciBFdmVudHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckhlbHBlclNlZ3M6IGZ1bmN0aW9uKHNlZ3MsIHNvdXJjZVNlZykge1xuXHRcdHZhciBoZWxwZXJFbHMgPSBbXTtcblx0XHR2YXIgaSwgc2VnO1xuXHRcdHZhciBzb3VyY2VFbDtcblxuXHRcdHNlZ3MgPSB0aGlzLnJlbmRlckZnU2Vnc0ludG9Db250YWluZXJzKHNlZ3MsIHRoaXMuaGVscGVyQ29udGFpbmVyRWxzKTtcblxuXHRcdC8vIFRyeSB0byBtYWtlIHRoZSBzZWdtZW50IHRoYXQgaXMgaW4gdGhlIHNhbWUgcm93IGFzIHNvdXJjZVNlZyBsb29rIHRoZSBzYW1lXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZyA9IHNlZ3NbaV07XG5cdFx0XHRpZiAoc291cmNlU2VnICYmIHNvdXJjZVNlZy5jb2wgPT09IHNlZy5jb2wpIHtcblx0XHRcdFx0c291cmNlRWwgPSBzb3VyY2VTZWcuZWw7XG5cdFx0XHRcdHNlZy5lbC5jc3Moe1xuXHRcdFx0XHRcdGxlZnQ6IHNvdXJjZUVsLmNzcygnbGVmdCcpLFxuXHRcdFx0XHRcdHJpZ2h0OiBzb3VyY2VFbC5jc3MoJ3JpZ2h0JyksXG5cdFx0XHRcdFx0J21hcmdpbi1sZWZ0Jzogc291cmNlRWwuY3NzKCdtYXJnaW4tbGVmdCcpLFxuXHRcdFx0XHRcdCdtYXJnaW4tcmlnaHQnOiBzb3VyY2VFbC5jc3MoJ21hcmdpbi1yaWdodCcpXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0aGVscGVyRWxzLnB1c2goc2VnLmVsWzBdKTtcblx0XHR9XG5cblx0XHR0aGlzLmhlbHBlclNlZ3MgPSBzZWdzO1xuXG5cdFx0cmV0dXJuICQoaGVscGVyRWxzKTsgLy8gbXVzdCByZXR1cm4gcmVuZGVyZWQgaGVscGVyc1xuXHR9LFxuXG5cblx0dW5yZW5kZXJIZWxwZXJTZWdzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVyTmFtZWRTZWdzKCdoZWxwZXJTZWdzJyk7XG5cdH0sXG5cblxuXHQvKiBCYWNrZ3JvdW5kIEV2ZW50c1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyQmdTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmlsbFNlZ0VscygnYmdFdmVudCcsIHNlZ3MpOyAvLyBUT0RPOiBvbGQgZmlsbCBzeXN0ZW1cblx0XHR0aGlzLnVwZGF0ZVNlZ1ZlcnRpY2FscyhzZWdzKTtcblx0XHR0aGlzLmF0dGFjaFNlZ3NCeUNvbCh0aGlzLmdyb3VwU2Vnc0J5Q29sKHNlZ3MpLCB0aGlzLmJnQ29udGFpbmVyRWxzKTtcblx0XHR0aGlzLmJnU2VncyA9IHNlZ3M7XG5cdFx0cmV0dXJuIHNlZ3M7IC8vIG5lZWRlZCBmb3IgR3JpZDo6cmVuZGVyRXZlbnRzXG5cdH0sXG5cblxuXHR1bnJlbmRlckJnU2VnczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlck5hbWVkU2VncygnYmdTZWdzJyk7XG5cdH0sXG5cblxuXHQvKiBIaWdobGlnaHRcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckhpZ2hsaWdodFNlZ3M6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGaWxsU2VnRWxzKCdoaWdobGlnaHQnLCBzZWdzKTsgLy8gVE9ETzogb2xkIGZpbGwgc3lzdGVtXG5cdFx0dGhpcy51cGRhdGVTZWdWZXJ0aWNhbHMoc2Vncyk7XG5cdFx0dGhpcy5hdHRhY2hTZWdzQnlDb2wodGhpcy5ncm91cFNlZ3NCeUNvbChzZWdzKSwgdGhpcy5oaWdobGlnaHRDb250YWluZXJFbHMpO1xuXHRcdHRoaXMuaGlnaGxpZ2h0U2VncyA9IHNlZ3M7XG5cdH0sXG5cblxuXHR1bnJlbmRlckhpZ2hsaWdodFNlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJOYW1lZFNlZ3MoJ2hpZ2hsaWdodFNlZ3MnKTtcblx0fSxcblxuXG5cdC8qIEJ1c2luZXNzIEhvdXJzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJCdXNpbmVzc1NlZ3M6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGaWxsU2VnRWxzKCdidXNpbmVzc0hvdXJzJywgc2Vncyk7IC8vIFRPRE86IG9sZCBmaWxsIHN5c3RlbVxuXHRcdHRoaXMudXBkYXRlU2VnVmVydGljYWxzKHNlZ3MpO1xuXHRcdHRoaXMuYXR0YWNoU2Vnc0J5Q29sKHRoaXMuZ3JvdXBTZWdzQnlDb2woc2VncyksIHRoaXMuYnVzaW5lc3NDb250YWluZXJFbHMpO1xuXHRcdHRoaXMuYnVzaW5lc3NTZWdzID0gc2Vncztcblx0fSxcblxuXG5cdHVucmVuZGVyQnVzaW5lc3NTZWdzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVyTmFtZWRTZWdzKCdidXNpbmVzc1NlZ3MnKTtcblx0fSxcblxuXG5cdC8qIFNlZyBSZW5kZXJpbmcgVXRpbHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEdpdmVuIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgcmV0dXJuIGFuIGFycmF5IG9mIHN1Yi1hcnJheXMsIGdyb3VwZWQgYnkgZWFjaCBzZWdtZW50J3MgY29sXG5cdGdyb3VwU2Vnc0J5Q29sOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dmFyIHNlZ3NCeUNvbCA9IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuY29sQ250OyBpKyspIHtcblx0XHRcdHNlZ3NCeUNvbC5wdXNoKFtdKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2Vnc0J5Q29sW3NlZ3NbaV0uY29sXS5wdXNoKHNlZ3NbaV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzQnlDb2w7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBzZWdtZW50cyBncm91cGVkIGJ5IGNvbHVtbiwgaW5zZXJ0IHRoZSBzZWdtZW50cycgZWxlbWVudHMgaW50byBhIHBhcmFsbGVsIGFycmF5IG9mIGNvbnRhaW5lclxuXHQvLyBlbGVtZW50cywgZWFjaCBsaXZpbmcgd2l0aGluIGEgY29sdW1uLlxuXHRhdHRhY2hTZWdzQnlDb2w6IGZ1bmN0aW9uKHNlZ3NCeUNvbCwgY29udGFpbmVyRWxzKSB7XG5cdFx0dmFyIGNvbDtcblx0XHR2YXIgc2Vncztcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCsrKSB7IC8vIGl0ZXJhdGUgZWFjaCBjb2x1bW4gZ3JvdXBpbmdcblx0XHRcdHNlZ3MgPSBzZWdzQnlDb2xbY29sXTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29udGFpbmVyRWxzLmVxKGNvbCkuYXBwZW5kKHNlZ3NbaV0uZWwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIEdpdmVuIHRoZSBuYW1lIG9mIGEgcHJvcGVydHkgb2YgYHRoaXNgIG9iamVjdCwgYXNzdW1lZCB0byBiZSBhbiBhcnJheSBvZiBzZWdtZW50cyxcblx0Ly8gbG9vcHMgdGhyb3VnaCBlYWNoIHNlZ21lbnQgYW5kIHJlbW92ZXMgZnJvbSBET00uIFdpbGwgbnVsbC1vdXQgdGhlIHByb3BlcnR5IGFmdGVyd2FyZHMuXG5cdHVucmVuZGVyTmFtZWRTZWdzOiBmdW5jdGlvbihwcm9wTmFtZSkge1xuXHRcdHZhciBzZWdzID0gdGhpc1twcm9wTmFtZV07XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoc2Vncykge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0c2Vnc1tpXS5lbC5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHRcdHRoaXNbcHJvcE5hbWVdID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblxuXG5cdC8qIEZvcmVncm91bmQgRXZlbnQgUmVuZGVyaW5nIFV0aWxzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBHaXZlbiBhbiBhcnJheSBvZiBmb3JlZ3JvdW5kIHNlZ21lbnRzLCByZW5kZXIgYSBET00gZWxlbWVudCBmb3IgZWFjaCwgY29tcHV0ZXMgcG9zaXRpb24sXG5cdC8vIGFuZCBhdHRhY2hlcyB0byB0aGUgY29sdW1uIGlubmVyLWNvbnRhaW5lciBlbGVtZW50cy5cblx0cmVuZGVyRmdTZWdzSW50b0NvbnRhaW5lcnM6IGZ1bmN0aW9uKHNlZ3MsIGNvbnRhaW5lckVscykge1xuXHRcdHZhciBzZWdzQnlDb2w7XG5cdFx0dmFyIGNvbDtcblxuXHRcdHNlZ3MgPSB0aGlzLnJlbmRlckZnU2VnRWxzKHNlZ3MpOyAvLyB3aWxsIGNhbGwgZmdTZWdIdG1sXG5cdFx0c2Vnc0J5Q29sID0gdGhpcy5ncm91cFNlZ3NCeUNvbChzZWdzKTtcblxuXHRcdGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCsrKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZUZnU2VnQ29vcmRzKHNlZ3NCeUNvbFtjb2xdKTtcblx0XHR9XG5cblx0XHR0aGlzLmF0dGFjaFNlZ3NCeUNvbChzZWdzQnlDb2wsIGNvbnRhaW5lckVscyk7XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIEhUTUwgZm9yIGEgc2luZ2xlIGV2ZW50IHNlZ21lbnQncyBkZWZhdWx0IHJlbmRlcmluZ1xuXHRmZ1NlZ0h0bWw6IGZ1bmN0aW9uKHNlZywgZGlzYWJsZVJlc2l6aW5nKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGV2ZW50ID0gc2VnLmV2ZW50O1xuXHRcdHZhciBpc0RyYWdnYWJsZSA9IHZpZXcuaXNFdmVudERyYWdnYWJsZShldmVudCk7XG5cdFx0dmFyIGlzUmVzaXphYmxlRnJvbVN0YXJ0ID0gIWRpc2FibGVSZXNpemluZyAmJiBzZWcuaXNTdGFydCAmJiB2aWV3LmlzRXZlbnRSZXNpemFibGVGcm9tU3RhcnQoZXZlbnQpO1xuXHRcdHZhciBpc1Jlc2l6YWJsZUZyb21FbmQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIHNlZy5pc0VuZCAmJiB2aWV3LmlzRXZlbnRSZXNpemFibGVGcm9tRW5kKGV2ZW50KTtcblx0XHR2YXIgY2xhc3NlcyA9IHRoaXMuZ2V0U2VnQ2xhc3NlcyhzZWcsIGlzRHJhZ2dhYmxlLCBpc1Jlc2l6YWJsZUZyb21TdGFydCB8fCBpc1Jlc2l6YWJsZUZyb21FbmQpO1xuXHRcdHZhciBza2luQ3NzID0gY3NzVG9TdHIodGhpcy5nZXRTZWdTa2luQ3NzKHNlZykpO1xuXHRcdHZhciB0aW1lVGV4dDtcblx0XHR2YXIgZnVsbFRpbWVUZXh0OyAvLyBtb3JlIHZlcmJvc2UgdGltZSB0ZXh0LiBmb3IgdGhlIHByaW50IHN0eWxlc2hlZXRcblx0XHR2YXIgc3RhcnRUaW1lVGV4dDsgLy8ganVzdCB0aGUgc3RhcnQgdGltZSB0ZXh0XG5cblx0XHRjbGFzc2VzLnVuc2hpZnQoJ2ZjLXRpbWUtZ3JpZC1ldmVudCcsICdmYy12LWV2ZW50Jyk7XG5cblx0XHRpZiAodmlldy5pc011bHRpRGF5RXZlbnQoZXZlbnQpKSB7IC8vIGlmIHRoZSBldmVudCBhcHBlYXJzIHRvIHNwYW4gbW9yZSB0aGFuIG9uZSBkYXkuLi5cblx0XHRcdC8vIERvbid0IGRpc3BsYXkgdGltZSB0ZXh0IG9uIHNlZ21lbnRzIHRoYXQgcnVuIGVudGlyZWx5IHRocm91Z2ggYSBkYXkuXG5cdFx0XHQvLyBUaGF0IHdvdWxkIGFwcGVhciBhcyBtaWRuaWdodC1taWRuaWdodCBhbmQgd291bGQgbG9vayBkdW1iLlxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBkaXNwbGF5IHRoZSB0aW1lIHRleHQgZm9yIHRoZSAqc2VnbWVudCdzKiB0aW1lcyAobGlrZSA2cG0tbWlkbmlnaHQgb3IgbWlkbmlnaHQtMTBhbSlcblx0XHRcdGlmIChzZWcuaXNTdGFydCB8fCBzZWcuaXNFbmQpIHtcblx0XHRcdFx0dGltZVRleHQgPSB0aGlzLmdldEV2ZW50VGltZVRleHQoc2VnKTtcblx0XHRcdFx0ZnVsbFRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KHNlZywgJ0xUJyk7XG5cdFx0XHRcdHN0YXJ0VGltZVRleHQgPSB0aGlzLmdldEV2ZW50VGltZVRleHQoc2VnLCBudWxsLCBmYWxzZSk7IC8vIGRpc3BsYXlFbmQ9ZmFsc2Vcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRGlzcGxheSB0aGUgbm9ybWFsIHRpbWUgdGV4dCBmb3IgdGhlICpldmVudCdzKiB0aW1lc1xuXHRcdFx0dGltZVRleHQgPSB0aGlzLmdldEV2ZW50VGltZVRleHQoZXZlbnQpO1xuXHRcdFx0ZnVsbFRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KGV2ZW50LCAnTFQnKTtcblx0XHRcdHN0YXJ0VGltZVRleHQgPSB0aGlzLmdldEV2ZW50VGltZVRleHQoZXZlbnQsIG51bGwsIGZhbHNlKTsgLy8gZGlzcGxheUVuZD1mYWxzZVxuXHRcdH1cblxuXHRcdHJldHVybiAnPGEgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcblx0XHRcdChldmVudC51cmwgP1xuXHRcdFx0XHQnIGhyZWY9XCInICsgaHRtbEVzY2FwZShldmVudC51cmwpICsgJ1wiJyA6XG5cdFx0XHRcdCcnXG5cdFx0XHRcdCkgK1xuXHRcdFx0KHNraW5Dc3MgP1xuXHRcdFx0XHQnIHN0eWxlPVwiJyArIHNraW5Dc3MgKyAnXCInIDpcblx0XHRcdFx0Jydcblx0XHRcdFx0KSArXG5cdFx0XHQnPicgK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnRcIj4nICtcblx0XHRcdFx0XHQodGltZVRleHQgP1xuXHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy10aW1lXCInICtcblx0XHRcdFx0XHRcdCcgZGF0YS1zdGFydD1cIicgKyBodG1sRXNjYXBlKHN0YXJ0VGltZVRleHQpICsgJ1wiJyArXG5cdFx0XHRcdFx0XHQnIGRhdGEtZnVsbD1cIicgKyBodG1sRXNjYXBlKGZ1bGxUaW1lVGV4dCkgKyAnXCInICtcblx0XHRcdFx0XHRcdCc+JyArXG5cdFx0XHRcdFx0XHRcdCc8c3Bhbj4nICsgaHRtbEVzY2FwZSh0aW1lVGV4dCkgKyAnPC9zcGFuPicgK1xuXHRcdFx0XHRcdFx0JzwvZGl2PicgOlxuXHRcdFx0XHRcdFx0Jydcblx0XHRcdFx0XHRcdCkgK1xuXHRcdFx0XHRcdChldmVudC50aXRsZSA/XG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXG5cdFx0XHRcdFx0XHRcdGh0bWxFc2NhcGUoZXZlbnQudGl0bGUpICtcblx0XHRcdFx0XHRcdCc8L2Rpdj4nIDpcblx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHQpICtcblx0XHRcdFx0JzwvZGl2PicgK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWJnXCIvPicgK1xuXHRcdFx0XHQvKiBUT0RPOiB3cml0ZSBDU1MgZm9yIHRoaXNcblx0XHRcdFx0KGlzUmVzaXphYmxlRnJvbVN0YXJ0ID9cblx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLXJlc2l6ZXIgZmMtc3RhcnQtcmVzaXplclwiIC8+JyA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0XHQpICtcblx0XHRcdFx0Ki9cblx0XHRcdFx0KGlzUmVzaXphYmxlRnJvbUVuZCA/XG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLWVuZC1yZXNpemVyXCIgLz4nIDpcblx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdCkgK1xuXHRcdFx0JzwvYT4nO1xuXHR9LFxuXG5cblx0LyogU2VnIFBvc2l0aW9uIFV0aWxzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZWZyZXNoZXMgdGhlIENTUyB0b3AvYm90dG9tIGNvb3JkaW5hdGVzIGZvciBlYWNoIHNlZ21lbnQgZWxlbWVudC5cblx0Ly8gV29ya3Mgd2hlbiBjYWxsZWQgYWZ0ZXIgaW5pdGlhbCByZW5kZXIsIGFmdGVyIGEgd2luZG93IHJlc2l6ZS96b29tIGZvciBleGFtcGxlLlxuXHR1cGRhdGVTZWdWZXJ0aWNhbHM6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR0aGlzLmNvbXB1dGVTZWdWZXJ0aWNhbHMoc2Vncyk7XG5cdFx0dGhpcy5hc3NpZ25TZWdWZXJ0aWNhbHMoc2Vncyk7XG5cdH0sXG5cblxuXHQvLyBGb3IgZWFjaCBzZWdtZW50IGluIGFuIGFycmF5LCBjb21wdXRlcyBhbmQgYXNzaWducyBpdHMgdG9wIGFuZCBib3R0b20gcHJvcGVydGllc1xuXHRjb21wdXRlU2VnVmVydGljYWxzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dmFyIGksIHNlZztcblx0XHR2YXIgZGF5RGF0ZTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWcgPSBzZWdzW2ldO1xuXHRcdFx0ZGF5RGF0ZSA9IHRoaXMuZGF5RGF0ZXNbc2VnLmRheUluZGV4XTtcblxuXHRcdFx0c2VnLnRvcCA9IHRoaXMuY29tcHV0ZURhdGVUb3Aoc2VnLnN0YXJ0LCBkYXlEYXRlKTtcblx0XHRcdHNlZy5ib3R0b20gPSB0aGlzLmNvbXB1dGVEYXRlVG9wKHNlZy5lbmQsIGRheURhdGUpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEdpdmVuIHNlZ21lbnRzIHRoYXQgYWxyZWFkeSBoYXZlIHRoZWlyIHRvcC9ib3R0b20gcHJvcGVydGllcyBjb21wdXRlZCwgYXBwbGllcyB0aG9zZSB2YWx1ZXMgdG9cblx0Ly8gdGhlIHNlZ21lbnRzJyBlbGVtZW50cy5cblx0YXNzaWduU2VnVmVydGljYWxzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dmFyIGksIHNlZztcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWcgPSBzZWdzW2ldO1xuXHRcdFx0c2VnLmVsLmNzcyh0aGlzLmdlbmVyYXRlU2VnVmVydGljYWxDc3Moc2VnKSk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIGFuIG9iamVjdCB3aXRoIENTUyBwcm9wZXJ0aWVzIGZvciB0aGUgdG9wL2JvdHRvbSBjb29yZGluYXRlcyBvZiBhIHNlZ21lbnQgZWxlbWVudFxuXHRnZW5lcmF0ZVNlZ1ZlcnRpY2FsQ3NzOiBmdW5jdGlvbihzZWcpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBzZWcudG9wLFxuXHRcdFx0Ym90dG9tOiAtc2VnLmJvdHRvbSAvLyBmbGlwcGVkIGJlY2F1c2UgbmVlZHMgdG8gYmUgc3BhY2UgYmV5b25kIGJvdHRvbSBlZGdlIG9mIGV2ZW50IGNvbnRhaW5lclxuXHRcdH07XG5cdH0sXG5cblxuXHQvKiBGb3JlZ3JvdW5kIEV2ZW50IFBvc2l0aW9uaW5nIFV0aWxzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBHaXZlbiBzZWdtZW50cyB0aGF0IGFyZSBhc3N1bWVkIHRvIGFsbCBsaXZlIGluIHRoZSAqc2FtZSBjb2x1bW4qLFxuXHQvLyBjb21wdXRlIHRoZWlyIHZlcmljYWwvaG9yaXpvbnRhbCBjb29yZGluYXRlcyBhbmQgYXNzaWduIHRvIHRoZWlyIGVsZW1lbnRzLlxuXHR1cGRhdGVGZ1NlZ0Nvb3JkczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHRoaXMuY29tcHV0ZVNlZ1ZlcnRpY2FscyhzZWdzKTsgLy8gaG9yaXpvbnRhbHMgcmVsaWVzIG9uIHRoaXNcblx0XHR0aGlzLmNvbXB1dGVGZ1NlZ0hvcml6b250YWxzKHNlZ3MpOyAvLyBjb21wdXRlIGhvcml6b250YWwgY29vcmRpbmF0ZXMsIHotaW5kZXgncywgYW5kIHJlb3JkZXIgdGhlIGFycmF5XG5cdFx0dGhpcy5hc3NpZ25TZWdWZXJ0aWNhbHMoc2Vncyk7XG5cdFx0dGhpcy5hc3NpZ25GZ1NlZ0hvcml6b250YWxzKHNlZ3MpO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYW4gYXJyYXkgb2Ygc2VnbWVudHMgdGhhdCBhcmUgYWxsIGluIHRoZSBzYW1lIGNvbHVtbiwgc2V0cyB0aGUgYmFja3dhcmRDb29yZCBhbmQgZm9yd2FyZENvb3JkIG9uIGVhY2guXG5cdC8vIE5PVEU6IEFsc28gcmVvcmRlcnMgdGhlIGdpdmVuIGFycmF5IGJ5IGRhdGUhXG5cdGNvbXB1dGVGZ1NlZ0hvcml6b250YWxzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dmFyIGxldmVscztcblx0XHR2YXIgbGV2ZWwwO1xuXHRcdHZhciBpO1xuXG5cdFx0dGhpcy5zb3J0RXZlbnRTZWdzKHNlZ3MpOyAvLyBvcmRlciBieSBjZXJ0YWluIGNyaXRlcmlhXG5cdFx0bGV2ZWxzID0gYnVpbGRTbG90U2VnTGV2ZWxzKHNlZ3MpO1xuXHRcdGNvbXB1dGVGb3J3YXJkU2xvdFNlZ3MobGV2ZWxzKTtcblxuXHRcdGlmICgobGV2ZWwwID0gbGV2ZWxzWzBdKSkge1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGV2ZWwwLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbXB1dGVTbG90U2VnUHJlc3N1cmVzKGxldmVsMFtpXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZXZlbDAubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5jb21wdXRlRmdTZWdGb3J3YXJkQmFjayhsZXZlbDBbaV0sIDAsIDApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIENhbGN1bGF0ZSBzZWcuZm9yd2FyZENvb3JkIGFuZCBzZWcuYmFja3dhcmRDb29yZCBmb3IgdGhlIHNlZ21lbnQsIHdoZXJlIGJvdGggdmFsdWVzIHJhbmdlXG5cdC8vIGZyb20gMCB0byAxLiBJZiB0aGUgY2FsZW5kYXIgaXMgbGVmdC10by1yaWdodCwgdGhlIHNlZy5iYWNrd2FyZENvb3JkIG1hcHMgdG8gXCJsZWZ0XCIgYW5kXG5cdC8vIHNlZy5mb3J3YXJkQ29vcmQgbWFwcyB0byBcInJpZ2h0XCIgKHZpYSBwZXJjZW50YWdlKS4gVmljZS12ZXJzYSBpZiB0aGUgY2FsZW5kYXIgaXMgcmlnaHQtdG8tbGVmdC5cblx0Ly9cblx0Ly8gVGhlIHNlZ21lbnQgbWlnaHQgYmUgcGFydCBvZiBhIFwic2VyaWVzXCIsIHdoaWNoIG1lYW5zIGNvbnNlY3V0aXZlIHNlZ21lbnRzIHdpdGggdGhlIHNhbWUgcHJlc3N1cmVcblx0Ly8gd2hvJ3Mgd2lkdGggaXMgdW5rbm93biB1bnRpbCBhbiBlZGdlIGhhcyBiZWVuIGhpdC4gYHNlcmllc0JhY2t3YXJkUHJlc3N1cmVgIGlzIHRoZSBudW1iZXIgb2Zcblx0Ly8gc2VnbWVudHMgYmVoaW5kIHRoaXMgb25lIGluIHRoZSBjdXJyZW50IHNlcmllcywgYW5kIGBzZXJpZXNCYWNrd2FyZENvb3JkYCBpcyB0aGUgc3RhcnRpbmdcblx0Ly8gY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3Qgc2VnbWVudCBpbiB0aGUgc2VyaWVzLlxuXHRjb21wdXRlRmdTZWdGb3J3YXJkQmFjazogZnVuY3Rpb24oc2VnLCBzZXJpZXNCYWNrd2FyZFByZXNzdXJlLCBzZXJpZXNCYWNrd2FyZENvb3JkKSB7XG5cdFx0dmFyIGZvcndhcmRTZWdzID0gc2VnLmZvcndhcmRTZWdzO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKHNlZy5mb3J3YXJkQ29vcmQgPT09IHVuZGVmaW5lZCkgeyAvLyBub3QgYWxyZWFkeSBjb21wdXRlZFxuXG5cdFx0XHRpZiAoIWZvcndhcmRTZWdzLmxlbmd0aCkge1xuXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBmb3J3YXJkIHNlZ21lbnRzLCB0aGlzIHNlZ21lbnQgc2hvdWxkIGJ1dHQgdXAgYWdhaW5zdCB0aGUgZWRnZVxuXHRcdFx0XHRzZWcuZm9yd2FyZENvb3JkID0gMTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXG5cdFx0XHRcdC8vIHNvcnQgaGlnaGVzdCBwcmVzc3VyZSBmaXJzdFxuXHRcdFx0XHR0aGlzLnNvcnRGb3J3YXJkU2Vncyhmb3J3YXJkU2Vncyk7XG5cblx0XHRcdFx0Ly8gdGhpcyBzZWdtZW50J3MgZm9yd2FyZENvb3JkIHdpbGwgYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBiYWNrd2FyZENvb3JkIG9mIHRoZVxuXHRcdFx0XHQvLyBoaWdoZXN0LXByZXNzdXJlIGZvcndhcmQgc2VnbWVudC5cblx0XHRcdFx0dGhpcy5jb21wdXRlRmdTZWdGb3J3YXJkQmFjayhmb3J3YXJkU2Vnc1swXSwgc2VyaWVzQmFja3dhcmRQcmVzc3VyZSArIDEsIHNlcmllc0JhY2t3YXJkQ29vcmQpO1xuXHRcdFx0XHRzZWcuZm9yd2FyZENvb3JkID0gZm9yd2FyZFNlZ3NbMF0uYmFja3dhcmRDb29yZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSBiYWNrd2FyZENvb3JkIGZyb20gdGhlIGZvcndhcmRDb29yZC4gY29uc2lkZXIgdGhlIHNlcmllc1xuXHRcdFx0c2VnLmJhY2t3YXJkQ29vcmQgPSBzZWcuZm9yd2FyZENvb3JkIC1cblx0XHRcdFx0KHNlZy5mb3J3YXJkQ29vcmQgLSBzZXJpZXNCYWNrd2FyZENvb3JkKSAvIC8vIGF2YWlsYWJsZSB3aWR0aCBmb3Igc2VyaWVzXG5cdFx0XHRcdChzZXJpZXNCYWNrd2FyZFByZXNzdXJlICsgMSk7IC8vICMgb2Ygc2VnbWVudHMgaW4gdGhlIHNlcmllc1xuXG5cdFx0XHQvLyB1c2UgdGhpcyBzZWdtZW50J3MgY29vcmRpbmF0ZXMgdG8gY29tcHV0ZWQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsZXNzLXByZXNzdXJpemVkXG5cdFx0XHQvLyBmb3J3YXJkIHNlZ21lbnRzXG5cdFx0XHRmb3IgKGk9MDsgaTxmb3J3YXJkU2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGZvcndhcmRTZWdzW2ldLCAwLCBzZWcuZm9yd2FyZENvb3JkKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHRzb3J0Rm9yd2FyZFNlZ3M6IGZ1bmN0aW9uKGZvcndhcmRTZWdzKSB7XG5cdFx0Zm9yd2FyZFNlZ3Muc29ydChwcm94eSh0aGlzLCAnY29tcGFyZUZvcndhcmRTZWdzJykpO1xuXHR9LFxuXG5cblx0Ly8gQSBjbXAgZnVuY3Rpb24gZm9yIGRldGVybWluaW5nIHdoaWNoIGZvcndhcmQgc2VnbWVudCB0byByZWx5IG9uIG1vcmUgd2hlbiBjb21wdXRpbmcgY29vcmRpbmF0ZXMuXG5cdGNvbXBhcmVGb3J3YXJkU2VnczogZnVuY3Rpb24oc2VnMSwgc2VnMikge1xuXHRcdC8vIHB1dCBoaWdoZXItcHJlc3N1cmUgZmlyc3Rcblx0XHRyZXR1cm4gc2VnMi5mb3J3YXJkUHJlc3N1cmUgLSBzZWcxLmZvcndhcmRQcmVzc3VyZSB8fFxuXHRcdFx0Ly8gcHV0IHNlZ21lbnRzIHRoYXQgYXJlIGNsb3NlciB0byBpbml0aWFsIGVkZ2UgZmlyc3QgKGFuZCBmYXZvciBvbmVzIHdpdGggbm8gY29vcmRzIHlldClcblx0XHRcdChzZWcxLmJhY2t3YXJkQ29vcmQgfHwgMCkgLSAoc2VnMi5iYWNrd2FyZENvb3JkIHx8IDApIHx8XG5cdFx0XHQvLyBkbyBub3JtYWwgc29ydGluZy4uLlxuXHRcdFx0dGhpcy5jb21wYXJlRXZlbnRTZWdzKHNlZzEsIHNlZzIpO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gZm9yZWdyb3VuZCBldmVudCBzZWdtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBoYWQgdGhlaXIgcG9zaXRpb24gY29vcmRpbmF0ZXMgY29tcHV0ZWQsXG5cdC8vIGFzc2lnbnMgcG9zaXRpb24tcmVsYXRlZCBDU1MgdmFsdWVzIHRvIHRoZWlyIGVsZW1lbnRzLlxuXHRhc3NpZ25GZ1NlZ0hvcml6b250YWxzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dmFyIGksIHNlZztcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWcgPSBzZWdzW2ldO1xuXHRcdFx0c2VnLmVsLmNzcyh0aGlzLmdlbmVyYXRlRmdTZWdIb3Jpem9udGFsQ3NzKHNlZykpO1xuXG5cdFx0XHQvLyBpZiB0aGUgaGVpZ2h0IGlzIHNob3J0LCBhZGQgYSBjbGFzc05hbWUgZm9yIGFsdGVybmF0ZSBzdHlsaW5nXG5cdFx0XHRpZiAoc2VnLmJvdHRvbSAtIHNlZy50b3AgPCAzMCkge1xuXHRcdFx0XHRzZWcuZWwuYWRkQ2xhc3MoJ2ZjLXNob3J0Jyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIGFuIG9iamVjdCB3aXRoIENTUyBwcm9wZXJ0aWVzL3ZhbHVlcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGFuIGV2ZW50IHNlZ21lbnQgZWxlbWVudC5cblx0Ly8gQ29udGFpbnMgaW1wb3J0YW50IHBvc2l0aW9uaW5nLXJlbGF0ZWQgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGFueSBldmVudCBlbGVtZW50LCBjdXN0b21pemVkIG9yIG5vdC5cblx0Z2VuZXJhdGVGZ1NlZ0hvcml6b250YWxDc3M6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHZhciBzaG91bGRPdmVybGFwID0gdGhpcy52aWV3Lm9wdCgnc2xvdEV2ZW50T3ZlcmxhcCcpO1xuXHRcdHZhciBiYWNrd2FyZENvb3JkID0gc2VnLmJhY2t3YXJkQ29vcmQ7IC8vIHRoZSBsZWZ0IHNpZGUgaWYgTFRSLiB0aGUgcmlnaHQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XG5cdFx0dmFyIGZvcndhcmRDb29yZCA9IHNlZy5mb3J3YXJkQ29vcmQ7IC8vIHRoZSByaWdodCBzaWRlIGlmIExUUi4gdGhlIGxlZnQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XG5cdFx0dmFyIHByb3BzID0gdGhpcy5nZW5lcmF0ZVNlZ1ZlcnRpY2FsQ3NzKHNlZyk7IC8vIGdldCB0b3AvYm90dG9tIGZpcnN0XG5cdFx0dmFyIGxlZnQ7IC8vIGFtb3VudCBvZiBzcGFjZSBmcm9tIGxlZnQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcblx0XHR2YXIgcmlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBmcm9tIHJpZ2h0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXG5cblx0XHRpZiAoc2hvdWxkT3ZlcmxhcCkge1xuXHRcdFx0Ly8gZG91YmxlIHRoZSB3aWR0aCwgYnV0IGRvbid0IGdvIGJleW9uZCB0aGUgbWF4aW11bSBmb3J3YXJkIGNvb3JkaW5hdGUgKDEuMClcblx0XHRcdGZvcndhcmRDb29yZCA9IE1hdGgubWluKDEsIGJhY2t3YXJkQ29vcmQgKyAoZm9yd2FyZENvb3JkIC0gYmFja3dhcmRDb29yZCkgKiAyKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5pc1JUTCkge1xuXHRcdFx0bGVmdCA9IDEgLSBmb3J3YXJkQ29vcmQ7XG5cdFx0XHRyaWdodCA9IGJhY2t3YXJkQ29vcmQ7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bGVmdCA9IGJhY2t3YXJkQ29vcmQ7XG5cdFx0XHRyaWdodCA9IDEgLSBmb3J3YXJkQ29vcmQ7XG5cdFx0fVxuXG5cdFx0cHJvcHMuekluZGV4ID0gc2VnLmxldmVsICsgMTsgLy8gY29udmVydCBmcm9tIDAtYmFzZSB0byAxLWJhc2VkXG5cdFx0cHJvcHMubGVmdCA9IGxlZnQgKiAxMDAgKyAnJSc7XG5cdFx0cHJvcHMucmlnaHQgPSByaWdodCAqIDEwMCArICclJztcblxuXHRcdGlmIChzaG91bGRPdmVybGFwICYmIHNlZy5mb3J3YXJkUHJlc3N1cmUpIHtcblx0XHRcdC8vIGFkZCBwYWRkaW5nIHRvIHRoZSBlZGdlIHNvIHRoYXQgZm9yd2FyZCBzdGFja2VkIGV2ZW50cyBkb24ndCBjb3ZlciB0aGUgcmVzaXplcidzIGljb25cblx0XHRcdHByb3BzW3RoaXMuaXNSVEwgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luUmlnaHQnXSA9IDEwICogMjsgLy8gMTAgaXMgYSBndWVzc3RpbWF0ZSBvZiB0aGUgaWNvbidzIHdpZHRoXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByb3BzO1xuXHR9XG5cbn0pO1xuXG5cbi8vIEJ1aWxkcyBhbiBhcnJheSBvZiBzZWdtZW50cyBcImxldmVsc1wiLiBUaGUgZmlyc3QgbGV2ZWwgd2lsbCBiZSB0aGUgbGVmdG1vc3QgdGllciBvZiBzZWdtZW50cyBpZiB0aGUgY2FsZW5kYXIgaXNcbi8vIGxlZnQtdG8tcmlnaHQsIG9yIHRoZSByaWdodG1vc3QgaWYgdGhlIGNhbGVuZGFyIGlzIHJpZ2h0LXRvLWxlZnQuIEFzc3VtZXMgdGhlIHNlZ21lbnRzIGFyZSBhbHJlYWR5IG9yZGVyZWQgYnkgZGF0ZS5cbmZ1bmN0aW9uIGJ1aWxkU2xvdFNlZ0xldmVscyhzZWdzKSB7XG5cdHZhciBsZXZlbHMgPSBbXTtcblx0dmFyIGksIHNlZztcblx0dmFyIGo7XG5cblx0Zm9yIChpPTA7IGk8c2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdHNlZyA9IHNlZ3NbaV07XG5cblx0XHQvLyBnbyB0aHJvdWdoIGFsbCB0aGUgbGV2ZWxzIGFuZCBzdG9wIG9uIHRoZSBmaXJzdCBsZXZlbCB3aGVyZSB0aGVyZSBhcmUgbm8gY29sbGlzaW9uc1xuXHRcdGZvciAoaj0wOyBqPGxldmVscy5sZW5ndGg7IGorKykge1xuXHRcdFx0aWYgKCFjb21wdXRlU2xvdFNlZ0NvbGxpc2lvbnMoc2VnLCBsZXZlbHNbal0pLmxlbmd0aCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZWcubGV2ZWwgPSBqO1xuXG5cdFx0KGxldmVsc1tqXSB8fCAobGV2ZWxzW2pdID0gW10pKS5wdXNoKHNlZyk7XG5cdH1cblxuXHRyZXR1cm4gbGV2ZWxzO1xufVxuXG5cbi8vIEZvciBldmVyeSBzZWdtZW50LCBmaWd1cmUgb3V0IHRoZSBvdGhlciBzZWdtZW50cyB0aGF0IGFyZSBpbiBzdWJzZXF1ZW50XG4vLyBsZXZlbHMgdGhhdCBhbHNvIG9jY3VweSB0aGUgc2FtZSB2ZXJ0aWNhbCBzcGFjZS4gQWNjdW11bGF0ZSBpbiBzZWcuZm9yd2FyZFNlZ3NcbmZ1bmN0aW9uIGNvbXB1dGVGb3J3YXJkU2xvdFNlZ3MobGV2ZWxzKSB7XG5cdHZhciBpLCBsZXZlbDtcblx0dmFyIGosIHNlZztcblx0dmFyIGs7XG5cblx0Zm9yIChpPTA7IGk8bGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0bGV2ZWwgPSBsZXZlbHNbaV07XG5cblx0XHRmb3IgKGo9MDsgajxsZXZlbC5sZW5ndGg7IGorKykge1xuXHRcdFx0c2VnID0gbGV2ZWxbal07XG5cblx0XHRcdHNlZy5mb3J3YXJkU2VncyA9IFtdO1xuXHRcdFx0Zm9yIChrPWkrMTsgazxsZXZlbHMubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0Y29tcHV0ZVNsb3RTZWdDb2xsaXNpb25zKHNlZywgbGV2ZWxzW2tdLCBzZWcuZm9yd2FyZFNlZ3MpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5cbi8vIEZpZ3VyZSBvdXQgd2hpY2ggcGF0aCBmb3J3YXJkICh2aWEgc2VnLmZvcndhcmRTZWdzKSByZXN1bHRzIGluIHRoZSBsb25nZXN0IHBhdGggdW50aWxcbi8vIHRoZSBmdXJ0aGVzdCBlZGdlIGlzIHJlYWNoZWQuIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgaW4gdGhpcyBwYXRoIHdpbGwgYmUgc2VnLmZvcndhcmRQcmVzc3VyZVxuZnVuY3Rpb24gY29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMoc2VnKSB7XG5cdHZhciBmb3J3YXJkU2VncyA9IHNlZy5mb3J3YXJkU2Vncztcblx0dmFyIGZvcndhcmRQcmVzc3VyZSA9IDA7XG5cdHZhciBpLCBmb3J3YXJkU2VnO1xuXG5cdGlmIChzZWcuZm9yd2FyZFByZXNzdXJlID09PSB1bmRlZmluZWQpIHsgLy8gbm90IGFscmVhZHkgY29tcHV0ZWRcblxuXHRcdGZvciAoaT0wOyBpPGZvcndhcmRTZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRmb3J3YXJkU2VnID0gZm9yd2FyZFNlZ3NbaV07XG5cblx0XHRcdC8vIGZpZ3VyZSBvdXQgdGhlIGNoaWxkJ3MgbWF4aW11bSBmb3J3YXJkIHBhdGhcblx0XHRcdGNvbXB1dGVTbG90U2VnUHJlc3N1cmVzKGZvcndhcmRTZWcpO1xuXG5cdFx0XHQvLyBlaXRoZXIgdXNlIHRoZSBleGlzdGluZyBtYXhpbXVtLCBvciB1c2UgdGhlIGNoaWxkJ3MgZm9yd2FyZCBwcmVzc3VyZVxuXHRcdFx0Ly8gcGx1cyBvbmUgKGZvciB0aGUgZm9yd2FyZFNlZyBpdHNlbGYpXG5cdFx0XHRmb3J3YXJkUHJlc3N1cmUgPSBNYXRoLm1heChcblx0XHRcdFx0Zm9yd2FyZFByZXNzdXJlLFxuXHRcdFx0XHQxICsgZm9yd2FyZFNlZy5mb3J3YXJkUHJlc3N1cmVcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0c2VnLmZvcndhcmRQcmVzc3VyZSA9IGZvcndhcmRQcmVzc3VyZTtcblx0fVxufVxuXG5cbi8vIEZpbmQgYWxsIHRoZSBzZWdtZW50cyBpbiBgb3RoZXJTZWdzYCB0aGF0IHZlcnRpY2FsbHkgY29sbGlkZSB3aXRoIGBzZWdgLlxuLy8gQXBwZW5kIGludG8gYW4gb3B0aW9uYWxseS1zdXBwbGllZCBgcmVzdWx0c2AgYXJyYXkgYW5kIHJldHVybi5cbmZ1bmN0aW9uIGNvbXB1dGVTbG90U2VnQ29sbGlzaW9ucyhzZWcsIG90aGVyU2VncywgcmVzdWx0cykge1xuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHRmb3IgKHZhciBpPTA7IGk8b3RoZXJTZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKGlzU2xvdFNlZ0NvbGxpc2lvbihzZWcsIG90aGVyU2Vnc1tpXSkpIHtcblx0XHRcdHJlc3VsdHMucHVzaChvdGhlclNlZ3NbaV0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5cbi8vIERvIHRoZXNlIHNlZ21lbnRzIG9jY3VweSB0aGUgc2FtZSB2ZXJ0aWNhbCBzcGFjZT9cbmZ1bmN0aW9uIGlzU2xvdFNlZ0NvbGxpc2lvbihzZWcxLCBzZWcyKSB7XG5cdHJldHVybiBzZWcxLmJvdHRvbSA+IHNlZzIudG9wICYmIHNlZzEudG9wIDwgc2VnMi5ib3R0b207XG59XG5cbjs7XG5cbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZyb20gd2hpY2ggb3RoZXIgdmlld3MgaW5oZXJpdCBmcm9tXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxudmFyIFZpZXcgPSBGQy5WaWV3ID0gTW9kZWwuZXh0ZW5kKHtcblxuXHR0eXBlOiBudWxsLCAvLyBzdWJjbGFzcycgdmlldyBuYW1lIChzdHJpbmcpXG5cdG5hbWU6IG51bGwsIC8vIGRlcHJlY2F0ZWQuIHVzZSBgdHlwZWAgaW5zdGVhZFxuXHR0aXRsZTogbnVsbCwgLy8gdGhlIHRleHQgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgaGVhZGVyJ3MgdGl0bGVcblxuXHRjYWxlbmRhcjogbnVsbCwgLy8gb3duZXIgQ2FsZW5kYXIgb2JqZWN0XG5cdHZpZXdTcGVjOiBudWxsLFxuXHRvcHRpb25zOiBudWxsLCAvLyBoYXNoIGNvbnRhaW5pbmcgYWxsIG9wdGlvbnMuIGFscmVhZHkgbWVyZ2VkIHdpdGggdmlldy1zcGVjaWZpYy1vcHRpb25zXG5cdGVsOiBudWxsLCAvLyB0aGUgdmlldydzIGNvbnRhaW5pbmcgZWxlbWVudC4gc2V0IGJ5IENhbGVuZGFyXG5cblx0cmVuZGVyUXVldWU6IG51bGwsXG5cdGJhdGNoUmVuZGVyRGVwdGg6IDAsXG5cdGlzRGF0ZXNSZW5kZXJlZDogZmFsc2UsXG5cdGlzRXZlbnRzUmVuZGVyZWQ6IGZhbHNlLFxuXHRpc0Jhc2VSZW5kZXJlZDogZmFsc2UsIC8vIHJlbGF0ZWQgdG8gdmlld1JlbmRlci92aWV3RGVzdHJveSB0cmlnZ2Vyc1xuXG5cdHF1ZXVlZFNjcm9sbDogbnVsbCxcblxuXHRpc1JUTDogZmFsc2UsXG5cdGlzU2VsZWN0ZWQ6IGZhbHNlLCAvLyBib29sZWFuIHdoZXRoZXIgYSByYW5nZSBvZiB0aW1lIGlzIHVzZXItc2VsZWN0ZWQgb3Igbm90XG5cdHNlbGVjdGVkRXZlbnQ6IG51bGwsXG5cblx0ZXZlbnRPcmRlclNwZWNzOiBudWxsLCAvLyBjcml0ZXJpYSBmb3Igb3JkZXJpbmcgZXZlbnRzIHdoZW4gdGhleSBoYXZlIHNhbWUgZGF0ZS90aW1lXG5cblx0Ly8gY2xhc3NOYW1lcyBzdHlsZWQgYnkganF1aSB0aGVtZXNcblx0d2lkZ2V0SGVhZGVyQ2xhc3M6IG51bGwsXG5cdHdpZGdldENvbnRlbnRDbGFzczogbnVsbCxcblx0aGlnaGxpZ2h0U3RhdGVDbGFzczogbnVsbCxcblxuXHQvLyBmb3IgZGF0ZSB1dGlscywgY29tcHV0ZWQgZnJvbSBvcHRpb25zXG5cdG5leHREYXlUaHJlc2hvbGQ6IG51bGwsXG5cdGlzSGlkZGVuRGF5SGFzaDogbnVsbCxcblxuXHQvLyBub3cgaW5kaWNhdG9yXG5cdGlzTm93SW5kaWNhdG9yUmVuZGVyZWQ6IG51bGwsXG5cdGluaXRpYWxOb3dEYXRlOiBudWxsLCAvLyByZXN1bHQgZmlyc3QgZ2V0Tm93IGNhbGxcblx0aW5pdGlhbE5vd1F1ZXJpZWRNczogbnVsbCwgLy8gbXMgdGltZSB0aGUgZ2V0Tm93IHdhcyBjYWxsZWRcblx0bm93SW5kaWNhdG9yVGltZW91dElEOiBudWxsLCAvLyBmb3IgcmVmcmVzaCB0aW1pbmcgb2Ygbm93IGluZGljYXRvclxuXHRub3dJbmRpY2F0b3JJbnRlcnZhbElEOiBudWxsLCAvLyBcIlxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKGNhbGVuZGFyLCB2aWV3U3BlYykge1xuXHRcdE1vZGVsLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuXG5cdFx0dGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xuXHRcdHRoaXMudmlld1NwZWMgPSB2aWV3U3BlYztcblxuXHRcdC8vIHNob3J0Y3V0c1xuXHRcdHRoaXMudHlwZSA9IHZpZXdTcGVjLnR5cGU7XG5cdFx0dGhpcy5vcHRpb25zID0gdmlld1NwZWMub3B0aW9ucztcblxuXHRcdC8vIC5uYW1lIGlzIGRlcHJlY2F0ZWRcblx0XHR0aGlzLm5hbWUgPSB0aGlzLnR5cGU7XG5cblx0XHR0aGlzLm5leHREYXlUaHJlc2hvbGQgPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ25leHREYXlUaHJlc2hvbGQnKSk7XG5cdFx0dGhpcy5pbml0VGhlbWluZ1Byb3BzKCk7XG5cdFx0dGhpcy5pbml0SGlkZGVuRGF5cygpO1xuXHRcdHRoaXMuaXNSVEwgPSB0aGlzLm9wdCgnaXNSVEwnKTtcblxuXHRcdHRoaXMuZXZlbnRPcmRlclNwZWNzID0gcGFyc2VGaWVsZFNwZWNzKHRoaXMub3B0KCdldmVudE9yZGVyJykpO1xuXG5cdFx0dGhpcy5yZW5kZXJRdWV1ZSA9IHRoaXMuYnVpbGRSZW5kZXJRdWV1ZSgpO1xuXHRcdHRoaXMuaW5pdEF1dG9CYXRjaFJlbmRlcigpO1xuXG5cdFx0dGhpcy5pbml0aWFsaXplKCk7XG5cdH0sXG5cblxuXHRidWlsZFJlbmRlclF1ZXVlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciByZW5kZXJRdWV1ZSA9IG5ldyBSZW5kZXJRdWV1ZSh7XG5cdFx0XHRldmVudDogdGhpcy5vcHQoJ2V2ZW50UmVuZGVyV2FpdCcpXG5cdFx0fSk7XG5cblx0XHRyZW5kZXJRdWV1ZS5vbignc3RhcnQnLCBmdW5jdGlvbigpIHtcblx0XHRcdF90aGlzLmZyZWV6ZUhlaWdodCgpO1xuXHRcdFx0X3RoaXMuYWRkU2Nyb2xsKF90aGlzLnF1ZXJ5U2Nyb2xsKCkpO1xuXHRcdH0pO1xuXG5cdFx0cmVuZGVyUXVldWUub24oJ3N0b3AnLCBmdW5jdGlvbigpIHtcblx0XHRcdF90aGlzLnRoYXdIZWlnaHQoKTtcblx0XHRcdF90aGlzLnBvcFNjcm9sbCgpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHJlbmRlclF1ZXVlO1xuXHR9LFxuXG5cblx0aW5pdEF1dG9CYXRjaFJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHRoaXMub24oJ2JlZm9yZTpjaGFuZ2UnLCBmdW5jdGlvbigpIHtcblx0XHRcdF90aGlzLnN0YXJ0QmF0Y2hSZW5kZXIoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0X3RoaXMuc3RvcEJhdGNoUmVuZGVyKCk7XG5cdFx0fSk7XG5cdH0sXG5cblxuXHRzdGFydEJhdGNoUmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoISh0aGlzLmJhdGNoUmVuZGVyRGVwdGgrKykpIHtcblx0XHRcdHRoaXMucmVuZGVyUXVldWUucGF1c2UoKTtcblx0XHR9XG5cdH0sXG5cblxuXHRzdG9wQmF0Y2hSZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghKC0tdGhpcy5iYXRjaFJlbmRlckRlcHRoKSkge1xuXHRcdFx0dGhpcy5yZW5kZXJRdWV1ZS5yZXN1bWUoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBBIGdvb2QgcGxhY2UgZm9yIHN1YmNsYXNzZXMgdG8gaW5pdGlhbGl6ZSBtZW1iZXIgdmFyaWFibGVzXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgY2FuIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gUmV0cmlldmVzIGFuIG9wdGlvbiB3aXRoIHRoZSBnaXZlbiBuYW1lXG5cdG9wdDogZnVuY3Rpb24obmFtZSkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnNbbmFtZV07XG5cdH0sXG5cblxuXHQvLyBUcmlnZ2VycyBoYW5kbGVycyB0aGF0IGFyZSB2aWV3LXJlbGF0ZWQuIE1vZGlmaWVzIGFyZ3MgYmVmb3JlIHBhc3NpbmcgdG8gY2FsZW5kYXIuXG5cdHB1YmxpY2x5VHJpZ2dlcjogZnVuY3Rpb24obmFtZSwgdGhpc09iaikgeyAvLyBhcmd1bWVudHMgYmV5b25kIHRoaXNPYmogYXJlIHBhc3NlZCBhbG9uZ1xuXHRcdHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XG5cblx0XHRyZXR1cm4gY2FsZW5kYXIucHVibGljbHlUcmlnZ2VyLmFwcGx5KFxuXHRcdFx0Y2FsZW5kYXIsXG5cdFx0XHRbbmFtZSwgdGhpc09iaiB8fCB0aGlzXS5jb25jYXQoXG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksIC8vIGFyZ3VtZW50cyBiZXlvbmQgdGhpc09ialxuXHRcdFx0XHRbIHRoaXMgXSAvLyBhbHdheXMgbWFrZSB0aGUgbGFzdCBhcmd1bWVudCBhIHJlZmVyZW5jZSB0byB0aGUgdmlldy4gVE9ETzogZGVwcmVjYXRlXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXG5cdC8qIFRpdGxlIGFuZCBEYXRlIEZvcm1hdHRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFNldHMgdGhlIHZpZXcncyB0aXRsZSBwcm9wZXJ0eSB0byB0aGUgbW9zdCB1cGRhdGVkIGNvbXB1dGVkIHZhbHVlXG5cdHVwZGF0ZVRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpdGxlID0gdGhpcy5jb21wdXRlVGl0bGUoKTtcblx0XHR0aGlzLmNhbGVuZGFyLnNldFRvb2xiYXJzVGl0bGUodGhpcy50aXRsZSk7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyB3aGF0IHRoZSB0aXRsZSBhdCB0aGUgdG9wIG9mIHRoZSBjYWxlbmRhciBzaG91bGQgYmUgZm9yIHRoaXMgdmlld1xuXHRjb21wdXRlVGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByYW5nZTtcblxuXHRcdC8vIGZvciB2aWV3cyB0aGF0IHNwYW4gYSBsYXJnZSB1bml0IG9mIHRpbWUsIHNob3cgdGhlIHByb3BlciBpbnRlcnZhbCwgaWdub3Jpbmcgc3RyYXkgZGF5cyBiZWZvcmUgYW5kIGFmdGVyXG5cdFx0aWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdCh0aGlzLmN1cnJlbnRSYW5nZVVuaXQpKSB7XG5cdFx0XHRyYW5nZSA9IHRoaXMuY3VycmVudFJhbmdlO1xuXHRcdH1cblx0XHRlbHNlIHsgLy8gZm9yIGRheSB1bml0cyBvciBzbWFsbGVyLCB1c2UgdGhlIGFjdHVhbCBkYXkgcmFuZ2Vcblx0XHRcdHJhbmdlID0gdGhpcy5hY3RpdmVSYW5nZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5mb3JtYXRSYW5nZShcblx0XHRcdHtcblx0XHRcdFx0Ly8gaW4gY2FzZSBjdXJyZW50UmFuZ2UgaGFzIGEgdGltZSwgbWFrZSBzdXJlIHRpbWV6b25lIGlzIGNvcnJlY3Rcblx0XHRcdFx0c3RhcnQ6IHRoaXMuY2FsZW5kYXIuYXBwbHlUaW1lem9uZShyYW5nZS5zdGFydCksXG5cdFx0XHRcdGVuZDogdGhpcy5jYWxlbmRhci5hcHBseVRpbWV6b25lKHJhbmdlLmVuZClcblx0XHRcdH0sXG5cdFx0XHR0aGlzLm9wdCgndGl0bGVGb3JtYXQnKSB8fCB0aGlzLmNvbXB1dGVUaXRsZUZvcm1hdCgpLFxuXHRcdFx0dGhpcy5vcHQoJ3RpdGxlUmFuZ2VTZXBhcmF0b3InKVxuXHRcdCk7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIGZvcm1hdCBzdHJpbmcgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGl0bGUgZm9yIHRoZSBjdXJyZW50IGRhdGUgcmFuZ2UuXG5cdC8vIEF0dGVtcHRzIHRvIGNvbXB1dGUgdGhlIG1vc3QgYXBwcm9wcmlhdGUgZm9ybWF0IGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCB3aXRoIGB0aXRsZUZvcm1hdGAuXG5cdGNvbXB1dGVUaXRsZUZvcm1hdDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuY3VycmVudFJhbmdlVW5pdCA9PSAneWVhcicpIHtcblx0XHRcdHJldHVybiAnWVlZWSc7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuY3VycmVudFJhbmdlVW5pdCA9PSAnbW9udGgnKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHQoJ21vbnRoWWVhckZvcm1hdCcpOyAvLyBsaWtlIFwiU2VwdGVtYmVyIDIwMTRcIlxuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLmN1cnJlbnRSYW5nZUFzKCdkYXlzJykgPiAxKSB7XG5cdFx0XHRyZXR1cm4gJ2xsJzsgLy8gbXVsdGktZGF5IHJhbmdlLiBzaG9ydGVyLCBsaWtlIFwiU2VwIDkgLSAxMCAyMDE0XCJcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gJ0xMJzsgLy8gb25lIGRheS4gbG9uZ2VyLCBsaWtlIFwiU2VwdGVtYmVyIDkgMjAxNFwiXG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVXRpbGl0eSBmb3IgZm9ybWF0dGluZyBhIHJhbmdlLiBBY2NlcHRzIGEgcmFuZ2Ugb2JqZWN0LCBmb3JtYXR0aW5nIHN0cmluZywgYW5kIG9wdGlvbmFsIHNlcGFyYXRvci5cblx0Ly8gRGlzcGxheXMgYWxsLWRheSByYW5nZXMgbmF0dXJhbGx5LCB3aXRoIGFuIGluY2x1c2l2ZSBlbmQuIFRha2VzIHRoZSBjdXJyZW50IGlzUlRMIGludG8gYWNjb3VudC5cblx0Ly8gVGhlIHRpbWV6b25lcyBvZiB0aGUgZGF0ZXMgd2l0aGluIGByYW5nZWAgd2lsbCBiZSByZXNwZWN0ZWQuXG5cdGZvcm1hdFJhbmdlOiBmdW5jdGlvbihyYW5nZSwgZm9ybWF0U3RyLCBzZXBhcmF0b3IpIHtcblx0XHR2YXIgZW5kID0gcmFuZ2UuZW5kO1xuXG5cdFx0aWYgKCFlbmQuaGFzVGltZSgpKSB7IC8vIGFsbC1kYXk/XG5cdFx0XHRlbmQgPSBlbmQuY2xvbmUoKS5zdWJ0cmFjdCgxKTsgLy8gY29udmVydCB0byBpbmNsdXNpdmUuIGxhc3QgbXMgb2YgcHJldmlvdXMgZGF5XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZvcm1hdFJhbmdlKHJhbmdlLnN0YXJ0LCBlbmQsIGZvcm1hdFN0ciwgc2VwYXJhdG9yLCB0aGlzLm9wdCgnaXNSVEwnKSk7XG5cdH0sXG5cblxuXHRnZXRBbGxEYXlIdG1sOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHQoJ2FsbERheUh0bWwnKSB8fCBodG1sRXNjYXBlKHRoaXMub3B0KCdhbGxEYXlUZXh0JykpO1xuXHR9LFxuXG5cblx0LyogTmF2aWdhdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gR2VuZXJhdGVzIEhUTUwgZm9yIGFuIGFuY2hvciB0byBhbm90aGVyIHZpZXcgaW50byB0aGUgY2FsZW5kYXIuXG5cdC8vIFdpbGwgZWl0aGVyIGdlbmVyYXRlIGFuIDxhPiB0YWcgb3IgYSBub24tY2xpY2thYmxlIDxzcGFuPiB0YWcsIGRlcGVuZGluZyBvbiBlbmFibGVkIHNldHRpbmdzLlxuXHQvLyBgZ290b09wdGlvbnNgIGNhbiBlaXRoZXIgYmUgYSBtb21lbnQgaW5wdXQsIG9yIGFuIG9iamVjdCB3aXRoIHRoZSBmb3JtOlxuXHQvLyB7IGRhdGUsIHR5cGUsIGZvcmNlT2ZmIH1cblx0Ly8gYHR5cGVgIGlzIGEgdmlldy10eXBlIGxpa2UgXCJkYXlcIiBvciBcIndlZWtcIi4gZGVmYXVsdCB2YWx1ZSBpcyBcImRheVwiLlxuXHQvLyBgYXR0cnNgIGFuZCBgaW5uZXJIdG1sYCBhcmUgdXNlIHRvIGdlbmVyYXRlIHRoZSByZXN0IG9mIHRoZSBIVE1MIHRhZy5cblx0YnVpbGRHb3RvQW5jaG9ySHRtbDogZnVuY3Rpb24oZ290b09wdGlvbnMsIGF0dHJzLCBpbm5lckh0bWwpIHtcblx0XHR2YXIgZGF0ZSwgdHlwZSwgZm9yY2VPZmY7XG5cdFx0dmFyIGZpbmFsT3B0aW9ucztcblxuXHRcdGlmICgkLmlzUGxhaW5PYmplY3QoZ290b09wdGlvbnMpKSB7XG5cdFx0XHRkYXRlID0gZ290b09wdGlvbnMuZGF0ZTtcblx0XHRcdHR5cGUgPSBnb3RvT3B0aW9ucy50eXBlO1xuXHRcdFx0Zm9yY2VPZmYgPSBnb3RvT3B0aW9ucy5mb3JjZU9mZjtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRkYXRlID0gZ290b09wdGlvbnM7IC8vIGEgc2luZ2xlIG1vbWVudCBpbnB1dFxuXHRcdH1cblx0XHRkYXRlID0gRkMubW9tZW50KGRhdGUpOyAvLyBpZiBhIHN0cmluZywgcGFyc2UgaXRcblxuXHRcdGZpbmFsT3B0aW9ucyA9IHsgLy8gZm9yIHNlcmlhbGl6YXRpb24gaW50byB0aGUgbGlua1xuXHRcdFx0ZGF0ZTogZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSxcblx0XHRcdHR5cGU6IHR5cGUgfHwgJ2RheSdcblx0XHR9O1xuXG5cdFx0aWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGlubmVySHRtbCA9IGF0dHJzO1xuXHRcdFx0YXR0cnMgPSBudWxsO1xuXHRcdH1cblxuXHRcdGF0dHJzID0gYXR0cnMgPyAnICcgKyBhdHRyc1RvU3RyKGF0dHJzKSA6ICcnOyAvLyB3aWxsIGhhdmUgYSBsZWFkaW5nIHNwYWNlXG5cdFx0aW5uZXJIdG1sID0gaW5uZXJIdG1sIHx8ICcnO1xuXG5cdFx0aWYgKCFmb3JjZU9mZiAmJiB0aGlzLm9wdCgnbmF2TGlua3MnKSkge1xuXHRcdFx0cmV0dXJuICc8YScgKyBhdHRycyArXG5cdFx0XHRcdCcgZGF0YS1nb3RvPVwiJyArIGh0bWxFc2NhcGUoSlNPTi5zdHJpbmdpZnkoZmluYWxPcHRpb25zKSkgKyAnXCI+JyArXG5cdFx0XHRcdGlubmVySHRtbCArXG5cdFx0XHRcdCc8L2E+Jztcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gJzxzcGFuJyArIGF0dHJzICsgJz4nICtcblx0XHRcdFx0aW5uZXJIdG1sICtcblx0XHRcdFx0Jzwvc3Bhbj4nO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJlbmRlcmluZyBOb24tZGF0ZS1yZWxhdGVkIENvbnRlbnRcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdC8vIFNldHMgdGhlIGNvbnRhaW5lciBlbGVtZW50IHRoYXQgdGhlIHZpZXcgc2hvdWxkIHJlbmRlciBpbnNpZGUgb2YsIGRvZXMgZ2xvYmFsIERPTS1yZWxhdGVkIGluaXRpYWxpemF0aW9ucyxcblx0Ly8gYW5kIHJlbmRlcnMgYWxsIHRoZSBub24tZGF0ZS1yZWxhdGVkIGNvbnRlbnQgaW5zaWRlLlxuXHRzZXRFbGVtZW50OiBmdW5jdGlvbihlbCkge1xuXHRcdHRoaXMuZWwgPSBlbDtcblx0XHR0aGlzLmJpbmRHbG9iYWxIYW5kbGVycygpO1xuXHRcdHRoaXMuYmluZEJhc2VSZW5kZXJIYW5kbGVycygpO1xuXHRcdHRoaXMucmVuZGVyU2tlbGV0b24oKTtcblx0fSxcblxuXG5cdC8vIFJlbW92ZXMgdGhlIHZpZXcncyBjb250YWluZXIgZWxlbWVudCBmcm9tIHRoZSBET00sIGNsZWFyaW5nIGFueSBjb250ZW50IGJlZm9yZWhhbmQuXG5cdC8vIFVuZG9lcyBhbnkgb3RoZXIgRE9NLXJlbGF0ZWQgYXR0YWNobWVudHMuXG5cdHJlbW92ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5zZXREYXRlKCk7XG5cdFx0dGhpcy51bnJlbmRlclNrZWxldG9uKCk7XG5cblx0XHR0aGlzLnVuYmluZEdsb2JhbEhhbmRsZXJzKCk7XG5cdFx0dGhpcy51bmJpbmRCYXNlUmVuZGVySGFuZGxlcnMoKTtcblxuXHRcdHRoaXMuZWwucmVtb3ZlKCk7XG5cdFx0Ly8gTk9URTogZG9uJ3QgbnVsbC1vdXQgdGhpcy5lbCBpbiBjYXNlIHRoZSBWaWV3IHdhcyBkZXN0cm95ZWQgd2l0aGluIGFuIEFQSSBjYWxsYmFjay5cblx0XHQvLyBXZSBkb24ndCBudWxsLW91dCB0aGUgVmlldydzIG90aGVyIGpRdWVyeSBlbGVtZW50IHJlZmVyZW5jZXMgdXBvbiBkZXN0cm95LFxuXHRcdC8vICBzbyB3ZSBzaG91bGRuJ3Qga2lsbCB0aGlzLmVsIGVpdGhlci5cblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIGJhc2ljIHN0cnVjdHVyZSBvZiB0aGUgdmlldyBiZWZvcmUgYW55IGNvbnRlbnQgaXMgcmVuZGVyZWRcblx0cmVuZGVyU2tlbGV0b246IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIHRoZSBiYXNpYyBzdHJ1Y3R1cmUgb2YgdGhlIHZpZXdcblx0dW5yZW5kZXJTa2VsZXRvbjogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBEYXRlIFNldHRpbmcvVW5zZXR0aW5nXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRzZXREYXRlOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIGN1cnJlbnREYXRlUHJvZmlsZSA9IHRoaXMuZ2V0KCdkYXRlUHJvZmlsZScpO1xuXHRcdHZhciBuZXdEYXRlUHJvZmlsZSA9IHRoaXMuYnVpbGREYXRlUHJvZmlsZShkYXRlLCBudWxsLCB0cnVlKTsgLy8gZm9yY2VUb1ZhbGlkPXRydWVcblxuXHRcdGlmIChcblx0XHRcdCFjdXJyZW50RGF0ZVByb2ZpbGUgfHxcblx0XHRcdCFpc1Jhbmdlc0VxdWFsKGN1cnJlbnREYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgbmV3RGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UpXG5cdFx0KSB7XG5cdFx0XHR0aGlzLnNldCgnZGF0ZVByb2ZpbGUnLCBuZXdEYXRlUHJvZmlsZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld0RhdGVQcm9maWxlLmRhdGU7XG5cdH0sXG5cblxuXHR1bnNldERhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5zZXQoJ2RhdGVQcm9maWxlJyk7XG5cdH0sXG5cblxuXHQvLyBEYXRlIFJlbmRlcmluZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0cmVxdWVzdERhdGVSZW5kZXI6IGZ1bmN0aW9uKGRhdGVQcm9maWxlKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHRoaXMucmVuZGVyUXVldWUucXVldWUoZnVuY3Rpb24oKSB7XG5cdFx0XHRfdGhpcy5leGVjdXRlRGF0ZVJlbmRlcihkYXRlUHJvZmlsZSk7XG5cdFx0fSwgJ2RhdGUnLCAnaW5pdCcpO1xuXHR9LFxuXG5cblx0cmVxdWVzdERhdGVVbnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHRoaXMucmVuZGVyUXVldWUucXVldWUoZnVuY3Rpb24oKSB7XG5cdFx0XHRfdGhpcy5leGVjdXRlRGF0ZVVucmVuZGVyKCk7XG5cdFx0fSwgJ2RhdGUnLCAnZGVzdHJveScpO1xuXHR9LFxuXG5cblx0Ly8gRXZlbnQgRGF0YVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0ZmV0Y2hJbml0aWFsRXZlbnRzOiBmdW5jdGlvbihkYXRlUHJvZmlsZSkge1xuXHRcdHJldHVybiB0aGlzLmNhbGVuZGFyLnJlcXVlc3RFdmVudHMoXG5cdFx0XHRkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5zdGFydCxcblx0XHRcdGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLmVuZFxuXHRcdCk7XG5cdH0sXG5cblxuXHRiaW5kRXZlbnRDaGFuZ2VzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmxpc3RlblRvKHRoaXMuY2FsZW5kYXIsICdldmVudHNSZXNldCcsIHRoaXMucmVzZXRFdmVudHMpO1xuXHR9LFxuXG5cblx0dW5iaW5kRXZlbnRDaGFuZ2VzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3BMaXN0ZW5pbmdUbyh0aGlzLmNhbGVuZGFyLCAnZXZlbnRzUmVzZXQnKTtcblx0fSxcblxuXG5cdHNldEV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0dGhpcy5zZXQoJ2N1cnJlbnRFdmVudHMnLCBldmVudHMpO1xuXHRcdHRoaXMuc2V0KCdoYXNFdmVudHMnLCB0cnVlKTtcblx0fSxcblxuXG5cdHVuc2V0RXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVuc2V0KCdjdXJyZW50RXZlbnRzJyk7XG5cdFx0dGhpcy51bnNldCgnaGFzRXZlbnRzJyk7XG5cdH0sXG5cblxuXHRyZXNldEV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0dGhpcy5zdGFydEJhdGNoUmVuZGVyKCk7XG5cdFx0dGhpcy51bnNldEV2ZW50cygpO1xuXHRcdHRoaXMuc2V0RXZlbnRzKGV2ZW50cyk7XG5cdFx0dGhpcy5zdG9wQmF0Y2hSZW5kZXIoKTtcblx0fSxcblxuXG5cdC8vIEV2ZW50IFJlbmRlcmluZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0cmVxdWVzdEV2ZW50c1JlbmRlcjogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHRoaXMucmVuZGVyUXVldWUucXVldWUoZnVuY3Rpb24oKSB7XG5cdFx0XHRfdGhpcy5leGVjdXRlRXZlbnRzUmVuZGVyKGV2ZW50cyk7XG5cdFx0fSwgJ2V2ZW50JywgJ2luaXQnKTtcblx0fSxcblxuXG5cdHJlcXVlc3RFdmVudHNVbnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHRoaXMucmVuZGVyUXVldWUucXVldWUoZnVuY3Rpb24oKSB7XG5cdFx0XHRfdGhpcy5leGVjdXRlRXZlbnRzVW5yZW5kZXIoKTtcblx0XHR9LCAnZXZlbnQnLCAnZGVzdHJveScpO1xuXHR9LFxuXG5cblx0Ly8gRGF0ZSBIaWdoLWxldmVsIFJlbmRlcmluZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gaWYgZGF0ZVByb2ZpbGUgbm90IHNwZWNpZmllZCwgdXNlcyBjdXJyZW50XG5cdGV4ZWN1dGVEYXRlUmVuZGVyOiBmdW5jdGlvbihkYXRlUHJvZmlsZSwgc2tpcFNjcm9sbCkge1xuXG5cdFx0dGhpcy5zZXREYXRlUHJvZmlsZUZvclJlbmRlcmluZyhkYXRlUHJvZmlsZSk7XG5cdFx0dGhpcy51cGRhdGVUaXRsZSgpO1xuXHRcdHRoaXMuY2FsZW5kYXIudXBkYXRlVG9vbGJhckJ1dHRvbnMoKTtcblxuXHRcdGlmICh0aGlzLnJlbmRlcikge1xuXHRcdFx0dGhpcy5yZW5kZXIoKTsgLy8gVE9ETzogZGVwcmVjYXRlXG5cdFx0fVxuXG5cdFx0dGhpcy5yZW5kZXJEYXRlcygpO1xuXHRcdHRoaXMudXBkYXRlU2l6ZSgpO1xuXHRcdHRoaXMucmVuZGVyQnVzaW5lc3NIb3VycygpOyAvLyBtaWdodCBuZWVkIGNvb3JkaW5hdGVzLCBzbyBzaG91bGQgZ28gYWZ0ZXIgdXBkYXRlU2l6ZSgpXG5cdFx0dGhpcy5zdGFydE5vd0luZGljYXRvcigpO1xuXG5cdFx0aWYgKCFza2lwU2Nyb2xsKSB7XG5cdFx0XHR0aGlzLmFkZFNjcm9sbCh0aGlzLmNvbXB1dGVJbml0aWFsRGF0ZVNjcm9sbCgpKTtcblx0XHR9XG5cblx0XHR0aGlzLmlzRGF0ZXNSZW5kZXJlZCA9IHRydWU7XG5cdFx0dGhpcy50cmlnZ2VyKCdkYXRlc1JlbmRlcmVkJyk7XG5cdH0sXG5cblxuXHRleGVjdXRlRGF0ZVVucmVuZGVyOiBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMudW5zZWxlY3QoKTtcblx0XHR0aGlzLnN0b3BOb3dJbmRpY2F0b3IoKTtcblxuXHRcdHRoaXMudHJpZ2dlcignYmVmb3JlOmRhdGVzVW5yZW5kZXJlZCcpO1xuXG5cdFx0dGhpcy51bnJlbmRlckJ1c2luZXNzSG91cnMoKTtcblx0XHR0aGlzLnVucmVuZGVyRGF0ZXMoKTtcblxuXHRcdGlmICh0aGlzLmRlc3Ryb3kpIHtcblx0XHRcdHRoaXMuZGVzdHJveSgpOyAvLyBUT0RPOiBkZXByZWNhdGVcblx0XHR9XG5cblx0XHR0aGlzLmlzRGF0ZXNSZW5kZXJlZCA9IGZhbHNlO1xuXHR9LFxuXG5cblx0Ly8gRGF0ZSBMb3ctbGV2ZWwgUmVuZGVyaW5nXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHQvLyBkYXRlLWNlbGwgY29udGVudCBvbmx5XG5cdHJlbmRlckRhdGVzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIGRhdGUtY2VsbCBjb250ZW50IG9ubHlcblx0dW5yZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcblx0fSxcblxuXG5cdC8vIERldGVybWluZyB3aGVuIHRoZSBcIm1lYXRcIiBvZiB0aGUgdmlldyBpcyByZW5kZXJlZCAoYWthIHRoZSBiYXNlKVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0YmluZEJhc2VSZW5kZXJIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHRoaXMub24oJ2RhdGVzUmVuZGVyZWQuYmFzZUhhbmRsZXInLCBmdW5jdGlvbigpIHtcblx0XHRcdF90aGlzLm9uQmFzZVJlbmRlcigpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5vbignYmVmb3JlOmRhdGVzVW5yZW5kZXJlZC5iYXNlSGFuZGxlcicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0X3RoaXMub25CZWZvcmVCYXNlVW5yZW5kZXIoKTtcblx0XHR9KTtcblx0fSxcblxuXG5cdHVuYmluZEJhc2VSZW5kZXJIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5vZmYoJy5iYXNlSGFuZGxlcicpO1xuXHR9LFxuXG5cblx0b25CYXNlUmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmFwcGx5U2NyZWVuU3RhdGUoKTtcblx0XHR0aGlzLnB1YmxpY2x5VHJpZ2dlcigndmlld1JlbmRlcicsIHRoaXMsIHRoaXMsIHRoaXMuZWwpO1xuXHR9LFxuXG5cblx0b25CZWZvcmVCYXNlVW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYXBwbHlTY3JlZW5TdGF0ZSgpO1xuXHRcdHRoaXMucHVibGljbHlUcmlnZ2VyKCd2aWV3RGVzdHJveScsIHRoaXMsIHRoaXMsIHRoaXMuZWwpO1xuXHR9LFxuXG5cblx0Ly8gTWlzYyB2aWV3IHJlbmRlcmluZyB1dGlsc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gQmluZHMgRE9NIGhhbmRsZXJzIHRvIGVsZW1lbnRzIHRoYXQgcmVzaWRlIG91dHNpZGUgdGhlIHZpZXcgY29udGFpbmVyLCBzdWNoIGFzIHRoZSBkb2N1bWVudFxuXHRiaW5kR2xvYmFsSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMubGlzdGVuVG8oR2xvYmFsRW1pdHRlci5nZXQoKSwge1xuXHRcdFx0dG91Y2hzdGFydDogdGhpcy5wcm9jZXNzVW5zZWxlY3QsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZWRvd25cblx0XHR9KTtcblx0fSxcblxuXG5cdC8vIFVuYmluZHMgRE9NIGhhbmRsZXJzIGZyb20gZWxlbWVudHMgdGhhdCByZXNpZGUgb3V0c2lkZSB0aGUgdmlldyBjb250YWluZXJcblx0dW5iaW5kR2xvYmFsSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RvcExpc3RlbmluZ1RvKEdsb2JhbEVtaXR0ZXIuZ2V0KCkpO1xuXHR9LFxuXG5cblx0Ly8gSW5pdGlhbGl6ZXMgaW50ZXJuYWwgdmFyaWFibGVzIHJlbGF0ZWQgdG8gdGhlbWluZ1xuXHRpbml0VGhlbWluZ1Byb3BzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdG0gPSB0aGlzLm9wdCgndGhlbWUnKSA/ICd1aScgOiAnZmMnO1xuXG5cdFx0dGhpcy53aWRnZXRIZWFkZXJDbGFzcyA9IHRtICsgJy13aWRnZXQtaGVhZGVyJztcblx0XHR0aGlzLndpZGdldENvbnRlbnRDbGFzcyA9IHRtICsgJy13aWRnZXQtY29udGVudCc7XG5cdFx0dGhpcy5oaWdobGlnaHRTdGF0ZUNsYXNzID0gdG0gKyAnLXN0YXRlLWhpZ2hsaWdodCc7XG5cdH0sXG5cblxuXHQvKiBCdXNpbmVzcyBIb3Vyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBidXNpbmVzcy1ob3VycyBvbnRvIHRoZSB2aWV3LiBBc3N1bWVzIHVwZGF0ZVNpemUgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQuXG5cdHJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIHByZXZpb3VzbHktcmVuZGVyZWQgYnVzaW5lc3MtaG91cnNcblx0dW5yZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8qIE5vdyBJbmRpY2F0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEltbWVkaWF0ZWx5IHJlbmRlciB0aGUgY3VycmVudCB0aW1lIGluZGljYXRvciBhbmQgYmVnaW5zIHJlLXJlbmRlcmluZyBpdCBhdCBhbiBpbnRlcnZhbCxcblx0Ly8gd2hpY2ggaXMgZGVmaW5lZCBieSB0aGlzLmdldE5vd0luZGljYXRvclVuaXQoKS5cblx0Ly8gVE9ETzogc29tZWhvdyBkbyB0aGlzIGZvciB0aGUgY3VycmVudCB3aG9sZSBkYXkncyBiYWNrZ3JvdW5kIHRvb1xuXHRzdGFydE5vd0luZGljYXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdW5pdDtcblx0XHR2YXIgdXBkYXRlO1xuXHRcdHZhciBkZWxheTsgLy8gbXMgd2FpdCB2YWx1ZVxuXG5cdFx0aWYgKHRoaXMub3B0KCdub3dJbmRpY2F0b3InKSkge1xuXHRcdFx0dW5pdCA9IHRoaXMuZ2V0Tm93SW5kaWNhdG9yVW5pdCgpO1xuXHRcdFx0aWYgKHVuaXQpIHtcblx0XHRcdFx0dXBkYXRlID0gcHJveHkodGhpcywgJ3VwZGF0ZU5vd0luZGljYXRvcicpOyAvLyBiaW5kIHRvIGB0aGlzYFxuXG5cdFx0XHRcdHRoaXMuaW5pdGlhbE5vd0RhdGUgPSB0aGlzLmNhbGVuZGFyLmdldE5vdygpO1xuXHRcdFx0XHR0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMgPSArbmV3IERhdGUoKTtcblx0XHRcdFx0dGhpcy5yZW5kZXJOb3dJbmRpY2F0b3IodGhpcy5pbml0aWFsTm93RGF0ZSk7XG5cdFx0XHRcdHRoaXMuaXNOb3dJbmRpY2F0b3JSZW5kZXJlZCA9IHRydWU7XG5cblx0XHRcdFx0Ly8gd2FpdCB1bnRpbCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGludGVydmFsXG5cdFx0XHRcdGRlbGF5ID0gdGhpcy5pbml0aWFsTm93RGF0ZS5jbG9uZSgpLnN0YXJ0T2YodW5pdCkuYWRkKDEsIHVuaXQpIC0gdGhpcy5pbml0aWFsTm93RGF0ZTtcblx0XHRcdFx0dGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdF90aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCA9IG51bGw7XG5cdFx0XHRcdFx0dXBkYXRlKCk7XG5cdFx0XHRcdFx0ZGVsYXkgPSArbW9tZW50LmR1cmF0aW9uKDEsIHVuaXQpO1xuXHRcdFx0XHRcdGRlbGF5ID0gTWF0aC5tYXgoMTAwLCBkZWxheSk7IC8vIHByZXZlbnQgdG9vIGZyZXF1ZW50XG5cdFx0XHRcdFx0X3RoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCA9IHNldEludGVydmFsKHVwZGF0ZSwgZGVsYXkpOyAvLyB1cGRhdGUgZXZlcnkgaW50ZXJ2YWxcblx0XHRcdFx0fSwgZGVsYXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIHJlcmVuZGVycyB0aGUgbm93IGluZGljYXRvciwgY29tcHV0aW5nIHRoZSBuZXcgY3VycmVudCB0aW1lIGZyb20gdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzIHBhc3NlZFxuXHQvLyBzaW5jZSB0aGUgaW5pdGlhbCBnZXROb3cgY2FsbC5cblx0dXBkYXRlTm93SW5kaWNhdG9yOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkKSB7XG5cdFx0XHR0aGlzLnVucmVuZGVyTm93SW5kaWNhdG9yKCk7XG5cdFx0XHR0aGlzLnJlbmRlck5vd0luZGljYXRvcihcblx0XHRcdFx0dGhpcy5pbml0aWFsTm93RGF0ZS5jbG9uZSgpLmFkZChuZXcgRGF0ZSgpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKSAvLyBhZGQgbXNcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gSW1tZWRpYXRlbHkgdW5yZW5kZXJzIHRoZSB2aWV3J3MgY3VycmVudCB0aW1lIGluZGljYXRvciBhbmQgc3RvcHMgYW55IHJlLXJlbmRlcmluZyB0aW1lcnMuXG5cdC8vIFdvbid0IGNhdXNlIHNpZGUgZWZmZWN0cyBpZiBpbmRpY2F0b3IgaXNuJ3QgcmVuZGVyZWQuXG5cdHN0b3BOb3dJbmRpY2F0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQpIHtcblxuXHRcdFx0aWYgKHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCk7XG5cdFx0XHRcdHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLm5vd0luZGljYXRvckludGVydmFsSUQpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCk7XG5cdFx0XHRcdHRoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudW5yZW5kZXJOb3dJbmRpY2F0b3IoKTtcblx0XHRcdHRoaXMuaXNOb3dJbmRpY2F0b3JSZW5kZXJlZCA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgdW5pdCwgbGlrZSAnc2Vjb25kJyBvciAnbWludXRlJyB0aGF0IGRlZmluZWQgaG93IG9mdGVuIHRoZSBjdXJyZW50IHRpbWUgaW5kaWNhdG9yXG5cdC8vIHNob3VsZCBiZSByZWZyZXNoZWQuIElmIHNvbWV0aGluZyBmYWxzeSBpcyByZXR1cm5lZCwgbm8gdGltZSBpbmRpY2F0b3IgaXMgcmVuZGVyZWQgYXQgYWxsLlxuXHRnZXROb3dJbmRpY2F0b3JVbml0OiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgYSBjdXJyZW50IHRpbWUgaW5kaWNhdG9yIGF0IHRoZSBnaXZlbiBkYXRldGltZVxuXHRyZW5kZXJOb3dJbmRpY2F0b3I6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVuZG9lcyB0aGUgcmVuZGVyaW5nIGFjdGlvbnMgZnJvbSByZW5kZXJOb3dJbmRpY2F0b3Jcblx0dW5yZW5kZXJOb3dJbmRpY2F0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogRGltZW5zaW9uc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVmcmVzaGVzIGFueXRoaW5nIGRlcGVuZGFudCB1cG9uIHNpemluZyBvZiB0aGUgY29udGFpbmVyIGVsZW1lbnQgb2YgdGhlIGdyaWRcblx0dXBkYXRlU2l6ZTogZnVuY3Rpb24oaXNSZXNpemUpIHtcblx0XHR2YXIgc2Nyb2xsO1xuXG5cdFx0aWYgKGlzUmVzaXplKSB7XG5cdFx0XHRzY3JvbGwgPSB0aGlzLnF1ZXJ5U2Nyb2xsKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy51cGRhdGVIZWlnaHQoaXNSZXNpemUpO1xuXHRcdHRoaXMudXBkYXRlV2lkdGgoaXNSZXNpemUpO1xuXHRcdHRoaXMudXBkYXRlTm93SW5kaWNhdG9yKCk7XG5cblx0XHRpZiAoaXNSZXNpemUpIHtcblx0XHRcdHRoaXMuYXBwbHlTY3JvbGwoc2Nyb2xsKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBSZWZyZXNoZXMgdGhlIGhvcml6b250YWwgZGltZW5zaW9ucyBvZiB0aGUgY2FsZW5kYXJcblx0dXBkYXRlV2lkdGg6IGZ1bmN0aW9uKGlzUmVzaXplKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBSZWZyZXNoZXMgdGhlIHZlcnRpY2FsIGRpbWVuc2lvbnMgb2YgdGhlIGNhbGVuZGFyXG5cdHVwZGF0ZUhlaWdodDogZnVuY3Rpb24oaXNSZXNpemUpIHtcblx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyOyAvLyB3ZSBwb2xsIHRoZSBjYWxlbmRhciBmb3IgaGVpZ2h0IGluZm9ybWF0aW9uXG5cblx0XHR0aGlzLnNldEhlaWdodChcblx0XHRcdGNhbGVuZGFyLmdldFN1Z2dlc3RlZFZpZXdIZWlnaHQoKSxcblx0XHRcdGNhbGVuZGFyLmlzSGVpZ2h0QXV0bygpXG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIFVwZGF0ZXMgdGhlIHZlcnRpY2FsIGRpbWVuc2lvbnMgb2YgdGhlIGNhbGVuZGFyIHRvIHRoZSBzcGVjaWZpZWQgaGVpZ2h0LlxuXHQvLyBpZiBgaXNBdXRvYCBpcyBzZXQgdG8gdHJ1ZSwgaGVpZ2h0IGJlY29tZXMgbWVyZWx5IGEgc3VnZ2VzdGlvbiBhbmQgdGhlIHZpZXcgc2hvdWxkIHVzZSBpdHMgXCJuYXR1cmFsXCIgaGVpZ2h0LlxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCwgaXNBdXRvKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvKiBTY3JvbGxlclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0YWRkRm9yY2VkU2Nyb2xsOiBmdW5jdGlvbihzY3JvbGwpIHtcblx0XHR0aGlzLmFkZFNjcm9sbChcblx0XHRcdCQuZXh0ZW5kKHNjcm9sbCwgeyBpc0ZvcmNlZDogdHJ1ZSB9KVxuXHRcdCk7XG5cdH0sXG5cblxuXHRhZGRTY3JvbGw6IGZ1bmN0aW9uKHNjcm9sbCkge1xuXHRcdHZhciBxdWV1ZWRTY3JvbGwgPSB0aGlzLnF1ZXVlZFNjcm9sbCB8fCAodGhpcy5xdWV1ZWRTY3JvbGwgPSB7fSk7XG5cblx0XHRpZiAoIXF1ZXVlZFNjcm9sbC5pc0ZvcmNlZCkge1xuXHRcdFx0JC5leHRlbmQocXVldWVkU2Nyb2xsLCBzY3JvbGwpO1xuXHRcdH1cblx0fSxcblxuXG5cdHBvcFNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5hcHBseVF1ZXVlZFNjcm9sbCgpO1xuXHRcdHRoaXMucXVldWVkU2Nyb2xsID0gbnVsbDtcblx0fSxcblxuXG5cdGFwcGx5UXVldWVkU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5xdWV1ZWRTY3JvbGwpIHtcblx0XHRcdHRoaXMuYXBwbHlTY3JvbGwodGhpcy5xdWV1ZWRTY3JvbGwpO1xuXHRcdH1cblx0fSxcblxuXG5cdHF1ZXJ5U2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2Nyb2xsID0ge307XG5cblx0XHRpZiAodGhpcy5pc0RhdGVzUmVuZGVyZWQpIHtcblx0XHRcdCQuZXh0ZW5kKHNjcm9sbCwgdGhpcy5xdWVyeURhdGVTY3JvbGwoKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNjcm9sbDtcblx0fSxcblxuXG5cdGFwcGx5U2Nyb2xsOiBmdW5jdGlvbihzY3JvbGwpIHtcblx0XHRpZiAodGhpcy5pc0RhdGVzUmVuZGVyZWQpIHtcblx0XHRcdHRoaXMuYXBwbHlEYXRlU2Nyb2xsKHNjcm9sbCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Y29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge307IC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdHF1ZXJ5RGF0ZVNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHt9OyAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHRhcHBseURhdGVTY3JvbGw6IGZ1bmN0aW9uKHNjcm9sbCkge1xuXHRcdDsgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogSGVpZ2h0IEZyZWV6aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRmcmVlemVIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY2FsZW5kYXIuZnJlZXplQ29udGVudEhlaWdodCgpO1xuXHR9LFxuXG5cblx0dGhhd0hlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jYWxlbmRhci50aGF3Q29udGVudEhlaWdodCgpO1xuXHR9LFxuXG5cblx0Ly8gRXZlbnQgSGlnaC1sZXZlbCBSZW5kZXJpbmdcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdGV4ZWN1dGVFdmVudHNSZW5kZXI6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdHRoaXMucmVuZGVyRXZlbnRzKGV2ZW50cyk7XG5cdFx0dGhpcy5pc0V2ZW50c1JlbmRlcmVkID0gdHJ1ZTtcblxuXHRcdHRoaXMub25FdmVudHNSZW5kZXIoKTtcblx0fSxcblxuXG5cdGV4ZWN1dGVFdmVudHNVbnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5vbkJlZm9yZUV2ZW50c1VucmVuZGVyKCk7XG5cblx0XHRpZiAodGhpcy5kZXN0cm95RXZlbnRzKSB7XG5cdFx0XHR0aGlzLmRlc3Ryb3lFdmVudHMoKTsgLy8gVE9ETzogZGVwcmVjYXRlXG5cdFx0fVxuXG5cdFx0dGhpcy51bnJlbmRlckV2ZW50cygpO1xuXHRcdHRoaXMuaXNFdmVudHNSZW5kZXJlZCA9IGZhbHNlO1xuXHR9LFxuXG5cblx0Ly8gRXZlbnQgUmVuZGVyaW5nIFRyaWdnZXJzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHQvLyBTaWduYWxzIHRoYXQgYWxsIGV2ZW50cyBoYXZlIGJlZW4gcmVuZGVyZWRcblx0b25FdmVudHNSZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYXBwbHlTY3JlZW5TdGF0ZSgpO1xuXG5cdFx0dGhpcy5yZW5kZXJlZEV2ZW50U2VnRWFjaChmdW5jdGlvbihzZWcpIHtcblx0XHRcdHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudEFmdGVyUmVuZGVyJywgc2VnLmV2ZW50LCBzZWcuZXZlbnQsIHNlZy5lbCk7XG5cdFx0fSk7XG5cdFx0dGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50QWZ0ZXJBbGxSZW5kZXInKTtcblx0fSxcblxuXG5cdC8vIFNpZ25hbHMgdGhhdCBhbGwgZXZlbnQgZWxlbWVudHMgYXJlIGFib3V0IHRvIGJlIHJlbW92ZWRcblx0b25CZWZvcmVFdmVudHNVbnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5hcHBseVNjcmVlblN0YXRlKCk7XG5cblx0XHR0aGlzLnJlbmRlcmVkRXZlbnRTZWdFYWNoKGZ1bmN0aW9uKHNlZykge1xuXHRcdFx0dGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RGVzdHJveScsIHNlZy5ldmVudCwgc2VnLmV2ZW50LCBzZWcuZWwpO1xuXHRcdH0pO1xuXHR9LFxuXG5cblx0YXBwbHlTY3JlZW5TdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aGF3SGVpZ2h0KCk7XG5cdFx0dGhpcy5mcmVlemVIZWlnaHQoKTtcblx0XHR0aGlzLmFwcGx5UXVldWVkU2Nyb2xsKCk7XG5cdH0sXG5cblxuXHQvLyBFdmVudCBMb3ctbGV2ZWwgUmVuZGVyaW5nXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBldmVudHMgb250byB0aGUgdmlldy5cblx0cmVuZGVyRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFJlbW92ZXMgZXZlbnQgZWxlbWVudHMgZnJvbSB0aGUgdmlldy5cblx0dW5yZW5kZXJFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gRXZlbnQgUmVuZGVyaW5nIFV0aWxzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHQvLyBHaXZlbiBhbiBldmVudCBhbmQgdGhlIGRlZmF1bHQgZWxlbWVudCB1c2VkIGZvciByZW5kZXJpbmcsIHJldHVybnMgdGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgYWN0dWFsbHkgYmUgdXNlZC5cblx0Ly8gQmFzaWNhbGx5IHJ1bnMgZXZlbnRzIGFuZCBlbGVtZW50cyB0aHJvdWdoIHRoZSBldmVudFJlbmRlciBob29rLlxuXHRyZXNvbHZlRXZlbnRFbDogZnVuY3Rpb24oZXZlbnQsIGVsKSB7XG5cdFx0dmFyIGN1c3RvbSA9IHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudFJlbmRlcicsIGV2ZW50LCBldmVudCwgZWwpO1xuXG5cdFx0aWYgKGN1c3RvbSA9PT0gZmFsc2UpIHsgLy8gbWVhbnMgZG9uJ3QgcmVuZGVyIGF0IGFsbFxuXHRcdFx0ZWwgPSBudWxsO1xuXHRcdH1cblx0XHRlbHNlIGlmIChjdXN0b20gJiYgY3VzdG9tICE9PSB0cnVlKSB7XG5cdFx0XHRlbCA9ICQoY3VzdG9tKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWw7XG5cdH0sXG5cblxuXHQvLyBIaWRlcyBhbGwgcmVuZGVyZWQgZXZlbnQgc2VnbWVudHMgbGlua2VkIHRvIHRoZSBnaXZlbiBldmVudFxuXHRzaG93RXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dGhpcy5yZW5kZXJlZEV2ZW50U2VnRWFjaChmdW5jdGlvbihzZWcpIHtcblx0XHRcdHNlZy5lbC5jc3MoJ3Zpc2liaWxpdHknLCAnJyk7XG5cdFx0fSwgZXZlbnQpO1xuXHR9LFxuXG5cblx0Ly8gU2hvd3MgYWxsIHJlbmRlcmVkIGV2ZW50IHNlZ21lbnRzIGxpbmtlZCB0byB0aGUgZ2l2ZW4gZXZlbnRcblx0aGlkZUV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHRoaXMucmVuZGVyZWRFdmVudFNlZ0VhY2goZnVuY3Rpb24oc2VnKSB7XG5cdFx0XHRzZWcuZWwuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuXHRcdH0sIGV2ZW50KTtcblx0fSxcblxuXG5cdC8vIEl0ZXJhdGVzIHRocm91Z2ggZXZlbnQgc2VnbWVudHMgdGhhdCBoYXZlIGJlZW4gcmVuZGVyZWQgKGhhdmUgYW4gZWwpLiBHb2VzIHRocm91Z2ggYWxsIGJ5IGRlZmF1bHQuXG5cdC8vIElmIHRoZSBvcHRpb25hbCBgZXZlbnRgIGFyZ3VtZW50IGlzIHNwZWNpZmllZCwgb25seSBpdGVyYXRlcyB0aHJvdWdoIHNlZ21lbnRzIGxpbmtlZCB0byB0aGF0IGV2ZW50LlxuXHQvLyBUaGUgYHRoaXNgIHZhbHVlIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIHRoZSB2aWV3LlxuXHRyZW5kZXJlZEV2ZW50U2VnRWFjaDogZnVuY3Rpb24oZnVuYywgZXZlbnQpIHtcblx0XHR2YXIgc2VncyA9IHRoaXMuZ2V0RXZlbnRTZWdzKCk7XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKCFldmVudCB8fCBzZWdzW2ldLmV2ZW50Ll9pZCA9PT0gZXZlbnQuX2lkKSB7XG5cdFx0XHRcdGlmIChzZWdzW2ldLmVsKSB7XG5cdFx0XHRcdFx0ZnVuYy5jYWxsKHRoaXMsIHNlZ3NbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmV0cmlldmVzIGFsbCB0aGUgcmVuZGVyZWQgc2VnbWVudCBvYmplY3RzIGZvciB0aGUgdmlld1xuXHRnZXRFdmVudFNlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0XHRyZXR1cm4gW107XG5cdH0sXG5cblxuXHQvKiBFdmVudCBEcmFnLW4tRHJvcFxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgZHJhZ2dlZCBieSB0aGUgdXNlclxuXHRpc0V2ZW50RHJhZ2dhYmxlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiB0aGlzLmlzRXZlbnRTdGFydEVkaXRhYmxlKGV2ZW50KTtcblx0fSxcblxuXG5cdGlzRXZlbnRTdGFydEVkaXRhYmxlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiBmaXJzdERlZmluZWQoXG5cdFx0XHRldmVudC5zdGFydEVkaXRhYmxlLFxuXHRcdFx0KGV2ZW50LnNvdXJjZSB8fCB7fSkuc3RhcnRFZGl0YWJsZSxcblx0XHRcdHRoaXMub3B0KCdldmVudFN0YXJ0RWRpdGFibGUnKSxcblx0XHRcdHRoaXMuaXNFdmVudEdlbmVyYWxseUVkaXRhYmxlKGV2ZW50KVxuXHRcdCk7XG5cdH0sXG5cblxuXHRpc0V2ZW50R2VuZXJhbGx5RWRpdGFibGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGZpcnN0RGVmaW5lZChcblx0XHRcdGV2ZW50LmVkaXRhYmxlLFxuXHRcdFx0KGV2ZW50LnNvdXJjZSB8fCB7fSkuZWRpdGFibGUsXG5cdFx0XHR0aGlzLm9wdCgnZWRpdGFibGUnKVxuXHRcdCk7XG5cdH0sXG5cblxuXHQvLyBNdXN0IGJlIGNhbGxlZCB3aGVuIGFuIGV2ZW50IGluIHRoZSB2aWV3IGlzIGRyb3BwZWQgb250byBuZXcgbG9jYXRpb24uXG5cdC8vIGBkcm9wTG9jYXRpb25gIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBuZXcgem9uZWQgc3RhcnQvZW5kL2FsbERheSB2YWx1ZXMgZm9yIHRoZSBldmVudC5cblx0cmVwb3J0U2VnRHJvcDogZnVuY3Rpb24oc2VnLCBkcm9wTG9jYXRpb24sIGxhcmdlVW5pdCwgZWwsIGV2KSB7XG5cdFx0dmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcblx0XHR2YXIgbXV0YXRlUmVzdWx0ID0gY2FsZW5kYXIubXV0YXRlU2VnKHNlZywgZHJvcExvY2F0aW9uLCBsYXJnZVVuaXQpO1xuXHRcdHZhciB1bmRvRnVuYyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0bXV0YXRlUmVzdWx0LnVuZG8oKTtcblx0XHRcdGNhbGVuZGFyLnJlcG9ydEV2ZW50Q2hhbmdlKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMudHJpZ2dlckV2ZW50RHJvcChzZWcuZXZlbnQsIG11dGF0ZVJlc3VsdC5kYXRlRGVsdGEsIHVuZG9GdW5jLCBlbCwgZXYpO1xuXHRcdGNhbGVuZGFyLnJlcG9ydEV2ZW50Q2hhbmdlKCk7IC8vIHdpbGwgcmVyZW5kZXIgZXZlbnRzXG5cdH0sXG5cblxuXHQvLyBUcmlnZ2VycyBldmVudC1kcm9wIGhhbmRsZXJzIHRoYXQgaGF2ZSBzdWJzY3JpYmVkIHZpYSB0aGUgQVBJXG5cdHRyaWdnZXJFdmVudERyb3A6IGZ1bmN0aW9uKGV2ZW50LCBkYXRlRGVsdGEsIHVuZG9GdW5jLCBlbCwgZXYpIHtcblx0XHR0aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnREcm9wJywgZWxbMF0sIGV2ZW50LCBkYXRlRGVsdGEsIHVuZG9GdW5jLCBldiwge30pOyAvLyB7fSA9IGpxdWkgZHVtbXlcblx0fSxcblxuXG5cdC8qIEV4dGVybmFsIEVsZW1lbnQgRHJhZy1uLURyb3Bcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIE11c3QgYmUgY2FsbGVkIHdoZW4gYW4gZXh0ZXJuYWwgZWxlbWVudCwgdmlhIGpRdWVyeSBVSSwgaGFzIGJlZW4gZHJvcHBlZCBvbnRvIHRoZSBjYWxlbmRhci5cblx0Ly8gYG1ldGFgIGlzIHRoZSBwYXJzZWQgZGF0YSB0aGF0IGhhcyBiZWVuIGVtYmVkZGVkIGludG8gdGhlIGRyYWdnaW5nIGV2ZW50LlxuXHQvLyBgZHJvcExvY2F0aW9uYCBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHpvbmVkIHN0YXJ0L2VuZC9hbGxEYXkgdmFsdWVzIGZvciB0aGUgZXZlbnQuXG5cdHJlcG9ydEV4dGVybmFsRHJvcDogZnVuY3Rpb24obWV0YSwgZHJvcExvY2F0aW9uLCBlbCwgZXYsIHVpKSB7XG5cdFx0dmFyIGV2ZW50UHJvcHMgPSBtZXRhLmV2ZW50UHJvcHM7XG5cdFx0dmFyIGV2ZW50SW5wdXQ7XG5cdFx0dmFyIGV2ZW50O1xuXG5cdFx0Ly8gVHJ5IHRvIGJ1aWxkIGFuIGV2ZW50IG9iamVjdCBhbmQgcmVuZGVyIGl0LiBUT0RPOiBkZWNvdXBsZSB0aGUgdHdvXG5cdFx0aWYgKGV2ZW50UHJvcHMpIHtcblx0XHRcdGV2ZW50SW5wdXQgPSAkLmV4dGVuZCh7fSwgZXZlbnRQcm9wcywgZHJvcExvY2F0aW9uKTtcblx0XHRcdGV2ZW50ID0gdGhpcy5jYWxlbmRhci5yZW5kZXJFdmVudChldmVudElucHV0LCBtZXRhLnN0aWNrKVswXTsgLy8gcmVuZGVyRXZlbnQgcmV0dXJucyBhbiBhcnJheVxuXHRcdH1cblxuXHRcdHRoaXMudHJpZ2dlckV4dGVybmFsRHJvcChldmVudCwgZHJvcExvY2F0aW9uLCBlbCwgZXYsIHVpKTtcblx0fSxcblxuXG5cdC8vIFRyaWdnZXJzIGV4dGVybmFsLWRyb3AgaGFuZGxlcnMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdmlhIHRoZSBBUElcblx0dHJpZ2dlckV4dGVybmFsRHJvcDogZnVuY3Rpb24oZXZlbnQsIGRyb3BMb2NhdGlvbiwgZWwsIGV2LCB1aSkge1xuXG5cdFx0Ly8gdHJpZ2dlciAnZHJvcCcgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGVsZW1lbnQgcmVwcmVzZW50cyBhbiBldmVudFxuXHRcdHRoaXMucHVibGljbHlUcmlnZ2VyKCdkcm9wJywgZWxbMF0sIGRyb3BMb2NhdGlvbi5zdGFydCwgZXYsIHVpKTtcblxuXHRcdGlmIChldmVudCkge1xuXHRcdFx0dGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVjZWl2ZScsIG51bGwsIGV2ZW50KTsgLy8gc2lnbmFsIGFuIGV4dGVybmFsIGV2ZW50IGxhbmRlZFxuXHRcdH1cblx0fSxcblxuXG5cdC8qIERyYWctbi1Ecm9wIFJlbmRlcmluZyAoZm9yIGJvdGggZXZlbnRzIGFuZCBleHRlcm5hbCBlbGVtZW50cylcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIGV2ZW50IG9yIGV4dGVybmFsLWVsZW1lbnQgZHJhZyBvdmVyIHRoZSBnaXZlbiBkcm9wIHpvbmUuXG5cdC8vIElmIGFuIGV4dGVybmFsLWVsZW1lbnQsIHNlZyB3aWxsIGJlIGBudWxsYC5cblx0Ly8gTXVzdCByZXR1cm4gZWxlbWVudHMgdXNlZCBmb3IgYW55IG1vY2sgZXZlbnRzLlxuXHRyZW5kZXJEcmFnOiBmdW5jdGlvbihkcm9wTG9jYXRpb24sIHNlZykge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IG9yIGV4dGVybmFsLWVsZW1lbnQgYmVpbmcgZHJhZ2dlZC5cblx0dW5yZW5kZXJEcmFnOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvKiBFdmVudCBSZXNpemluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgcmVzaXplZCBmcm9tIGl0cyBzdGFydGluZyBlZGdlXG5cdGlzRXZlbnRSZXNpemFibGVGcm9tU3RhcnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0KCdldmVudFJlc2l6YWJsZUZyb21TdGFydCcpICYmIHRoaXMuaXNFdmVudFJlc2l6YWJsZShldmVudCk7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYWxsb3dlZCB0byBiZSByZXNpemVkIGZyb20gaXRzIGVuZGluZyBlZGdlXG5cdGlzRXZlbnRSZXNpemFibGVGcm9tRW5kOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiB0aGlzLmlzRXZlbnRSZXNpemFibGUoZXZlbnQpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgcmVzaXplZCBieSB0aGUgdXNlciBhdCBhbGxcblx0aXNFdmVudFJlc2l6YWJsZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgc291cmNlID0gZXZlbnQuc291cmNlIHx8IHt9O1xuXG5cdFx0cmV0dXJuIGZpcnN0RGVmaW5lZChcblx0XHRcdGV2ZW50LmR1cmF0aW9uRWRpdGFibGUsXG5cdFx0XHRzb3VyY2UuZHVyYXRpb25FZGl0YWJsZSxcblx0XHRcdHRoaXMub3B0KCdldmVudER1cmF0aW9uRWRpdGFibGUnKSxcblx0XHRcdGV2ZW50LmVkaXRhYmxlLFxuXHRcdFx0c291cmNlLmVkaXRhYmxlLFxuXHRcdFx0dGhpcy5vcHQoJ2VkaXRhYmxlJylcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gTXVzdCBiZSBjYWxsZWQgd2hlbiBhbiBldmVudCBpbiB0aGUgdmlldyBoYXMgYmVlbiByZXNpemVkIHRvIGEgbmV3IGxlbmd0aFxuXHRyZXBvcnRTZWdSZXNpemU6IGZ1bmN0aW9uKHNlZywgcmVzaXplTG9jYXRpb24sIGxhcmdlVW5pdCwgZWwsIGV2KSB7XG5cdFx0dmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcblx0XHR2YXIgbXV0YXRlUmVzdWx0ID0gY2FsZW5kYXIubXV0YXRlU2VnKHNlZywgcmVzaXplTG9jYXRpb24sIGxhcmdlVW5pdCk7XG5cdFx0dmFyIHVuZG9GdW5jID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRtdXRhdGVSZXN1bHQudW5kbygpO1xuXHRcdFx0Y2FsZW5kYXIucmVwb3J0RXZlbnRDaGFuZ2UoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy50cmlnZ2VyRXZlbnRSZXNpemUoc2VnLmV2ZW50LCBtdXRhdGVSZXN1bHQuZHVyYXRpb25EZWx0YSwgdW5kb0Z1bmMsIGVsLCBldik7XG5cdFx0Y2FsZW5kYXIucmVwb3J0RXZlbnRDaGFuZ2UoKTsgLy8gd2lsbCByZXJlbmRlciBldmVudHNcblx0fSxcblxuXG5cdC8vIFRyaWdnZXJzIGV2ZW50LXJlc2l6ZSBoYW5kbGVycyB0aGF0IGhhdmUgc3Vic2NyaWJlZCB2aWEgdGhlIEFQSVxuXHR0cmlnZ2VyRXZlbnRSZXNpemU6IGZ1bmN0aW9uKGV2ZW50LCBkdXJhdGlvbkRlbHRhLCB1bmRvRnVuYywgZWwsIGV2KSB7XG5cdFx0dGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVzaXplJywgZWxbMF0sIGV2ZW50LCBkdXJhdGlvbkRlbHRhLCB1bmRvRnVuYywgZXYsIHt9KTsgLy8ge30gPSBqcXVpIGR1bW15XG5cdH0sXG5cblxuXHQvKiBTZWxlY3Rpb24gKHRpbWUgcmFuZ2UpXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBTZWxlY3RzIGEgZGF0ZSBzcGFuIG9uIHRoZSB2aWV3LiBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgYm90aCBNb21lbnRzLlxuXHQvLyBgZXZgIGlzIHRoZSBuYXRpdmUgbW91c2UgZXZlbnQgdGhhdCBiZWdpbiB0aGUgaW50ZXJhY3Rpb24uXG5cdHNlbGVjdDogZnVuY3Rpb24oc3BhbiwgZXYpIHtcblx0XHR0aGlzLnVuc2VsZWN0KGV2KTtcblx0XHR0aGlzLnJlbmRlclNlbGVjdGlvbihzcGFuKTtcblx0XHR0aGlzLnJlcG9ydFNlbGVjdGlvbihzcGFuLCBldik7XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgdGhlIHNlbGVjdGlvblxuXHRyZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIGEgbmV3IHNlbGVjdGlvbiBpcyBtYWRlLiBVcGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycy5cblx0cmVwb3J0U2VsZWN0aW9uOiBmdW5jdGlvbihzcGFuLCBldikge1xuXHRcdHRoaXMuaXNTZWxlY3RlZCA9IHRydWU7XG5cdFx0dGhpcy50cmlnZ2VyU2VsZWN0KHNwYW4sIGV2KTtcblx0fSxcblxuXG5cdC8vIFRyaWdnZXJzIGhhbmRsZXJzIHRvICdzZWxlY3QnXG5cdHRyaWdnZXJTZWxlY3Q6IGZ1bmN0aW9uKHNwYW4sIGV2KSB7XG5cdFx0dGhpcy5wdWJsaWNseVRyaWdnZXIoXG5cdFx0XHQnc2VsZWN0Jyxcblx0XHRcdG51bGwsXG5cdFx0XHR0aGlzLmNhbGVuZGFyLmFwcGx5VGltZXpvbmUoc3Bhbi5zdGFydCksIC8vIGNvbnZlcnQgdG8gY2FsZW5kYXIncyB0eiBmb3IgZXh0ZXJuYWwgQVBJXG5cdFx0XHR0aGlzLmNhbGVuZGFyLmFwcGx5VGltZXpvbmUoc3Bhbi5lbmQpLCAvLyBcIlxuXHRcdFx0ZXZcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gVW5kb2VzIGEgc2VsZWN0aW9uLiB1cGRhdGVzIGluIHRoZSBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMuXG5cdC8vIGBldmAgaXMgdGhlIG5hdGl2ZSBtb3VzZSBldmVudCB0aGF0IGJlZ2FuIHRoZSBpbnRlcmFjdGlvbi5cblx0dW5zZWxlY3Q6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0aWYgKHRoaXMuaXNTZWxlY3RlZCkge1xuXHRcdFx0dGhpcy5pc1NlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy5kZXN0cm95U2VsZWN0aW9uKSB7XG5cdFx0XHRcdHRoaXMuZGVzdHJveVNlbGVjdGlvbigpOyAvLyBUT0RPOiBkZXByZWNhdGVcblx0XHRcdH1cblx0XHRcdHRoaXMudW5yZW5kZXJTZWxlY3Rpb24oKTtcblx0XHRcdHRoaXMucHVibGljbHlUcmlnZ2VyKCd1bnNlbGVjdCcsIG51bGwsIGV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBzZWxlY3Rpb25cblx0dW5yZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogRXZlbnQgU2VsZWN0aW9uXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRzZWxlY3RFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMuc2VsZWN0ZWRFdmVudCB8fCB0aGlzLnNlbGVjdGVkRXZlbnQgIT09IGV2ZW50KSB7XG5cdFx0XHR0aGlzLnVuc2VsZWN0RXZlbnQoKTtcblx0XHRcdHRoaXMucmVuZGVyZWRFdmVudFNlZ0VhY2goZnVuY3Rpb24oc2VnKSB7XG5cdFx0XHRcdHNlZy5lbC5hZGRDbGFzcygnZmMtc2VsZWN0ZWQnKTtcblx0XHRcdH0sIGV2ZW50KTtcblx0XHRcdHRoaXMuc2VsZWN0ZWRFdmVudCA9IGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXG5cdHVuc2VsZWN0RXZlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLnNlbGVjdGVkRXZlbnQpIHtcblx0XHRcdHRoaXMucmVuZGVyZWRFdmVudFNlZ0VhY2goZnVuY3Rpb24oc2VnKSB7XG5cdFx0XHRcdHNlZy5lbC5yZW1vdmVDbGFzcygnZmMtc2VsZWN0ZWQnKTtcblx0XHRcdH0sIHRoaXMuc2VsZWN0ZWRFdmVudCk7XG5cdFx0XHR0aGlzLnNlbGVjdGVkRXZlbnQgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXG5cdGlzRXZlbnRTZWxlY3RlZDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvLyBldmVudCByZWZlcmVuY2VzIG1pZ2h0IGNoYW5nZSBvbiByZWZldGNoRXZlbnRzKCksIHdoaWxlIHNlbGVjdGVkRXZlbnQgZG9lc24ndCxcblx0XHQvLyBzbyBjb21wYXJlIElEc1xuXHRcdHJldHVybiB0aGlzLnNlbGVjdGVkRXZlbnQgJiYgdGhpcy5zZWxlY3RlZEV2ZW50Ll9pZCA9PT0gZXZlbnQuX2lkO1xuXHR9LFxuXG5cblx0LyogTW91c2UgLyBUb3VjaCBVbnNlbGVjdGluZyAodGltZSByYW5nZSAmIGV2ZW50IHVuc2VsZWN0aW9uKVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQvLyBUT0RPOiBtb3ZlIGNvbnNpc3RlbnRseSB0byBkb3duL3N0YXJ0IG9yIHVwL2VuZD9cblx0Ly8gVE9ETzogZG9uJ3Qga2lsbCBwcmV2aW91cyBzZWxlY3Rpb24gaWYgdG91Y2ggc2Nyb2xsaW5nXG5cblxuXHRoYW5kbGVEb2N1bWVudE1vdXNlZG93bjogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAoaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpKSB7XG5cdFx0XHR0aGlzLnByb2Nlc3NVbnNlbGVjdChldik7XG5cdFx0fVxuXHR9LFxuXG5cblx0cHJvY2Vzc1Vuc2VsZWN0OiBmdW5jdGlvbihldikge1xuXHRcdHRoaXMucHJvY2Vzc1JhbmdlVW5zZWxlY3QoZXYpO1xuXHRcdHRoaXMucHJvY2Vzc0V2ZW50VW5zZWxlY3QoZXYpO1xuXHR9LFxuXG5cblx0cHJvY2Vzc1JhbmdlVW5zZWxlY3Q6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIGlnbm9yZTtcblxuXHRcdC8vIGlzIHRoZXJlIGEgdGltZS1yYW5nZSBzZWxlY3Rpb24/XG5cdFx0aWYgKHRoaXMuaXNTZWxlY3RlZCAmJiB0aGlzLm9wdCgndW5zZWxlY3RBdXRvJykpIHtcblx0XHRcdC8vIG9ubHkgdW5zZWxlY3QgaWYgdGhlIGNsaWNrZWQgZWxlbWVudCBpcyBub3QgaWRlbnRpY2FsIHRvIG9yIGluc2lkZSBvZiBhbiAndW5zZWxlY3RDYW5jZWwnIGVsZW1lbnRcblx0XHRcdGlnbm9yZSA9IHRoaXMub3B0KCd1bnNlbGVjdENhbmNlbCcpO1xuXHRcdFx0aWYgKCFpZ25vcmUgfHwgISQoZXYudGFyZ2V0KS5jbG9zZXN0KGlnbm9yZSkubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMudW5zZWxlY3QoZXYpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdHByb2Nlc3NFdmVudFVuc2VsZWN0OiBmdW5jdGlvbihldikge1xuXHRcdGlmICh0aGlzLnNlbGVjdGVkRXZlbnQpIHtcblx0XHRcdGlmICghJChldi50YXJnZXQpLmNsb3Nlc3QoJy5mYy1zZWxlY3RlZCcpLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLnVuc2VsZWN0RXZlbnQoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvKiBEYXkgQ2xpY2tcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFRyaWdnZXJzIGhhbmRsZXJzIHRvICdkYXlDbGljaydcblx0Ly8gU3BhbiBoYXMgc3RhcnQvZW5kIG9mIHRoZSBjbGlja2VkIGFyZWEuIE9ubHkgdGhlIHN0YXJ0IGlzIHVzZWZ1bC5cblx0dHJpZ2dlckRheUNsaWNrOiBmdW5jdGlvbihzcGFuLCBkYXlFbCwgZXYpIHtcblx0XHR0aGlzLnB1YmxpY2x5VHJpZ2dlcihcblx0XHRcdCdkYXlDbGljaycsXG5cdFx0XHRkYXlFbCxcblx0XHRcdHRoaXMuY2FsZW5kYXIuYXBwbHlUaW1lem9uZShzcGFuLnN0YXJ0KSwgLy8gY29udmVydCB0byBjYWxlbmRhcidzIHRpbWV6b25lIGZvciBleHRlcm5hbCBBUElcblx0XHRcdGV2XG5cdFx0KTtcblx0fSxcblxuXG5cdC8qIERhdGUgVXRpbHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJldHVybnMgdGhlIGRhdGUgcmFuZ2Ugb2YgdGhlIGZ1bGwgZGF5cyB0aGUgZ2l2ZW4gcmFuZ2UgdmlzdWFsbHkgYXBwZWFycyB0byBvY2N1cHkuXG5cdC8vIFJldHVybnMgYSBuZXcgcmFuZ2Ugb2JqZWN0LlxuXHRjb21wdXRlRGF5UmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG5cdFx0dmFyIHN0YXJ0RGF5ID0gcmFuZ2Uuc3RhcnQuY2xvbmUoKS5zdHJpcFRpbWUoKTsgLy8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZGF5IHRoZSByYW5nZSBzdGFydHNcblx0XHR2YXIgZW5kID0gcmFuZ2UuZW5kO1xuXHRcdHZhciBlbmREYXkgPSBudWxsO1xuXHRcdHZhciBlbmRUaW1lTVM7XG5cblx0XHRpZiAoZW5kKSB7XG5cdFx0XHRlbmREYXkgPSBlbmQuY2xvbmUoKS5zdHJpcFRpbWUoKTsgLy8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZGF5IHRoZSByYW5nZSBleGNsdXNpdmVseSBlbmRzXG5cdFx0XHRlbmRUaW1lTVMgPSArZW5kLnRpbWUoKTsgLy8gIyBvZiBtaWxsaXNlY29uZHMgaW50byBgZW5kRGF5YFxuXG5cdFx0XHQvLyBJZiB0aGUgZW5kIHRpbWUgaXMgYWN0dWFsbHkgaW5jbHVzaXZlbHkgcGFydCBvZiB0aGUgbmV4dCBkYXkgYW5kIGlzIGVxdWFsIHRvIG9yXG5cdFx0XHQvLyBiZXlvbmQgdGhlIG5leHQgZGF5IHRocmVzaG9sZCwgYWRqdXN0IHRoZSBlbmQgdG8gYmUgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYGVuZERheWAuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cblx0XHRcdGlmIChlbmRUaW1lTVMgJiYgZW5kVGltZU1TID49IHRoaXMubmV4dERheVRocmVzaG9sZCkge1xuXHRcdFx0XHRlbmREYXkuYWRkKDEsICdkYXlzJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbm8gZW5kIHdhcyBzcGVjaWZpZWQsIG9yIGlmIGl0IGlzIHdpdGhpbiBgc3RhcnREYXlgIGJ1dCBub3QgcGFzdCBuZXh0RGF5VGhyZXNob2xkLFxuXHRcdC8vIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxuXHRcdGlmICghZW5kIHx8IGVuZERheSA8PSBzdGFydERheSkge1xuXHRcdFx0ZW5kRGF5ID0gc3RhcnREYXkuY2xvbmUoKS5hZGQoMSwgJ2RheXMnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4geyBzdGFydDogc3RhcnREYXksIGVuZDogZW5kRGF5IH07XG5cdH0sXG5cblxuXHQvLyBEb2VzIHRoZSBnaXZlbiBldmVudCB2aXN1YWxseSBhcHBlYXIgdG8gb2NjdXB5IG1vcmUgdGhhbiBvbmUgZGF5P1xuXHRpc011bHRpRGF5RXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHJhbmdlID0gdGhpcy5jb21wdXRlRGF5UmFuZ2UoZXZlbnQpOyAvLyBldmVudCBpcyByYW5nZS1pc2hcblxuXHRcdHJldHVybiByYW5nZS5lbmQuZGlmZihyYW5nZS5zdGFydCwgJ2RheXMnKSA+IDE7XG5cdH1cblxufSk7XG5cblxuVmlldy53YXRjaCgnZGlzcGxheWluZ0RhdGVzJywgWyAnZGF0ZVByb2ZpbGUnIF0sIGZ1bmN0aW9uKGRlcHMpIHtcblx0dGhpcy5yZXF1ZXN0RGF0ZVJlbmRlcihkZXBzLmRhdGVQcm9maWxlKTtcbn0sIGZ1bmN0aW9uKCkge1xuXHR0aGlzLnJlcXVlc3REYXRlVW5yZW5kZXIoKTtcbn0pO1xuXG5cblZpZXcud2F0Y2goJ2luaXRpYWxFdmVudHMnLCBbICdkYXRlUHJvZmlsZScgXSwgZnVuY3Rpb24oZGVwcykge1xuXHRyZXR1cm4gdGhpcy5mZXRjaEluaXRpYWxFdmVudHMoZGVwcy5kYXRlUHJvZmlsZSk7XG59KTtcblxuXG5WaWV3LndhdGNoKCdiaW5kaW5nRXZlbnRzJywgWyAnaW5pdGlhbEV2ZW50cycgXSwgZnVuY3Rpb24oZGVwcykge1xuXHR0aGlzLnNldEV2ZW50cyhkZXBzLmluaXRpYWxFdmVudHMpO1xuXHR0aGlzLmJpbmRFdmVudENoYW5nZXMoKTtcbn0sIGZ1bmN0aW9uKCkge1xuXHR0aGlzLnVuYmluZEV2ZW50Q2hhbmdlcygpO1xuXHR0aGlzLnVuc2V0RXZlbnRzKCk7XG59KTtcblxuXG5WaWV3LndhdGNoKCdkaXNwbGF5aW5nRXZlbnRzJywgWyAnZGlzcGxheWluZ0RhdGVzJywgJ2hhc0V2ZW50cycgXSwgZnVuY3Rpb24oKSB7XG5cdHRoaXMucmVxdWVzdEV2ZW50c1JlbmRlcih0aGlzLmdldCgnY3VycmVudEV2ZW50cycpKTsgLy8gaWYgdGhlcmUgd2VyZSBldmVudCBtdXRhdGlvbnMgYWZ0ZXIgaW5pdGlhbEV2ZW50c1xufSwgZnVuY3Rpb24oKSB7XG5cdHRoaXMucmVxdWVzdEV2ZW50c1VucmVuZGVyKCk7XG59KTtcblxuOztcblxuVmlldy5taXhpbih7XG5cblx0Ly8gcmFuZ2UgdGhlIHZpZXcgaXMgZm9ybWFsbHkgcmVzcG9uc2libGUgZm9yLlxuXHQvLyBmb3IgZXhhbXBsZSwgYSBtb250aCB2aWV3IG1pZ2h0IGhhdmUgMXN0LTMxc3QsIGV4Y2x1ZGluZyBwYWRkZWQgZGF0ZXNcblx0Y3VycmVudFJhbmdlOiBudWxsLFxuXHRjdXJyZW50UmFuZ2VVbml0OiBudWxsLCAvLyBuYW1lIG9mIGxhcmdlc3QgdW5pdCBiZWluZyBkaXNwbGF5ZWQsIGxpa2UgXCJtb250aFwiIG9yIFwid2Vla1wiXG5cblx0Ly8gZGF0ZSByYW5nZSB3aXRoIGEgcmVuZGVyZWQgc2tlbGV0b25cblx0Ly8gaW5jbHVkZXMgbm90LWFjdGl2ZSBkYXlzIHRoYXQgbmVlZCBzb21lIHNvcnQgb2YgRE9NXG5cdHJlbmRlclJhbmdlOiBudWxsLFxuXG5cdC8vIGRhdGVzIHRoYXQgZGlzcGxheSBldmVudHMgYW5kIGFjY2VwdCBkcmFnLW4tZHJvcFxuXHRhY3RpdmVSYW5nZTogbnVsbCxcblxuXHQvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxuXHQvLyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydCBhbmQgZW5kIHByb3BlcnRpZXMuXG5cdHZhbGlkUmFuZ2U6IG51bGwsXG5cblx0Ly8gaG93IGZhciB0aGUgY3VycmVudCBkYXRlIHdpbGwgbW92ZSBmb3IgYSBwcmV2L25leHQgb3BlcmF0aW9uXG5cdGRhdGVJbmNyZW1lbnQ6IG51bGwsXG5cblx0bWluVGltZTogbnVsbCwgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcblx0bWF4VGltZTogbnVsbCwgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZXhjbHVzaXZlIHZpc2libGUgZW5kIHRpbWUgb2YgYW55IGdpdmVuIGRheVxuXHR1c2VzTWluTWF4VGltZTogZmFsc2UsIC8vIHdoZXRoZXIgbWluVGltZS9tYXhUaW1lIHdpbGwgYWZmZWN0IHRoZSBhY3RpdmVSYW5nZS4gVmlld3MgbXVzdCBvcHQtaW4uXG5cblx0Ly8gREVQUkVDQVRFRFxuXHRzdGFydDogbnVsbCwgLy8gdXNlIGFjdGl2ZVJhbmdlLnN0YXJ0XG5cdGVuZDogbnVsbCwgLy8gdXNlIGFjdGl2ZVJhbmdlLmVuZFxuXHRpbnRlcnZhbFN0YXJ0OiBudWxsLCAvLyB1c2UgY3VycmVudFJhbmdlLnN0YXJ0XG5cdGludGVydmFsRW5kOiBudWxsLCAvLyB1c2UgY3VycmVudFJhbmdlLmVuZFxuXG5cblx0LyogRGF0ZSBSYW5nZSBDb21wdXRhdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0c2V0RGF0ZVByb2ZpbGVGb3JSZW5kZXJpbmc6IGZ1bmN0aW9uKGRhdGVQcm9maWxlKSB7XG5cdFx0dGhpcy5jdXJyZW50UmFuZ2UgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2U7XG5cdFx0dGhpcy5jdXJyZW50UmFuZ2VVbml0ID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdDtcblx0XHR0aGlzLnJlbmRlclJhbmdlID0gZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2U7XG5cdFx0dGhpcy5hY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlO1xuXHRcdHRoaXMudmFsaWRSYW5nZSA9IGRhdGVQcm9maWxlLnZhbGlkUmFuZ2U7XG5cdFx0dGhpcy5kYXRlSW5jcmVtZW50ID0gZGF0ZVByb2ZpbGUuZGF0ZUluY3JlbWVudDtcblx0XHR0aGlzLm1pblRpbWUgPSBkYXRlUHJvZmlsZS5taW5UaW1lO1xuXHRcdHRoaXMubWF4VGltZSA9IGRhdGVQcm9maWxlLm1heFRpbWU7XG5cblx0XHQvLyBERVBSRUNBVEVELCBidXQgd2UgbmVlZCB0byBrZWVwIGl0IHVwZGF0ZWRcblx0XHR0aGlzLnN0YXJ0ID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2Uuc3RhcnQ7XG5cdFx0dGhpcy5lbmQgPSBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5lbmQ7XG5cdFx0dGhpcy5pbnRlcnZhbFN0YXJ0ID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0O1xuXHRcdHRoaXMuaW50ZXJ2YWxFbmQgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kO1xuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB3aGF0IHRoZSBkYXRlcy9yYW5nZXMgd2lsbCBiZSBmb3IgdGhlIFwicHJldlwiIHZpZXcuXG5cdGJ1aWxkUHJldkRhdGVQcm9maWxlOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIHByZXZEYXRlID0gZGF0ZS5jbG9uZSgpLnN0YXJ0T2YodGhpcy5jdXJyZW50UmFuZ2VVbml0KS5zdWJ0cmFjdCh0aGlzLmRhdGVJbmNyZW1lbnQpO1xuXG5cdFx0cmV0dXJuIHRoaXMuYnVpbGREYXRlUHJvZmlsZShwcmV2RGF0ZSwgLTEpO1xuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB3aGF0IHRoZSBkYXRlcy9yYW5nZXMgd2lsbCBiZSBmb3IgdGhlIFwibmV4dFwiIHZpZXcuXG5cdGJ1aWxkTmV4dERhdGVQcm9maWxlOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIG5leHREYXRlID0gZGF0ZS5jbG9uZSgpLnN0YXJ0T2YodGhpcy5jdXJyZW50UmFuZ2VVbml0KS5hZGQodGhpcy5kYXRlSW5jcmVtZW50KTtcblxuXHRcdHJldHVybiB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGUobmV4dERhdGUsIDEpO1xuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxuXHQvLyBPcHRpb25hbCBkaXJlY3Rpb24gcGFyYW0gaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRhdGUgaXMgYmVpbmcgaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWRcblx0Ly8gZnJvbSBpdHMgcHJldmlvdXMgdmFsdWUuIGRlY3JlbWVudGVkID0gLTEsIGluY3JlbWVudGVkID0gMSAoZGVmYXVsdCkuXG5cdGJ1aWxkRGF0ZVByb2ZpbGU6IGZ1bmN0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZm9yY2VUb1ZhbGlkKSB7XG5cdFx0dmFyIHZhbGlkUmFuZ2UgPSB0aGlzLmJ1aWxkVmFsaWRSYW5nZSgpO1xuXHRcdHZhciBtaW5UaW1lID0gbnVsbDtcblx0XHR2YXIgbWF4VGltZSA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRJbmZvO1xuXHRcdHZhciByZW5kZXJSYW5nZTtcblx0XHR2YXIgYWN0aXZlUmFuZ2U7XG5cdFx0dmFyIGlzVmFsaWQ7XG5cblx0XHRpZiAoZm9yY2VUb1ZhbGlkKSB7XG5cdFx0XHRkYXRlID0gY29uc3RyYWluRGF0ZShkYXRlLCB2YWxpZFJhbmdlKTtcblx0XHR9XG5cblx0XHRjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGRhdGUsIGRpcmVjdGlvbik7XG5cdFx0cmVuZGVyUmFuZ2UgPSB0aGlzLmJ1aWxkUmVuZGVyUmFuZ2UoY3VycmVudEluZm8ucmFuZ2UsIGN1cnJlbnRJbmZvLnVuaXQpO1xuXHRcdGFjdGl2ZVJhbmdlID0gY2xvbmVSYW5nZShyZW5kZXJSYW5nZSk7XG5cblx0XHRpZiAoIXRoaXMub3B0KCdzaG93Tm9uQ3VycmVudERhdGVzJykpIHtcblx0XHRcdGFjdGl2ZVJhbmdlID0gY29uc3RyYWluUmFuZ2UoYWN0aXZlUmFuZ2UsIGN1cnJlbnRJbmZvLnJhbmdlKTtcblx0XHR9XG5cblx0XHRtaW5UaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdtaW5UaW1lJykpO1xuXHRcdG1heFRpbWUgPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ21heFRpbWUnKSk7XG5cdFx0dGhpcy5hZGp1c3RBY3RpdmVSYW5nZShhY3RpdmVSYW5nZSwgbWluVGltZSwgbWF4VGltZSk7XG5cblx0XHRhY3RpdmVSYW5nZSA9IGNvbnN0cmFpblJhbmdlKGFjdGl2ZVJhbmdlLCB2YWxpZFJhbmdlKTtcblx0XHRkYXRlID0gY29uc3RyYWluRGF0ZShkYXRlLCBhY3RpdmVSYW5nZSk7XG5cblx0XHQvLyBpdCdzIGludmFsaWQgaWYgdGhlIG9yaWdpbmFsbHkgcmVxdWVzdGVkIGRhdGUgaXMgbm90IGNvbnRhaW5lZCxcblx0XHQvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cblx0XHRpc1ZhbGlkID0gZG9SYW5nZXNJbnRlcnNlY3QoY3VycmVudEluZm8ucmFuZ2UsIHZhbGlkUmFuZ2UpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHZhbGlkUmFuZ2U6IHZhbGlkUmFuZ2UsXG5cdFx0XHRjdXJyZW50UmFuZ2U6IGN1cnJlbnRJbmZvLnJhbmdlLFxuXHRcdFx0Y3VycmVudFJhbmdlVW5pdDogY3VycmVudEluZm8udW5pdCxcblx0XHRcdGFjdGl2ZVJhbmdlOiBhY3RpdmVSYW5nZSxcblx0XHRcdHJlbmRlclJhbmdlOiByZW5kZXJSYW5nZSxcblx0XHRcdG1pblRpbWU6IG1pblRpbWUsXG5cdFx0XHRtYXhUaW1lOiBtYXhUaW1lLFxuXHRcdFx0aXNWYWxpZDogaXNWYWxpZCxcblx0XHRcdGRhdGU6IGRhdGUsXG5cdFx0XHRkYXRlSW5jcmVtZW50OiB0aGlzLmJ1aWxkRGF0ZUluY3JlbWVudChjdXJyZW50SW5mby5kdXJhdGlvbilcblx0XHRcdFx0Ly8gcGFzcyBhIGZhbGxiYWNrIChtaWdodCBiZSBudWxsKSBeXG5cdFx0fTtcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydC9lbmQgcHJvcGVydGllcy5cblx0Ly8gSW5kaWNhdGVzIHRoZSBtaW5pbXVtL21heGltdW0gZGF0ZXMgdG8gZGlzcGxheS5cblx0YnVpbGRWYWxpZFJhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRSYW5nZU9wdGlvbigndmFsaWRSYW5nZScsIHRoaXMuY2FsZW5kYXIuZ2V0Tm93KCkpIHx8IHt9O1xuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB0aGUgXCJjdXJyZW50XCIgcmFuZ2UsIHRoZSByYW5nZSB0aGF0IGlzXG5cdC8vIGhpZ2hsaWdodGVkIGFzIGJlaW5nIHRoZSBjdXJyZW50IG1vbnRoIGZvciBleGFtcGxlLlxuXHQvLyBTZWUgYnVpbGREYXRlUHJvZmlsZSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBgZGlyZWN0aW9uYC5cblx0Ly8gR3VhcmFudGVlZCB0byBoYXZlIGByYW5nZWAgYW5kIGB1bml0YCBwcm9wZXJ0aWVzLiBgZHVyYXRpb25gIGlzIG9wdGlvbmFsLlxuXHRidWlsZEN1cnJlbnRSYW5nZUluZm86IGZ1bmN0aW9uKGRhdGUsIGRpcmVjdGlvbikge1xuXHRcdHZhciBkdXJhdGlvbiA9IG51bGw7XG5cdFx0dmFyIHVuaXQgPSBudWxsO1xuXHRcdHZhciByYW5nZSA9IG51bGw7XG5cdFx0dmFyIGRheUNvdW50O1xuXG5cdFx0aWYgKHRoaXMudmlld1NwZWMuZHVyYXRpb24pIHtcblx0XHRcdGR1cmF0aW9uID0gdGhpcy52aWV3U3BlYy5kdXJhdGlvbjtcblx0XHRcdHVuaXQgPSB0aGlzLnZpZXdTcGVjLmR1cmF0aW9uVW5pdDtcblx0XHRcdHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLm9wdCgnZGF5Q291bnQnKSkpIHtcblx0XHRcdHVuaXQgPSAnZGF5Jztcblx0XHRcdHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbURheUNvdW50KGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgocmFuZ2UgPSB0aGlzLmJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpKSkge1xuXHRcdFx0dW5pdCA9IGNvbXB1dGVHcmVhdGVzdFVuaXQocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZHVyYXRpb24gPSB0aGlzLmdldEZhbGxiYWNrRHVyYXRpb24oKTtcblx0XHRcdHVuaXQgPSBjb21wdXRlR3JlYXRlc3RVbml0KGR1cmF0aW9uKTtcblx0XHRcdHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xuXHRcdH1cblxuXHRcdHRoaXMubm9ybWFsaXplQ3VycmVudFJhbmdlKHJhbmdlLCB1bml0KTsgLy8gbW9kaWZpZXMgaW4tcGxhY2VcblxuXHRcdHJldHVybiB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgdW5pdDogdW5pdCwgcmFuZ2U6IHJhbmdlIH07XG5cdH0sXG5cblxuXHRnZXRGYWxsYmFja0R1cmF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKHsgZGF5czogMSB9KTtcblx0fSxcblxuXG5cdC8vIElmIHRoZSByYW5nZSBoYXMgZGF5IHVuaXRzIG9yIGxhcmdlciwgcmVtb3ZlIHRpbWVzLiBPdGhlcndpc2UsIGVuc3VyZSB0aW1lcy5cblx0bm9ybWFsaXplQ3VycmVudFJhbmdlOiBmdW5jdGlvbihyYW5nZSwgdW5pdCkge1xuXG5cdFx0aWYgKC9eKHllYXJ8bW9udGh8d2Vla3xkYXkpJC8udGVzdCh1bml0KSkgeyAvLyB3aG9sZS1kYXlzP1xuXHRcdFx0cmFuZ2Uuc3RhcnQuc3RyaXBUaW1lKCk7XG5cdFx0XHRyYW5nZS5lbmQuc3RyaXBUaW1lKCk7XG5cdFx0fVxuXHRcdGVsc2UgeyAvLyBuZWVkcyB0byBoYXZlIGEgdGltZT9cblx0XHRcdGlmICghcmFuZ2Uuc3RhcnQuaGFzVGltZSgpKSB7XG5cdFx0XHRcdHJhbmdlLnN0YXJ0LnRpbWUoMCk7IC8vIGdpdmUgMDA6MDAgdGltZVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFyYW5nZS5lbmQuaGFzVGltZSgpKSB7XG5cdFx0XHRcdHJhbmdlLmVuZC50aW1lKDApOyAvLyBnaXZlIDAwOjAwIHRpbWVcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBNdXRhdGVzIHRoZSBnaXZlbiBhY3RpdmVSYW5nZSB0byBoYXZlIHRpbWUgdmFsdWVzICh1bi1hbWJpZ3VhdGUpXG5cdC8vIGlmIHRoZSBtaW5UaW1lIG9yIG1heFRpbWUgY2F1c2VzIHRoZSByYW5nZSB0byBleHBhbmQuXG5cdC8vIFRPRE86IGV2ZW50dWFsbHkgYWN0aXZlUmFuZ2Ugc2hvdWxkICphbHdheXMqIGhhdmUgdGltZXMuXG5cdGFkanVzdEFjdGl2ZVJhbmdlOiBmdW5jdGlvbihyYW5nZSwgbWluVGltZSwgbWF4VGltZSkge1xuXHRcdHZhciBoYXNTcGVjaWFsVGltZXMgPSBmYWxzZTtcblxuXHRcdGlmICh0aGlzLnVzZXNNaW5NYXhUaW1lKSB7XG5cblx0XHRcdGlmIChtaW5UaW1lIDwgMCkge1xuXHRcdFx0XHRyYW5nZS5zdGFydC50aW1lKDApLmFkZChtaW5UaW1lKTtcblx0XHRcdFx0aGFzU3BlY2lhbFRpbWVzID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1heFRpbWUgPiAyNCAqIDYwICogNjAgKiAxMDAwKSB7IC8vIGJleW9uZCAyNCBob3Vycz9cblx0XHRcdFx0cmFuZ2UuZW5kLnRpbWUobWF4VGltZSAtICgyNCAqIDYwICogNjAgKiAxMDAwKSk7XG5cdFx0XHRcdGhhc1NwZWNpYWxUaW1lcyA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoYXNTcGVjaWFsVGltZXMpIHtcblx0XHRcdFx0aWYgKCFyYW5nZS5zdGFydC5oYXNUaW1lKCkpIHtcblx0XHRcdFx0XHRyYW5nZS5zdGFydC50aW1lKDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghcmFuZ2UuZW5kLmhhc1RpbWUoKSkge1xuXHRcdFx0XHRcdHJhbmdlLmVuZC50aW1lKDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGl0IGlzIHNwZWNpZmllZCBhcyBhbiBleHBsaWNpdCBkdXJhdGlvbi5cblx0Ly8gYHVuaXRgIGlzIHRoZSBhbHJlYWR5LWNvbXB1dGVkIGNvbXB1dGVHcmVhdGVzdFVuaXQgdmFsdWUgb2YgZHVyYXRpb24uXG5cdGJ1aWxkUmFuZ2VGcm9tRHVyYXRpb246IGZ1bmN0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpIHtcblx0XHR2YXIgYWxpZ25tZW50ID0gdGhpcy5vcHQoJ2RhdGVBbGlnbm1lbnQnKTtcblx0XHR2YXIgc3RhcnQgPSBkYXRlLmNsb25lKCk7XG5cdFx0dmFyIGVuZDtcblx0XHR2YXIgZGF0ZUluY3JlbWVudElucHV0O1xuXHRcdHZhciBkYXRlSW5jcmVtZW50RHVyYXRpb247XG5cblx0XHQvLyBpZiB0aGUgdmlldyBkaXNwbGF5cyBhIHNpbmdsZSBkYXkgb3Igc21hbGxlclxuXHRcdGlmIChkdXJhdGlvbi5hcygnZGF5cycpIDw9IDEpIHtcblx0XHRcdGlmICh0aGlzLmlzSGlkZGVuRGF5KHN0YXJ0KSkge1xuXHRcdFx0XHRzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQsIGRpcmVjdGlvbik7XG5cdFx0XHRcdHN0YXJ0LnN0YXJ0T2YoJ2RheScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGNvbXB1dGUgd2hhdCB0aGUgYWxpZ25tZW50IHNob3VsZCBiZVxuXHRcdGlmICghYWxpZ25tZW50KSB7XG5cdFx0XHRkYXRlSW5jcmVtZW50SW5wdXQgPSB0aGlzLm9wdCgnZGF0ZUluY3JlbWVudCcpO1xuXG5cdFx0XHRpZiAoZGF0ZUluY3JlbWVudElucHV0KSB7XG5cdFx0XHRcdGRhdGVJbmNyZW1lbnREdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihkYXRlSW5jcmVtZW50SW5wdXQpO1xuXG5cdFx0XHRcdC8vIHVzZSB0aGUgc21hbGxlciBvZiB0aGUgdHdvIHVuaXRzXG5cdFx0XHRcdGlmIChkYXRlSW5jcmVtZW50RHVyYXRpb24gPCBkdXJhdGlvbikge1xuXHRcdFx0XHRcdGFsaWdubWVudCA9IGNvbXB1dGVEdXJhdGlvbkdyZWF0ZXN0VW5pdChkYXRlSW5jcmVtZW50RHVyYXRpb24sIGRhdGVJbmNyZW1lbnRJbnB1dCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0YWxpZ25tZW50ID0gdW5pdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGFsaWdubWVudCA9IHVuaXQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3RhcnQuc3RhcnRPZihhbGlnbm1lbnQpO1xuXHRcdGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKGR1cmF0aW9uKTtcblxuXHRcdHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBhIGRheUNvdW50IGlzIHNwZWNpZmllZC5cblx0YnVpbGRSYW5nZUZyb21EYXlDb3VudDogZnVuY3Rpb24oZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCkge1xuXHRcdHZhciBjdXN0b21BbGlnbm1lbnQgPSB0aGlzLm9wdCgnZGF0ZUFsaWdubWVudCcpO1xuXHRcdHZhciBydW5uaW5nQ291bnQgPSAwO1xuXHRcdHZhciBzdGFydCA9IGRhdGUuY2xvbmUoKTtcblx0XHR2YXIgZW5kO1xuXG5cdFx0aWYgKGN1c3RvbUFsaWdubWVudCkge1xuXHRcdFx0c3RhcnQuc3RhcnRPZihjdXN0b21BbGlnbm1lbnQpO1xuXHRcdH1cblxuXHRcdHN0YXJ0LnN0YXJ0T2YoJ2RheScpO1xuXHRcdHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcblxuXHRcdGVuZCA9IHN0YXJ0LmNsb25lKCk7XG5cdFx0ZG8ge1xuXHRcdFx0ZW5kLmFkZCgxLCAnZGF5Jyk7XG5cdFx0XHRpZiAoIXRoaXMuaXNIaWRkZW5EYXkoZW5kKSkge1xuXHRcdFx0XHRydW5uaW5nQ291bnQrKztcblx0XHRcdH1cblx0XHR9IHdoaWxlIChydW5uaW5nQ291bnQgPCBkYXlDb3VudCk7XG5cblx0XHRyZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG5cdH0sXG5cblxuXHQvLyBCdWlsZHMgYSBub3JtYWxpemVkIHJhbmdlIG9iamVjdCBmb3IgdGhlIFwidmlzaWJsZVwiIHJhbmdlLFxuXHQvLyB3aGljaCBpcyBhIHdheSB0byBkZWZpbmUgdGhlIGN1cnJlbnRSYW5nZSBhbmQgYWN0aXZlUmFuZ2UgYXQgdGhlIHNhbWUgdGltZS5cblx0YnVpbGRDdXN0b21WaXNpYmxlUmFuZ2U6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR2YXIgdmlzaWJsZVJhbmdlID0gdGhpcy5nZXRSYW5nZU9wdGlvbihcblx0XHRcdCd2aXNpYmxlUmFuZ2UnLFxuXHRcdFx0dGhpcy5jYWxlbmRhci5tb21lbnQoZGF0ZSkgLy8gY29ycmVjdCB6b25lLiBhbHNvIGdlbmVyYXRlcyBuZXcgb2JqIHRoYXQgYXZvaWRzIG11dGF0aW9uc1xuXHRcdCk7XG5cblx0XHRpZiAodmlzaWJsZVJhbmdlICYmICghdmlzaWJsZVJhbmdlLnN0YXJ0IHx8ICF2aXNpYmxlUmFuZ2UuZW5kKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpc2libGVSYW5nZTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIHRoZSByYW5nZSB0aGF0IHdpbGwgcmVwcmVzZW50IHRoZSBlbGVtZW50L2NlbGxzIGZvciAqcmVuZGVyaW5nKixcblx0Ly8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxuXHRidWlsZFJlbmRlclJhbmdlOiBmdW5jdGlvbihjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQpIHtcblx0XHQvLyBjdXQgb2ZmIGRheXMgaW4gdGhlIGN1cnJlbnRSYW5nZSB0aGF0IGFyZSBoaWRkZW5cblx0XHRyZXR1cm4gdGhpcy50cmltSGlkZGVuRGF5cyhjdXJyZW50UmFuZ2UpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZSB0aGUgZHVyYXRpb24gdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQvc3Vic3RyYWN0ZWQgdG8gdGhlIGN1cnJlbnQgZGF0ZVxuXHQvLyB3aGVuIGEgcHJldi9uZXh0IG9wZXJhdGlvbiBoYXBwZW5zLlxuXHRidWlsZERhdGVJbmNyZW1lbnQ6IGZ1bmN0aW9uKGZhbGxiYWNrKSB7XG5cdFx0dmFyIGRhdGVJbmNyZW1lbnRJbnB1dCA9IHRoaXMub3B0KCdkYXRlSW5jcmVtZW50Jyk7XG5cdFx0dmFyIGN1c3RvbUFsaWdubWVudDtcblxuXHRcdGlmIChkYXRlSW5jcmVtZW50SW5wdXQpIHtcblx0XHRcdHJldHVybiBtb21lbnQuZHVyYXRpb24oZGF0ZUluY3JlbWVudElucHV0KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMub3B0KCdkYXRlQWxpZ25tZW50JykpKSB7XG5cdFx0XHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKDEsIGN1c3RvbUFsaWdubWVudCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGZhbGxiYWNrKSB7XG5cdFx0XHRyZXR1cm4gZmFsbGJhY2s7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbih7IGRheXM6IDEgfSk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmVtb3ZlIGRheXMgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIHJhbmdlIHRoYXQgYXJlIGNvbXB1dGVkIGFzIGhpZGRlbi5cblx0dHJpbUhpZGRlbkRheXM6IGZ1bmN0aW9uKGlucHV0UmFuZ2UpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnQ6IHRoaXMuc2tpcEhpZGRlbkRheXMoaW5wdXRSYW5nZS5zdGFydCksXG5cdFx0XHRlbmQ6IHRoaXMuc2tpcEhpZGRlbkRheXMoaW5wdXRSYW5nZS5lbmQsIC0xLCB0cnVlKSAvLyBleGNsdXNpdmVseSBtb3ZlIGJhY2t3YXJkc1xuXHRcdH07XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlIHRoZSBudW1iZXIgb2YgdGhlIGdpdmUgdW5pdHMgaW4gdGhlIFwiY3VycmVudFwiIHJhbmdlLlxuXHQvLyBXaWxsIHJldHVybiBhIGZsb2F0aW5nLXBvaW50IG51bWJlci4gV29uJ3Qgcm91bmQuXG5cdGN1cnJlbnRSYW5nZUFzOiBmdW5jdGlvbih1bml0KSB7XG5cdFx0dmFyIGN1cnJlbnRSYW5nZSA9IHRoaXMuY3VycmVudFJhbmdlO1xuXHRcdHJldHVybiBjdXJyZW50UmFuZ2UuZW5kLmRpZmYoY3VycmVudFJhbmdlLnN0YXJ0LCB1bml0LCB0cnVlKTtcblx0fSxcblxuXG5cdC8vIEFyZ3VtZW50cyBhZnRlciBuYW1lIHdpbGwgYmUgZm9yd2FyZGVkIHRvIGEgaHlwb3RoZXRpY2FsIGZ1bmN0aW9uIHZhbHVlXG5cdC8vIFdBUk5JTkc6IHBhc3NlZC1pbiBhcmd1bWVudHMgd2lsbCBiZSBnaXZlbiB0byBnZW5lcmF0b3IgZnVuY3Rpb25zIGFzLWlzIGFuZCBjYW4gY2F1c2Ugc2lkZS1lZmZlY3RzLlxuXHQvLyBBbHdheXMgY2xvbmUgeW91ciBvYmplY3RzIGlmIHlvdSBmZWFyIG11dGF0aW9uLlxuXHRnZXRSYW5nZU9wdGlvbjogZnVuY3Rpb24obmFtZSkge1xuXHRcdHZhciB2YWwgPSB0aGlzLm9wdChuYW1lKTtcblxuXHRcdGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR2YWwgPSB2YWwuYXBwbHkoXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2FsZW5kYXIucGFyc2VSYW5nZSh2YWwpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8qIEhpZGRlbiBEYXlzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXG5cdGluaXRIaWRkZW5EYXlzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGlkZGVuRGF5cyA9IHRoaXMub3B0KCdoaWRkZW5EYXlzJykgfHwgW107IC8vIGFycmF5IG9mIGRheS1vZi13ZWVrIGluZGljZXMgdGhhdCBhcmUgaGlkZGVuXG5cdFx0dmFyIGlzSGlkZGVuRGF5SGFzaCA9IFtdOyAvLyBpcyB0aGUgZGF5LW9mLXdlZWsgaGlkZGVuPyAoaGFzaCB3aXRoIGRheS1vZi13ZWVrLWluZGV4IC0+IGJvb2wpXG5cdFx0dmFyIGRheUNudCA9IDA7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAodGhpcy5vcHQoJ3dlZWtlbmRzJykgPT09IGZhbHNlKSB7XG5cdFx0XHRoaWRkZW5EYXlzLnB1c2goMCwgNik7IC8vIDA9c3VuZGF5LCA2PXNhdHVyZGF5XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQhKGlzSGlkZGVuRGF5SGFzaFtpXSA9ICQuaW5BcnJheShpLCBoaWRkZW5EYXlzKSAhPT0gLTEpXG5cdFx0XHQpIHtcblx0XHRcdFx0ZGF5Q250Kys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFkYXlDbnQpIHtcblx0XHRcdHRocm93ICdpbnZhbGlkIGhpZGRlbkRheXMnOyAvLyBhbGwgZGF5cyB3ZXJlIGhpZGRlbj8gYmFkLlxuXHRcdH1cblxuXHRcdHRoaXMuaXNIaWRkZW5EYXlIYXNoID0gaXNIaWRkZW5EYXlIYXNoO1xuXHR9LFxuXG5cblx0Ly8gSXMgdGhlIGN1cnJlbnQgZGF5IGhpZGRlbj9cblx0Ly8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBNb21lbnRcblx0aXNIaWRkZW5EYXk6IGZ1bmN0aW9uKGRheSkge1xuXHRcdGlmIChtb21lbnQuaXNNb21lbnQoZGF5KSkge1xuXHRcdFx0ZGF5ID0gZGF5LmRheSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5pc0hpZGRlbkRheUhhc2hbZGF5XTtcblx0fSxcblxuXG5cdC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cblx0Ly8gRE9FUyBOT1QgQ09OU0lERVIgdmFsaWRSYW5nZSFcblx0Ly8gSWYgdGhlIGluaXRpYWwgdmFsdWUgb2YgYGRhdGVgIGlzIG5vdCBhIGhpZGRlbiBkYXksIGRvbid0IGRvIGFueXRoaW5nLlxuXHQvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxuXHQvLyBgaW5jYCBkZWZhdWx0cyB0byBgMWAgKGluY3JlbWVudCBvbmUgZGF5IGZvcndhcmQgZWFjaCB0aW1lKVxuXHRza2lwSGlkZGVuRGF5czogZnVuY3Rpb24oZGF0ZSwgaW5jLCBpc0V4Y2x1c2l2ZSkge1xuXHRcdHZhciBvdXQgPSBkYXRlLmNsb25lKCk7XG5cdFx0aW5jID0gaW5jIHx8IDE7XG5cdFx0d2hpbGUgKFxuXHRcdFx0dGhpcy5pc0hpZGRlbkRheUhhc2hbKG91dC5kYXkoKSArIChpc0V4Y2x1c2l2ZSA/IGluYyA6IDApICsgNykgJSA3XVxuXHRcdCkge1xuXHRcdFx0b3V0LmFkZChpbmMsICdkYXlzJyk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblxufSk7XG5cbjs7XG5cbi8qXG5FbWJvZGllcyBhIGRpdiB0aGF0IGhhcyBwb3RlbnRpYWwgc2Nyb2xsYmFyc1xuKi9cbnZhciBTY3JvbGxlciA9IEZDLlNjcm9sbGVyID0gQ2xhc3MuZXh0ZW5kKHtcblxuXHRlbDogbnVsbCwgLy8gdGhlIGd1YXJhbnRlZWQgb3V0ZXIgZWxlbWVudFxuXHRzY3JvbGxFbDogbnVsbCwgLy8gdGhlIGVsZW1lbnQgd2l0aCB0aGUgc2Nyb2xsYmFyc1xuXHRvdmVyZmxvd1g6IG51bGwsXG5cdG92ZXJmbG93WTogbnVsbCxcblxuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0dGhpcy5vdmVyZmxvd1ggPSBvcHRpb25zLm92ZXJmbG93WCB8fCBvcHRpb25zLm92ZXJmbG93IHx8ICdhdXRvJztcblx0XHR0aGlzLm92ZXJmbG93WSA9IG9wdGlvbnMub3ZlcmZsb3dZIHx8IG9wdGlvbnMub3ZlcmZsb3cgfHwgJ2F1dG8nO1xuXHR9LFxuXG5cblx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsID0gdGhpcy5yZW5kZXJFbCgpO1xuXHRcdHRoaXMuYXBwbHlPdmVyZmxvdygpO1xuXHR9LFxuXG5cblx0cmVuZGVyRWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5zY3JvbGxFbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1zY3JvbGxlclwiPjwvZGl2PicpKTtcblx0fSxcblxuXG5cdC8vIHNldHMgdG8gbmF0dXJhbCBoZWlnaHQsIHVubG9ja3Mgb3ZlcmZsb3dcblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2V0SGVpZ2h0KCdhdXRvJyk7XG5cdFx0dGhpcy5hcHBseU92ZXJmbG93KCk7XG5cdH0sXG5cblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsLnJlbW92ZSgpO1xuXHR9LFxuXG5cblx0Ly8gT3ZlcmZsb3dcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdGFwcGx5T3ZlcmZsb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2Nyb2xsRWwuY3NzKHtcblx0XHRcdCdvdmVyZmxvdy14JzogdGhpcy5vdmVyZmxvd1gsXG5cdFx0XHQnb3ZlcmZsb3cteSc6IHRoaXMub3ZlcmZsb3dZXG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvLyBDYXVzZXMgYW55ICdhdXRvJyBvdmVyZmxvdyB2YWx1ZXMgdG8gcmVzb2x2ZXMgdG8gJ3Njcm9sbCcgb3IgJ2hpZGRlbicuXG5cdC8vIFVzZWZ1bCBmb3IgcHJlc2VydmluZyBzY3JvbGxiYXIgd2lkdGhzIHJlZ2FyZGxlc3Mgb2YgZnV0dXJlIHJlc2l6ZXMuXG5cdC8vIENhbiBwYXNzIGluIHNjcm9sbGJhcldpZHRocyBmb3Igb3B0aW1pemF0aW9uLlxuXHRsb2NrT3ZlcmZsb3c6IGZ1bmN0aW9uKHNjcm9sbGJhcldpZHRocykge1xuXHRcdHZhciBvdmVyZmxvd1ggPSB0aGlzLm92ZXJmbG93WDtcblx0XHR2YXIgb3ZlcmZsb3dZID0gdGhpcy5vdmVyZmxvd1k7XG5cblx0XHRzY3JvbGxiYXJXaWR0aHMgPSBzY3JvbGxiYXJXaWR0aHMgfHwgdGhpcy5nZXRTY3JvbGxiYXJXaWR0aHMoKTtcblxuXHRcdGlmIChvdmVyZmxvd1ggPT09ICdhdXRvJykge1xuXHRcdFx0b3ZlcmZsb3dYID0gKFxuXHRcdFx0XHRcdHNjcm9sbGJhcldpZHRocy50b3AgfHwgc2Nyb2xsYmFyV2lkdGhzLmJvdHRvbSB8fCAvLyBob3Jpem9udGFsIHNjcm9sbGJhcnM/XG5cdFx0XHRcdFx0Ly8gT1Igc2Nyb2xsaW5nIHBhbmUgd2l0aCBtYXNzbGVzcyBzY3JvbGxiYXJzP1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsRWxbMF0uc2Nyb2xsV2lkdGggLSAxID4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRXaWR0aFxuXHRcdFx0XHRcdFx0Ly8gc3VidHJhY3QgMSBiZWNhdXNlIG9mIElFIG9mZi1ieS1vbmUgaXNzdWVcblx0XHRcdFx0KSA/ICdzY3JvbGwnIDogJ2hpZGRlbic7XG5cdFx0fVxuXG5cdFx0aWYgKG92ZXJmbG93WSA9PT0gJ2F1dG8nKSB7XG5cdFx0XHRvdmVyZmxvd1kgPSAoXG5cdFx0XHRcdFx0c2Nyb2xsYmFyV2lkdGhzLmxlZnQgfHwgc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0IHx8IC8vIHZlcnRpY2FsIHNjcm9sbGJhcnM/XG5cdFx0XHRcdFx0Ly8gT1Igc2Nyb2xsaW5nIHBhbmUgd2l0aCBtYXNzbGVzcyBzY3JvbGxiYXJzP1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsRWxbMF0uc2Nyb2xsSGVpZ2h0IC0gMSA+IHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50SGVpZ2h0XG5cdFx0XHRcdFx0XHQvLyBzdWJ0cmFjdCAxIGJlY2F1c2Ugb2YgSUUgb2ZmLWJ5LW9uZSBpc3N1ZVxuXHRcdFx0XHQpID8gJ3Njcm9sbCcgOiAnaGlkZGVuJztcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbEVsLmNzcyh7ICdvdmVyZmxvdy14Jzogb3ZlcmZsb3dYLCAnb3ZlcmZsb3cteSc6IG92ZXJmbG93WSB9KTtcblx0fSxcblxuXG5cdC8vIEdldHRlcnMgLyBTZXR0ZXJzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuc2Nyb2xsRWwuaGVpZ2h0KGhlaWdodCk7XG5cdH0sXG5cblxuXHRnZXRTY3JvbGxUb3A6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnNjcm9sbEVsLnNjcm9sbFRvcCgpO1xuXHR9LFxuXG5cblx0c2V0U2Nyb2xsVG9wOiBmdW5jdGlvbih0b3ApIHtcblx0XHR0aGlzLnNjcm9sbEVsLnNjcm9sbFRvcCh0b3ApO1xuXHR9LFxuXG5cblx0Z2V0Q2xpZW50V2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnNjcm9sbEVsWzBdLmNsaWVudFdpZHRoO1xuXHR9LFxuXG5cblx0Z2V0Q2xpZW50SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRIZWlnaHQ7XG5cdH0sXG5cblxuXHRnZXRTY3JvbGxiYXJXaWR0aHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBnZXRTY3JvbGxiYXJXaWR0aHModGhpcy5zY3JvbGxFbCk7XG5cdH1cblxufSk7XG5cbjs7XG5mdW5jdGlvbiBJdGVyYXRvcihpdGVtcykge1xuICAgIHRoaXMuaXRlbXMgPSBpdGVtcyB8fCBbXTtcbn1cblxuXG4vKiBDYWxscyBhIG1ldGhvZCBvbiBldmVyeSBpdGVtIHBhc3NpbmcgdGhlIGFyZ3VtZW50cyB0aHJvdWdoICovXG5JdGVyYXRvci5wcm90b3R5cGUucHJveHlDYWxsID0gZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW1bbWV0aG9kTmFtZV0uYXBwbHkoaXRlbSwgYXJncykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG47O1xuXG4vKiBUb29sYmFyIHdpdGggYnV0dG9ucyBhbmQgdGl0bGVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5mdW5jdGlvbiBUb29sYmFyKGNhbGVuZGFyLCB0b29sYmFyT3B0aW9ucykge1xuXHR2YXIgdCA9IHRoaXM7XG5cblx0Ly8gZXhwb3J0c1xuXHR0LnNldFRvb2xiYXJPcHRpb25zID0gc2V0VG9vbGJhck9wdGlvbnM7XG5cdHQucmVuZGVyID0gcmVuZGVyO1xuXHR0LnJlbW92ZUVsZW1lbnQgPSByZW1vdmVFbGVtZW50O1xuXHR0LnVwZGF0ZVRpdGxlID0gdXBkYXRlVGl0bGU7XG5cdHQuYWN0aXZhdGVCdXR0b24gPSBhY3RpdmF0ZUJ1dHRvbjtcblx0dC5kZWFjdGl2YXRlQnV0dG9uID0gZGVhY3RpdmF0ZUJ1dHRvbjtcblx0dC5kaXNhYmxlQnV0dG9uID0gZGlzYWJsZUJ1dHRvbjtcblx0dC5lbmFibGVCdXR0b24gPSBlbmFibGVCdXR0b247XG5cdHQuZ2V0Vmlld3NXaXRoQnV0dG9ucyA9IGdldFZpZXdzV2l0aEJ1dHRvbnM7XG5cdHQuZWwgPSBudWxsOyAvLyBtaXJyb3JzIGxvY2FsIGBlbGBcblxuXHQvLyBsb2NhbHNcblx0dmFyIGVsO1xuXHR2YXIgdmlld3NXaXRoQnV0dG9ucyA9IFtdO1xuXHR2YXIgdG07XG5cblx0Ly8gbWV0aG9kIHRvIHVwZGF0ZSB0b29sYmFyLXNwZWNpZmljIG9wdGlvbnMsIG5vdCBjYWxlbmRhci13aWRlIG9wdGlvbnNcblx0ZnVuY3Rpb24gc2V0VG9vbGJhck9wdGlvbnMobmV3VG9vbGJhck9wdGlvbnMpIHtcblx0XHR0b29sYmFyT3B0aW9ucyA9IG5ld1Rvb2xiYXJPcHRpb25zO1xuXHR9XG5cblx0Ly8gY2FuIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFuZCB3aWxsIHJlcmVuZGVyXG5cdGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0XHR2YXIgc2VjdGlvbnMgPSB0b29sYmFyT3B0aW9ucy5sYXlvdXQ7XG5cblx0XHR0bSA9IGNhbGVuZGFyLm9wdCgndGhlbWUnKSA/ICd1aScgOiAnZmMnO1xuXG5cdFx0aWYgKHNlY3Rpb25zKSB7XG5cdFx0XHRpZiAoIWVsKSB7XG5cdFx0XHRcdGVsID0gdGhpcy5lbCA9ICQoXCI8ZGl2IGNsYXNzPSdmYy10b29sYmFyIFwiKyB0b29sYmFyT3B0aW9ucy5leHRyYUNsYXNzZXMgKyBcIicvPlwiKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRlbC5lbXB0eSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWwuYXBwZW5kKHJlbmRlclNlY3Rpb24oJ2xlZnQnKSlcblx0XHRcdFx0LmFwcGVuZChyZW5kZXJTZWN0aW9uKCdyaWdodCcpKVxuXHRcdFx0XHQuYXBwZW5kKHJlbmRlclNlY3Rpb24oJ2NlbnRlcicpKVxuXHRcdFx0XHQuYXBwZW5kKCc8ZGl2IGNsYXNzPVwiZmMtY2xlYXJcIi8+Jyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlRWxlbWVudCgpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gcmVtb3ZlRWxlbWVudCgpIHtcblx0XHRpZiAoZWwpIHtcblx0XHRcdGVsLnJlbW92ZSgpO1xuXHRcdFx0ZWwgPSB0LmVsID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHJlbmRlclNlY3Rpb24ocG9zaXRpb24pIHtcblx0XHR2YXIgc2VjdGlvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLScgKyBwb3NpdGlvbiArICdcIi8+Jyk7XG5cdFx0dmFyIGJ1dHRvblN0ciA9IHRvb2xiYXJPcHRpb25zLmxheW91dFtwb3NpdGlvbl07XG5cdFx0dmFyIGNhbGVuZGFyQ3VzdG9tQnV0dG9ucyA9IGNhbGVuZGFyLm9wdCgnY3VzdG9tQnV0dG9ucycpIHx8IHt9O1xuXHRcdHZhciBjYWxlbmRhckJ1dHRvblRleHQgPSBjYWxlbmRhci5vcHQoJ2J1dHRvblRleHQnKSB8fCB7fTtcblxuXHRcdGlmIChidXR0b25TdHIpIHtcblx0XHRcdCQuZWFjaChidXR0b25TdHIuc3BsaXQoJyAnKSwgZnVuY3Rpb24oaSkge1xuXHRcdFx0XHR2YXIgZ3JvdXBDaGlsZHJlbiA9ICQoKTtcblx0XHRcdFx0dmFyIGlzT25seUJ1dHRvbnMgPSB0cnVlO1xuXHRcdFx0XHR2YXIgZ3JvdXBFbDtcblxuXHRcdFx0XHQkLmVhY2godGhpcy5zcGxpdCgnLCcpLCBmdW5jdGlvbihqLCBidXR0b25OYW1lKSB7XG5cdFx0XHRcdFx0dmFyIGN1c3RvbUJ1dHRvblByb3BzO1xuXHRcdFx0XHRcdHZhciB2aWV3U3BlYztcblx0XHRcdFx0XHR2YXIgYnV0dG9uQ2xpY2s7XG5cdFx0XHRcdFx0dmFyIG92ZXJyaWRlVGV4dDsgLy8gdGV4dCBleHBsaWNpdGx5IHNldCBieSBjYWxlbmRhcidzIGNvbnN0cnVjdG9yIG9wdGlvbnMuIG92ZXJjb21lcyBpY29uc1xuXHRcdFx0XHRcdHZhciBkZWZhdWx0VGV4dDtcblx0XHRcdFx0XHR2YXIgdGhlbWVJY29uO1xuXHRcdFx0XHRcdHZhciBub3JtYWxJY29uO1xuXHRcdFx0XHRcdHZhciBpbm5lckh0bWw7XG5cdFx0XHRcdFx0dmFyIGNsYXNzZXM7XG5cdFx0XHRcdFx0dmFyIGJ1dHRvbjsgLy8gdGhlIGVsZW1lbnRcblxuXHRcdFx0XHRcdGlmIChidXR0b25OYW1lID09ICd0aXRsZScpIHtcblx0XHRcdFx0XHRcdGdyb3VwQ2hpbGRyZW4gPSBncm91cENoaWxkcmVuLmFkZCgkKCc8aDI+Jm5ic3A7PC9oMj4nKSk7IC8vIHdlIGFsd2F5cyB3YW50IGl0IHRvIHRha2UgdXAgaGVpZ2h0XG5cdFx0XHRcdFx0XHRpc09ubHlCdXR0b25zID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKChjdXN0b21CdXR0b25Qcm9wcyA9IGNhbGVuZGFyQ3VzdG9tQnV0dG9uc1tidXR0b25OYW1lXSkpIHtcblx0XHRcdFx0XHRcdFx0YnV0dG9uQ2xpY2sgPSBmdW5jdGlvbihldikge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjdXN0b21CdXR0b25Qcm9wcy5jbGljaykge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQnV0dG9uUHJvcHMuY2xpY2suY2FsbChidXR0b25bMF0sIGV2KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdG92ZXJyaWRlVGV4dCA9ICcnOyAvLyBpY29ucyB3aWxsIG92ZXJyaWRlIHRleHRcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFRleHQgPSBjdXN0b21CdXR0b25Qcm9wcy50ZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoKHZpZXdTcGVjID0gY2FsZW5kYXIuZ2V0Vmlld1NwZWMoYnV0dG9uTmFtZSkpKSB7XG5cdFx0XHRcdFx0XHRcdGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsZW5kYXIuY2hhbmdlVmlldyhidXR0b25OYW1lKTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0dmlld3NXaXRoQnV0dG9ucy5wdXNoKGJ1dHRvbk5hbWUpO1xuXHRcdFx0XHRcdFx0XHRvdmVycmlkZVRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGU7XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRUZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChjYWxlbmRhcltidXR0b25OYW1lXSkgeyAvLyBhIGNhbGVuZGFyIG1ldGhvZFxuXHRcdFx0XHRcdFx0XHRidXR0b25DbGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGNhbGVuZGFyW2J1dHRvbk5hbWVdKCk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdG92ZXJyaWRlVGV4dCA9IChjYWxlbmRhci5vdmVycmlkZXMuYnV0dG9uVGV4dCB8fCB7fSlbYnV0dG9uTmFtZV07XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRUZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdOyAvLyBldmVyeXRoaW5nIGVsc2UgaXMgY29uc2lkZXJlZCBkZWZhdWx0XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChidXR0b25DbGljaykge1xuXG5cdFx0XHRcdFx0XHRcdHRoZW1lSWNvbiA9XG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQnV0dG9uUHJvcHMgP1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQnV0dG9uUHJvcHMudGhlbWVJY29uIDpcblx0XHRcdFx0XHRcdFx0XHRcdGNhbGVuZGFyLm9wdCgndGhlbWVCdXR0b25JY29ucycpW2J1dHRvbk5hbWVdO1xuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbEljb24gPVxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUJ1dHRvblByb3BzID9cblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUJ1dHRvblByb3BzLmljb24gOlxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FsZW5kYXIub3B0KCdidXR0b25JY29ucycpW2J1dHRvbk5hbWVdO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChvdmVycmlkZVRleHQpIHtcblx0XHRcdFx0XHRcdFx0XHRpbm5lckh0bWwgPSBodG1sRXNjYXBlKG92ZXJyaWRlVGV4dCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAodGhlbWVJY29uICYmIGNhbGVuZGFyLm9wdCgndGhlbWUnKSkge1xuXHRcdFx0XHRcdFx0XHRcdGlubmVySHRtbCA9IFwiPHNwYW4gY2xhc3M9J3VpLWljb24gdWktaWNvbi1cIiArIHRoZW1lSWNvbiArIFwiJz48L3NwYW4+XCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAobm9ybWFsSWNvbiAmJiAhY2FsZW5kYXIub3B0KCd0aGVtZScpKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXJIdG1sID0gXCI8c3BhbiBjbGFzcz0nZmMtaWNvbiBmYy1pY29uLVwiICsgbm9ybWFsSWNvbiArIFwiJz48L3NwYW4+XCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXJIdG1sID0gaHRtbEVzY2FwZShkZWZhdWx0VGV4dCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRjbGFzc2VzID0gW1xuXHRcdFx0XHRcdFx0XHRcdCdmYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJyxcblx0XHRcdFx0XHRcdFx0XHR0bSArICctYnV0dG9uJyxcblx0XHRcdFx0XHRcdFx0XHR0bSArICctc3RhdGUtZGVmYXVsdCdcblx0XHRcdFx0XHRcdFx0XTtcblxuXHRcdFx0XHRcdFx0XHRidXR0b24gPSAkKCAvLyB0eXBlPVwiYnV0dG9uXCIgc28gdGhhdCBpdCBkb2Vzbid0IHN1Ym1pdCBhIGZvcm1cblx0XHRcdFx0XHRcdFx0XHQnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCI+JyArXG5cdFx0XHRcdFx0XHRcdFx0XHRpbm5lckh0bWwgK1xuXHRcdFx0XHRcdFx0XHRcdCc8L2J1dHRvbj4nXG5cdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdC5jbGljayhmdW5jdGlvbihldikge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZG9uJ3QgcHJvY2VzcyBjbGlja3MgZm9yIGRpc2FibGVkIGJ1dHRvbnNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICghYnV0dG9uLmhhc0NsYXNzKHRtICsgJy1zdGF0ZS1kaXNhYmxlZCcpKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YnV0dG9uQ2xpY2soZXYpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFmdGVyIHRoZSBjbGljayBhY3Rpb24sIGlmIHRoZSBidXR0b24gYmVjb21lcyB0aGUgXCJhY3RpdmVcIiB0YWIsIG9yIGRpc2FibGVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBpdCBzaG91bGQgbmV2ZXIgaGF2ZSBhIGhvdmVyIGNsYXNzLCBzbyByZW1vdmUgaXQgbm93LlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnV0dG9uLmhhc0NsYXNzKHRtICsgJy1zdGF0ZS1hY3RpdmUnKSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJ1dHRvbi5oYXNDbGFzcyh0bSArICctc3RhdGUtZGlzYWJsZWQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRidXR0b24ucmVtb3ZlQ2xhc3ModG0gKyAnLXN0YXRlLWhvdmVyJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHRcdC5tb3VzZWRvd24oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB0aGUgKmRvd24qIGVmZmVjdCAobW91c2UgcHJlc3NlZCBpbikuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBvbmx5IG9uIGJ1dHRvbnMgdGhhdCBhcmUgbm90IHRoZSBcImFjdGl2ZVwiIHRhYiwgb3IgZGlzYWJsZWRcblx0XHRcdFx0XHRcdFx0XHRcdGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQubm90KCcuJyArIHRtICsgJy1zdGF0ZS1hY3RpdmUnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQubm90KCcuJyArIHRtICsgJy1zdGF0ZS1kaXNhYmxlZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5hZGRDbGFzcyh0bSArICctc3RhdGUtZG93bicpO1xuXHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFx0Lm1vdXNldXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB1bmRvIHRoZSAqZG93biogZWZmZWN0XG5cdFx0XHRcdFx0XHRcdFx0XHRidXR0b24ucmVtb3ZlQ2xhc3ModG0gKyAnLXN0YXRlLWRvd24nKTtcblx0XHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHRcdC5ob3Zlcihcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyB0aGUgKmhvdmVyKiBlZmZlY3QuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIG9ubHkgb24gYnV0dG9ucyB0aGF0IGFyZSBub3QgdGhlIFwiYWN0aXZlXCIgdGFiLCBvciBkaXNhYmxlZFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRidXR0b25cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQubm90KCcuJyArIHRtICsgJy1zdGF0ZS1hY3RpdmUnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5ub3QoJy4nICsgdG0gKyAnLXN0YXRlLWRpc2FibGVkJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3ModG0gKyAnLXN0YXRlLWhvdmVyJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHVuZG8gdGhlICpob3ZlciogZWZmZWN0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyh0bSArICctc3RhdGUtaG92ZXInKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyh0bSArICctc3RhdGUtZG93bicpOyAvLyBpZiBtb3VzZWxlYXZlIGhhcHBlbnMgYmVmb3JlIG1vdXNldXBcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGdyb3VwQ2hpbGRyZW4gPSBncm91cENoaWxkcmVuLmFkZChidXR0b24pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKGlzT25seUJ1dHRvbnMpIHtcblx0XHRcdFx0XHRncm91cENoaWxkcmVuXG5cdFx0XHRcdFx0XHQuZmlyc3QoKS5hZGRDbGFzcyh0bSArICctY29ybmVyLWxlZnQnKS5lbmQoKVxuXHRcdFx0XHRcdFx0Lmxhc3QoKS5hZGRDbGFzcyh0bSArICctY29ybmVyLXJpZ2h0JykuZW5kKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZ3JvdXBDaGlsZHJlbi5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0Z3JvdXBFbCA9ICQoJzxkaXYvPicpO1xuXHRcdFx0XHRcdGlmIChpc09ubHlCdXR0b25zKSB7XG5cdFx0XHRcdFx0XHRncm91cEVsLmFkZENsYXNzKCdmYy1idXR0b24tZ3JvdXAnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Z3JvdXBFbC5hcHBlbmQoZ3JvdXBDaGlsZHJlbik7XG5cdFx0XHRcdFx0c2VjdGlvbkVsLmFwcGVuZChncm91cEVsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRzZWN0aW9uRWwuYXBwZW5kKGdyb3VwQ2hpbGRyZW4pOyAvLyAxIG9yIDAgY2hpbGRyZW5cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlY3Rpb25FbDtcblx0fVxuXG5cblx0ZnVuY3Rpb24gdXBkYXRlVGl0bGUodGV4dCkge1xuXHRcdGlmIChlbCkge1xuXHRcdFx0ZWwuZmluZCgnaDInKS50ZXh0KHRleHQpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gYWN0aXZhdGVCdXR0b24oYnV0dG9uTmFtZSkge1xuXHRcdGlmIChlbCkge1xuXHRcdFx0ZWwuZmluZCgnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKVxuXHRcdFx0XHQuYWRkQ2xhc3ModG0gKyAnLXN0YXRlLWFjdGl2ZScpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gZGVhY3RpdmF0ZUJ1dHRvbihidXR0b25OYW1lKSB7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRlbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyh0bSArICctc3RhdGUtYWN0aXZlJyk7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBkaXNhYmxlQnV0dG9uKGJ1dHRvbk5hbWUpIHtcblx0XHRpZiAoZWwpIHtcblx0XHRcdGVsLmZpbmQoJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJylcblx0XHRcdFx0LnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSlcblx0XHRcdFx0LmFkZENsYXNzKHRtICsgJy1zdGF0ZS1kaXNhYmxlZCcpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gZW5hYmxlQnV0dG9uKGJ1dHRvbk5hbWUpIHtcblx0XHRpZiAoZWwpIHtcblx0XHRcdGVsLmZpbmQoJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJylcblx0XHRcdFx0LnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyh0bSArICctc3RhdGUtZGlzYWJsZWQnKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGdldFZpZXdzV2l0aEJ1dHRvbnMoKSB7XG5cdFx0cmV0dXJuIHZpZXdzV2l0aEJ1dHRvbnM7XG5cdH1cblxufVxuXG47O1xuXG52YXIgQ2FsZW5kYXIgPSBGQy5DYWxlbmRhciA9IENsYXNzLmV4dGVuZChFbWl0dGVyTWl4aW4sIHtcblxuXHR2aWV3OiBudWxsLCAvLyBjdXJyZW50IFZpZXcgb2JqZWN0XG5cdHZpZXdzQnlUeXBlOiBudWxsLCAvLyBob2xkcyBhbGwgaW5zdGFudGlhdGVkIHZpZXcgaW5zdGFuY2VzLCBjdXJyZW50IG9yIG5vdFxuXHRjdXJyZW50RGF0ZTogbnVsbCwgLy8gdW56b25lZCBtb21lbnQuIHByaXZhdGUgKHB1YmxpYyBBUEkgc2hvdWxkIHVzZSBnZXREYXRlIGluc3RlYWQpXG5cdGxvYWRpbmdMZXZlbDogMCwgLy8gbnVtYmVyIG9mIHNpbXVsdGFuZW91cyBsb2FkaW5nIHRhc2tzXG5cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oZWwsIG92ZXJyaWRlcykge1xuXG5cdFx0Ly8gZGVjbGFyZSB0aGUgY3VycmVudCBjYWxlbmRhciBpbnN0YW5jZSByZWxpZXMgb24gR2xvYmFsRW1pdHRlci4gbmVlZGVkIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG5cdFx0Ly8gdW5uZWVkZWQoKSBpcyBjYWxsZWQgaW4gZGVzdHJveS5cblx0XHRHbG9iYWxFbWl0dGVyLm5lZWRlZCgpO1xuXG5cdFx0dGhpcy5lbCA9IGVsO1xuXHRcdHRoaXMudmlld3NCeVR5cGUgPSB7fTtcblx0XHR0aGlzLnZpZXdTcGVjQ2FjaGUgPSB7fTtcblxuXHRcdHRoaXMuaW5pdE9wdGlvbnNJbnRlcm5hbHMob3ZlcnJpZGVzKTtcblx0XHR0aGlzLmluaXRNb21lbnRJbnRlcm5hbHMoKTsgLy8gbmVlZHMgdG8gaGFwcGVuIGFmdGVyIG9wdGlvbnMgaGFzaCBpbml0aWFsaXplZFxuXHRcdHRoaXMuaW5pdEN1cnJlbnREYXRlKCk7XG5cblx0XHRFdmVudE1hbmFnZXIuY2FsbCh0aGlzKTsgLy8gbmVlZHMgb3B0aW9ucyBpbW1lZGlhdGVseVxuXHRcdHRoaXMuaW5pdGlhbGl6ZSgpO1xuXHR9LFxuXG5cblx0Ly8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb24gbG9naWMgYWZ0ZXIgdGhlIGNvbnN0cnVjdG9yIGhhcyBiZWVuIGNhbGxlZFxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdC8vIFB1YmxpYyBBUElcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdGdldENhbGVuZGFyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXc7XG5cdH0sXG5cblxuXHRwdWJsaWNseVRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUsIHRoaXNPYmopIHtcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cdFx0dmFyIG9wdEhhbmRsZXIgPSB0aGlzLm9wdChuYW1lKTtcblxuXHRcdHRoaXNPYmogPSB0aGlzT2JqIHx8IHRoaXMuZWxbMF07XG5cdFx0dGhpcy50cmlnZ2VyV2l0aChuYW1lLCB0aGlzT2JqLCBhcmdzKTsgLy8gRW1pdHRlcidzIG1ldGhvZFxuXG5cdFx0aWYgKG9wdEhhbmRsZXIpIHtcblx0XHRcdHJldHVybiBvcHRIYW5kbGVyLmFwcGx5KHRoaXNPYmosIGFyZ3MpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFZpZXdcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdC8vIEdpdmVuIGEgdmlldyBuYW1lIGZvciBhIGN1c3RvbSB2aWV3IG9yIGEgc3RhbmRhcmQgdmlldywgY3JlYXRlcyBhIHJlYWR5LXRvLWdvIFZpZXcgb2JqZWN0XG5cdGluc3RhbnRpYXRlVmlldzogZnVuY3Rpb24odmlld1R5cGUpIHtcblx0XHR2YXIgc3BlYyA9IHRoaXMuZ2V0Vmlld1NwZWModmlld1R5cGUpO1xuXG5cdFx0cmV0dXJuIG5ldyBzcGVjWydjbGFzcyddKHRoaXMsIHNwZWMpO1xuXHR9LFxuXG5cblx0Ly8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciB0aGUgdmlldyBpcyBva2F5IHRvIGluc3RhbnRpYXRlIGF0IHNvbWUgcG9pbnRcblx0aXNWYWxpZFZpZXdUeXBlOiBmdW5jdGlvbih2aWV3VHlwZSkge1xuXHRcdHJldHVybiBCb29sZWFuKHRoaXMuZ2V0Vmlld1NwZWModmlld1R5cGUpKTtcblx0fSxcblxuXG5cdGNoYW5nZVZpZXc6IGZ1bmN0aW9uKHZpZXdOYW1lLCBkYXRlT3JSYW5nZSkge1xuXG5cdFx0aWYgKGRhdGVPclJhbmdlKSB7XG5cblx0XHRcdGlmIChkYXRlT3JSYW5nZS5zdGFydCAmJiBkYXRlT3JSYW5nZS5lbmQpIHsgLy8gYSByYW5nZVxuXHRcdFx0XHR0aGlzLnJlY29yZE9wdGlvbk92ZXJyaWRlcyh7IC8vIHdpbGwgbm90IHJlcmVuZGVyXG5cdFx0XHRcdFx0dmlzaWJsZVJhbmdlOiBkYXRlT3JSYW5nZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgeyAvLyBhIGRhdGVcblx0XHRcdFx0dGhpcy5jdXJyZW50RGF0ZSA9IHRoaXMubW9tZW50KGRhdGVPclJhbmdlKS5zdHJpcFpvbmUoKTsgLy8ganVzdCBsaWtlIGdvdG9EYXRlXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5yZW5kZXJWaWV3KHZpZXdOYW1lKTtcblx0fSxcblxuXG5cdC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXG5cdC8vIGB2aWV3VHlwZWAgY2FuIGJlIGEgc3BlY2lmaWMgdmlldyBuYW1lIG9yIGEgZ2VuZXJpYyBvbmUgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLlxuXHR6b29tVG86IGZ1bmN0aW9uKG5ld0RhdGUsIHZpZXdUeXBlKSB7XG5cdFx0dmFyIHNwZWM7XG5cblx0XHR2aWV3VHlwZSA9IHZpZXdUeXBlIHx8ICdkYXknOyAvLyBkYXkgaXMgZGVmYXVsdCB6b29tXG5cdFx0c3BlYyA9IHRoaXMuZ2V0Vmlld1NwZWModmlld1R5cGUpIHx8IHRoaXMuZ2V0VW5pdFZpZXdTcGVjKHZpZXdUeXBlKTtcblxuXHRcdHRoaXMuY3VycmVudERhdGUgPSBuZXdEYXRlLmNsb25lKCk7XG5cdFx0dGhpcy5yZW5kZXJWaWV3KHNwZWMgPyBzcGVjLnR5cGUgOiBudWxsKTtcblx0fSxcblxuXG5cdC8vIEN1cnJlbnQgRGF0ZVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0aW5pdEN1cnJlbnREYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVmYXVsdERhdGVJbnB1dCA9IHRoaXMub3B0KCdkZWZhdWx0RGF0ZScpO1xuXG5cdFx0Ly8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXG5cdFx0aWYgKGRlZmF1bHREYXRlSW5wdXQgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5jdXJyZW50RGF0ZSA9IHRoaXMubW9tZW50KGRlZmF1bHREYXRlSW5wdXQpLnN0cmlwWm9uZSgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuY3VycmVudERhdGUgPSB0aGlzLmdldE5vdygpOyAvLyBnZXROb3cgYWxyZWFkeSByZXR1cm5zIHVuem9uZWRcblx0XHR9XG5cdH0sXG5cblxuXHRwcmV2OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcHJldkluZm8gPSB0aGlzLnZpZXcuYnVpbGRQcmV2RGF0ZVByb2ZpbGUodGhpcy5jdXJyZW50RGF0ZSk7XG5cblx0XHRpZiAocHJldkluZm8uaXNWYWxpZCkge1xuXHRcdFx0dGhpcy5jdXJyZW50RGF0ZSA9IHByZXZJbmZvLmRhdGU7XG5cdFx0XHR0aGlzLnJlbmRlclZpZXcoKTtcblx0XHR9XG5cdH0sXG5cblxuXHRuZXh0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV4dEluZm8gPSB0aGlzLnZpZXcuYnVpbGROZXh0RGF0ZVByb2ZpbGUodGhpcy5jdXJyZW50RGF0ZSk7XG5cblx0XHRpZiAobmV4dEluZm8uaXNWYWxpZCkge1xuXHRcdFx0dGhpcy5jdXJyZW50RGF0ZSA9IG5leHRJbmZvLmRhdGU7XG5cdFx0XHR0aGlzLnJlbmRlclZpZXcoKTtcblx0XHR9XG5cdH0sXG5cblxuXHRwcmV2WWVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jdXJyZW50RGF0ZS5hZGQoLTEsICd5ZWFycycpO1xuXHRcdHRoaXMucmVuZGVyVmlldygpO1xuXHR9LFxuXG5cblx0bmV4dFllYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY3VycmVudERhdGUuYWRkKDEsICd5ZWFycycpO1xuXHRcdHRoaXMucmVuZGVyVmlldygpO1xuXHR9LFxuXG5cblx0dG9kYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY3VycmVudERhdGUgPSB0aGlzLmdldE5vdygpOyAvLyBzaG91bGQgZGVueSBsaWtlIHByZXYvbmV4dD9cblx0XHR0aGlzLnJlbmRlclZpZXcoKTtcblx0fSxcblxuXG5cdGdvdG9EYXRlOiBmdW5jdGlvbih6b25lZERhdGVJbnB1dCkge1xuXHRcdHRoaXMuY3VycmVudERhdGUgPSB0aGlzLm1vbWVudCh6b25lZERhdGVJbnB1dCkuc3RyaXBab25lKCk7XG5cdFx0dGhpcy5yZW5kZXJWaWV3KCk7XG5cdH0sXG5cblxuXHRpbmNyZW1lbnREYXRlOiBmdW5jdGlvbihkZWx0YSkge1xuXHRcdHRoaXMuY3VycmVudERhdGUuYWRkKG1vbWVudC5kdXJhdGlvbihkZWx0YSkpO1xuXHRcdHRoaXMucmVuZGVyVmlldygpO1xuXHR9LFxuXG5cblx0Ly8gZm9yIGV4dGVybmFsIEFQSVxuXHRnZXREYXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBseVRpbWV6b25lKHRoaXMuY3VycmVudERhdGUpOyAvLyBpbmZ1c2UgdGhlIGNhbGVuZGFyJ3MgdGltZXpvbmVcblx0fSxcblxuXG5cdC8vIExvYWRpbmcgVHJpZ2dlcmluZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gU2hvdWxkIGJlIGNhbGxlZCB3aGVuIGFueSB0eXBlIG9mIGFzeW5jIGRhdGEgZmV0Y2hpbmcgYmVnaW5zXG5cdHB1c2hMb2FkaW5nOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoISh0aGlzLmxvYWRpbmdMZXZlbCsrKSkge1xuXHRcdFx0dGhpcy5wdWJsaWNseVRyaWdnZXIoJ2xvYWRpbmcnLCBudWxsLCB0cnVlLCB0aGlzLnZpZXcpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBhbnkgdHlwZSBvZiBhc3luYyBkYXRhIGZldGNoaW5nIGNvbXBsZXRlc1xuXHRwb3BMb2FkaW5nOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoISgtLXRoaXMubG9hZGluZ0xldmVsKSkge1xuXHRcdFx0dGhpcy5wdWJsaWNseVRyaWdnZXIoJ2xvYWRpbmcnLCBudWxsLCBmYWxzZSwgdGhpcy52aWV3KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBTZWxlY3Rpb25cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdC8vIHRoaXMgcHVibGljIG1ldGhvZCByZWNlaXZlcyBzdGFydC9lbmQgZGF0ZXMgaW4gYW55IGZvcm1hdCwgd2l0aCBhbnkgdGltZXpvbmVcblx0c2VsZWN0OiBmdW5jdGlvbih6b25lZFN0YXJ0SW5wdXQsIHpvbmVkRW5kSW5wdXQpIHtcblx0XHR0aGlzLnZpZXcuc2VsZWN0KFxuXHRcdFx0dGhpcy5idWlsZFNlbGVjdFNwYW4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuXHRcdCk7XG5cdH0sXG5cblxuXHR1bnNlbGVjdDogZnVuY3Rpb24oKSB7IC8vIHNhZmUgdG8gYmUgY2FsbGVkIGJlZm9yZSByZW5kZXJWaWV3XG5cdFx0aWYgKHRoaXMudmlldykge1xuXHRcdFx0dGhpcy52aWV3LnVuc2VsZWN0KCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYXJndW1lbnRzIHRvIHRoZSBzZWxlY3QgbWV0aG9kIGluIHRoZSBBUEksIHJldHVybnMgYSBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgb3RoZXIgaW5mbylcblx0YnVpbGRTZWxlY3RTcGFuOiBmdW5jdGlvbih6b25lZFN0YXJ0SW5wdXQsIHpvbmVkRW5kSW5wdXQpIHtcblx0XHR2YXIgc3RhcnQgPSB0aGlzLm1vbWVudCh6b25lZFN0YXJ0SW5wdXQpLnN0cmlwWm9uZSgpO1xuXHRcdHZhciBlbmQ7XG5cblx0XHRpZiAoem9uZWRFbmRJbnB1dCkge1xuXHRcdFx0ZW5kID0gdGhpcy5tb21lbnQoem9uZWRFbmRJbnB1dCkuc3RyaXBab25lKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHN0YXJ0Lmhhc1RpbWUoKSkge1xuXHRcdFx0ZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQodGhpcy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRlbmQgPSBzdGFydC5jbG9uZSgpLmFkZCh0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcblx0XHR9XG5cblx0XHRyZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG5cdH0sXG5cblxuXHQvLyBNaXNjXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHQvLyB3aWxsIHJldHVybiBgbnVsbGAgaWYgaW52YWxpZCByYW5nZVxuXHRwYXJzZVJhbmdlOiBmdW5jdGlvbihyYW5nZUlucHV0KSB7XG5cdFx0dmFyIHN0YXJ0ID0gbnVsbDtcblx0XHR2YXIgZW5kID0gbnVsbDtcblxuXHRcdGlmIChyYW5nZUlucHV0LnN0YXJ0KSB7XG5cdFx0XHRzdGFydCA9IHRoaXMubW9tZW50KHJhbmdlSW5wdXQuc3RhcnQpLnN0cmlwWm9uZSgpO1xuXHRcdH1cblxuXHRcdGlmIChyYW5nZUlucHV0LmVuZCkge1xuXHRcdFx0ZW5kID0gdGhpcy5tb21lbnQocmFuZ2VJbnB1dC5lbmQpLnN0cmlwWm9uZSgpO1xuXHRcdH1cblxuXHRcdGlmICghc3RhcnQgJiYgIWVuZCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHN0YXJ0ICYmIGVuZCAmJiBlbmQuaXNCZWZvcmUoc3RhcnQpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG5cdH0sXG5cblxuXHRyZXJlbmRlckV2ZW50czogZnVuY3Rpb24oKSB7IC8vIEFQSSBtZXRob2QuIGRlc3Ryb3lzIG9sZCBldmVudHMgaWYgcHJldmlvdXNseSByZW5kZXJlZC5cblx0XHRpZiAodGhpcy5lbGVtZW50VmlzaWJsZSgpKSB7XG5cdFx0XHR0aGlzLnJlcG9ydEV2ZW50Q2hhbmdlKCk7IC8vIHdpbGwgcmUtdHJhc21pdCBldmVudHMgdG8gdGhlIHZpZXcsIGNhdXNpbmcgYSByZXJlbmRlclxuXHRcdH1cblx0fVxuXG59KTtcblxuOztcbi8qXG5PcHRpb25zIGJpbmRpbmcvdHJpZ2dlcmluZyBzeXN0ZW0uXG4qL1xuQ2FsZW5kYXIubWl4aW4oe1xuXG5cdGRpckRlZmF1bHRzOiBudWxsLCAvLyBvcHRpb24gZGVmYXVsdHMgcmVsYXRlZCB0byBMVFIgb3IgUlRMXG5cdGxvY2FsZURlZmF1bHRzOiBudWxsLCAvLyBvcHRpb24gZGVmYXVsdHMgcmVsYXRlZCB0byBjdXJyZW50IGxvY2FsZVxuXHRvdmVycmlkZXM6IG51bGwsIC8vIG9wdGlvbiBvdmVycmlkZXMgZ2l2ZW4gdG8gdGhlIGZ1bGxDYWxlbmRhciBjb25zdHJ1Y3RvclxuXHRkeW5hbWljT3ZlcnJpZGVzOiBudWxsLCAvLyBvcHRpb25zIHNldCB3aXRoIGR5bmFtaWMgc2V0dGVyIG1ldGhvZC4gaGlnaGVyIHByZWNlZGVuY2UgdGhhbiB2aWV3IG92ZXJyaWRlcy5cblx0b3B0aW9uc01vZGVsOiBudWxsLCAvLyBhbGwgZGVmYXVsdHMgY29tYmluZWQgd2l0aCBvdmVycmlkZXNcblxuXG5cdGluaXRPcHRpb25zSW50ZXJuYWxzOiBmdW5jdGlvbihvdmVycmlkZXMpIHtcblx0XHR0aGlzLm92ZXJyaWRlcyA9ICQuZXh0ZW5kKHt9LCBvdmVycmlkZXMpOyAvLyBtYWtlIGEgY29weVxuXHRcdHRoaXMuZHluYW1pY092ZXJyaWRlcyA9IHt9O1xuXHRcdHRoaXMub3B0aW9uc01vZGVsID0gbmV3IE1vZGVsKCk7XG5cblx0XHR0aGlzLnBvcHVsYXRlT3B0aW9uc0hhc2goKTtcblx0fSxcblxuXG5cdC8vIHB1YmxpYyBnZXR0ZXIvc2V0dGVyXG5cdG9wdGlvbjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcblx0XHR2YXIgbmV3T3B0aW9uSGFzaDtcblxuXHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7IC8vIGdldHRlclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zTW9kZWwuZ2V0KG5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IC8vIHNldHRlciBmb3IgaW5kaXZpZHVhbCBvcHRpb25cblx0XHRcdFx0bmV3T3B0aW9uSGFzaCA9IHt9O1xuXHRcdFx0XHRuZXdPcHRpb25IYXNoW25hbWVdID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuc2V0T3B0aW9ucyhuZXdPcHRpb25IYXNoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7IC8vIGNvbXBvdW5kIHNldHRlciB3aXRoIG9iamVjdCBpbnB1dFxuXHRcdFx0dGhpcy5zZXRPcHRpb25zKG5hbWUpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIHByaXZhdGUgZ2V0dGVyXG5cdG9wdDogZnVuY3Rpb24obmFtZSkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnNNb2RlbC5nZXQobmFtZSk7XG5cdH0sXG5cblxuXHRzZXRPcHRpb25zOiBmdW5jdGlvbihuZXdPcHRpb25IYXNoKSB7XG5cdFx0dmFyIG9wdGlvbkNudCA9IDA7XG5cdFx0dmFyIG9wdGlvbk5hbWU7XG5cblx0XHR0aGlzLnJlY29yZE9wdGlvbk92ZXJyaWRlcyhuZXdPcHRpb25IYXNoKTtcblxuXHRcdGZvciAob3B0aW9uTmFtZSBpbiBuZXdPcHRpb25IYXNoKSB7XG5cdFx0XHRvcHRpb25DbnQrKztcblx0XHR9XG5cblx0XHQvLyBzcGVjaWFsLWNhc2UgaGFuZGxpbmcgb2Ygc2luZ2xlIG9wdGlvbiBjaGFuZ2UuXG5cdFx0Ly8gaWYgb25seSBvbmUgb3B0aW9uIGNoYW5nZSwgYG9wdGlvbk5hbWVgIHdpbGwgYmUgaXRzIG5hbWUuXG5cdFx0aWYgKG9wdGlvbkNudCA9PT0gMSkge1xuXHRcdFx0aWYgKG9wdGlvbk5hbWUgPT09ICdoZWlnaHQnIHx8IG9wdGlvbk5hbWUgPT09ICdjb250ZW50SGVpZ2h0JyB8fCBvcHRpb25OYW1lID09PSAnYXNwZWN0UmF0aW8nKSB7XG5cdFx0XHRcdHRoaXMudXBkYXRlU2l6ZSh0cnVlKTsgLy8gdHJ1ZSA9IGFsbG93IHJlY2FsY3VsYXRpb24gb2YgaGVpZ2h0XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09ICdkZWZhdWx0RGF0ZScpIHtcblx0XHRcdFx0cmV0dXJuOyAvLyBjYW4ndCBjaGFuZ2UgZGF0ZSB0aGlzIHdheS4gdXNlIGdvdG9EYXRlIGluc3RlYWRcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09ICdidXNpbmVzc0hvdXJzJykge1xuXHRcdFx0XHRpZiAodGhpcy52aWV3KSB7XG5cdFx0XHRcdFx0dGhpcy52aWV3LnVucmVuZGVyQnVzaW5lc3NIb3VycygpO1xuXHRcdFx0XHRcdHRoaXMudmlldy5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAob3B0aW9uTmFtZSA9PT0gJ3RpbWV6b25lJykge1xuXHRcdFx0XHR0aGlzLnJlem9uZUFycmF5RXZlbnRTb3VyY2VzKCk7XG5cdFx0XHRcdHRoaXMucmVmZXRjaEV2ZW50cygpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gY2F0Y2gtYWxsLiByZXJlbmRlciB0aGUgaGVhZGVyIGFuZCBmb290ZXIgYW5kIHJlYnVpbGQvcmVyZW5kZXIgdGhlIGN1cnJlbnQgdmlld1xuXHRcdHRoaXMucmVuZGVySGVhZGVyKCk7XG5cdFx0dGhpcy5yZW5kZXJGb290ZXIoKTtcblxuXHRcdC8vIGV2ZW4gbm9uLWN1cnJlbnQgdmlld3Mgd2lsbCBiZSBhZmZlY3RlZCBieSB0aGlzIG9wdGlvbiBjaGFuZ2UuIGRvIGJlZm9yZSByZXJlbmRlclxuXHRcdC8vIFRPRE86IGRldGFuZ2xlXG5cdFx0dGhpcy52aWV3c0J5VHlwZSA9IHt9O1xuXG5cdFx0dGhpcy5yZWluaXRWaWV3KCk7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyB0aGUgZmxhdHRlbmVkIG9wdGlvbnMgaGFzaCBmb3IgdGhlIGNhbGVuZGFyIGFuZCBhc3NpZ25zIHRvIGB0aGlzLm9wdGlvbnNgLlxuXHQvLyBBc3N1bWVzIHRoaXMub3ZlcnJpZGVzIGFuZCB0aGlzLmR5bmFtaWNPdmVycmlkZXMgaGF2ZSBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQuXG5cdHBvcHVsYXRlT3B0aW9uc0hhc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsb2NhbGUsIGxvY2FsZURlZmF1bHRzO1xuXHRcdHZhciBpc1JUTCwgZGlyRGVmYXVsdHM7XG5cdFx0dmFyIHJhd09wdGlvbnM7XG5cblx0XHRsb2NhbGUgPSBmaXJzdERlZmluZWQoIC8vIGV4cGxpY2l0IGxvY2FsZSBvcHRpb24gZ2l2ZW4/XG5cdFx0XHR0aGlzLmR5bmFtaWNPdmVycmlkZXMubG9jYWxlLFxuXHRcdFx0dGhpcy5vdmVycmlkZXMubG9jYWxlXG5cdFx0KTtcblx0XHRsb2NhbGVEZWZhdWx0cyA9IGxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlXTtcblx0XHRpZiAoIWxvY2FsZURlZmF1bHRzKSB7IC8vIGV4cGxpY2l0IGxvY2FsZSBvcHRpb24gbm90IGdpdmVuIG9yIGludmFsaWQ/XG5cdFx0XHRsb2NhbGUgPSBDYWxlbmRhci5kZWZhdWx0cy5sb2NhbGU7XG5cdFx0XHRsb2NhbGVEZWZhdWx0cyA9IGxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlXSB8fCB7fTtcblx0XHR9XG5cblx0XHRpc1JUTCA9IGZpcnN0RGVmaW5lZCggLy8gYmFzZWQgb24gb3B0aW9ucyBjb21wdXRlZCBzbyBmYXIsIGlzIGRpcmVjdGlvbiBSVEw/XG5cdFx0XHR0aGlzLmR5bmFtaWNPdmVycmlkZXMuaXNSVEwsXG5cdFx0XHR0aGlzLm92ZXJyaWRlcy5pc1JUTCxcblx0XHRcdGxvY2FsZURlZmF1bHRzLmlzUlRMLFxuXHRcdFx0Q2FsZW5kYXIuZGVmYXVsdHMuaXNSVExcblx0XHQpO1xuXHRcdGRpckRlZmF1bHRzID0gaXNSVEwgPyBDYWxlbmRhci5ydGxEZWZhdWx0cyA6IHt9O1xuXG5cdFx0dGhpcy5kaXJEZWZhdWx0cyA9IGRpckRlZmF1bHRzO1xuXHRcdHRoaXMubG9jYWxlRGVmYXVsdHMgPSBsb2NhbGVEZWZhdWx0cztcblxuXHRcdHJhd09wdGlvbnMgPSBtZXJnZU9wdGlvbnMoWyAvLyBtZXJnZSBkZWZhdWx0cyBhbmQgb3ZlcnJpZGVzLiBsb3dlc3QgdG8gaGlnaGVzdCBwcmVjZWRlbmNlXG5cdFx0XHRDYWxlbmRhci5kZWZhdWx0cywgLy8gZ2xvYmFsIGRlZmF1bHRzXG5cdFx0XHRkaXJEZWZhdWx0cyxcblx0XHRcdGxvY2FsZURlZmF1bHRzLFxuXHRcdFx0dGhpcy5vdmVycmlkZXMsXG5cdFx0XHR0aGlzLmR5bmFtaWNPdmVycmlkZXNcblx0XHRdKTtcblx0XHRwb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMocmF3T3B0aW9ucyk7IC8vIGZpbGwgaW4gZ2FwcyB3aXRoIGNvbXB1dGVkIG9wdGlvbnNcblxuXHRcdHRoaXMub3B0aW9uc01vZGVsLnJlc2V0KHJhd09wdGlvbnMpO1xuXHR9LFxuXG5cblx0Ly8gc3RvcmVzIHRoZSBuZXcgb3B0aW9ucyBpbnRlcm5hbGx5LCBidXQgZG9lcyBub3QgcmVyZW5kZXIgYW55dGhpbmcuXG5cdHJlY29yZE9wdGlvbk92ZXJyaWRlczogZnVuY3Rpb24obmV3T3B0aW9uSGFzaCkge1xuXHRcdHZhciBvcHRpb25OYW1lO1xuXG5cdFx0Zm9yIChvcHRpb25OYW1lIGluIG5ld09wdGlvbkhhc2gpIHtcblx0XHRcdHRoaXMuZHluYW1pY092ZXJyaWRlc1tvcHRpb25OYW1lXSA9IG5ld09wdGlvbkhhc2hbb3B0aW9uTmFtZV07XG5cdFx0fVxuXG5cdFx0dGhpcy52aWV3U3BlY0NhY2hlID0ge307IC8vIHRoZSBkeW5hbWljIG92ZXJyaWRlIGludmFsaWRhdGVzIHRoZSBvcHRpb25zIGluIHRoaXMgY2FjaGUsIHNvIGp1c3QgY2xlYXIgaXRcblx0XHR0aGlzLnBvcHVsYXRlT3B0aW9uc0hhc2goKTsgLy8gdGhpcy5vcHRpb25zIG5lZWRzIHRvIGJlIHJlY29tcHV0ZWQgYWZ0ZXIgdGhlIGR5bmFtaWMgb3ZlcnJpZGVcblx0fVxuXG59KTtcblxuOztcblxuQ2FsZW5kYXIubWl4aW4oe1xuXG5cdGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiBudWxsLFxuXHRkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiBudWxsLFxuXHRsb2NhbGVEYXRhOiBudWxsLFxuXG5cblx0aW5pdE1vbWVudEludGVybmFsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHRoaXMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ2RlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uJykpO1xuXHRcdHRoaXMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm9wdCgnZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbicpKTtcblxuXHRcdC8vIENhbGxlZCBpbW1lZGlhdGVseSwgYW5kIHdoZW4gYW55IG9mIHRoZSBvcHRpb25zIGNoYW5nZS5cblx0XHQvLyBIYXBwZW5zIGJlZm9yZSBhbnkgaW50ZXJuYWwgb2JqZWN0cyByZWJ1aWxkIG9yIHJlcmVuZGVyLCBiZWNhdXNlIHRoaXMgaXMgdmVyeSBjb3JlLlxuXHRcdHRoaXMub3B0aW9uc01vZGVsLndhdGNoKCdidWlsZGluZ01vbWVudExvY2FsZScsIFtcblx0XHRcdCc/bG9jYWxlJywgJz9tb250aE5hbWVzJywgJz9tb250aE5hbWVzU2hvcnQnLCAnP2RheU5hbWVzJywgJz9kYXlOYW1lc1Nob3J0Jyxcblx0XHRcdCc/Zmlyc3REYXknLCAnP3dlZWtOdW1iZXJDYWxjdWxhdGlvbidcblx0XHRdLCBmdW5jdGlvbihvcHRzKSB7XG5cdFx0XHR2YXIgd2Vla051bWJlckNhbGN1bGF0aW9uID0gb3B0cy53ZWVrTnVtYmVyQ2FsY3VsYXRpb247XG5cdFx0XHR2YXIgZmlyc3REYXkgPSBvcHRzLmZpcnN0RGF5O1xuXHRcdFx0dmFyIF93ZWVrO1xuXG5cdFx0XHQvLyBub3JtYWxpemVcblx0XHRcdGlmICh3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdpc28nKSB7XG5cdFx0XHRcdHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9ICdJU08nOyAvLyBub3JtYWxpemVcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxvY2FsZURhdGEgPSBjcmVhdGVPYmplY3QoIC8vIG1ha2UgYSBjaGVhcCBjb3B5XG5cdFx0XHRcdGdldE1vbWVudExvY2FsZURhdGEob3B0cy5sb2NhbGUpIC8vIHdpbGwgZmFsbCBiYWNrIHRvIGVuXG5cdFx0XHQpO1xuXG5cdFx0XHRpZiAob3B0cy5tb250aE5hbWVzKSB7XG5cdFx0XHRcdGxvY2FsZURhdGEuX21vbnRocyA9IG9wdHMubW9udGhOYW1lcztcblx0XHRcdH1cblx0XHRcdGlmIChvcHRzLm1vbnRoTmFtZXNTaG9ydCkge1xuXHRcdFx0XHRsb2NhbGVEYXRhLl9tb250aHNTaG9ydCA9IG9wdHMubW9udGhOYW1lc1Nob3J0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9wdHMuZGF5TmFtZXMpIHtcblx0XHRcdFx0bG9jYWxlRGF0YS5fd2Vla2RheXMgPSBvcHRzLmRheU5hbWVzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9wdHMuZGF5TmFtZXNTaG9ydCkge1xuXHRcdFx0XHRsb2NhbGVEYXRhLl93ZWVrZGF5c1Nob3J0ID0gb3B0cy5kYXlOYW1lc1Nob3J0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZmlyc3REYXkgPT0gbnVsbCAmJiB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XG5cdFx0XHRcdGZpcnN0RGF5ID0gMTtcblx0XHRcdH1cblx0XHRcdGlmIChmaXJzdERheSAhPSBudWxsKSB7XG5cdFx0XHRcdF93ZWVrID0gY3JlYXRlT2JqZWN0KGxvY2FsZURhdGEuX3dlZWspOyAvLyBfd2VlazogeyBkb3c6ICMgfVxuXHRcdFx0XHRfd2Vlay5kb3cgPSBmaXJzdERheTtcblx0XHRcdFx0bG9jYWxlRGF0YS5fd2VlayA9IF93ZWVrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIC8vIHdoaXRlbGlzdCBjZXJ0YWluIGtpbmRzIG9mIGlucHV0XG5cdFx0XHRcdHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ0lTTycgfHxcblx0XHRcdFx0d2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnbG9jYWwnIHx8XG5cdFx0XHRcdHR5cGVvZiB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbidcblx0XHRcdCkge1xuXHRcdFx0XHRsb2NhbGVEYXRhLl9mdWxsQ2FsZW5kYXJfd2Vla0NhbGMgPSB3ZWVrTnVtYmVyQ2FsY3VsYXRpb247IC8vIG1vbWVudC1leHQgd2lsbCBrbm93IHdoYXQgdG8gZG8gd2l0aCBpdFxuXHRcdFx0fVxuXG5cdFx0XHRfdGhpcy5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcblxuXHRcdFx0Ly8gSWYgdGhlIGludGVybmFsIGN1cnJlbnQgZGF0ZSBvYmplY3QgYWxyZWFkeSBleGlzdHMsIG1vdmUgdG8gbmV3IGxvY2FsZS5cblx0XHRcdC8vIFdlIGRvIE5PVCBuZWVkIHRvIGRvIHRoaXMgdGVjaG5pcXVlIGZvciBldmVudCBkYXRlcywgYmVjYXVzZSB0aGlzIGhhcHBlbnMgd2hlbiBjb252ZXJ0aW5nIHRvIFwic2VnbWVudHNcIi5cblx0XHRcdGlmIChfdGhpcy5jdXJyZW50RGF0ZSkge1xuXHRcdFx0XHRfdGhpcy5sb2NhbGl6ZU1vbWVudChfdGhpcy5jdXJyZW50RGF0ZSk7IC8vIHNldHMgdG8gbG9jYWxlRGF0YVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIGEgbW9tZW50IHVzaW5nIHRoZSBzZXR0aW5ncyBvZiB0aGUgY3VycmVudCBjYWxlbmRhcjogdGltZXpvbmUgYW5kIGxvY2FsZS5cblx0Ly8gQWNjZXB0cyBhbnl0aGluZyB0aGUgdmFuaWxsYSBtb21lbnQoKSBjb25zdHJ1Y3RvciBhY2NlcHRzLlxuXHRtb21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtb207XG5cblx0XHRpZiAodGhpcy5vcHQoJ3RpbWV6b25lJykgPT09ICdsb2NhbCcpIHtcblx0XHRcdG1vbSA9IEZDLm1vbWVudC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXG5cdFx0XHQvLyBGb3JjZSB0aGUgbW9tZW50IHRvIGJlIGxvY2FsLCBiZWNhdXNlIEZDLm1vbWVudCBkb2Vzbid0IGd1YXJhbnRlZSBpdC5cblx0XHRcdGlmIChtb20uaGFzVGltZSgpKSB7IC8vIGRvbid0IGdpdmUgYW1iaWd1b3VzbHktdGltZWQgbW9tZW50cyBhIGxvY2FsIHpvbmVcblx0XHRcdFx0bW9tLmxvY2FsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMub3B0KCd0aW1lem9uZScpID09PSAnVVRDJykge1xuXHRcdFx0bW9tID0gRkMubW9tZW50LnV0Yy5hcHBseShudWxsLCBhcmd1bWVudHMpOyAvLyBwcm9jZXNzIGFzIFVUQ1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG1vbSA9IEZDLm1vbWVudC5wYXJzZVpvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgLy8gbGV0IHRoZSBpbnB1dCBkZWNpZGUgdGhlIHpvbmVcblx0XHR9XG5cblx0XHR0aGlzLmxvY2FsaXplTW9tZW50KG1vbSk7IC8vIFRPRE9cblxuXHRcdHJldHVybiBtb207XG5cdH0sXG5cblxuXHQvLyBVcGRhdGVzIHRoZSBnaXZlbiBtb21lbnQncyBsb2NhbGUgc2V0dGluZ3MgdG8gdGhlIGN1cnJlbnQgY2FsZW5kYXIgbG9jYWxlIHNldHRpbmdzLlxuXHRsb2NhbGl6ZU1vbWVudDogZnVuY3Rpb24obW9tKSB7XG5cdFx0bW9tLl9sb2NhbGUgPSB0aGlzLmxvY2FsZURhdGE7XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIGEgYm9vbGVhbiBhYm91dCB3aGV0aGVyIG9yIG5vdCB0aGUgY2FsZW5kYXIga25vd3MgaG93IHRvIGNhbGN1bGF0ZVxuXHQvLyB0aGUgdGltZXpvbmUgb2Zmc2V0IG9mIGFyYml0cmFyeSBkYXRlcyBpbiB0aGUgY3VycmVudCB0aW1lem9uZS5cblx0Z2V0SXNBbWJpZ1RpbWV6b25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHQoJ3RpbWV6b25lJykgIT09ICdsb2NhbCcgJiYgdGhpcy5vcHQoJ3RpbWV6b25lJykgIT09ICdVVEMnO1xuXHR9LFxuXG5cblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGdpdmVuIGRhdGUgaW4gdGhlIGN1cnJlbnQgdGltZXpvbmUuIEhhcyBubyBlZmZlY3Qgb24gZGF0ZXMgd2l0aG91dCB0aW1lcy5cblx0YXBwbHlUaW1lem9uZTogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdGlmICghZGF0ZS5oYXNUaW1lKCkpIHtcblx0XHRcdHJldHVybiBkYXRlLmNsb25lKCk7XG5cdFx0fVxuXG5cdFx0dmFyIHpvbmVkRGF0ZSA9IHRoaXMubW9tZW50KGRhdGUudG9BcnJheSgpKTtcblx0XHR2YXIgdGltZUFkanVzdCA9IGRhdGUudGltZSgpIC0gem9uZWREYXRlLnRpbWUoKTtcblx0XHR2YXIgYWRqdXN0ZWRab25lZERhdGU7XG5cblx0XHQvLyBTYWZhcmkgc29tZXRpbWVzIGhhcyBwcm9ibGVtcyB3aXRoIHRoaXMgY29lcnNpb24gd2hlbiBuZWFyIERTVC4gQWRqdXN0IGlmIG5lY2Vzc2FyeS4gKGJ1ZyAjMjM5Nilcblx0XHRpZiAodGltZUFkanVzdCkgeyAvLyBpcyB0aGUgdGltZSByZXN1bHQgZGlmZmVyZW50IHRoYW4gZXhwZWN0ZWQ/XG5cdFx0XHRhZGp1c3RlZFpvbmVkRGF0ZSA9IHpvbmVkRGF0ZS5jbG9uZSgpLmFkZCh0aW1lQWRqdXN0KTsgLy8gYWRkIG1pbGxpc2Vjb25kc1xuXHRcdFx0aWYgKGRhdGUudGltZSgpIC0gYWRqdXN0ZWRab25lZERhdGUudGltZSgpID09PSAwKSB7IC8vIGRvZXMgaXQgbWF0Y2ggcGVyZmVjdGx5IG5vdz9cblx0XHRcdFx0em9uZWREYXRlID0gYWRqdXN0ZWRab25lZERhdGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHpvbmVkRGF0ZTtcblx0fSxcblxuXG5cdC8vIFJldHVybnMgYSBtb21lbnQgZm9yIHRoZSBjdXJyZW50IGRhdGUsIGFzIGRlZmluZWQgYnkgdGhlIGNsaWVudCdzIGNvbXB1dGVyIG9yIGZyb20gdGhlIGBub3dgIG9wdGlvbi5cblx0Ly8gV2lsbCByZXR1cm4gYW4gbW9tZW50IHdpdGggYW4gYW1iaWd1b3VzIHRpbWV6b25lLlxuXHRnZXROb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBub3cgPSB0aGlzLm9wdCgnbm93Jyk7XG5cdFx0aWYgKHR5cGVvZiBub3cgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG5vdyA9IG5vdygpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5tb21lbnQobm93KS5zdHJpcFpvbmUoKTtcblx0fSxcblxuXG5cdC8vIFByb2R1Y2VzIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGZvciB0aGUgZ2l2ZW4gZHVyYXRpb24uXG5cdC8vIFNpZGUtZWZmZWN0OiBjaGFuZ2VzIHRoZSBsb2NhbGUgb2YgdGhlIGdpdmVuIGR1cmF0aW9uLlxuXHRodW1hbml6ZUR1cmF0aW9uOiBmdW5jdGlvbihkdXJhdGlvbikge1xuXHRcdHJldHVybiBkdXJhdGlvbi5sb2NhbGUodGhpcy5vcHQoJ2xvY2FsZScpKS5odW1hbml6ZSgpO1xuXHR9LFxuXG5cblxuXHQvLyBFdmVudC1TcGVjaWZpYyBEYXRlIFV0aWxpdGllcy4gVE9ETzogbW92ZVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gR2V0IGFuIGV2ZW50J3Mgbm9ybWFsaXplZCBlbmQgZGF0ZS4gSWYgbm90IHByZXNlbnQsIGNhbGN1bGF0ZSBpdCBmcm9tIHRoZSBkZWZhdWx0cy5cblx0Z2V0RXZlbnRFbmQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKGV2ZW50LmVuZCkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmVuZC5jbG9uZSgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmdldERlZmF1bHRFdmVudEVuZChldmVudC5hbGxEYXksIGV2ZW50LnN0YXJ0KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhbiBldmVudCdzIGFsbERheSBzdGF0dXMgYW5kIHN0YXJ0IGRhdGUsIHJldHVybiB3aGF0IGl0cyBmYWxsYmFjayBlbmQgZGF0ZSBzaG91bGQgYmUuXG5cdC8vIFRPRE86IHJlbmFtZSB0byBjb21wdXRlRGVmYXVsdEV2ZW50RW5kXG5cdGdldERlZmF1bHRFdmVudEVuZDogZnVuY3Rpb24oYWxsRGF5LCB6b25lZFN0YXJ0KSB7XG5cdFx0dmFyIGVuZCA9IHpvbmVkU3RhcnQuY2xvbmUoKTtcblxuXHRcdGlmIChhbGxEYXkpIHtcblx0XHRcdGVuZC5zdHJpcFRpbWUoKS5hZGQodGhpcy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbik7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZW5kLmFkZCh0aGlzLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmdldElzQW1iaWdUaW1lem9uZSgpKSB7XG5cdFx0XHRlbmQuc3RyaXBab25lKCk7IC8vIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgdHpvIHNob3VsZCBiZVxuXHRcdH1cblxuXHRcdHJldHVybiBlbmQ7XG5cdH1cblxufSk7XG5cbjs7XG5cbkNhbGVuZGFyLm1peGluKHtcblxuXHR2aWV3U3BlY0NhY2hlOiBudWxsLCAvLyBjYWNoZSBvZiB2aWV3IGRlZmluaXRpb25zIChpbml0aWFsaXplZCBpbiBDYWxlbmRhci5qcylcblxuXG5cdC8vIEdldHMgaW5mb3JtYXRpb24gYWJvdXQgaG93IHRvIGNyZWF0ZSBhIHZpZXcuIFdpbGwgdXNlIGEgY2FjaGUuXG5cdGdldFZpZXdTcGVjOiBmdW5jdGlvbih2aWV3VHlwZSkge1xuXHRcdHZhciBjYWNoZSA9IHRoaXMudmlld1NwZWNDYWNoZTtcblxuXHRcdHJldHVybiBjYWNoZVt2aWV3VHlwZV0gfHwgKGNhY2hlW3ZpZXdUeXBlXSA9IHRoaXMuYnVpbGRWaWV3U3BlYyh2aWV3VHlwZSkpO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYSBkdXJhdGlvbiBzaW5ndWxhciB1bml0LCBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIsIGZpbmRzIGEgbWF0Y2hpbmcgdmlldyBzcGVjLlxuXHQvLyBQcmVmZXJlbmNlIGlzIGdpdmVuIHRvIHZpZXdzIHRoYXQgaGF2ZSBjb3JyZXNwb25kaW5nIGJ1dHRvbnMuXG5cdGdldFVuaXRWaWV3U3BlYzogZnVuY3Rpb24odW5pdCkge1xuXHRcdHZhciB2aWV3VHlwZXM7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIHNwZWM7XG5cblx0XHRpZiAoJC5pbkFycmF5KHVuaXQsIHVuaXRzRGVzYykgIT0gLTEpIHtcblxuXHRcdFx0Ly8gcHV0IHZpZXdzIHRoYXQgaGF2ZSBidXR0b25zIGZpcnN0LiB0aGVyZSB3aWxsIGJlIGR1cGxpY2F0ZXMsIGJ1dCBvaCB3ZWxsXG5cdFx0XHR2aWV3VHlwZXMgPSB0aGlzLmhlYWRlci5nZXRWaWV3c1dpdGhCdXR0b25zKCk7IC8vIFRPRE86IGluY2x1ZGUgZm9vdGVyIGFzIHdlbGw/XG5cdFx0XHQkLmVhY2goRkMudmlld3MsIGZ1bmN0aW9uKHZpZXdUeXBlKSB7IC8vIGFsbCB2aWV3c1xuXHRcdFx0XHR2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHZpZXdUeXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzcGVjID0gdGhpcy5nZXRWaWV3U3BlYyh2aWV3VHlwZXNbaV0pO1xuXHRcdFx0XHRpZiAoc3BlYykge1xuXHRcdFx0XHRcdGlmIChzcGVjLnNpbmdsZVVuaXQgPT0gdW5pdCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNwZWM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIGFuIG9iamVjdCB3aXRoIGluZm9ybWF0aW9uIG9uIGhvdyB0byBjcmVhdGUgYSBnaXZlbiB2aWV3XG5cdGJ1aWxkVmlld1NwZWM6IGZ1bmN0aW9uKHJlcXVlc3RlZFZpZXdUeXBlKSB7XG5cdFx0dmFyIHZpZXdPdmVycmlkZXMgPSB0aGlzLm92ZXJyaWRlcy52aWV3cyB8fCB7fTtcblx0XHR2YXIgc3BlY0NoYWluID0gW107IC8vIGZvciB0aGUgdmlldy4gbG93ZXN0IHRvIGhpZ2hlc3QgcHJpb3JpdHlcblx0XHR2YXIgZGVmYXVsdHNDaGFpbiA9IFtdOyAvLyBmb3IgdGhlIHZpZXcuIGxvd2VzdCB0byBoaWdoZXN0IHByaW9yaXR5XG5cdFx0dmFyIG92ZXJyaWRlc0NoYWluID0gW107IC8vIGZvciB0aGUgdmlldy4gbG93ZXN0IHRvIGhpZ2hlc3QgcHJpb3JpdHlcblx0XHR2YXIgdmlld1R5cGUgPSByZXF1ZXN0ZWRWaWV3VHlwZTtcblx0XHR2YXIgc3BlYzsgLy8gZm9yIHRoZSB2aWV3XG5cdFx0dmFyIG92ZXJyaWRlczsgLy8gZm9yIHRoZSB2aWV3XG5cdFx0dmFyIGR1cmF0aW9uSW5wdXQ7XG5cdFx0dmFyIGR1cmF0aW9uO1xuXHRcdHZhciB1bml0O1xuXG5cdFx0Ly8gaXRlcmF0ZSBmcm9tIHRoZSBzcGVjaWZpYyB2aWV3IGRlZmluaXRpb24gdG8gYSBtb3JlIGdlbmVyYWwgb25lIHVudGlsIHdlIGhpdCBhbiBhY3R1YWwgVmlldyBjbGFzc1xuXHRcdHdoaWxlICh2aWV3VHlwZSkge1xuXHRcdFx0c3BlYyA9IGZjVmlld3Nbdmlld1R5cGVdO1xuXHRcdFx0b3ZlcnJpZGVzID0gdmlld092ZXJyaWRlc1t2aWV3VHlwZV07XG5cdFx0XHR2aWV3VHlwZSA9IG51bGw7IC8vIGNsZWFyLiBtaWdodCByZXBvcHVsYXRlIGZvciBhbm90aGVyIGl0ZXJhdGlvblxuXG5cdFx0XHRpZiAodHlwZW9mIHNwZWMgPT09ICdmdW5jdGlvbicpIHsgLy8gVE9ETzogZGVwcmVjYXRlXG5cdFx0XHRcdHNwZWMgPSB7ICdjbGFzcyc6IHNwZWMgfTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHNwZWMpIHtcblx0XHRcdFx0c3BlY0NoYWluLnVuc2hpZnQoc3BlYyk7XG5cdFx0XHRcdGRlZmF1bHRzQ2hhaW4udW5zaGlmdChzcGVjLmRlZmF1bHRzIHx8IHt9KTtcblx0XHRcdFx0ZHVyYXRpb25JbnB1dCA9IGR1cmF0aW9uSW5wdXQgfHwgc3BlYy5kdXJhdGlvbjtcblx0XHRcdFx0dmlld1R5cGUgPSB2aWV3VHlwZSB8fCBzcGVjLnR5cGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvdmVycmlkZXMpIHtcblx0XHRcdFx0b3ZlcnJpZGVzQ2hhaW4udW5zaGlmdChvdmVycmlkZXMpOyAvLyB2aWV3LXNwZWNpZmljIG9wdGlvbiBoYXNoZXMgaGF2ZSBvcHRpb25zIGF0IHplcm8tbGV2ZWxcblx0XHRcdFx0ZHVyYXRpb25JbnB1dCA9IGR1cmF0aW9uSW5wdXQgfHwgb3ZlcnJpZGVzLmR1cmF0aW9uO1xuXHRcdFx0XHR2aWV3VHlwZSA9IHZpZXdUeXBlIHx8IG92ZXJyaWRlcy50eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNwZWMgPSBtZXJnZVByb3BzKHNwZWNDaGFpbik7XG5cdFx0c3BlYy50eXBlID0gcmVxdWVzdGVkVmlld1R5cGU7XG5cdFx0aWYgKCFzcGVjWydjbGFzcyddKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gZmFsbCBiYWNrIHRvIHRvcC1sZXZlbCBgZHVyYXRpb25gIG9wdGlvblxuXHRcdGR1cmF0aW9uSW5wdXQgPSBkdXJhdGlvbklucHV0IHx8XG5cdFx0XHR0aGlzLmR5bmFtaWNPdmVycmlkZXMuZHVyYXRpb24gfHxcblx0XHRcdHRoaXMub3ZlcnJpZGVzLmR1cmF0aW9uO1xuXG5cdFx0aWYgKGR1cmF0aW9uSW5wdXQpIHtcblx0XHRcdGR1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKGR1cmF0aW9uSW5wdXQpO1xuXG5cdFx0XHRpZiAoZHVyYXRpb24udmFsdWVPZigpKSB7IC8vIHZhbGlkP1xuXG5cdFx0XHRcdHVuaXQgPSBjb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQoZHVyYXRpb24sIGR1cmF0aW9uSW5wdXQpO1xuXG5cdFx0XHRcdHNwZWMuZHVyYXRpb24gPSBkdXJhdGlvbjtcblx0XHRcdFx0c3BlYy5kdXJhdGlvblVuaXQgPSB1bml0O1xuXG5cdFx0XHRcdC8vIHZpZXcgaXMgYSBzaW5nbGUtdW5pdCBkdXJhdGlvbiwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiXG5cdFx0XHRcdC8vIGluY29ycG9yYXRlIG9wdGlvbnMgZm9yIHRoaXMuIGxvd2VzdCBwcmlvcml0eVxuXHRcdFx0XHRpZiAoZHVyYXRpb24uYXModW5pdCkgPT09IDEpIHtcblx0XHRcdFx0XHRzcGVjLnNpbmdsZVVuaXQgPSB1bml0O1xuXHRcdFx0XHRcdG92ZXJyaWRlc0NoYWluLnVuc2hpZnQodmlld092ZXJyaWRlc1t1bml0XSB8fCB7fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRzcGVjLmRlZmF1bHRzID0gbWVyZ2VPcHRpb25zKGRlZmF1bHRzQ2hhaW4pO1xuXHRcdHNwZWMub3ZlcnJpZGVzID0gbWVyZ2VPcHRpb25zKG92ZXJyaWRlc0NoYWluKTtcblxuXHRcdHRoaXMuYnVpbGRWaWV3U3BlY09wdGlvbnMoc3BlYyk7XG5cdFx0dGhpcy5idWlsZFZpZXdTcGVjQnV0dG9uVGV4dChzcGVjLCByZXF1ZXN0ZWRWaWV3VHlwZSk7XG5cblx0XHRyZXR1cm4gc3BlYztcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyBhbmQgYXNzaWducyBhIHZpZXcgc3BlYydzIG9wdGlvbnMgb2JqZWN0IGZyb20gaXRzIGFscmVhZHktYXNzaWduZWQgZGVmYXVsdHMgYW5kIG92ZXJyaWRlc1xuXHRidWlsZFZpZXdTcGVjT3B0aW9uczogZnVuY3Rpb24oc3BlYykge1xuXHRcdHNwZWMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhbIC8vIGxvd2VzdCB0byBoaWdoZXN0IHByaW9yaXR5XG5cdFx0XHRDYWxlbmRhci5kZWZhdWx0cywgLy8gZ2xvYmFsIGRlZmF1bHRzXG5cdFx0XHRzcGVjLmRlZmF1bHRzLCAvLyB2aWV3J3MgZGVmYXVsdHMgKGZyb20gVmlld1N1YmNsYXNzLmRlZmF1bHRzKVxuXHRcdFx0dGhpcy5kaXJEZWZhdWx0cyxcblx0XHRcdHRoaXMubG9jYWxlRGVmYXVsdHMsIC8vIGxvY2FsZSBhbmQgZGlyIHRha2UgcHJlY2VkZW5jZSBvdmVyIHZpZXcncyBkZWZhdWx0cyFcblx0XHRcdHRoaXMub3ZlcnJpZGVzLCAvLyBjYWxlbmRhcidzIG92ZXJyaWRlcyAob3B0aW9ucyBnaXZlbiB0byBjb25zdHJ1Y3Rvcilcblx0XHRcdHNwZWMub3ZlcnJpZGVzLCAvLyB2aWV3J3Mgb3ZlcnJpZGVzICh2aWV3LXNwZWNpZmljIG9wdGlvbnMpXG5cdFx0XHR0aGlzLmR5bmFtaWNPdmVycmlkZXMgLy8gZHluYW1pY2FsbHkgc2V0IHZpYSBzZXR0ZXIuIGhpZ2hlc3QgcHJlY2VkZW5jZVxuXHRcdF0pO1xuXHRcdHBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyhzcGVjLm9wdGlvbnMpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgYW5kIGFzc2lnbnMgYSB2aWV3IHNwZWMncyBidXR0b25UZXh0LXJlbGF0ZWQgb3B0aW9uc1xuXHRidWlsZFZpZXdTcGVjQnV0dG9uVGV4dDogZnVuY3Rpb24oc3BlYywgcmVxdWVzdGVkVmlld1R5cGUpIHtcblxuXHRcdC8vIGdpdmVuIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggYSBwb3NzaWJsZSBgYnV0dG9uVGV4dGAgaGFzaCwgbG9va3VwIHRoZSBidXR0b25UZXh0IGZvciB0aGVcblx0XHQvLyByZXF1ZXN0ZWQgdmlldywgZmFsbGluZyBiYWNrIHRvIGEgZ2VuZXJpYyB1bml0IGVudHJ5IGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIlxuXHRcdGZ1bmN0aW9uIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zKSB7XG5cdFx0XHR2YXIgYnV0dG9uVGV4dCA9IG9wdGlvbnMuYnV0dG9uVGV4dCB8fCB7fTtcblx0XHRcdHJldHVybiBidXR0b25UZXh0W3JlcXVlc3RlZFZpZXdUeXBlXSB8fFxuXHRcdFx0XHQvLyB2aWV3IGNhbiBkZWNpZGUgdG8gbG9vayB1cCBhIGNlcnRhaW4ga2V5XG5cdFx0XHRcdChzcGVjLmJ1dHRvblRleHRLZXkgPyBidXR0b25UZXh0W3NwZWMuYnV0dG9uVGV4dEtleV0gOiBudWxsKSB8fFxuXHRcdFx0XHQvLyBhIGtleSBsaWtlIFwibW9udGhcIlxuXHRcdFx0XHQoc3BlYy5zaW5nbGVVbml0ID8gYnV0dG9uVGV4dFtzcGVjLnNpbmdsZVVuaXRdIDogbnVsbCk7XG5cdFx0fVxuXG5cdFx0Ly8gaGlnaGVzdCB0byBsb3dlc3QgcHJpb3JpdHlcblx0XHRzcGVjLmJ1dHRvblRleHRPdmVycmlkZSA9XG5cdFx0XHRxdWVyeUJ1dHRvblRleHQodGhpcy5keW5hbWljT3ZlcnJpZGVzKSB8fFxuXHRcdFx0cXVlcnlCdXR0b25UZXh0KHRoaXMub3ZlcnJpZGVzKSB8fCAvLyBjb25zdHJ1Y3Rvci1zcGVjaWZpZWQgYnV0dG9uVGV4dCBsb29rdXAgaGFzaCB0YWtlcyBwcmVjZWRlbmNlXG5cdFx0XHRzcGVjLm92ZXJyaWRlcy5idXR0b25UZXh0OyAvLyBgYnV0dG9uVGV4dGAgZm9yIHZpZXctc3BlY2lmaWMgb3B0aW9ucyBpcyBhIHN0cmluZ1xuXG5cdFx0Ly8gaGlnaGVzdCB0byBsb3dlc3QgcHJpb3JpdHkuIG1pcnJvcnMgYnVpbGRWaWV3U3BlY09wdGlvbnNcblx0XHRzcGVjLmJ1dHRvblRleHREZWZhdWx0ID1cblx0XHRcdHF1ZXJ5QnV0dG9uVGV4dCh0aGlzLmxvY2FsZURlZmF1bHRzKSB8fFxuXHRcdFx0cXVlcnlCdXR0b25UZXh0KHRoaXMuZGlyRGVmYXVsdHMpIHx8XG5cdFx0XHRzcGVjLmRlZmF1bHRzLmJ1dHRvblRleHQgfHwgLy8gYSBzaW5nbGUgc3RyaW5nLiBmcm9tIFZpZXdTdWJjbGFzcy5kZWZhdWx0c1xuXHRcdFx0cXVlcnlCdXR0b25UZXh0KENhbGVuZGFyLmRlZmF1bHRzKSB8fFxuXHRcdFx0KHNwZWMuZHVyYXRpb24gPyB0aGlzLmh1bWFuaXplRHVyYXRpb24oc3BlYy5kdXJhdGlvbikgOiBudWxsKSB8fCAvLyBsaWtlIFwiMyBkYXlzXCJcblx0XHRcdHJlcXVlc3RlZFZpZXdUeXBlOyAvLyBmYWxsIGJhY2sgdG8gZ2l2ZW4gdmlldyBuYW1lXG5cdH1cblxufSk7XG5cbjs7XG5cbkNhbGVuZGFyLm1peGluKHtcblxuXHRlbDogbnVsbCxcblx0Y29udGVudEVsOiBudWxsLFxuXHRzdWdnZXN0ZWRWaWV3SGVpZ2h0OiBudWxsLFxuXHR3aW5kb3dSZXNpemVQcm94eTogbnVsbCxcblx0aWdub3JlV2luZG93UmVzaXplOiAwLFxuXG5cblx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuY29udGVudEVsKSB7XG5cdFx0XHR0aGlzLmluaXRpYWxSZW5kZXIoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodGhpcy5lbGVtZW50VmlzaWJsZSgpKSB7XG5cdFx0XHQvLyBtYWlubHkgZm9yIHRoZSBwdWJsaWMgQVBJXG5cdFx0XHR0aGlzLmNhbGNTaXplKCk7XG5cdFx0XHR0aGlzLnJlbmRlclZpZXcoKTtcblx0XHR9XG5cdH0sXG5cblxuXHRpbml0aWFsUmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBlbCA9IHRoaXMuZWw7XG5cblx0XHRlbC5hZGRDbGFzcygnZmMnKTtcblxuXHRcdC8vIGV2ZW50IGRlbGVnYXRpb24gZm9yIG5hdiBsaW5rc1xuXHRcdGVsLm9uKCdjbGljay5mYycsICdhW2RhdGEtZ290b10nLCBmdW5jdGlvbihldikge1xuXHRcdFx0dmFyIGFuY2hvckVsID0gJCh0aGlzKTtcblx0XHRcdHZhciBnb3RvT3B0aW9ucyA9IGFuY2hvckVsLmRhdGEoJ2dvdG8nKTsgLy8gd2lsbCBhdXRvbWF0aWNhbGx5IHBhcnNlIEpTT05cblx0XHRcdHZhciBkYXRlID0gX3RoaXMubW9tZW50KGdvdG9PcHRpb25zLmRhdGUpO1xuXHRcdFx0dmFyIHZpZXdUeXBlID0gZ290b09wdGlvbnMudHlwZTtcblxuXHRcdFx0Ly8gcHJvcGVydHkgbGlrZSBcIm5hdkxpbmtEYXlDbGlja1wiLiBtaWdodCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uXG5cdFx0XHR2YXIgY3VzdG9tQWN0aW9uID0gX3RoaXMudmlldy5vcHQoJ25hdkxpbmsnICsgY2FwaXRhbGlzZUZpcnN0TGV0dGVyKHZpZXdUeXBlKSArICdDbGljaycpO1xuXG5cdFx0XHRpZiAodHlwZW9mIGN1c3RvbUFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjdXN0b21BY3Rpb24oZGF0ZSwgZXYpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZpZXdUeXBlID0gY3VzdG9tQWN0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF90aGlzLnpvb21UbyhkYXRlLCB2aWV3VHlwZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBjYWxsZWQgaW1tZWRpYXRlbHksIGFuZCB1cG9uIG9wdGlvbiBjaGFuZ2Vcblx0XHR0aGlzLm9wdGlvbnNNb2RlbC53YXRjaCgnYXBwbHlpbmdUaGVtZUNsYXNzZXMnLCBbICc/dGhlbWUnIF0sIGZ1bmN0aW9uKG9wdHMpIHtcblx0XHRcdGVsLnRvZ2dsZUNsYXNzKCd1aS13aWRnZXQnLCBvcHRzLnRoZW1lKTtcblx0XHRcdGVsLnRvZ2dsZUNsYXNzKCdmYy11bnRoZW1lZCcsICFvcHRzLnRoZW1lKTtcblx0XHR9KTtcblxuXHRcdC8vIGNhbGxlZCBpbW1lZGlhdGVseSwgYW5kIHVwb24gb3B0aW9uIGNoYW5nZS5cblx0XHQvLyBIQUNLOiBsb2NhbGUgb2Z0ZW4gYWZmZWN0cyBpc1JUTCwgc28gd2UgZXhwbGljaXRseSBsaXN0ZW4gdG8gdGhhdCB0b28uXG5cdFx0dGhpcy5vcHRpb25zTW9kZWwud2F0Y2goJ2FwcGx5aW5nRGlyQ2xhc3NlcycsIFsgJz9pc1JUTCcsICc/bG9jYWxlJyBdLCBmdW5jdGlvbihvcHRzKSB7XG5cdFx0XHRlbC50b2dnbGVDbGFzcygnZmMtbHRyJywgIW9wdHMuaXNSVEwpO1xuXHRcdFx0ZWwudG9nZ2xlQ2xhc3MoJ2ZjLXJ0bCcsIG9wdHMuaXNSVEwpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5jb250ZW50RWwgPSAkKFwiPGRpdiBjbGFzcz0nZmMtdmlldy1jb250YWluZXInLz5cIikucHJlcGVuZFRvKGVsKTtcblxuXHRcdHRoaXMuaW5pdFRvb2xiYXJzKCk7XG5cdFx0dGhpcy5yZW5kZXJIZWFkZXIoKTtcblx0XHR0aGlzLnJlbmRlckZvb3RlcigpO1xuXHRcdHRoaXMucmVuZGVyVmlldyh0aGlzLm9wdCgnZGVmYXVsdFZpZXcnKSk7XG5cblx0XHRpZiAodGhpcy5vcHQoJ2hhbmRsZVdpbmRvd1Jlc2l6ZScpKSB7XG5cdFx0XHQkKHdpbmRvdykucmVzaXplKFxuXHRcdFx0XHR0aGlzLndpbmRvd1Jlc2l6ZVByb3h5ID0gZGVib3VuY2UoIC8vIHByZXZlbnRzIHJhcGlkIGNhbGxzXG5cdFx0XHRcdFx0dGhpcy53aW5kb3dSZXNpemUuYmluZCh0aGlzKSxcblx0XHRcdFx0XHR0aGlzLm9wdCgnd2luZG93UmVzaXplRGVsYXknKVxuXHRcdFx0XHQpXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYgKHRoaXMudmlldykge1xuXHRcdFx0dGhpcy52aWV3LnJlbW92ZUVsZW1lbnQoKTtcblxuXHRcdFx0Ly8gTk9URTogZG9uJ3QgbnVsbC1vdXQgdGhpcy52aWV3IGluIGNhc2UgQVBJIG1ldGhvZHMgYXJlIGNhbGxlZCBhZnRlciBkZXN0cm95LlxuXHRcdFx0Ly8gSXQgaXMgc3RpbGwgdGhlIFwiY3VycmVudFwiIHZpZXcsIGp1c3Qgbm90IHJlbmRlcmVkLlxuXHRcdH1cblxuXHRcdHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbCgncmVtb3ZlRWxlbWVudCcpO1xuXHRcdHRoaXMuY29udGVudEVsLnJlbW92ZSgpO1xuXHRcdHRoaXMuZWwucmVtb3ZlQ2xhc3MoJ2ZjIGZjLWx0ciBmYy1ydGwgZmMtdW50aGVtZWQgdWktd2lkZ2V0Jyk7XG5cblx0XHR0aGlzLmVsLm9mZignLmZjJyk7IC8vIHVuYmluZCBuYXYgbGluayBoYW5kbGVyc1xuXG5cdFx0aWYgKHRoaXMud2luZG93UmVzaXplUHJveHkpIHtcblx0XHRcdCQod2luZG93KS51bmJpbmQoJ3Jlc2l6ZScsIHRoaXMud2luZG93UmVzaXplUHJveHkpO1xuXHRcdFx0dGhpcy53aW5kb3dSZXNpemVQcm94eSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0R2xvYmFsRW1pdHRlci51bm5lZWRlZCgpO1xuXHR9LFxuXG5cblx0ZWxlbWVudFZpc2libGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVsLmlzKCc6dmlzaWJsZScpO1xuXHR9LFxuXG5cblxuXHQvLyBWaWV3IFJlbmRlcmluZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gUmVuZGVycyBhIHZpZXcgYmVjYXVzZSBvZiBhIGRhdGUgY2hhbmdlLCB2aWV3LXR5cGUgY2hhbmdlLCBvciBmb3IgdGhlIGZpcnN0IHRpbWUuXG5cdC8vIElmIG5vdCBnaXZlbiBhIHZpZXdUeXBlLCBrZWVwIHRoZSBjdXJyZW50IHZpZXcgYnV0IHJlbmRlciBkaWZmZXJlbnQgZGF0ZXMuXG5cdC8vIEFjY2VwdHMgYW4gb3B0aW9uYWwgc2Nyb2xsIHN0YXRlIHRvIHJlc3RvcmUgdG8uXG5cdHJlbmRlclZpZXc6IGZ1bmN0aW9uKHZpZXdUeXBlLCBmb3JjZWRTY3JvbGwpIHtcblxuXHRcdHRoaXMuaWdub3JlV2luZG93UmVzaXplKys7XG5cblx0XHR2YXIgbmVlZHNDbGVhclZpZXcgPSB0aGlzLnZpZXcgJiYgdmlld1R5cGUgJiYgdGhpcy52aWV3LnR5cGUgIT09IHZpZXdUeXBlO1xuXG5cdFx0Ly8gaWYgdmlld1R5cGUgaXMgY2hhbmdpbmcsIHJlbW92ZSB0aGUgb2xkIHZpZXcncyByZW5kZXJpbmdcblx0XHRpZiAobmVlZHNDbGVhclZpZXcpIHtcblx0XHRcdHRoaXMuZnJlZXplQ29udGVudEhlaWdodCgpOyAvLyBwcmV2ZW50IGEgc2Nyb2xsIGp1bXAgd2hlbiB2aWV3IGVsZW1lbnQgaXMgcmVtb3ZlZFxuXHRcdFx0dGhpcy5jbGVhclZpZXcoKTtcblx0XHR9XG5cblx0XHQvLyBpZiB2aWV3VHlwZSBjaGFuZ2VkLCBvciB0aGUgdmlldyB3YXMgbmV2ZXIgY3JlYXRlZCwgY3JlYXRlIGEgZnJlc2ggdmlld1xuXHRcdGlmICghdGhpcy52aWV3ICYmIHZpZXdUeXBlKSB7XG5cdFx0XHR0aGlzLnZpZXcgPVxuXHRcdFx0XHR0aGlzLnZpZXdzQnlUeXBlW3ZpZXdUeXBlXSB8fFxuXHRcdFx0XHQodGhpcy52aWV3c0J5VHlwZVt2aWV3VHlwZV0gPSB0aGlzLmluc3RhbnRpYXRlVmlldyh2aWV3VHlwZSkpO1xuXG5cdFx0XHR0aGlzLnZpZXcuc2V0RWxlbWVudChcblx0XHRcdFx0JChcIjxkaXYgY2xhc3M9J2ZjLXZpZXcgZmMtXCIgKyB2aWV3VHlwZSArIFwiLXZpZXcnIC8+XCIpLmFwcGVuZFRvKHRoaXMuY29udGVudEVsKVxuXHRcdFx0KTtcblx0XHRcdHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbCgnYWN0aXZhdGVCdXR0b24nLCB2aWV3VHlwZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMudmlldykge1xuXG5cdFx0XHRpZiAoZm9yY2VkU2Nyb2xsKSB7XG5cdFx0XHRcdHRoaXMudmlldy5hZGRGb3JjZWRTY3JvbGwoZm9yY2VkU2Nyb2xsKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuZWxlbWVudFZpc2libGUoKSkge1xuXHRcdFx0XHR0aGlzLmN1cnJlbnREYXRlID0gdGhpcy52aWV3LnNldERhdGUodGhpcy5jdXJyZW50RGF0ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG5lZWRzQ2xlYXJWaWV3KSB7XG5cdFx0XHR0aGlzLnRoYXdDb250ZW50SGVpZ2h0KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5pZ25vcmVXaW5kb3dSZXNpemUtLTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyB0aGUgY3VycmVudCB2aWV3IGFuZCByZWZsZWN0cyB0aGlzIGNoYW5nZSBpbiB0aGUgSGVhZGVyLlxuXHQvLyBVbnJlZ3NpdGVycyB0aGUgYHZpZXdgLCBidXQgZG9lcyBub3QgcmVtb3ZlIGZyb20gdmlld0J5VHlwZSBoYXNoLlxuXHRjbGVhclZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbCgnZGVhY3RpdmF0ZUJ1dHRvbicsIHRoaXMudmlldy50eXBlKTtcblx0XHR0aGlzLnZpZXcucmVtb3ZlRWxlbWVudCgpO1xuXHRcdHRoaXMudmlldyA9IG51bGw7XG5cdH0sXG5cblxuXHQvLyBEZXN0cm95cyB0aGUgdmlldywgaW5jbHVkaW5nIHRoZSB2aWV3IG9iamVjdC4gVGhlbiwgcmUtaW5zdGFudGlhdGVzIGl0IGFuZCByZW5kZXJzIGl0LlxuXHQvLyBNYWludGFpbnMgdGhlIHNhbWUgc2Nyb2xsIHN0YXRlLlxuXHQvLyBUT0RPOiBtYWludGFpbiBhbnkgb3RoZXIgdXNlci1tYW5pcHVsYXRlZCBzdGF0ZS5cblx0cmVpbml0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pZ25vcmVXaW5kb3dSZXNpemUrKztcblx0XHR0aGlzLmZyZWV6ZUNvbnRlbnRIZWlnaHQoKTtcblxuXHRcdHZhciB2aWV3VHlwZSA9IHRoaXMudmlldy50eXBlO1xuXHRcdHZhciBzY3JvbGxTdGF0ZSA9IHRoaXMudmlldy5xdWVyeVNjcm9sbCgpO1xuXHRcdHRoaXMuY2xlYXJWaWV3KCk7XG5cdFx0dGhpcy5jYWxjU2l6ZSgpO1xuXHRcdHRoaXMucmVuZGVyVmlldyh2aWV3VHlwZSwgc2Nyb2xsU3RhdGUpO1xuXG5cdFx0dGhpcy50aGF3Q29udGVudEhlaWdodCgpO1xuXHRcdHRoaXMuaWdub3JlV2luZG93UmVzaXplLS07XG5cdH0sXG5cblxuXHQvLyBSZXNpemluZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Z2V0U3VnZ2VzdGVkVmlld0hlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5jYWxjU2l6ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0O1xuXHR9LFxuXG5cblx0aXNIZWlnaHRBdXRvOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHQoJ2NvbnRlbnRIZWlnaHQnKSA9PT0gJ2F1dG8nIHx8IHRoaXMub3B0KCdoZWlnaHQnKSA9PT0gJ2F1dG8nO1xuXHR9LFxuXG5cblx0dXBkYXRlU2l6ZTogZnVuY3Rpb24oc2hvdWxkUmVjYWxjKSB7XG5cdFx0aWYgKHRoaXMuZWxlbWVudFZpc2libGUoKSkge1xuXG5cdFx0XHRpZiAoc2hvdWxkUmVjYWxjKSB7XG5cdFx0XHRcdHRoaXMuX2NhbGNTaXplKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuaWdub3JlV2luZG93UmVzaXplKys7XG5cdFx0XHR0aGlzLnZpZXcudXBkYXRlU2l6ZSh0cnVlKTsgLy8gaXNSZXNpemU9dHJ1ZS4gd2lsbCBwb2xsIGdldFN1Z2dlc3RlZFZpZXdIZWlnaHQoKSBhbmQgaXNIZWlnaHRBdXRvKClcblx0XHRcdHRoaXMuaWdub3JlV2luZG93UmVzaXplLS07XG5cblx0XHRcdHJldHVybiB0cnVlOyAvLyBzaWduYWwgc3VjY2Vzc1xuXHRcdH1cblx0fSxcblxuXG5cdGNhbGNTaXplOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5lbGVtZW50VmlzaWJsZSgpKSB7XG5cdFx0XHR0aGlzLl9jYWxjU2l6ZSgpO1xuXHRcdH1cblx0fSxcblxuXG5cdF9jYWxjU2l6ZTogZnVuY3Rpb24oKSB7IC8vIGFzc3VtZXMgZWxlbWVudFZpc2libGVcblx0XHR2YXIgY29udGVudEhlaWdodElucHV0ID0gdGhpcy5vcHQoJ2NvbnRlbnRIZWlnaHQnKTtcblx0XHR2YXIgaGVpZ2h0SW5wdXQgPSB0aGlzLm9wdCgnaGVpZ2h0Jyk7XG5cblx0XHRpZiAodHlwZW9mIGNvbnRlbnRIZWlnaHRJbnB1dCA9PT0gJ251bWJlcicpIHsgLy8gZXhpc3RzIGFuZCBub3QgJ2F1dG8nXG5cdFx0XHR0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBjb250ZW50SGVpZ2h0SW5wdXQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiBjb250ZW50SGVpZ2h0SW5wdXQgPT09ICdmdW5jdGlvbicpIHsgLy8gZXhpc3RzIGFuZCBpcyBhIGZ1bmN0aW9uXG5cdFx0XHR0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBjb250ZW50SGVpZ2h0SW5wdXQoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIGhlaWdodElucHV0ID09PSAnbnVtYmVyJykgeyAvLyBleGlzdHMgYW5kIG5vdCAnYXV0bydcblx0XHRcdHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IGhlaWdodElucHV0IC0gdGhpcy5xdWVyeVRvb2xiYXJzSGVpZ2h0KCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiBoZWlnaHRJbnB1dCA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBleGlzdHMgYW5kIGlzIGEgZnVuY3Rpb25cblx0XHRcdHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IGhlaWdodElucHV0KCkgLSB0aGlzLnF1ZXJ5VG9vbGJhcnNIZWlnaHQoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoaGVpZ2h0SW5wdXQgPT09ICdwYXJlbnQnKSB7IC8vIHNldCB0byBoZWlnaHQgb2YgcGFyZW50IGVsZW1lbnRcblx0XHRcdHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IHRoaXMuZWwucGFyZW50KCkuaGVpZ2h0KCkgLSB0aGlzLnF1ZXJ5VG9vbGJhcnNIZWlnaHQoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBNYXRoLnJvdW5kKFxuXHRcdFx0XHR0aGlzLmNvbnRlbnRFbC53aWR0aCgpIC9cblx0XHRcdFx0TWF0aC5tYXgodGhpcy5vcHQoJ2FzcGVjdFJhdGlvJyksIC41KVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblxuXHR3aW5kb3dSZXNpemU6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0aWYgKFxuXHRcdFx0IXRoaXMuaWdub3JlV2luZG93UmVzaXplICYmXG5cdFx0XHRldi50YXJnZXQgPT09IHdpbmRvdyAmJiAvLyBzbyB3ZSBkb24ndCBwcm9jZXNzIGpxdWkgXCJyZXNpemVcIiBldmVudHMgdGhhdCBoYXZlIGJ1YmJsZWQgdXBcblx0XHRcdHRoaXMudmlldy5yZW5kZXJSYW5nZSAvLyB2aWV3IGhhcyBhbHJlYWR5IGJlZW4gcmVuZGVyZWRcblx0XHQpIHtcblx0XHRcdGlmICh0aGlzLnVwZGF0ZVNpemUodHJ1ZSkpIHtcblx0XHRcdFx0dGhpcy52aWV3LnB1YmxpY2x5VHJpZ2dlcignd2luZG93UmVzaXplJywgdGhpcy5lbFswXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0LyogSGVpZ2h0IFwiRnJlZXppbmdcIlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRmcmVlemVDb250ZW50SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNvbnRlbnRFbC5jc3Moe1xuXHRcdFx0d2lkdGg6ICcxMDAlJyxcblx0XHRcdGhlaWdodDogdGhpcy5jb250ZW50RWwuaGVpZ2h0KCksXG5cdFx0XHRvdmVyZmxvdzogJ2hpZGRlbidcblx0XHR9KTtcblx0fSxcblxuXG5cdHRoYXdDb250ZW50SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNvbnRlbnRFbC5jc3Moe1xuXHRcdFx0d2lkdGg6ICcnLFxuXHRcdFx0aGVpZ2h0OiAnJyxcblx0XHRcdG92ZXJmbG93OiAnJ1xuXHRcdH0pO1xuXHR9XG5cbn0pO1xuXG47O1xuXG5DYWxlbmRhci5taXhpbih7XG5cblx0aGVhZGVyOiBudWxsLFxuXHRmb290ZXI6IG51bGwsXG5cdHRvb2xiYXJzTWFuYWdlcjogbnVsbCxcblxuXG5cdGluaXRUb29sYmFyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oZWFkZXIgPSBuZXcgVG9vbGJhcih0aGlzLCB0aGlzLmNvbXB1dGVIZWFkZXJPcHRpb25zKCkpO1xuXHRcdHRoaXMuZm9vdGVyID0gbmV3IFRvb2xiYXIodGhpcywgdGhpcy5jb21wdXRlRm9vdGVyT3B0aW9ucygpKTtcblx0XHR0aGlzLnRvb2xiYXJzTWFuYWdlciA9IG5ldyBJdGVyYXRvcihbIHRoaXMuaGVhZGVyLCB0aGlzLmZvb3RlciBdKTtcblx0fSxcblxuXG5cdGNvbXB1dGVIZWFkZXJPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0cmFDbGFzc2VzOiAnZmMtaGVhZGVyLXRvb2xiYXInLFxuXHRcdFx0bGF5b3V0OiB0aGlzLm9wdCgnaGVhZGVyJylcblx0XHR9O1xuXHR9LFxuXG5cblx0Y29tcHV0ZUZvb3Rlck9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHRyYUNsYXNzZXM6ICdmYy1mb290ZXItdG9vbGJhcicsXG5cdFx0XHRsYXlvdXQ6IHRoaXMub3B0KCdmb290ZXInKVxuXHRcdH07XG5cdH0sXG5cblxuXHQvLyBjYW4gYmUgY2FsbGVkIHJlcGVhdGVkbHkgYW5kIEhlYWRlciB3aWxsIHJlcmVuZGVyXG5cdHJlbmRlckhlYWRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhlYWRlciA9IHRoaXMuaGVhZGVyO1xuXG5cdFx0aGVhZGVyLnNldFRvb2xiYXJPcHRpb25zKHRoaXMuY29tcHV0ZUhlYWRlck9wdGlvbnMoKSk7XG5cdFx0aGVhZGVyLnJlbmRlcigpO1xuXG5cdFx0aWYgKGhlYWRlci5lbCkge1xuXHRcdFx0dGhpcy5lbC5wcmVwZW5kKGhlYWRlci5lbCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gY2FuIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFuZCBGb290ZXIgd2lsbCByZXJlbmRlclxuXHRyZW5kZXJGb290ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmb290ZXIgPSB0aGlzLmZvb3RlcjtcblxuXHRcdGZvb3Rlci5zZXRUb29sYmFyT3B0aW9ucyh0aGlzLmNvbXB1dGVGb290ZXJPcHRpb25zKCkpO1xuXHRcdGZvb3Rlci5yZW5kZXIoKTtcblxuXHRcdGlmIChmb290ZXIuZWwpIHtcblx0XHRcdHRoaXMuZWwuYXBwZW5kKGZvb3Rlci5lbCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0c2V0VG9vbGJhcnNUaXRsZTogZnVuY3Rpb24odGl0bGUpIHtcblx0XHR0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ3VwZGF0ZVRpdGxlJywgdGl0bGUpO1xuXHR9LFxuXG5cblx0dXBkYXRlVG9vbGJhckJ1dHRvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBub3cgPSB0aGlzLmdldE5vdygpO1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciB0b2RheUluZm8gPSB2aWV3LmJ1aWxkRGF0ZVByb2ZpbGUobm93KTtcblx0XHR2YXIgcHJldkluZm8gPSB2aWV3LmJ1aWxkUHJldkRhdGVQcm9maWxlKHRoaXMuY3VycmVudERhdGUpO1xuXHRcdHZhciBuZXh0SW5mbyA9IHZpZXcuYnVpbGROZXh0RGF0ZVByb2ZpbGUodGhpcy5jdXJyZW50RGF0ZSk7XG5cblx0XHR0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoXG5cdFx0XHQodG9kYXlJbmZvLmlzVmFsaWQgJiYgIWlzRGF0ZVdpdGhpblJhbmdlKG5vdywgdmlldy5jdXJyZW50UmFuZ2UpKSA/XG5cdFx0XHRcdCdlbmFibGVCdXR0b24nIDpcblx0XHRcdFx0J2Rpc2FibGVCdXR0b24nLFxuXHRcdFx0J3RvZGF5J1xuXHRcdCk7XG5cblx0XHR0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoXG5cdFx0XHRwcmV2SW5mby5pc1ZhbGlkID9cblx0XHRcdFx0J2VuYWJsZUJ1dHRvbicgOlxuXHRcdFx0XHQnZGlzYWJsZUJ1dHRvbicsXG5cdFx0XHQncHJldidcblx0XHQpO1xuXG5cdFx0dGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKFxuXHRcdFx0bmV4dEluZm8uaXNWYWxpZCA/XG5cdFx0XHRcdCdlbmFibGVCdXR0b24nIDpcblx0XHRcdFx0J2Rpc2FibGVCdXR0b24nLFxuXHRcdFx0J25leHQnXG5cdFx0KTtcblx0fSxcblxuXG5cdHF1ZXJ5VG9vbGJhcnNIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnRvb2xiYXJzTWFuYWdlci5pdGVtcy5yZWR1Y2UoZnVuY3Rpb24oYWNjdW11bGF0b3IsIHRvb2xiYXIpIHtcblx0XHRcdHZhciB0b29sYmFySGVpZ2h0ID0gdG9vbGJhci5lbCA/IHRvb2xiYXIuZWwub3V0ZXJIZWlnaHQodHJ1ZSkgOiAwOyAvLyBpbmNsdWRlcyBtYXJnaW5cblx0XHRcdHJldHVybiBhY2N1bXVsYXRvciArIHRvb2xiYXJIZWlnaHQ7XG5cdFx0fSwgMCk7XG5cdH1cblxufSk7XG5cbjs7XG5cbkNhbGVuZGFyLmRlZmF1bHRzID0ge1xuXG5cdHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLCAvLyBlbiBkYXNoXG5cdG1vbnRoWWVhckZvcm1hdDogJ01NTU0gWVlZWScsIC8vIHJlcXVpcmVkIGZvciBlbi4gb3RoZXIgbG9jYWxlcyByZWx5IG9uIGRhdGVwaWNrZXIgY29tcHV0YWJsZSBvcHRpb25cblxuXHRkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiAnMDI6MDA6MDAnLFxuXHRkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogeyBkYXlzOiAxIH0sXG5cdGZvcmNlRXZlbnREdXJhdGlvbjogZmFsc2UsXG5cdG5leHREYXlUaHJlc2hvbGQ6ICcwOTowMDowMCcsIC8vIDlhbVxuXG5cdC8vIGRpc3BsYXlcblx0ZGVmYXVsdFZpZXc6ICdtb250aCcsXG5cdGFzcGVjdFJhdGlvOiAxLjM1LFxuXHRoZWFkZXI6IHtcblx0XHRsZWZ0OiAndGl0bGUnLFxuXHRcdGNlbnRlcjogJycsXG5cdFx0cmlnaHQ6ICd0b2RheSBwcmV2LG5leHQnXG5cdH0sXG5cdHdlZWtlbmRzOiB0cnVlLFxuXHR3ZWVrTnVtYmVyczogZmFsc2UsXG5cblx0d2Vla051bWJlclRpdGxlOiAnVycsXG5cdHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogJ2xvY2FsJyxcblx0XG5cdC8vZWRpdGFibGU6IGZhbHNlLFxuXG5cdC8vbm93SW5kaWNhdG9yOiBmYWxzZSxcblxuXHRzY3JvbGxUaW1lOiAnMDY6MDA6MDAnLFxuXHRtaW5UaW1lOiAnMDA6MDA6MDAnLFxuXHRtYXhUaW1lOiAnMjQ6MDA6MDAnLFxuXHRzaG93Tm9uQ3VycmVudERhdGVzOiB0cnVlLFxuXHRcblx0Ly8gZXZlbnQgYWpheFxuXHRsYXp5RmV0Y2hpbmc6IHRydWUsXG5cdHN0YXJ0UGFyYW06ICdzdGFydCcsXG5cdGVuZFBhcmFtOiAnZW5kJyxcblx0dGltZXpvbmVQYXJhbTogJ3RpbWV6b25lJyxcblxuXHR0aW1lem9uZTogZmFsc2UsXG5cblx0Ly9hbGxEYXlEZWZhdWx0OiB1bmRlZmluZWQsXG5cblx0Ly8gbG9jYWxlXG5cdGlzUlRMOiBmYWxzZSxcblx0YnV0dG9uVGV4dDoge1xuXHRcdHByZXY6IFwicHJldlwiLFxuXHRcdG5leHQ6IFwibmV4dFwiLFxuXHRcdHByZXZZZWFyOiBcInByZXYgeWVhclwiLFxuXHRcdG5leHRZZWFyOiBcIm5leHQgeWVhclwiLFxuXHRcdHllYXI6ICd5ZWFyJywgLy8gVE9ETzogbG9jYWxlIGZpbGVzIG5lZWQgdG8gc3BlY2lmeSB0aGlzXG5cdFx0dG9kYXk6ICd0b2RheScsXG5cdFx0bW9udGg6ICdtb250aCcsXG5cdFx0d2VlazogJ3dlZWsnLFxuXHRcdGRheTogJ2RheSdcblx0fSxcblxuXHRidXR0b25JY29uczoge1xuXHRcdHByZXY6ICdsZWZ0LXNpbmdsZS1hcnJvdycsXG5cdFx0bmV4dDogJ3JpZ2h0LXNpbmdsZS1hcnJvdycsXG5cdFx0cHJldlllYXI6ICdsZWZ0LWRvdWJsZS1hcnJvdycsXG5cdFx0bmV4dFllYXI6ICdyaWdodC1kb3VibGUtYXJyb3cnXG5cdH0sXG5cblx0YWxsRGF5VGV4dDogJ2FsbC1kYXknLFxuXHRcblx0Ly8ganF1ZXJ5LXVpIHRoZW1pbmdcblx0dGhlbWU6IGZhbHNlLFxuXHR0aGVtZUJ1dHRvbkljb25zOiB7XG5cdFx0cHJldjogJ2NpcmNsZS10cmlhbmdsZS13Jyxcblx0XHRuZXh0OiAnY2lyY2xlLXRyaWFuZ2xlLWUnLFxuXHRcdHByZXZZZWFyOiAnc2Vlay1wcmV2Jyxcblx0XHRuZXh0WWVhcjogJ3NlZWstbmV4dCdcblx0fSxcblxuXHQvL2V2ZW50UmVzaXphYmxlRnJvbVN0YXJ0OiBmYWxzZSxcblx0ZHJhZ09wYWNpdHk6IC43NSxcblx0ZHJhZ1JldmVydER1cmF0aW9uOiA1MDAsXG5cdGRyYWdTY3JvbGw6IHRydWUsXG5cdFxuXHQvL3NlbGVjdGFibGU6IGZhbHNlLFxuXHR1bnNlbGVjdEF1dG86IHRydWUsXG5cdC8vc2VsZWN0TWluRGlzdGFuY2U6IDAsXG5cdFxuXHRkcm9wQWNjZXB0OiAnKicsXG5cblx0ZXZlbnRPcmRlcjogJ3RpdGxlJyxcblx0Ly9ldmVudFJlbmRlcldhaXQ6IG51bGwsXG5cblx0ZXZlbnRMaW1pdDogZmFsc2UsXG5cdGV2ZW50TGltaXRUZXh0OiAnbW9yZScsXG5cdGV2ZW50TGltaXRDbGljazogJ3BvcG92ZXInLFxuXHRkYXlQb3BvdmVyRm9ybWF0OiAnTEwnLFxuXHRcblx0aGFuZGxlV2luZG93UmVzaXplOiB0cnVlLFxuXHR3aW5kb3dSZXNpemVEZWxheTogMTAwLCAvLyBtaWxsaXNlY29uZHMgYmVmb3JlIGFuIHVwZGF0ZVNpemUgaGFwcGVuc1xuXG5cdGxvbmdQcmVzc0RlbGF5OiAxMDAwXG5cdFxufTtcblxuXG5DYWxlbmRhci5lbmdsaXNoRGVmYXVsdHMgPSB7IC8vIHVzZWQgYnkgbG9jYWxlLmpzXG5cdGRheVBvcG92ZXJGb3JtYXQ6ICdkZGRkLCBNTU1NIEQnXG59O1xuXG5cbkNhbGVuZGFyLnJ0bERlZmF1bHRzID0geyAvLyByaWdodC10by1sZWZ0IGRlZmF1bHRzXG5cdGhlYWRlcjogeyAvLyBUT0RPOiBzbWFydGVyIHNvbHV0aW9uIChmaXJzdC9jZW50ZXIvbGFzdCA/KVxuXHRcdGxlZnQ6ICduZXh0LHByZXYgdG9kYXknLFxuXHRcdGNlbnRlcjogJycsXG5cdFx0cmlnaHQ6ICd0aXRsZSdcblx0fSxcblx0YnV0dG9uSWNvbnM6IHtcblx0XHRwcmV2OiAncmlnaHQtc2luZ2xlLWFycm93Jyxcblx0XHRuZXh0OiAnbGVmdC1zaW5nbGUtYXJyb3cnLFxuXHRcdHByZXZZZWFyOiAncmlnaHQtZG91YmxlLWFycm93Jyxcblx0XHRuZXh0WWVhcjogJ2xlZnQtZG91YmxlLWFycm93J1xuXHR9LFxuXHR0aGVtZUJ1dHRvbkljb25zOiB7XG5cdFx0cHJldjogJ2NpcmNsZS10cmlhbmdsZS1lJyxcblx0XHRuZXh0OiAnY2lyY2xlLXRyaWFuZ2xlLXcnLFxuXHRcdG5leHRZZWFyOiAnc2Vlay1wcmV2Jyxcblx0XHRwcmV2WWVhcjogJ3NlZWstbmV4dCdcblx0fVxufTtcblxuOztcblxudmFyIGxvY2FsZU9wdGlvbkhhc2ggPSBGQy5sb2NhbGVzID0ge307IC8vIGluaXRpYWxpemUgYW5kIGV4cG9zZVxuXG5cbi8vIFRPRE86IGRvY3VtZW50IHRoZSBzdHJ1Y3R1cmUgYW5kIG9yZGVyaW5nIG9mIGEgRnVsbENhbGVuZGFyIGxvY2FsZSBmaWxlXG5cblxuLy8gSW5pdGlhbGl6ZSBqUXVlcnkgVUkgZGF0ZXBpY2tlciB0cmFuc2xhdGlvbnMgd2hpbGUgdXNpbmcgc29tZSBvZiB0aGUgdHJhbnNsYXRpb25zXG4vLyBXaWxsIHNldCB0aGlzIGFzIHRoZSBkZWZhdWx0IGxvY2FsZXMgZm9yIGRhdGVwaWNrZXIuXG5GQy5kYXRlcGlja2VyTG9jYWxlID0gZnVuY3Rpb24obG9jYWxlQ29kZSwgZHBMb2NhbGVDb2RlLCBkcE9wdGlvbnMpIHtcblxuXHQvLyBnZXQgdGhlIEZ1bGxDYWxlbmRhciBpbnRlcm5hbCBvcHRpb24gaGFzaCBmb3IgdGhpcyBsb2NhbGUuIGNyZWF0ZSBpZiBuZWNlc3Nhcnlcblx0dmFyIGZjT3B0aW9ucyA9IGxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gfHwgKGxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gPSB7fSk7XG5cblx0Ly8gdHJhbnNmZXIgc29tZSBzaW1wbGUgb3B0aW9ucyBmcm9tIGRhdGVwaWNrZXIgdG8gZmNcblx0ZmNPcHRpb25zLmlzUlRMID0gZHBPcHRpb25zLmlzUlRMO1xuXHRmY09wdGlvbnMud2Vla051bWJlclRpdGxlID0gZHBPcHRpb25zLndlZWtIZWFkZXI7XG5cblx0Ly8gY29tcHV0ZSBzb21lIG1vcmUgY29tcGxleCBvcHRpb25zIGZyb20gZGF0ZXBpY2tlclxuXHQkLmVhY2goZHBDb21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24obmFtZSwgZnVuYykge1xuXHRcdGZjT3B0aW9uc1tuYW1lXSA9IGZ1bmMoZHBPcHRpb25zKTtcblx0fSk7XG5cblx0Ly8gaXMgalF1ZXJ5IFVJIERhdGVwaWNrZXIgaXMgb24gdGhlIHBhZ2U/XG5cdGlmICgkLmRhdGVwaWNrZXIpIHtcblxuXHRcdC8vIFJlZ2lzdGVyIHRoZSBsb2NhbGUgZGF0YS5cblx0XHQvLyBGdWxsQ2FsZW5kYXIgYW5kIE1vbWVudEpTIHVzZSBsb2NhbGUgY29kZXMgbGlrZSBcInB0LWJyXCIgYnV0IERhdGVwaWNrZXJcblx0XHQvLyBkb2VzIGl0IGxpa2UgXCJwdC1CUlwiIG9yIGlmIGl0IGRvZXNuJ3QgaGF2ZSB0aGUgbG9jYWxlLCBtYXliZSBqdXN0IFwicHRcIi5cblx0XHQvLyBNYWtlIGFuIGFsaWFzIHNvIHRoZSBsb2NhbGUgY2FuIGJlIHJlZmVyZW5jZWQgZWl0aGVyIHdheS5cblx0XHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbZHBMb2NhbGVDb2RlXSA9XG5cdFx0XHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbbG9jYWxlQ29kZV0gPSAvLyBhbGlhc1xuXHRcdFx0XHRkcE9wdGlvbnM7XG5cblx0XHQvLyBBbGlhcyAnZW4nIHRvIHRoZSBkZWZhdWx0IGxvY2FsZSBkYXRhLiBEbyB0aGlzIGV2ZXJ5IHRpbWUuXG5cdFx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsLmVuID0gJC5kYXRlcGlja2VyLnJlZ2lvbmFsWycnXTtcblxuXHRcdC8vIFNldCBhcyBEYXRlcGlja2VyJ3MgZ2xvYmFsIGRlZmF1bHRzLlxuXHRcdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cyhkcE9wdGlvbnMpO1xuXHR9XG59O1xuXG5cbi8vIFNldHMgRnVsbENhbGVuZGFyLXNwZWNpZmljIHRyYW5zbGF0aW9ucy4gV2lsbCBzZXQgdGhlIGxvY2FsZXMgYXMgdGhlIGdsb2JhbCBkZWZhdWx0LlxuRkMubG9jYWxlID0gZnVuY3Rpb24obG9jYWxlQ29kZSwgbmV3RmNPcHRpb25zKSB7XG5cdHZhciBmY09wdGlvbnM7XG5cdHZhciBtb21PcHRpb25zO1xuXG5cdC8vIGdldCB0aGUgRnVsbENhbGVuZGFyIGludGVybmFsIG9wdGlvbiBoYXNoIGZvciB0aGlzIGxvY2FsZS4gY3JlYXRlIGlmIG5lY2Vzc2FyeVxuXHRmY09wdGlvbnMgPSBsb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdIHx8IChsb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdID0ge30pO1xuXG5cdC8vIHByb3ZpZGVkIG5ldyBvcHRpb25zIGZvciB0aGlzIGxvY2FsZXM/IG1lcmdlIHRoZW0gaW5cblx0aWYgKG5ld0ZjT3B0aW9ucykge1xuXHRcdGZjT3B0aW9ucyA9IGxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gPSBtZXJnZU9wdGlvbnMoWyBmY09wdGlvbnMsIG5ld0ZjT3B0aW9ucyBdKTtcblx0fVxuXG5cdC8vIGNvbXB1dGUgbG9jYWxlIG9wdGlvbnMgdGhhdCB3ZXJlbid0IGRlZmluZWQuXG5cdC8vIGFsd2F5cyBkbyB0aGlzLiBuZXdGY09wdGlvbnMgY2FuIGJlIHVuZGVmaW5lZCB3aGVuIGluaXRpYWxpemluZyBmcm9tIGkxOG4gZmlsZSxcblx0Ly8gc28gbm8gd2F5IHRvIHRlbGwgaWYgdGhpcyBpcyBhbiBpbml0aWFsaXphdGlvbiBvciBhIGRlZmF1bHQtc2V0dGluZy5cblx0bW9tT3B0aW9ucyA9IGdldE1vbWVudExvY2FsZURhdGEobG9jYWxlQ29kZSk7IC8vIHdpbGwgZmFsbCBiYWNrIHRvIGVuXG5cdCQuZWFjaChtb21Db21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24obmFtZSwgZnVuYykge1xuXHRcdGlmIChmY09wdGlvbnNbbmFtZV0gPT0gbnVsbCkge1xuXHRcdFx0ZmNPcHRpb25zW25hbWVdID0gZnVuYyhtb21PcHRpb25zLCBmY09wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gc2V0IGl0IGFzIHRoZSBkZWZhdWx0IGxvY2FsZSBmb3IgRnVsbENhbGVuZGFyXG5cdENhbGVuZGFyLmRlZmF1bHRzLmxvY2FsZSA9IGxvY2FsZUNvZGU7XG59O1xuXG5cbi8vIE5PVEU6IGNhbid0IGd1YXJhbnRlZSBhbnkgb2YgdGhlc2UgY29tcHV0YXRpb25zIHdpbGwgcnVuIGJlY2F1c2Ugbm90IGV2ZXJ5IGxvY2FsZSBoYXMgZGF0ZXBpY2tlclxuLy8gY29uZmlncywgc28gbWFrZSBzdXJlIHRoZXJlIGFyZSBFbmdsaXNoIGZhbGxiYWNrcyBmb3IgdGhlc2UgaW4gdGhlIGRlZmF1bHRzIGZpbGUuXG52YXIgZHBDb21wdXRhYmxlT3B0aW9ucyA9IHtcblxuXHRidXR0b25UZXh0OiBmdW5jdGlvbihkcE9wdGlvbnMpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Ly8gdGhlIHRyYW5zbGF0aW9ucyBzb21ldGltZXMgd3JvbmdseSBjb250YWluIEhUTUwgZW50aXRpZXNcblx0XHRcdHByZXY6IHN0cmlwSHRtbEVudGl0aWVzKGRwT3B0aW9ucy5wcmV2VGV4dCksXG5cdFx0XHRuZXh0OiBzdHJpcEh0bWxFbnRpdGllcyhkcE9wdGlvbnMubmV4dFRleHQpLFxuXHRcdFx0dG9kYXk6IHN0cmlwSHRtbEVudGl0aWVzKGRwT3B0aW9ucy5jdXJyZW50VGV4dClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJNTU1NIFlZWVlcIiAtPiBcIlNlcHRlbWJlciAyMDE0XCJcblx0bW9udGhZZWFyRm9ybWF0OiBmdW5jdGlvbihkcE9wdGlvbnMpIHtcblx0XHRyZXR1cm4gZHBPcHRpb25zLnNob3dNb250aEFmdGVyWWVhciA/XG5cdFx0XHQnWVlZWVsnICsgZHBPcHRpb25zLnllYXJTdWZmaXggKyAnXSBNTU1NJyA6XG5cdFx0XHQnTU1NTSBZWVlZWycgKyBkcE9wdGlvbnMueWVhclN1ZmZpeCArICddJztcblx0fVxuXG59O1xuXG52YXIgbW9tQ29tcHV0YWJsZU9wdGlvbnMgPSB7XG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImRkZCBNL0RcIiAtPiBcIkZyaSA5LzE1XCJcblx0ZGF5T2ZNb250aEZvcm1hdDogZnVuY3Rpb24obW9tT3B0aW9ucywgZmNPcHRpb25zKSB7XG5cdFx0dmFyIGZvcm1hdCA9IG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ2wnKTsgLy8gZm9yIHRoZSBmb3JtYXQgbGlrZSBcIk0vRC9ZWVlZXCJcblxuXHRcdC8vIHN0cmlwIHRoZSB5ZWFyIG9mZiB0aGUgZWRnZSwgYXMgd2VsbCBhcyBvdGhlciBtaXNjIG5vbi13aGl0ZXNwYWNlIGNoYXJzXG5cdFx0Zm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL15ZK1teXFx3XFxzXSp8W15cXHdcXHNdKlkrJC9nLCAnJyk7XG5cblx0XHRpZiAoZmNPcHRpb25zLmlzUlRMKSB7XG5cdFx0XHRmb3JtYXQgKz0gJyBkZGQnOyAvLyBmb3IgUlRMLCBhZGQgZGF5LW9mLXdlZWsgdG8gZW5kXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Zm9ybWF0ID0gJ2RkZCAnICsgZm9ybWF0OyAvLyBmb3IgTFRSLCBhZGQgZGF5LW9mLXdlZWsgdG8gYmVnaW5uaW5nXG5cdFx0fVxuXHRcdHJldHVybiBmb3JtYXQ7XG5cdH0sXG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImg6bW1hXCIgLT4gXCI2OjAwcG1cIlxuXHRtZWRpdW1UaW1lRm9ybWF0OiBmdW5jdGlvbihtb21PcHRpb25zKSB7IC8vIGNhbid0IGJlIGNhbGxlZCBgdGltZUZvcm1hdGAgYmVjYXVzZSBjb2xsaWRlcyB3aXRoIG9wdGlvblxuXHRcdHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXG5cdFx0XHQucmVwbGFjZSgvXFxzKmEkL2ksICdhJyk7IC8vIGNvbnZlcnQgQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXG5cdH0sXG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImgoOm1tKWFcIiAtPiBcIjZwbVwiIC8gXCI2OjMwcG1cIlxuXHRzbWFsbFRpbWVGb3JtYXQ6IGZ1bmN0aW9uKG1vbU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxuXHRcdFx0LnJlcGxhY2UoJzptbScsICcoOm1tKScpXG5cdFx0XHQucmVwbGFjZSgvKFxcV21tKSQvLCAnKCQxKScpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsb2NhbGVzXG5cdFx0XHQucmVwbGFjZSgvXFxzKmEkL2ksICdhJyk7IC8vIGNvbnZlcnQgQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXG5cdH0sXG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImgoOm1tKXRcIiAtPiBcIjZwXCIgLyBcIjY6MzBwXCJcblx0ZXh0cmFTbWFsbFRpbWVGb3JtYXQ6IGZ1bmN0aW9uKG1vbU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxuXHRcdFx0LnJlcGxhY2UoJzptbScsICcoOm1tKScpXG5cdFx0XHQucmVwbGFjZSgvKFxcV21tKSQvLCAnKCQxKScpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsb2NhbGVzXG5cdFx0XHQucmVwbGFjZSgvXFxzKmEkL2ksICd0Jyk7IC8vIGNvbnZlcnQgdG8gQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlIG9uZS1sZXR0ZXIuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcblx0fSxcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaGFcIiAvIFwiSFwiIC0+IFwiNnBtXCIgLyBcIjE4XCJcblx0aG91ckZvcm1hdDogZnVuY3Rpb24obW9tT3B0aW9ucykge1xuXHRcdHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXG5cdFx0XHQucmVwbGFjZSgnOm1tJywgJycpXG5cdFx0XHQucmVwbGFjZSgvKFxcV21tKSQvLCAnJykgLy8gbGlrZSBhYm92ZSwgYnV0IGZvciBmb3JlaWduIGxvY2FsZXNcblx0XHRcdC5yZXBsYWNlKC9cXHMqYSQvaSwgJ2EnKTsgLy8gY29udmVydCBBTS9QTS9hbS9wbSB0byBsb3dlcmNhc2UuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcblx0fSxcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaDptbVwiIC0+IFwiNjozMFwiICh3aXRoIG5vIEFNL1BNKVxuXHRub01lcmlkaWVtVGltZUZvcm1hdDogZnVuY3Rpb24obW9tT3B0aW9ucykge1xuXHRcdHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXG5cdFx0XHQucmVwbGFjZSgvXFxzKmEkL2ksICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIEFNL1BNXG5cdH1cblxufTtcblxuXG4vLyBvcHRpb25zIHRoYXQgc2hvdWxkIGJlIGNvbXB1dGVkIG9mZiBsaXZlIGNhbGVuZGFyIG9wdGlvbnMgKGNvbnNpZGVycyBvdmVycmlkZSBvcHRpb25zKVxuLy8gVE9ETzogYmVzdCBwbGFjZSBmb3IgdGhpcz8gcmVsYXRlZCB0byBsb2NhbGU/XG4vLyBUT0RPOiBmbGlwcGluZyB0ZXh0IGJhc2VkIG9uIGlzUlRMIGlzIGEgYmFkIGlkZWEgYmVjYXVzZSB0aGUgQ1NTIGBkaXJlY3Rpb25gIG1pZ2h0IHdhbnQgdG8gaGFuZGxlIGl0XG52YXIgaW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyA9IHtcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBmb3IgcmVzdWx0cyBsaWtlIFwiTW8gMTZcIlxuXHRzbWFsbERheURhdGVGb3JtYXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5pc1JUTCA/XG5cdFx0XHQnRCBkZCcgOlxuXHRcdFx0J2RkIEQnO1xuXHR9LFxuXG5cdC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGZvciByZXN1bHRzIGxpa2UgXCJXayA1XCJcblx0d2Vla0Zvcm1hdDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBvcHRpb25zLmlzUlRMID9cblx0XHRcdCd3WyAnICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnXScgOlxuXHRcdFx0J1snICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnIF13Jztcblx0fSxcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBmb3IgcmVzdWx0cyBsaWtlIFwiV2s1XCJcblx0c21hbGxXZWVrRm9ybWF0OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuaXNSVEwgP1xuXHRcdFx0J3dbJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJ10nIDpcblx0XHRcdCdbJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJ113Jztcblx0fVxuXG59O1xuXG4vLyBUT0RPOiBtYWtlIHRoZXNlIGNvbXB1dGFibGUgcHJvcGVydGllcyBpbiBvcHRpb25zTW9kZWxcbmZ1bmN0aW9uIHBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyhvcHRpb25zKSB7XG5cdCQuZWFjaChpbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zLCBmdW5jdGlvbihuYW1lLCBmdW5jKSB7XG5cdFx0aWYgKG9wdGlvbnNbbmFtZV0gPT0gbnVsbCkge1xuXHRcdFx0b3B0aW9uc1tuYW1lXSA9IGZ1bmMob3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcbn1cblxuXG4vLyBSZXR1cm5zIG1vbWVudCdzIGludGVybmFsIGxvY2FsZSBkYXRhLiBJZiBkb2Vzbid0IGV4aXN0LCByZXR1cm5zIEVuZ2xpc2guXG5mdW5jdGlvbiBnZXRNb21lbnRMb2NhbGVEYXRhKGxvY2FsZUNvZGUpIHtcblx0cmV0dXJuIG1vbWVudC5sb2NhbGVEYXRhKGxvY2FsZUNvZGUpIHx8IG1vbWVudC5sb2NhbGVEYXRhKCdlbicpO1xufVxuXG5cbi8vIEluaXRpYWxpemUgRW5nbGlzaCBieSBmb3JjaW5nIGNvbXB1dGF0aW9uIG9mIG1vbWVudC1kZXJpdmVkIG9wdGlvbnMuXG4vLyBBbHNvLCBzZXRzIGl0IGFzIHRoZSBkZWZhdWx0LlxuRkMubG9jYWxlKCdlbicsIENhbGVuZGFyLmVuZ2xpc2hEZWZhdWx0cyk7XG5cbjs7XG5cbkZDLnNvdXJjZU5vcm1hbGl6ZXJzID0gW107XG5GQy5zb3VyY2VGZXRjaGVycyA9IFtdO1xuXG52YXIgYWpheERlZmF1bHRzID0ge1xuXHRkYXRhVHlwZTogJ2pzb24nLFxuXHRjYWNoZTogZmFsc2Vcbn07XG5cbnZhciBldmVudEdVSUQgPSAxO1xuXG5cbmZ1bmN0aW9uIEV2ZW50TWFuYWdlcigpIHsgLy8gYXNzdW1lZCB0byBiZSBhIGNhbGVuZGFyXG5cdHZhciB0ID0gdGhpcztcblxuXG5cdC8vIGV4cG9ydHNcblx0dC5yZXF1ZXN0RXZlbnRzID0gcmVxdWVzdEV2ZW50cztcblx0dC5yZXBvcnRFdmVudENoYW5nZSA9IHJlcG9ydEV2ZW50Q2hhbmdlO1xuXHR0LmlzRmV0Y2hOZWVkZWQgPSBpc0ZldGNoTmVlZGVkO1xuXHR0LmZldGNoRXZlbnRzID0gZmV0Y2hFdmVudHM7XG5cdHQuZmV0Y2hFdmVudFNvdXJjZXMgPSBmZXRjaEV2ZW50U291cmNlcztcblx0dC5yZWZldGNoRXZlbnRzID0gcmVmZXRjaEV2ZW50cztcblx0dC5yZWZldGNoRXZlbnRTb3VyY2VzID0gcmVmZXRjaEV2ZW50U291cmNlcztcblx0dC5nZXRFdmVudFNvdXJjZXMgPSBnZXRFdmVudFNvdXJjZXM7XG5cdHQuZ2V0RXZlbnRTb3VyY2VCeUlkID0gZ2V0RXZlbnRTb3VyY2VCeUlkO1xuXHR0LmFkZEV2ZW50U291cmNlID0gYWRkRXZlbnRTb3VyY2U7XG5cdHQucmVtb3ZlRXZlbnRTb3VyY2UgPSByZW1vdmVFdmVudFNvdXJjZTtcblx0dC5yZW1vdmVFdmVudFNvdXJjZXMgPSByZW1vdmVFdmVudFNvdXJjZXM7XG5cdHQudXBkYXRlRXZlbnQgPSB1cGRhdGVFdmVudDtcblx0dC51cGRhdGVFdmVudHMgPSB1cGRhdGVFdmVudHM7XG5cdHQucmVuZGVyRXZlbnQgPSByZW5kZXJFdmVudDtcblx0dC5yZW5kZXJFdmVudHMgPSByZW5kZXJFdmVudHM7XG5cdHQucmVtb3ZlRXZlbnRzID0gcmVtb3ZlRXZlbnRzO1xuXHR0LmNsaWVudEV2ZW50cyA9IGNsaWVudEV2ZW50cztcblx0dC5tdXRhdGVFdmVudCA9IG11dGF0ZUV2ZW50O1xuXHR0Lm5vcm1hbGl6ZUV2ZW50RGF0ZXMgPSBub3JtYWxpemVFdmVudERhdGVzO1xuXHR0Lm5vcm1hbGl6ZUV2ZW50VGltZXMgPSBub3JtYWxpemVFdmVudFRpbWVzO1xuXG5cblx0Ly8gbG9jYWxzXG5cdHZhciBzdGlja3lTb3VyY2UgPSB7IGV2ZW50czogW10gfTtcblx0dmFyIHNvdXJjZXMgPSBbIHN0aWNreVNvdXJjZSBdO1xuXHR2YXIgcmFuZ2VTdGFydCwgcmFuZ2VFbmQ7XG5cdHZhciBwZW5kaW5nU291cmNlQ250ID0gMDsgLy8gb3V0c3RhbmRpbmcgZmV0Y2ggcmVxdWVzdHMsIG1heCBvbmUgcGVyIHNvdXJjZVxuXHR2YXIgY2FjaGUgPSBbXTsgLy8gaG9sZHMgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZXhwYW5kZWRcblx0dmFyIHBydW5lZENhY2hlOyAvLyBsaWtlIGNhY2hlLCBidXQgb25seSBldmVudHMgdGhhdCBpbnRlcnNlY3Qgd2l0aCByYW5nZVN0YXJ0L3JhbmdlRW5kXG5cblxuXHQkLmVhY2goXG5cdFx0KHQub3B0KCdldmVudHMnKSA/IFsgdC5vcHQoJ2V2ZW50cycpIF0gOiBbXSkuY29uY2F0KHQub3B0KCdldmVudFNvdXJjZXMnKSB8fCBbXSksXG5cdFx0ZnVuY3Rpb24oaSwgc291cmNlSW5wdXQpIHtcblx0XHRcdHZhciBzb3VyY2UgPSBidWlsZEV2ZW50U291cmNlKHNvdXJjZUlucHV0KTtcblx0XHRcdGlmIChzb3VyY2UpIHtcblx0XHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xuXG5cblxuXHRmdW5jdGlvbiByZXF1ZXN0RXZlbnRzKHN0YXJ0LCBlbmQpIHtcblx0XHRpZiAoIXQub3B0KCdsYXp5RmV0Y2hpbmcnKSB8fCBpc0ZldGNoTmVlZGVkKHN0YXJ0LCBlbmQpKSB7XG5cdFx0XHRyZXR1cm4gZmV0Y2hFdmVudHMoc3RhcnQsIGVuZCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShwcnVuZWRDYWNoZSk7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiByZXBvcnRFdmVudENoYW5nZSgpIHtcblx0XHRwcnVuZWRDYWNoZSA9IGZpbHRlckV2ZW50c1dpdGhpblJhbmdlKGNhY2hlKTtcblx0XHR0LnRyaWdnZXIoJ2V2ZW50c1Jlc2V0JywgcHJ1bmVkQ2FjaGUpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBmaWx0ZXJFdmVudHNXaXRoaW5SYW5nZShldmVudHMpIHtcblx0XHR2YXIgZmlsdGVyZWRFdmVudHMgPSBbXTtcblx0XHR2YXIgaSwgZXZlbnQ7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRldmVudCA9IGV2ZW50c1tpXTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRldmVudC5zdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpIDwgcmFuZ2VFbmQgJiZcblx0XHRcdFx0dC5nZXRFdmVudEVuZChldmVudCkuc3RyaXBab25lKCkgPiByYW5nZVN0YXJ0XG5cdFx0XHQpIHtcblx0XHRcdFx0ZmlsdGVyZWRFdmVudHMucHVzaChldmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZpbHRlcmVkRXZlbnRzO1xuXHR9XG5cblxuXHR0LmdldEV2ZW50Q2FjaGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gY2FjaGU7XG5cdH07XG5cblxuXG5cdC8qIEZldGNoaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIHN0YXJ0IGFuZCBlbmQgYXJlIGFzc3VtZWQgdG8gYmUgdW56b25lZFxuXHRmdW5jdGlvbiBpc0ZldGNoTmVlZGVkKHN0YXJ0LCBlbmQpIHtcblx0XHRyZXR1cm4gIXJhbmdlU3RhcnQgfHwgLy8gbm90aGluZyBoYXMgYmVlbiBmZXRjaGVkIHlldD9cblx0XHRcdHN0YXJ0IDwgcmFuZ2VTdGFydCB8fCBlbmQgPiByYW5nZUVuZDsgLy8gaXMgcGFydCBvZiB0aGUgbmV3IHJhbmdlIG91dHNpZGUgb2YgdGhlIG9sZCByYW5nZT9cblx0fVxuXG5cblx0ZnVuY3Rpb24gZmV0Y2hFdmVudHMoc3RhcnQsIGVuZCkge1xuXHRcdHJhbmdlU3RhcnQgPSBzdGFydDtcblx0XHRyYW5nZUVuZCA9IGVuZDtcblx0XHRyZXR1cm4gcmVmZXRjaEV2ZW50cygpO1xuXHR9XG5cblxuXHQvLyBwb29ybHkgbmFtZWQuIGZldGNoZXMgYWxsIHNvdXJjZXMgd2l0aCBjdXJyZW50IGByYW5nZVN0YXJ0YCBhbmQgYHJhbmdlRW5kYC5cblx0ZnVuY3Rpb24gcmVmZXRjaEV2ZW50cygpIHtcblx0XHRyZXR1cm4gZmV0Y2hFdmVudFNvdXJjZXMoc291cmNlcywgJ3Jlc2V0Jyk7XG5cdH1cblxuXG5cdC8vIHBvb3JseSBuYW1lZC4gZmV0Y2hlcyBhIHN1YnNldCBvZiBldmVudCBzb3VyY2VzLlxuXHRmdW5jdGlvbiByZWZldGNoRXZlbnRTb3VyY2VzKG1hdGNoSW5wdXRzKSB7XG5cdFx0cmV0dXJuIGZldGNoRXZlbnRTb3VyY2VzKGdldEV2ZW50U291cmNlc0J5TWF0Y2hBcnJheShtYXRjaElucHV0cykpO1xuXHR9XG5cblxuXHQvLyBleHBlY3RzIGFuIGFycmF5IG9mIGV2ZW50IHNvdXJjZSBvYmplY3RzICh0aGUgb3JpZ2luYWxzLCBub3QgY29waWVzKVxuXHQvLyBgc3BlY2lhbEZldGNoVHlwZWAgaXMgYW4gb3B0aW1pemF0aW9uIHBhcmFtZXRlciB0aGF0IGFmZmVjdHMgcHVyZ2luZyBvZiB0aGUgZXZlbnQgY2FjaGUuXG5cdGZ1bmN0aW9uIGZldGNoRXZlbnRTb3VyY2VzKHNwZWNpZmljU291cmNlcywgc3BlY2lhbEZldGNoVHlwZSkge1xuXHRcdHZhciBpLCBzb3VyY2U7XG5cblx0XHRpZiAoc3BlY2lhbEZldGNoVHlwZSA9PT0gJ3Jlc2V0Jykge1xuXHRcdFx0Y2FjaGUgPSBbXTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoc3BlY2lhbEZldGNoVHlwZSAhPT0gJ2FkZCcpIHtcblx0XHRcdGNhY2hlID0gZXhjbHVkZUV2ZW50c0J5U291cmNlcyhjYWNoZSwgc3BlY2lmaWNTb3VyY2VzKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BlY2lmaWNTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzb3VyY2UgPSBzcGVjaWZpY1NvdXJjZXNbaV07XG5cblx0XHRcdC8vIGFscmVhZHktcGVuZGluZyBzb3VyY2VzIGhhdmUgYWxyZWFkeSBiZWVuIGFjY291bnRlZCBmb3IgaW4gcGVuZGluZ1NvdXJjZUNudFxuXHRcdFx0aWYgKHNvdXJjZS5fc3RhdHVzICE9PSAncGVuZGluZycpIHtcblx0XHRcdFx0cGVuZGluZ1NvdXJjZUNudCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRzb3VyY2UuX2ZldGNoSWQgPSAoc291cmNlLl9mZXRjaElkIHx8IDApICsgMTtcblx0XHRcdHNvdXJjZS5fc3RhdHVzID0gJ3BlbmRpbmcnO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzcGVjaWZpY1NvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNvdXJjZSA9IHNwZWNpZmljU291cmNlc1tpXTtcblx0XHRcdHRyeUZldGNoRXZlbnRTb3VyY2Uoc291cmNlLCBzb3VyY2UuX2ZldGNoSWQpO1xuXHRcdH1cblxuXHRcdGlmIChwZW5kaW5nU291cmNlQ250KSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5jb25zdHJ1Y3QoZnVuY3Rpb24ocmVzb2x2ZSkge1xuXHRcdFx0XHR0Lm9uZSgnZXZlbnRzUmVjZWl2ZWQnLCByZXNvbHZlKTsgLy8gd2lsbCBzZW5kIHBydW5lZENhY2hlXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZWxzZSB7IC8vIGV4ZWN1dGVkIGFsbCBzeW5jaHJvbm91c2x5LCBvciBubyBzb3VyY2VzIGF0IGFsbFxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShwcnVuZWRDYWNoZSk7XG5cdFx0fVxuXHR9XG5cblxuXHQvLyBmZXRjaGVzIGFuIGV2ZW50IHNvdXJjZSBhbmQgcHJvY2Vzc2VzIGl0cyByZXN1bHQgT05MWSBpZiBpdCBpcyBzdGlsbCB0aGUgY3VycmVudCBmZXRjaC5cblx0Ly8gY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBpbmNyZW1lbnRpbmcgcGVuZGluZ1NvdXJjZUNudCBmaXJzdC5cblx0ZnVuY3Rpb24gdHJ5RmV0Y2hFdmVudFNvdXJjZShzb3VyY2UsIGZldGNoSWQpIHtcblx0XHRfZmV0Y2hFdmVudFNvdXJjZShzb3VyY2UsIGZ1bmN0aW9uKGV2ZW50SW5wdXRzKSB7XG5cdFx0XHR2YXIgaXNBcnJheVNvdXJjZSA9ICQuaXNBcnJheShzb3VyY2UuZXZlbnRzKTtcblx0XHRcdHZhciBpLCBldmVudElucHV0O1xuXHRcdFx0dmFyIGFic3RyYWN0RXZlbnQ7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0Ly8gaXMgdGhpcyB0aGUgc291cmNlJ3MgbW9zdCByZWNlbnQgZmV0Y2g/XG5cdFx0XHRcdC8vIGlmIG5vdCwgcmVseSBvbiBhbiB1cGNvbWluZyBmZXRjaCBvZiB0aGlzIHNvdXJjZSB0byBkZWNyZW1lbnQgcGVuZGluZ1NvdXJjZUNudFxuXHRcdFx0XHRmZXRjaElkID09PSBzb3VyY2UuX2ZldGNoSWQgJiZcblx0XHRcdFx0Ly8gZXZlbnQgc291cmNlIG5vIGxvbmdlciB2YWxpZD9cblx0XHRcdFx0c291cmNlLl9zdGF0dXMgIT09ICdyZWplY3RlZCdcblx0XHRcdCkge1xuXHRcdFx0XHRzb3VyY2UuX3N0YXR1cyA9ICdyZXNvbHZlZCc7XG5cblx0XHRcdFx0aWYgKGV2ZW50SW5wdXRzKSB7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGV2ZW50SW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRldmVudElucHV0ID0gZXZlbnRJbnB1dHNbaV07XG5cblx0XHRcdFx0XHRcdGlmIChpc0FycmF5U291cmNlKSB7IC8vIGFycmF5IHNvdXJjZXMgaGF2ZSBhbHJlYWR5IGJlZW4gY29udmVydCB0byBFdmVudCBPYmplY3RzXG5cdFx0XHRcdFx0XHRcdGFic3RyYWN0RXZlbnQgPSBldmVudElucHV0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGFic3RyYWN0RXZlbnQgPSBidWlsZEV2ZW50RnJvbUlucHV0KGV2ZW50SW5wdXQsIHNvdXJjZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChhYnN0cmFjdEV2ZW50KSB7IC8vIG5vdCBmYWxzZSAoYW4gaW52YWxpZCBldmVudClcblx0XHRcdFx0XHRcdFx0Y2FjaGUucHVzaC5hcHBseSggLy8gYXBwZW5kXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUsXG5cdFx0XHRcdFx0XHRcdFx0ZXhwYW5kRXZlbnQoYWJzdHJhY3RFdmVudCkgLy8gYWRkIGluZGl2aWR1YWwgZXhwYW5kZWQgZXZlbnRzIHRvIHRoZSBjYWNoZVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlY3JlbWVudFBlbmRpbmdTb3VyY2VDbnQoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gcmVqZWN0RXZlbnRTb3VyY2Uoc291cmNlKSB7XG5cdFx0dmFyIHdhc1BlbmRpbmcgPSBzb3VyY2UuX3N0YXR1cyA9PT0gJ3BlbmRpbmcnO1xuXG5cdFx0c291cmNlLl9zdGF0dXMgPSAncmVqZWN0ZWQnO1xuXG5cdFx0aWYgKHdhc1BlbmRpbmcpIHtcblx0XHRcdGRlY3JlbWVudFBlbmRpbmdTb3VyY2VDbnQoKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGRlY3JlbWVudFBlbmRpbmdTb3VyY2VDbnQoKSB7XG5cdFx0cGVuZGluZ1NvdXJjZUNudC0tO1xuXHRcdGlmICghcGVuZGluZ1NvdXJjZUNudCkge1xuXHRcdFx0cmVwb3J0RXZlbnRDaGFuZ2UoY2FjaGUpOyAvLyB1cGRhdGVzIHBydW5lZENhY2hlXG5cdFx0XHR0LnRyaWdnZXIoJ2V2ZW50c1JlY2VpdmVkJywgcHJ1bmVkQ2FjaGUpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gX2ZldGNoRXZlbnRTb3VyY2Uoc291cmNlLCBjYWxsYmFjaykge1xuXHRcdHZhciBpO1xuXHRcdHZhciBmZXRjaGVycyA9IEZDLnNvdXJjZUZldGNoZXJzO1xuXHRcdHZhciByZXM7XG5cblx0XHRmb3IgKGk9MDsgaTxmZXRjaGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0cmVzID0gZmV0Y2hlcnNbaV0uY2FsbChcblx0XHRcdFx0dCwgLy8gdGhpcywgdGhlIENhbGVuZGFyIG9iamVjdFxuXHRcdFx0XHRzb3VyY2UsXG5cdFx0XHRcdHJhbmdlU3RhcnQuY2xvbmUoKSxcblx0XHRcdFx0cmFuZ2VFbmQuY2xvbmUoKSxcblx0XHRcdFx0dC5vcHQoJ3RpbWV6b25lJyksXG5cdFx0XHRcdGNhbGxiYWNrXG5cdFx0XHQpO1xuXG5cdFx0XHRpZiAocmVzID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIHRoZSBmZXRjaGVyIGlzIGluIGNoYXJnZS4gbWFkZSBpdHMgb3duIGFzeW5jIHJlcXVlc3Rcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIHJlcyA9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHQvLyB0aGUgZmV0Y2hlciByZXR1cm5lZCBhIG5ldyBzb3VyY2UuIHByb2Nlc3MgaXRcblx0XHRcdFx0X2ZldGNoRXZlbnRTb3VyY2UocmVzLCBjYWxsYmFjayk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgZXZlbnRzID0gc291cmNlLmV2ZW50cztcblx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKGV2ZW50cykpIHtcblx0XHRcdFx0dC5wdXNoTG9hZGluZygpO1xuXHRcdFx0XHRldmVudHMuY2FsbChcblx0XHRcdFx0XHR0LCAvLyB0aGlzLCB0aGUgQ2FsZW5kYXIgb2JqZWN0XG5cdFx0XHRcdFx0cmFuZ2VTdGFydC5jbG9uZSgpLFxuXHRcdFx0XHRcdHJhbmdlRW5kLmNsb25lKCksXG5cdFx0XHRcdFx0dC5vcHQoJ3RpbWV6b25lJyksXG5cdFx0XHRcdFx0ZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayhldmVudHMpO1xuXHRcdFx0XHRcdFx0dC5wb3BMb2FkaW5nKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoJC5pc0FycmF5KGV2ZW50cykpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fVxuXHRcdH1lbHNle1xuXHRcdFx0dmFyIHVybCA9IHNvdXJjZS51cmw7XG5cdFx0XHRpZiAodXJsKSB7XG5cdFx0XHRcdHZhciBzdWNjZXNzID0gc291cmNlLnN1Y2Nlc3M7XG5cdFx0XHRcdHZhciBlcnJvciA9IHNvdXJjZS5lcnJvcjtcblx0XHRcdFx0dmFyIGNvbXBsZXRlID0gc291cmNlLmNvbXBsZXRlO1xuXG5cdFx0XHRcdC8vIHJldHJpZXZlIGFueSBvdXRib3VuZCBHRVQvUE9TVCAkLmFqYXggZGF0YSBmcm9tIHRoZSBvcHRpb25zXG5cdFx0XHRcdHZhciBjdXN0b21EYXRhO1xuXHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHNvdXJjZS5kYXRhKSkge1xuXHRcdFx0XHRcdC8vIHN1cHBsaWVkIGFzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5L3ZhbHVlIG9iamVjdFxuXHRcdFx0XHRcdGN1c3RvbURhdGEgPSBzb3VyY2UuZGF0YSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIHN1cHBsaWVkIGFzIGEgc3RyYWlnaHQga2V5L3ZhbHVlIG9iamVjdFxuXHRcdFx0XHRcdGN1c3RvbURhdGEgPSBzb3VyY2UuZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHVzZSBhIGNvcHkgb2YgdGhlIGN1c3RvbSBkYXRhIHNvIHdlIGNhbiBtb2RpZnkgdGhlIHBhcmFtZXRlcnNcblx0XHRcdFx0Ly8gYW5kIG5vdCBhZmZlY3QgdGhlIHBhc3NlZC1pbiBvYmplY3QuXG5cdFx0XHRcdHZhciBkYXRhID0gJC5leHRlbmQoe30sIGN1c3RvbURhdGEgfHwge30pO1xuXG5cdFx0XHRcdHZhciBzdGFydFBhcmFtID0gZmlyc3REZWZpbmVkKHNvdXJjZS5zdGFydFBhcmFtLCB0Lm9wdCgnc3RhcnRQYXJhbScpKTtcblx0XHRcdFx0dmFyIGVuZFBhcmFtID0gZmlyc3REZWZpbmVkKHNvdXJjZS5lbmRQYXJhbSwgdC5vcHQoJ2VuZFBhcmFtJykpO1xuXHRcdFx0XHR2YXIgdGltZXpvbmVQYXJhbSA9IGZpcnN0RGVmaW5lZChzb3VyY2UudGltZXpvbmVQYXJhbSwgdC5vcHQoJ3RpbWV6b25lUGFyYW0nKSk7XG5cblx0XHRcdFx0aWYgKHN0YXJ0UGFyYW0pIHtcblx0XHRcdFx0XHRkYXRhW3N0YXJ0UGFyYW1dID0gcmFuZ2VTdGFydC5mb3JtYXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZW5kUGFyYW0pIHtcblx0XHRcdFx0XHRkYXRhW2VuZFBhcmFtXSA9IHJhbmdlRW5kLmZvcm1hdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0Lm9wdCgndGltZXpvbmUnKSAmJiB0Lm9wdCgndGltZXpvbmUnKSAhPSAnbG9jYWwnKSB7XG5cdFx0XHRcdFx0ZGF0YVt0aW1lem9uZVBhcmFtXSA9IHQub3B0KCd0aW1lem9uZScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dC5wdXNoTG9hZGluZygpO1xuXHRcdFx0XHQkLmFqYXgoJC5leHRlbmQoe30sIGFqYXhEZWZhdWx0cywgc291cmNlLCB7XG5cdFx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbihldmVudHMpIHtcblx0XHRcdFx0XHRcdGV2ZW50cyA9IGV2ZW50cyB8fCBbXTtcblx0XHRcdFx0XHRcdHZhciByZXMgPSBhcHBseUFsbChzdWNjZXNzLCB0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0aWYgKCQuaXNBcnJheShyZXMpKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50cyA9IHJlcztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhbGxiYWNrKGV2ZW50cyk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRlcnJvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRhcHBseUFsbChlcnJvciwgdGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRhcHBseUFsbChjb21wbGV0ZSwgdGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdHQucG9wTG9hZGluZygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXG5cdC8qIFNvdXJjZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0ZnVuY3Rpb24gYWRkRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQpIHtcblx0XHR2YXIgc291cmNlID0gYnVpbGRFdmVudFNvdXJjZShzb3VyY2VJbnB1dCk7XG5cdFx0aWYgKHNvdXJjZSkge1xuXHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZSk7XG5cdFx0XHRmZXRjaEV2ZW50U291cmNlcyhbIHNvdXJjZSBdLCAnYWRkJyk7IC8vIHdpbGwgZXZlbnR1YWxseSBjYWxsIHJlcG9ydEV2ZW50Q2hhbmdlXG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBidWlsZEV2ZW50U291cmNlKHNvdXJjZUlucHV0KSB7IC8vIHdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiBpbnZhbGlkIHNvdXJjZVxuXHRcdHZhciBub3JtYWxpemVycyA9IEZDLnNvdXJjZU5vcm1hbGl6ZXJzO1xuXHRcdHZhciBzb3VyY2U7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoJC5pc0Z1bmN0aW9uKHNvdXJjZUlucHV0KSB8fCAkLmlzQXJyYXkoc291cmNlSW5wdXQpKSB7XG5cdFx0XHRzb3VyY2UgPSB7IGV2ZW50czogc291cmNlSW5wdXQgfTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIHNvdXJjZUlucHV0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0c291cmNlID0geyB1cmw6IHNvdXJjZUlucHV0IH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VJbnB1dCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHNvdXJjZSA9ICQuZXh0ZW5kKHt9LCBzb3VyY2VJbnB1dCk7IC8vIHNoYWxsb3cgY29weVxuXHRcdH1cblxuXHRcdGlmIChzb3VyY2UpIHtcblxuXHRcdFx0Ly8gVE9ETzogcmVwZWF0IGNvZGUsIHNhbWUgY29kZSBmb3IgZXZlbnQgY2xhc3NOYW1lc1xuXHRcdFx0aWYgKHNvdXJjZS5jbGFzc05hbWUpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBzb3VyY2UuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHNvdXJjZS5jbGFzc05hbWUgPSBzb3VyY2UuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gb3RoZXJ3aXNlLCBhc3N1bWVkIHRvIGJlIGFuIGFycmF5XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c291cmNlLmNsYXNzTmFtZSA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBmb3IgYXJyYXkgc291cmNlcywgd2UgY29udmVydCB0byBzdGFuZGFyZCBFdmVudCBPYmplY3RzIHVwIGZyb250XG5cdFx0XHRpZiAoJC5pc0FycmF5KHNvdXJjZS5ldmVudHMpKSB7XG5cdFx0XHRcdHNvdXJjZS5vcmlnQXJyYXkgPSBzb3VyY2UuZXZlbnRzOyAvLyBmb3IgcmVtb3ZlRXZlbnRTb3VyY2Vcblx0XHRcdFx0c291cmNlLmV2ZW50cyA9ICQubWFwKHNvdXJjZS5ldmVudHMsIGZ1bmN0aW9uKGV2ZW50SW5wdXQpIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVpbGRFdmVudEZyb21JbnB1dChldmVudElucHV0LCBzb3VyY2UpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpPTA7IGk8bm9ybWFsaXplcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bm9ybWFsaXplcnNbaV0uY2FsbCh0LCBzb3VyY2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc291cmNlO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gcmVtb3ZlRXZlbnRTb3VyY2UobWF0Y2hJbnB1dCkge1xuXHRcdHJlbW92ZVNwZWNpZmljRXZlbnRTb3VyY2VzKFxuXHRcdFx0Z2V0RXZlbnRTb3VyY2VzQnlNYXRjaChtYXRjaElucHV0KVxuXHRcdCk7XG5cdH1cblxuXG5cdC8vIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgcmVtb3ZlcyBhbGwuXG5cdGZ1bmN0aW9uIHJlbW92ZUV2ZW50U291cmNlcyhtYXRjaElucHV0cykge1xuXHRcdGlmIChtYXRjaElucHV0cyA9PSBudWxsKSB7XG5cdFx0XHRyZW1vdmVTcGVjaWZpY0V2ZW50U291cmNlcyhzb3VyY2VzLCB0cnVlKTsgLy8gaXNBbGw9dHJ1ZVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJlbW92ZVNwZWNpZmljRXZlbnRTb3VyY2VzKFxuXHRcdFx0XHRnZXRFdmVudFNvdXJjZXNCeU1hdGNoQXJyYXkobWF0Y2hJbnB1dHMpXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gcmVtb3ZlU3BlY2lmaWNFdmVudFNvdXJjZXModGFyZ2V0U291cmNlcywgaXNBbGwpIHtcblx0XHR2YXIgaTtcblxuXHRcdC8vIGNhbmNlbCBwZW5kaW5nIHJlcXVlc3RzXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldFNvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHJlamVjdEV2ZW50U291cmNlKHRhcmdldFNvdXJjZXNbaV0pO1xuXHRcdH1cblxuXHRcdGlmIChpc0FsbCkgeyAvLyBhbiBvcHRpbWl6YXRpb25cblx0XHRcdHNvdXJjZXMgPSBbXTtcblx0XHRcdGNhY2hlID0gW107XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gcmVtb3ZlIGZyb20gcGVyc2lzdGVkIHNvdXJjZSBsaXN0XG5cdFx0XHRzb3VyY2VzID0gJC5ncmVwKHNvdXJjZXMsIGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0U291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChzb3VyY2UgPT09IHRhcmdldFNvdXJjZXNbaV0pIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gZXhjbHVkZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gaW5jbHVkZVxuXHRcdFx0fSk7XG5cblx0XHRcdGNhY2hlID0gZXhjbHVkZUV2ZW50c0J5U291cmNlcyhjYWNoZSwgdGFyZ2V0U291cmNlcyk7XG5cdFx0fVxuXG5cdFx0cmVwb3J0RXZlbnRDaGFuZ2UoKTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2VzKCkge1xuXHRcdHJldHVybiBzb3VyY2VzLnNsaWNlKDEpOyAvLyByZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIHNvdXJjZXMgd2l0aCBzdGlja3lTb3VyY2UgcmVtb3ZlZFxuXHR9XG5cblxuXHRmdW5jdGlvbiBnZXRFdmVudFNvdXJjZUJ5SWQoaWQpIHtcblx0XHRyZXR1cm4gJC5ncmVwKHNvdXJjZXMsIGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuIHNvdXJjZS5pZCAmJiBzb3VyY2UuaWQgPT09IGlkO1xuXHRcdH0pWzBdO1xuXHR9XG5cblxuXHQvLyBsaWtlIGdldEV2ZW50U291cmNlc0J5TWF0Y2gsIGJ1dCBhY2NlcHRzIG11bHRwbGUgbWF0Y2ggY3JpdGVyaWEgKGxpa2UgbXVsdGlwbGUgSURzKVxuXHRmdW5jdGlvbiBnZXRFdmVudFNvdXJjZXNCeU1hdGNoQXJyYXkobWF0Y2hJbnB1dHMpIHtcblxuXHRcdC8vIGNvZXJjZSBpbnRvIGFuIGFycmF5XG5cdFx0aWYgKCFtYXRjaElucHV0cykge1xuXHRcdFx0bWF0Y2hJbnB1dHMgPSBbXTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoISQuaXNBcnJheShtYXRjaElucHV0cykpIHtcblx0XHRcdG1hdGNoSW5wdXRzID0gWyBtYXRjaElucHV0cyBdO1xuXHRcdH1cblxuXHRcdHZhciBtYXRjaGluZ1NvdXJjZXMgPSBbXTtcblx0XHR2YXIgaTtcblxuXHRcdC8vIHJlc29sdmUgcmF3IGlucHV0cyB0byByZWFsIGV2ZW50IHNvdXJjZSBvYmplY3RzXG5cdFx0Zm9yIChpID0gMDsgaSA8IG1hdGNoSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRtYXRjaGluZ1NvdXJjZXMucHVzaC5hcHBseSggLy8gYXBwZW5kXG5cdFx0XHRcdG1hdGNoaW5nU291cmNlcyxcblx0XHRcdFx0Z2V0RXZlbnRTb3VyY2VzQnlNYXRjaChtYXRjaElucHV0c1tpXSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoaW5nU291cmNlcztcblx0fVxuXG5cblx0Ly8gbWF0Y2hJbnB1dCBjYW4gZWl0aGVyIGJ5IGEgcmVhbCBldmVudCBzb3VyY2Ugb2JqZWN0LCBhbiBJRCwgb3IgdGhlIGZ1bmN0aW9uL1VSTCBmb3IgdGhlIHNvdXJjZS5cblx0Ly8gcmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGluZyBzb3VyY2Ugb2JqZWN0cy5cblx0ZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2VzQnlNYXRjaChtYXRjaElucHV0KSB7XG5cdFx0dmFyIGksIHNvdXJjZTtcblxuXHRcdC8vIGdpdmVuIGFuIHByb3BlciBldmVudCBzb3VyY2Ugb2JqZWN0XG5cdFx0Zm9yIChpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbaV07XG5cdFx0XHRpZiAoc291cmNlID09PSBtYXRjaElucHV0KSB7XG5cdFx0XHRcdHJldHVybiBbIHNvdXJjZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFuIElEIG1hdGNoXG5cdFx0c291cmNlID0gZ2V0RXZlbnRTb3VyY2VCeUlkKG1hdGNoSW5wdXQpO1xuXHRcdGlmIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiBbIHNvdXJjZSBdO1xuXHRcdH1cblxuXHRcdHJldHVybiAkLmdyZXAoc291cmNlcywgZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gaXNTb3VyY2VzRXF1aXZhbGVudChtYXRjaElucHV0LCBzb3VyY2UpO1xuXHRcdH0pO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBpc1NvdXJjZXNFcXVpdmFsZW50KHNvdXJjZTEsIHNvdXJjZTIpIHtcblx0XHRyZXR1cm4gc291cmNlMSAmJiBzb3VyY2UyICYmIGdldFNvdXJjZVByaW1pdGl2ZShzb3VyY2UxKSA9PSBnZXRTb3VyY2VQcmltaXRpdmUoc291cmNlMik7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGdldFNvdXJjZVByaW1pdGl2ZShzb3VyY2UpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0KHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSA/IC8vIGEgbm9ybWFsaXplZCBldmVudCBzb3VyY2U/XG5cdFx0XHRcdChzb3VyY2Uub3JpZ0FycmF5IHx8IHNvdXJjZS5nb29nbGVDYWxlbmRhcklkIHx8IHNvdXJjZS51cmwgfHwgc291cmNlLmV2ZW50cykgOiAvLyBnZXQgdGhlIHByaW1pdGl2ZVxuXHRcdFx0XHRudWxsXG5cdFx0KSB8fFxuXHRcdHNvdXJjZTsgLy8gdGhlIGdpdmVuIGFyZ3VtZW50ICppcyogdGhlIHByaW1pdGl2ZVxuXHR9XG5cblxuXHQvLyB1dGlsXG5cdC8vIHJldHVybnMgYSBmaWx0ZXJlZCBhcnJheSB3aXRob3V0IGV2ZW50cyB0aGF0IGFyZSBwYXJ0IG9mIGFueSBvZiB0aGUgZ2l2ZW4gc291cmNlc1xuXHRmdW5jdGlvbiBleGNsdWRlRXZlbnRzQnlTb3VyY2VzKHNwZWNpZmljRXZlbnRzLCBzcGVjaWZpY1NvdXJjZXMpIHtcblx0XHRyZXR1cm4gJC5ncmVwKHNwZWNpZmljRXZlbnRzLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpY1NvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGV2ZW50LnNvdXJjZSA9PT0gc3BlY2lmaWNTb3VyY2VzW2ldKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBleGNsdWRlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlOyAvLyBrZWVwXG5cdFx0fSk7XG5cdH1cblxuXG5cblx0LyogTWFuaXB1bGF0aW9uXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIE9ubHkgZXZlciBjYWxsZWQgZnJvbSB0aGUgZXh0ZXJuYWxseS1mYWNpbmcgQVBJXG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KGV2ZW50KSB7XG5cdFx0dXBkYXRlRXZlbnRzKFsgZXZlbnQgXSk7XG5cdH1cblxuXG5cdC8vIE9ubHkgZXZlciBjYWxsZWQgZnJvbSB0aGUgZXh0ZXJuYWxseS1mYWNpbmcgQVBJXG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50cyhldmVudHMpIHtcblx0XHR2YXIgaSwgZXZlbnQ7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRldmVudCA9IGV2ZW50c1tpXTtcblxuXHRcdFx0Ly8gbWFzc2FnZSBzdGFydC9lbmQgdmFsdWVzLCBldmVuIGlmIGRhdGUgc3RyaW5nIHZhbHVlc1xuXHRcdFx0ZXZlbnQuc3RhcnQgPSB0Lm1vbWVudChldmVudC5zdGFydCk7XG5cdFx0XHRpZiAoZXZlbnQuZW5kKSB7XG5cdFx0XHRcdGV2ZW50LmVuZCA9IHQubW9tZW50KGV2ZW50LmVuZCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZXZlbnQuZW5kID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0bXV0YXRlRXZlbnQoZXZlbnQsIGdldE1pc2NFdmVudFByb3BzKGV2ZW50KSk7IC8vIHdpbGwgaGFuZGxlIHN0YXJ0L2VuZC9hbGxEYXkgbm9ybWFsaXphdGlvblxuXHRcdH1cblxuXHRcdHJlcG9ydEV2ZW50Q2hhbmdlKCk7IC8vIHJlcG9ydHMgZXZlbnQgbW9kaWZpY2F0aW9ucyAoc28gd2UgY2FuIHJlZHJhdylcblx0fVxuXG5cblx0Ly8gUmV0dXJucyBhIGhhc2ggb2YgbWlzYyBldmVudCBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIGNvcGllZCBvdmVyIHRvIHJlbGF0ZWQgZXZlbnRzLlxuXHRmdW5jdGlvbiBnZXRNaXNjRXZlbnRQcm9wcyhldmVudCkge1xuXHRcdHZhciBwcm9wcyA9IHt9O1xuXG5cdFx0JC5lYWNoKGV2ZW50LCBmdW5jdGlvbihuYW1lLCB2YWwpIHtcblx0XHRcdGlmIChpc01pc2NFdmVudFByb3BOYW1lKG5hbWUpKSB7XG5cdFx0XHRcdGlmICh2YWwgIT09IHVuZGVmaW5lZCAmJiBpc0F0b21pYyh2YWwpKSB7IC8vIGEgZGVmaW5lZCBub24tb2JqZWN0XG5cdFx0XHRcdFx0cHJvcHNbbmFtZV0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBwcm9wcztcblx0fVxuXG5cdC8vIG5vbi1kYXRlLXJlbGF0ZWQsIG5vbi1pZC1yZWxhdGVkLCBub24tc2VjcmV0XG5cdGZ1bmN0aW9uIGlzTWlzY0V2ZW50UHJvcE5hbWUobmFtZSkge1xuXHRcdHJldHVybiAhL15ffF4oaWR8YWxsRGF5fHN0YXJ0fGVuZCkkLy50ZXN0KG5hbWUpO1xuXHR9XG5cblxuXHQvLyByZXR1cm5zIHRoZSBleHBhbmRlZCBldmVudHMgdGhhdCB3ZXJlIGNyZWF0ZWRcblx0ZnVuY3Rpb24gcmVuZGVyRXZlbnQoZXZlbnRJbnB1dCwgc3RpY2spIHtcblx0XHRyZXR1cm4gcmVuZGVyRXZlbnRzKFsgZXZlbnRJbnB1dCBdLCBzdGljayk7XG5cdH1cblxuXG5cdC8vIHJldHVybnMgdGhlIGV4cGFuZGVkIGV2ZW50cyB0aGF0IHdlcmUgY3JlYXRlZFxuXHRmdW5jdGlvbiByZW5kZXJFdmVudHMoZXZlbnRJbnB1dHMsIHN0aWNrKSB7XG5cdFx0dmFyIHJlbmRlcmVkRXZlbnRzID0gW107XG5cdFx0dmFyIHJlbmRlcmFibGVFdmVudHM7XG5cdFx0dmFyIGFic3RyYWN0RXZlbnQ7XG5cdFx0dmFyIGksIGosIGV2ZW50O1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGV2ZW50SW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhYnN0cmFjdEV2ZW50ID0gYnVpbGRFdmVudEZyb21JbnB1dChldmVudElucHV0c1tpXSk7XG5cblx0XHRcdGlmIChhYnN0cmFjdEV2ZW50KSB7IC8vIG5vdCBmYWxzZSAoYSB2YWxpZCBpbnB1dClcblx0XHRcdFx0cmVuZGVyYWJsZUV2ZW50cyA9IGV4cGFuZEV2ZW50KGFic3RyYWN0RXZlbnQpO1xuXG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCByZW5kZXJhYmxlRXZlbnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0ZXZlbnQgPSByZW5kZXJhYmxlRXZlbnRzW2pdO1xuXG5cdFx0XHRcdFx0aWYgKCFldmVudC5zb3VyY2UpIHtcblx0XHRcdFx0XHRcdGlmIChzdGljaykge1xuXHRcdFx0XHRcdFx0XHRzdGlja3lTb3VyY2UuZXZlbnRzLnB1c2goZXZlbnQpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zb3VyY2UgPSBzdGlja3lTb3VyY2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYWNoZS5wdXNoKGV2ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZW5kZXJlZEV2ZW50cyA9IHJlbmRlcmVkRXZlbnRzLmNvbmNhdChyZW5kZXJhYmxlRXZlbnRzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocmVuZGVyZWRFdmVudHMubGVuZ3RoKSB7IC8vIGFueSBuZXcgZXZlbnRzIHJlbmRlcmVkP1xuXHRcdFx0cmVwb3J0RXZlbnRDaGFuZ2UoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVuZGVyZWRFdmVudHM7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHJlbW92ZUV2ZW50cyhmaWx0ZXIpIHtcblx0XHR2YXIgZXZlbnRJRDtcblx0XHR2YXIgaTtcblxuXHRcdGlmIChmaWx0ZXIgPT0gbnVsbCkgeyAvLyBudWxsIG9yIHVuZGVmaW5lZC4gcmVtb3ZlIGFsbCBldmVudHNcblx0XHRcdGZpbHRlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTsgLy8gd2lsbCBhbHdheXMgbWF0Y2hcblx0XHR9XG5cdFx0ZWxzZSBpZiAoISQuaXNGdW5jdGlvbihmaWx0ZXIpKSB7IC8vIGFuIGV2ZW50IElEXG5cdFx0XHRldmVudElEID0gZmlsdGVyICsgJyc7XG5cdFx0XHRmaWx0ZXIgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQuX2lkID09IGV2ZW50SUQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFB1cmdlIGV2ZW50KHMpIGZyb20gb3VyIGxvY2FsIGNhY2hlXG5cdFx0Y2FjaGUgPSAkLmdyZXAoY2FjaGUsIGZpbHRlciwgdHJ1ZSk7IC8vIGludmVyc2U9dHJ1ZVxuXG5cdFx0Ly8gUmVtb3ZlIGV2ZW50cyBmcm9tIGFycmF5IHNvdXJjZXMuXG5cdFx0Ly8gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZXkgaGF2ZSBiZWVuIGNvbnZlcnRlZCB0byBvZmZpY2lhbCBFdmVudCBPYmplY3RzIHVwIGZyb250LlxuXHRcdC8vIChhbmQgYXMgYSByZXN1bHQsIGV2ZW50Ll9pZCBoYXMgYmVlbiBjYWxjdWxhdGVkKS5cblx0XHRmb3IgKGk9MDsgaTxzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoJC5pc0FycmF5KHNvdXJjZXNbaV0uZXZlbnRzKSkge1xuXHRcdFx0XHRzb3VyY2VzW2ldLmV2ZW50cyA9ICQuZ3JlcChzb3VyY2VzW2ldLmV2ZW50cywgZmlsdGVyLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXBvcnRFdmVudENoYW5nZSgpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBjbGllbnRFdmVudHMoZmlsdGVyKSB7XG5cdFx0aWYgKCQuaXNGdW5jdGlvbihmaWx0ZXIpKSB7XG5cdFx0XHRyZXR1cm4gJC5ncmVwKGNhY2hlLCBmaWx0ZXIpO1xuXHRcdH1cblx0XHRlbHNlIGlmIChmaWx0ZXIgIT0gbnVsbCkgeyAvLyBub3QgbnVsbCwgbm90IHVuZGVmaW5lZC4gYW4gZXZlbnQgSURcblx0XHRcdGZpbHRlciArPSAnJztcblx0XHRcdHJldHVybiAkLmdyZXAoY2FjaGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0cmV0dXJuIGUuX2lkID09IGZpbHRlcjtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7IC8vIGVsc2UsIHJldHVybiBhbGxcblx0fVxuXG5cblx0Ly8gTWFrZXMgc3VyZSBhbGwgYXJyYXkgZXZlbnQgc291cmNlcyBoYXZlIHRoZWlyIGludGVybmFsIGV2ZW50IG9iamVjdHNcblx0Ly8gY29udmVydGVkIG92ZXIgdG8gdGhlIENhbGVuZGFyJ3MgY3VycmVudCB0aW1lem9uZS5cblx0dC5yZXpvbmVBcnJheUV2ZW50U291cmNlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpO1xuXHRcdHZhciBldmVudHM7XG5cdFx0dmFyIGo7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZXZlbnRzID0gc291cmNlc1tpXS5ldmVudHM7XG5cdFx0XHRpZiAoJC5pc0FycmF5KGV2ZW50cykpIHtcblxuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZXZlbnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0cmV6b25lRXZlbnREYXRlcyhldmVudHNbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIHJlem9uZUV2ZW50RGF0ZXMoZXZlbnQpIHtcblx0XHRldmVudC5zdGFydCA9IHQubW9tZW50KGV2ZW50LnN0YXJ0KTtcblx0XHRpZiAoZXZlbnQuZW5kKSB7XG5cdFx0XHRldmVudC5lbmQgPSB0Lm1vbWVudChldmVudC5lbmQpO1xuXHRcdH1cblx0XHRiYWNrdXBFdmVudERhdGVzKGV2ZW50KTtcblx0fVxuXG5cblx0LyogRXZlbnQgTm9ybWFsaXphdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBHaXZlbiBhIHJhdyBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcHJvcGVydGllcywgcmV0dXJucyBhbiBcImFic3RyYWN0XCIgRXZlbnQgb2JqZWN0LlxuXHQvLyBBbiBcImFic3RyYWN0XCIgZXZlbnQgaXMgYW4gZXZlbnQgdGhhdCwgaWYgcmVjdXJyaW5nLCB3aWxsIG5vdCBoYXZlIGJlZW4gZXhwYW5kZWQgeWV0LlxuXHQvLyBXaWxsIHJldHVybiBgZmFsc2VgIHdoZW4gaW5wdXQgaXMgaW52YWxpZC5cblx0Ly8gYHNvdXJjZWAgaXMgb3B0aW9uYWxcblx0ZnVuY3Rpb24gYnVpbGRFdmVudEZyb21JbnB1dChpbnB1dCwgc291cmNlKSB7XG5cdFx0dmFyIGNhbGVuZGFyRXZlbnREYXRhVHJhbnNmb3JtID0gdC5vcHQoJ2V2ZW50RGF0YVRyYW5zZm9ybScpO1xuXHRcdHZhciBvdXQgPSB7fTtcblx0XHR2YXIgc3RhcnQsIGVuZDtcblx0XHR2YXIgYWxsRGF5O1xuXG5cdFx0aWYgKGNhbGVuZGFyRXZlbnREYXRhVHJhbnNmb3JtKSB7XG5cdFx0XHRpbnB1dCA9IGNhbGVuZGFyRXZlbnREYXRhVHJhbnNmb3JtKGlucHV0KTtcblx0XHR9XG5cdFx0aWYgKHNvdXJjZSAmJiBzb3VyY2UuZXZlbnREYXRhVHJhbnNmb3JtKSB7XG5cdFx0XHRpbnB1dCA9IHNvdXJjZS5ldmVudERhdGFUcmFuc2Zvcm0oaW5wdXQpO1xuXHRcdH1cblxuXHRcdC8vIENvcHkgYWxsIHByb3BlcnRpZXMgb3ZlciB0byB0aGUgcmVzdWx0aW5nIG9iamVjdC5cblx0XHQvLyBUaGUgc3BlY2lhbC1jYXNlIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQgb3ZlciBhZnRlcndhcmRzLlxuXHRcdCQuZXh0ZW5kKG91dCwgaW5wdXQpO1xuXG5cdFx0aWYgKHNvdXJjZSkge1xuXHRcdFx0b3V0LnNvdXJjZSA9IHNvdXJjZTtcblx0XHR9XG5cblx0XHRvdXQuX2lkID0gaW5wdXQuX2lkIHx8IChpbnB1dC5pZCA9PT0gdW5kZWZpbmVkID8gJ19mYycgKyBldmVudEdVSUQrKyA6IGlucHV0LmlkICsgJycpO1xuXG5cdFx0aWYgKGlucHV0LmNsYXNzTmFtZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBpbnB1dC5jbGFzc05hbWUgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0b3V0LmNsYXNzTmFtZSA9IGlucHV0LmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IC8vIGFzc3VtZWQgdG8gYmUgYW4gYXJyYXlcblx0XHRcdFx0b3V0LmNsYXNzTmFtZSA9IGlucHV0LmNsYXNzTmFtZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRvdXQuY2xhc3NOYW1lID0gW107XG5cdFx0fVxuXG5cdFx0c3RhcnQgPSBpbnB1dC5zdGFydCB8fCBpbnB1dC5kYXRlOyAvLyBcImRhdGVcIiBpcyBhbiBhbGlhcyBmb3IgXCJzdGFydFwiXG5cdFx0ZW5kID0gaW5wdXQuZW5kO1xuXG5cdFx0Ly8gcGFyc2UgYXMgYSB0aW1lIChEdXJhdGlvbikgaWYgYXBwbGljYWJsZVxuXHRcdGlmIChpc1RpbWVTdHJpbmcoc3RhcnQpKSB7XG5cdFx0XHRzdGFydCA9IG1vbWVudC5kdXJhdGlvbihzdGFydCk7XG5cdFx0fVxuXHRcdGlmIChpc1RpbWVTdHJpbmcoZW5kKSkge1xuXHRcdFx0ZW5kID0gbW9tZW50LmR1cmF0aW9uKGVuZCk7XG5cdFx0fVxuXG5cdFx0aWYgKGlucHV0LmRvdyB8fCBtb21lbnQuaXNEdXJhdGlvbihzdGFydCkgfHwgbW9tZW50LmlzRHVyYXRpb24oZW5kKSkge1xuXG5cdFx0XHQvLyB0aGUgZXZlbnQgaXMgXCJhYnN0cmFjdFwiIChyZWN1cnJpbmcpIHNvIGRvbid0IGNhbGN1bGF0ZSBleGFjdCBzdGFydC9lbmQgZGF0ZXMganVzdCB5ZXRcblx0XHRcdG91dC5zdGFydCA9IHN0YXJ0ID8gbW9tZW50LmR1cmF0aW9uKHN0YXJ0KSA6IG51bGw7IC8vIHdpbGwgYmUgYSBEdXJhdGlvbiBvciBudWxsXG5cdFx0XHRvdXQuZW5kID0gZW5kID8gbW9tZW50LmR1cmF0aW9uKGVuZCkgOiBudWxsOyAvLyB3aWxsIGJlIGEgRHVyYXRpb24gb3IgbnVsbFxuXHRcdFx0b3V0Ll9yZWN1cnJpbmcgPSB0cnVlOyAvLyBvdXIgaW50ZXJuYWwgbWFya2VyXG5cdFx0fVxuXHRcdGVsc2Uge1xuXG5cdFx0XHRpZiAoc3RhcnQpIHtcblx0XHRcdFx0c3RhcnQgPSB0Lm1vbWVudChzdGFydCk7XG5cdFx0XHRcdGlmICghc3RhcnQuaXNWYWxpZCgpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChlbmQpIHtcblx0XHRcdFx0ZW5kID0gdC5tb21lbnQoZW5kKTtcblx0XHRcdFx0aWYgKCFlbmQuaXNWYWxpZCgpKSB7XG5cdFx0XHRcdFx0ZW5kID0gbnVsbDsgLy8gbGV0IGRlZmF1bHRzIHRha2Ugb3ZlclxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGFsbERheSA9IGlucHV0LmFsbERheTtcblx0XHRcdGlmIChhbGxEYXkgPT09IHVuZGVmaW5lZCkgeyAvLyBzdGlsbCB1bmRlZmluZWQ/IGZhbGxiYWNrIHRvIGRlZmF1bHRcblx0XHRcdFx0YWxsRGF5ID0gZmlyc3REZWZpbmVkKFxuXHRcdFx0XHRcdHNvdXJjZSA/IHNvdXJjZS5hbGxEYXlEZWZhdWx0IDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdHQub3B0KCdhbGxEYXlEZWZhdWx0Jylcblx0XHRcdFx0KTtcblx0XHRcdFx0Ly8gc3RpbGwgdW5kZWZpbmVkPyBub3JtYWxpemVFdmVudERhdGVzIHdpbGwgY2FsY3VsYXRlIGl0XG5cdFx0XHR9XG5cblx0XHRcdGFzc2lnbkRhdGVzVG9FdmVudChzdGFydCwgZW5kLCBhbGxEYXksIG91dCk7XG5cdFx0fVxuXG5cdFx0dC5ub3JtYWxpemVFdmVudChvdXQpOyAvLyBob29rIGZvciBleHRlcm5hbCB1c2UuIGEgcHJvdG90eXBlIG1ldGhvZFxuXG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXHR0LmJ1aWxkRXZlbnRGcm9tSW5wdXQgPSBidWlsZEV2ZW50RnJvbUlucHV0O1xuXG5cblx0Ly8gTm9ybWFsaXplcyBhbmQgYXNzaWducyB0aGUgZ2l2ZW4gZGF0ZXMgdG8gdGhlIGdpdmVuIHBhcnRpYWxseS1mb3JtZWQgZXZlbnQgb2JqZWN0LlxuXHQvLyBOT1RFOiBtdXRhdGVzIHRoZSBnaXZlbiBzdGFydC9lbmQgbW9tZW50cy4gZG9lcyBub3QgbWFrZSBhIGNvcHkuXG5cdGZ1bmN0aW9uIGFzc2lnbkRhdGVzVG9FdmVudChzdGFydCwgZW5kLCBhbGxEYXksIGV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RhcnQgPSBzdGFydDtcblx0XHRldmVudC5lbmQgPSBlbmQ7XG5cdFx0ZXZlbnQuYWxsRGF5ID0gYWxsRGF5O1xuXHRcdG5vcm1hbGl6ZUV2ZW50RGF0ZXMoZXZlbnQpO1xuXHRcdGJhY2t1cEV2ZW50RGF0ZXMoZXZlbnQpO1xuXHR9XG5cblxuXHQvLyBFbnN1cmVzIHByb3BlciB2YWx1ZXMgZm9yIGFsbERheS9zdGFydC9lbmQuIEFjY2VwdHMgYW4gRXZlbnQgb2JqZWN0LCBvciBhIHBsYWluIG9iamVjdCB3aXRoIGV2ZW50LWlzaCBwcm9wZXJ0aWVzLlxuXHQvLyBOT1RFOiBXaWxsIG1vZGlmeSB0aGUgZ2l2ZW4gb2JqZWN0LlxuXHRmdW5jdGlvbiBub3JtYWxpemVFdmVudERhdGVzKGV2ZW50UHJvcHMpIHtcblxuXHRcdG5vcm1hbGl6ZUV2ZW50VGltZXMoZXZlbnRQcm9wcyk7XG5cblx0XHRpZiAoZXZlbnRQcm9wcy5lbmQgJiYgIWV2ZW50UHJvcHMuZW5kLmlzQWZ0ZXIoZXZlbnRQcm9wcy5zdGFydCkpIHtcblx0XHRcdGV2ZW50UHJvcHMuZW5kID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAoIWV2ZW50UHJvcHMuZW5kKSB7XG5cdFx0XHRpZiAodC5vcHQoJ2ZvcmNlRXZlbnREdXJhdGlvbicpKSB7XG5cdFx0XHRcdGV2ZW50UHJvcHMuZW5kID0gdC5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnRQcm9wcy5hbGxEYXksIGV2ZW50UHJvcHMuc3RhcnQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGV2ZW50UHJvcHMuZW5kID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdC8vIEVuc3VyZXMgdGhlIGFsbERheSBwcm9wZXJ0eSBleGlzdHMgYW5kIHRoZSB0aW1lbGluZXNzIG9mIHRoZSBzdGFydC9lbmQgZGF0ZXMgYXJlIGNvbnNpc3RlbnRcblx0ZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRUaW1lcyhldmVudFByb3BzKSB7XG5cdFx0aWYgKGV2ZW50UHJvcHMuYWxsRGF5ID09IG51bGwpIHtcblx0XHRcdGV2ZW50UHJvcHMuYWxsRGF5ID0gIShldmVudFByb3BzLnN0YXJ0Lmhhc1RpbWUoKSB8fCAoZXZlbnRQcm9wcy5lbmQgJiYgZXZlbnRQcm9wcy5lbmQuaGFzVGltZSgpKSk7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50UHJvcHMuYWxsRGF5KSB7XG5cdFx0XHRldmVudFByb3BzLnN0YXJ0LnN0cmlwVGltZSgpO1xuXHRcdFx0aWYgKGV2ZW50UHJvcHMuZW5kKSB7XG5cdFx0XHRcdC8vIFRPRE86IGNvbnNpZGVyIG5leHREYXlUaHJlc2hvbGQgaGVyZT8gSWYgc28sIHdpbGwgcmVxdWlyZSBhIGxvdCBvZiB0ZXN0aW5nIGFuZCBhZGp1c3RtZW50XG5cdFx0XHRcdGV2ZW50UHJvcHMuZW5kLnN0cmlwVGltZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICghZXZlbnRQcm9wcy5zdGFydC5oYXNUaW1lKCkpIHtcblx0XHRcdFx0ZXZlbnRQcm9wcy5zdGFydCA9IHQuYXBwbHlUaW1lem9uZShldmVudFByb3BzLnN0YXJ0LnRpbWUoMCkpOyAvLyB3aWxsIGFzc2lnbiBhIDAwOjAwIHRpbWVcblx0XHRcdH1cblx0XHRcdGlmIChldmVudFByb3BzLmVuZCAmJiAhZXZlbnRQcm9wcy5lbmQuaGFzVGltZSgpKSB7XG5cdFx0XHRcdGV2ZW50UHJvcHMuZW5kID0gdC5hcHBseVRpbWV6b25lKGV2ZW50UHJvcHMuZW5kLnRpbWUoMCkpOyAvLyB3aWxsIGFzc2lnbiBhIDAwOjAwIHRpbWVcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdC8vIElmIHRoZSBnaXZlbiBldmVudCBpcyBhIHJlY3VycmluZyBldmVudCwgYnJlYWsgaXQgZG93biBpbnRvIGFuIGFycmF5IG9mIGluZGl2aWR1YWwgaW5zdGFuY2VzLlxuXHQvLyBJZiBub3QgYSByZWN1cnJpbmcgZXZlbnQsIHJldHVybiBhbiBhcnJheSB3aXRoIHRoZSBzaW5nbGUgb3JpZ2luYWwgZXZlbnQuXG5cdC8vIElmIGdpdmVuIGEgZmFsc3kgaW5wdXQgKHByb2JhYmx5IGJlY2F1c2Ugb2YgYSBmYWlsZWQgYnVpbGRFdmVudEZyb21JbnB1dCBjYWxsKSwgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cblx0Ly8gSEFDSzogY2FuIG92ZXJyaWRlIHRoZSByZWN1cnJpbmcgd2luZG93IGJ5IHByb3ZpZGluZyBjdXN0b20gcmFuZ2VTdGFydC9yYW5nZUVuZCAoZm9yIGJ1c2luZXNzSG91cnMpLlxuXHRmdW5jdGlvbiBleHBhbmRFdmVudChhYnN0cmFjdEV2ZW50LCBfcmFuZ2VTdGFydCwgX3JhbmdlRW5kKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFtdO1xuXHRcdHZhciBkb3dIYXNoO1xuXHRcdHZhciBkb3c7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIGRhdGU7XG5cdFx0dmFyIHN0YXJ0VGltZSwgZW5kVGltZTtcblx0XHR2YXIgc3RhcnQsIGVuZDtcblx0XHR2YXIgZXZlbnQ7XG5cblx0XHRfcmFuZ2VTdGFydCA9IF9yYW5nZVN0YXJ0IHx8IHJhbmdlU3RhcnQ7XG5cdFx0X3JhbmdlRW5kID0gX3JhbmdlRW5kIHx8IHJhbmdlRW5kO1xuXG5cdFx0aWYgKGFic3RyYWN0RXZlbnQpIHtcblx0XHRcdGlmIChhYnN0cmFjdEV2ZW50Ll9yZWN1cnJpbmcpIHtcblxuXHRcdFx0XHQvLyBtYWtlIGEgYm9vbGVhbiBoYXNoIGFzIHRvIHdoZXRoZXIgdGhlIGV2ZW50IG9jY3VycyBvbiBlYWNoIGRheS1vZi13ZWVrXG5cdFx0XHRcdGlmICgoZG93ID0gYWJzdHJhY3RFdmVudC5kb3cpKSB7XG5cdFx0XHRcdFx0ZG93SGFzaCA9IHt9O1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkb3cubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGRvd0hhc2hbZG93W2ldXSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IGRheSBpbiB0aGUgY3VycmVudCByYW5nZVxuXHRcdFx0XHRkYXRlID0gX3JhbmdlU3RhcnQuY2xvbmUoKS5zdHJpcFRpbWUoKTsgLy8gaG9sZHMgdGhlIGRhdGUgb2YgdGhlIGN1cnJlbnQgZGF5XG5cdFx0XHRcdHdoaWxlIChkYXRlLmlzQmVmb3JlKF9yYW5nZUVuZCkpIHtcblxuXHRcdFx0XHRcdGlmICghZG93SGFzaCB8fCBkb3dIYXNoW2RhdGUuZGF5KCldKSB7IC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcblxuXHRcdFx0XHRcdFx0c3RhcnRUaW1lID0gYWJzdHJhY3RFdmVudC5zdGFydDsgLy8gdGhlIHN0b3JlZCBzdGFydCBhbmQgZW5kIHByb3BlcnRpZXMgYXJlIHRpbWVzIChEdXJhdGlvbnMpXG5cdFx0XHRcdFx0XHRlbmRUaW1lID0gYWJzdHJhY3RFdmVudC5lbmQ7IC8vIFwiXG5cdFx0XHRcdFx0XHRzdGFydCA9IGRhdGUuY2xvbmUoKTtcblx0XHRcdFx0XHRcdGVuZCA9IG51bGw7XG5cblx0XHRcdFx0XHRcdGlmIChzdGFydFRpbWUpIHtcblx0XHRcdFx0XHRcdFx0c3RhcnQgPSBzdGFydC50aW1lKHN0YXJ0VGltZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoZW5kVGltZSkge1xuXHRcdFx0XHRcdFx0XHRlbmQgPSBkYXRlLmNsb25lKCkudGltZShlbmRUaW1lKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZXZlbnQgPSAkLmV4dGVuZCh7fSwgYWJzdHJhY3RFdmVudCk7IC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbFxuXHRcdFx0XHRcdFx0YXNzaWduRGF0ZXNUb0V2ZW50KFxuXHRcdFx0XHRcdFx0XHRzdGFydCwgZW5kLFxuXHRcdFx0XHRcdFx0XHQhc3RhcnRUaW1lICYmICFlbmRUaW1lLCAvLyBhbGxEYXk/XG5cdFx0XHRcdFx0XHRcdGV2ZW50XG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0ZXZlbnRzLnB1c2goZXZlbnQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRhdGUuYWRkKDEsICdkYXlzJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRldmVudHMucHVzaChhYnN0cmFjdEV2ZW50KTsgLy8gcmV0dXJuIHRoZSBvcmlnaW5hbCBldmVudC4gd2lsbCBiZSBhIG9uZS1pdGVtIGFycmF5XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fVxuXHR0LmV4cGFuZEV2ZW50ID0gZXhwYW5kRXZlbnQ7XG5cblxuXG5cdC8qIEV2ZW50IE1vZGlmaWNhdGlvbiBNYXRoXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIE1vZGlmaWVzIGFuIGV2ZW50IGFuZCBhbGwgcmVsYXRlZCBldmVudHMgYnkgYXBwbHlpbmcgdGhlIGdpdmVuIHByb3BlcnRpZXMuXG5cdC8vIFNwZWNpYWwgZGF0ZS1kaWZmaW5nIGxvZ2ljIGlzIHVzZWQgZm9yIG1hbmlwdWxhdGlvbiBvZiBkYXRlcy5cblx0Ly8gSWYgYHByb3BzYCBkb2VzIG5vdCBjb250YWluIHN0YXJ0L2VuZCBkYXRlcywgdGhlIHVwZGF0ZWQgdmFsdWVzIGFyZSBhc3N1bWVkIHRvIGJlIHRoZSBldmVudCdzIGN1cnJlbnQgc3RhcnQvZW5kLlxuXHQvLyBBbGwgZGF0ZSBjb21wYXJpc29ucyBhcmUgZG9uZSBhZ2FpbnN0IHRoZSBldmVudCdzIHByaXN0aW5lIF9zdGFydCBhbmQgX2VuZCBkYXRlcy5cblx0Ly8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBkZWx0YSBpbmZvcm1hdGlvbiBhbmQgYSBmdW5jdGlvbiB0byB1bmRvIGFsbCBvcGVyYXRpb25zLlxuXHQvLyBGb3IgbWFraW5nIGNvbXB1dGF0aW9ucyBpbiBhIGdyYW51bGFyaXR5IGdyZWF0ZXIgdGhhbiBkYXkvdGltZSwgc3BlY2lmeSBsYXJnZVVuaXQuXG5cdC8vIE5PVEU6IFRoZSBnaXZlbiBgbmV3UHJvcHNgIG1pZ2h0IGJlIG11dGF0ZWQgZm9yIG5vcm1hbGl6YXRpb24gcHVycG9zZXMuXG5cdGZ1bmN0aW9uIG11dGF0ZUV2ZW50KGV2ZW50LCBuZXdQcm9wcywgbGFyZ2VVbml0KSB7XG5cdFx0dmFyIG1pc2NQcm9wcyA9IHt9O1xuXHRcdHZhciBvbGRQcm9wcztcblx0XHR2YXIgY2xlYXJFbmQ7XG5cdFx0dmFyIHN0YXJ0RGVsdGE7XG5cdFx0dmFyIGVuZERlbHRhO1xuXHRcdHZhciBkdXJhdGlvbkRlbHRhO1xuXHRcdHZhciB1bmRvRnVuYztcblxuXHRcdC8vIGRpZmZzIHRoZSBkYXRlcyBpbiB0aGUgYXBwcm9wcmlhdGUgd2F5LCByZXR1cm5pbmcgYSBkdXJhdGlvblxuXHRcdGZ1bmN0aW9uIGRpZmZEYXRlcyhkYXRlMSwgZGF0ZTApIHsgLy8gZGF0ZTEgLSBkYXRlMFxuXHRcdFx0aWYgKGxhcmdlVW5pdCkge1xuXHRcdFx0XHRyZXR1cm4gZGlmZkJ5VW5pdChkYXRlMSwgZGF0ZTAsIGxhcmdlVW5pdCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChuZXdQcm9wcy5hbGxEYXkpIHtcblx0XHRcdFx0cmV0dXJuIGRpZmZEYXkoZGF0ZTEsIGRhdGUwKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZGlmZkRheVRpbWUoZGF0ZTEsIGRhdGUwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRuZXdQcm9wcyA9IG5ld1Byb3BzIHx8IHt9O1xuXG5cdFx0Ly8gbm9ybWFsaXplIG5ldyBkYXRlLXJlbGF0ZWQgcHJvcGVydGllc1xuXHRcdGlmICghbmV3UHJvcHMuc3RhcnQpIHtcblx0XHRcdG5ld1Byb3BzLnN0YXJ0ID0gZXZlbnQuc3RhcnQuY2xvbmUoKTtcblx0XHR9XG5cdFx0aWYgKG5ld1Byb3BzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRuZXdQcm9wcy5lbmQgPSBldmVudC5lbmQgPyBldmVudC5lbmQuY2xvbmUoKSA6IG51bGw7XG5cdFx0fVxuXHRcdGlmIChuZXdQcm9wcy5hbGxEYXkgPT0gbnVsbCkgeyAvLyBpcyBudWxsIG9yIHVuZGVmaW5lZD9cblx0XHRcdG5ld1Byb3BzLmFsbERheSA9IGV2ZW50LmFsbERheTtcblx0XHR9XG5cdFx0bm9ybWFsaXplRXZlbnREYXRlcyhuZXdQcm9wcyk7XG5cblx0XHQvLyBjcmVhdGUgbm9ybWFsaXplZCB2ZXJzaW9ucyBvZiB0aGUgb3JpZ2luYWwgcHJvcHMgdG8gY29tcGFyZSBhZ2FpbnN0XG5cdFx0Ly8gbmVlZCBhIHJlYWwgZW5kIHZhbHVlLCBmb3IgZGlmZmluZ1xuXHRcdG9sZFByb3BzID0ge1xuXHRcdFx0c3RhcnQ6IGV2ZW50Ll9zdGFydC5jbG9uZSgpLFxuXHRcdFx0ZW5kOiBldmVudC5fZW5kID8gZXZlbnQuX2VuZC5jbG9uZSgpIDogdC5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnQuX2FsbERheSwgZXZlbnQuX3N0YXJ0KSxcblx0XHRcdGFsbERheTogbmV3UHJvcHMuYWxsRGF5IC8vIG5vcm1hbGl6ZSB0aGUgZGF0ZXMgaW4gdGhlIHNhbWUgcmVnYXJkIGFzIHRoZSBuZXcgcHJvcGVydGllc1xuXHRcdH07XG5cdFx0bm9ybWFsaXplRXZlbnREYXRlcyhvbGRQcm9wcyk7XG5cblx0XHQvLyBuZWVkIHRvIGNsZWFyIHRoZSBlbmQgZGF0ZSBpZiBleHBsaWNpdGx5IGNoYW5nZWQgdG8gbnVsbFxuXHRcdGNsZWFyRW5kID0gZXZlbnQuX2VuZCAhPT0gbnVsbCAmJiBuZXdQcm9wcy5lbmQgPT09IG51bGw7XG5cblx0XHQvLyBjb21wdXRlIHRoZSBkZWx0YSBmb3IgbW92aW5nIHRoZSBzdGFydCBkYXRlXG5cdFx0c3RhcnREZWx0YSA9IGRpZmZEYXRlcyhuZXdQcm9wcy5zdGFydCwgb2xkUHJvcHMuc3RhcnQpO1xuXG5cdFx0Ly8gY29tcHV0ZSB0aGUgZGVsdGEgZm9yIG1vdmluZyB0aGUgZW5kIGRhdGVcblx0XHRpZiAobmV3UHJvcHMuZW5kKSB7XG5cdFx0XHRlbmREZWx0YSA9IGRpZmZEYXRlcyhuZXdQcm9wcy5lbmQsIG9sZFByb3BzLmVuZCk7XG5cdFx0XHRkdXJhdGlvbkRlbHRhID0gZW5kRGVsdGEuc3VidHJhY3Qoc3RhcnREZWx0YSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZHVyYXRpb25EZWx0YSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gZ2F0aGVyIGFsbCBub24tZGF0ZS1yZWxhdGVkIHByb3BlcnRpZXNcblx0XHQkLmVhY2gobmV3UHJvcHMsIGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuXHRcdFx0aWYgKGlzTWlzY0V2ZW50UHJvcE5hbWUobmFtZSkpIHtcblx0XHRcdFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0bWlzY1Byb3BzW25hbWVdID0gdmFsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBhcHBseSB0aGUgb3BlcmF0aW9ucyB0byB0aGUgZXZlbnQgYW5kIGFsbCByZWxhdGVkIGV2ZW50c1xuXHRcdHVuZG9GdW5jID0gbXV0YXRlRXZlbnRzKFxuXHRcdFx0Y2xpZW50RXZlbnRzKGV2ZW50Ll9pZCksIC8vIGdldCBldmVudHMgd2l0aCB0aGlzIElEXG5cdFx0XHRjbGVhckVuZCxcblx0XHRcdG5ld1Byb3BzLmFsbERheSxcblx0XHRcdHN0YXJ0RGVsdGEsXG5cdFx0XHRkdXJhdGlvbkRlbHRhLFxuXHRcdFx0bWlzY1Byb3BzXG5cdFx0KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRlRGVsdGE6IHN0YXJ0RGVsdGEsXG5cdFx0XHRkdXJhdGlvbkRlbHRhOiBkdXJhdGlvbkRlbHRhLFxuXHRcdFx0dW5kbzogdW5kb0Z1bmNcblx0XHR9O1xuXHR9XG5cblxuXHQvLyBNb2RpZmllcyBhbiBhcnJheSBvZiBldmVudHMgaW4gdGhlIGZvbGxvd2luZyB3YXlzIChvcGVyYXRpb25zIGFyZSBpbiBvcmRlcik6XG5cdC8vIC0gY2xlYXIgdGhlIGV2ZW50J3MgYGVuZGBcblx0Ly8gLSBjb252ZXJ0IHRoZSBldmVudCB0byBhbGxEYXlcblx0Ly8gLSBhZGQgYGRhdGVEZWx0YWAgdG8gdGhlIHN0YXJ0IGFuZCBlbmRcblx0Ly8gLSBhZGQgYGR1cmF0aW9uRGVsdGFgIHRvIHRoZSBldmVudCdzIGR1cmF0aW9uXG5cdC8vIC0gYXNzaWduIGBtaXNjUHJvcHNgIHRvIHRoZSBldmVudFxuXHQvL1xuXHQvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkIHRvIHVuZG8gYWxsIHRoZSBvcGVyYXRpb25zLlxuXHQvL1xuXHQvLyBUT0RPOiBkb24ndCB1c2Ugc28gbWFueSBjbG9zdXJlcy4gcG9zc2libGUgbWVtb3J5IGlzc3VlcyB3aGVuIGxvdHMgb2YgZXZlbnRzIHdpdGggc2FtZSBJRC5cblx0Ly9cblx0ZnVuY3Rpb24gbXV0YXRlRXZlbnRzKGV2ZW50cywgY2xlYXJFbmQsIGFsbERheSwgZGF0ZURlbHRhLCBkdXJhdGlvbkRlbHRhLCBtaXNjUHJvcHMpIHtcblx0XHR2YXIgaXNBbWJpZ1RpbWV6b25lID0gdC5nZXRJc0FtYmlnVGltZXpvbmUoKTtcblx0XHR2YXIgdW5kb0Z1bmN0aW9ucyA9IFtdO1xuXG5cdFx0Ly8gbm9ybWFsaXplIHplcm8tbGVuZ3RoIGRlbHRhcyB0byBiZSBudWxsXG5cdFx0aWYgKGRhdGVEZWx0YSAmJiAhZGF0ZURlbHRhLnZhbHVlT2YoKSkgeyBkYXRlRGVsdGEgPSBudWxsOyB9XG5cdFx0aWYgKGR1cmF0aW9uRGVsdGEgJiYgIWR1cmF0aW9uRGVsdGEudmFsdWVPZigpKSB7IGR1cmF0aW9uRGVsdGEgPSBudWxsOyB9XG5cblx0XHQkLmVhY2goZXZlbnRzLCBmdW5jdGlvbihpLCBldmVudCkge1xuXHRcdFx0dmFyIG9sZFByb3BzO1xuXHRcdFx0dmFyIG5ld1Byb3BzO1xuXG5cdFx0XHQvLyBidWlsZCBhbiBvYmplY3QgaG9sZGluZyBhbGwgdGhlIG9sZCB2YWx1ZXMsIGJvdGggZGF0ZS1yZWxhdGVkIGFuZCBtaXNjLlxuXHRcdFx0Ly8gZm9yIHRoZSB1bmRvIGZ1bmN0aW9uLlxuXHRcdFx0b2xkUHJvcHMgPSB7XG5cdFx0XHRcdHN0YXJ0OiBldmVudC5zdGFydC5jbG9uZSgpLFxuXHRcdFx0XHRlbmQ6IGV2ZW50LmVuZCA/IGV2ZW50LmVuZC5jbG9uZSgpIDogbnVsbCxcblx0XHRcdFx0YWxsRGF5OiBldmVudC5hbGxEYXlcblx0XHRcdH07XG5cdFx0XHQkLmVhY2gobWlzY1Byb3BzLCBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdG9sZFByb3BzW25hbWVdID0gZXZlbnRbbmFtZV07XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gbmV3IGRhdGUtcmVsYXRlZCBwcm9wZXJ0aWVzLiB3b3JrIG9mZiB0aGUgb3JpZ2luYWwgZGF0ZSBzbmFwc2hvdC5cblx0XHRcdC8vIG9rIHRvIHVzZSByZWZlcmVuY2VzIGJlY2F1c2UgdGhleSB3aWxsIGJlIHRocm93biBhd2F5IHdoZW4gYmFja3VwRXZlbnREYXRlcyBpcyBjYWxsZWQuXG5cdFx0XHRuZXdQcm9wcyA9IHtcblx0XHRcdFx0c3RhcnQ6IGV2ZW50Ll9zdGFydCxcblx0XHRcdFx0ZW5kOiBldmVudC5fZW5kLFxuXHRcdFx0XHRhbGxEYXk6IGFsbERheSAvLyBub3JtYWxpemUgdGhlIGRhdGVzIGluIHRoZSBzYW1lIHJlZ2FyZCBhcyB0aGUgbmV3IHByb3BlcnRpZXNcblx0XHRcdH07XG5cdFx0XHRub3JtYWxpemVFdmVudERhdGVzKG5ld1Byb3BzKTsgLy8gbWFzc2FnZXMgc3RhcnQvZW5kL2FsbERheVxuXG5cdFx0XHQvLyBzdHJpcCBvciBlbnN1cmUgdGhlIGVuZCBkYXRlXG5cdFx0XHRpZiAoY2xlYXJFbmQpIHtcblx0XHRcdFx0bmV3UHJvcHMuZW5kID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGR1cmF0aW9uRGVsdGEgJiYgIW5ld1Byb3BzLmVuZCkgeyAvLyB0aGUgZHVyYXRpb24gdHJhbnNsYXRpb24gcmVxdWlyZXMgYW4gZW5kIGRhdGVcblx0XHRcdFx0bmV3UHJvcHMuZW5kID0gdC5nZXREZWZhdWx0RXZlbnRFbmQobmV3UHJvcHMuYWxsRGF5LCBuZXdQcm9wcy5zdGFydCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRlRGVsdGEpIHtcblx0XHRcdFx0bmV3UHJvcHMuc3RhcnQuYWRkKGRhdGVEZWx0YSk7XG5cdFx0XHRcdGlmIChuZXdQcm9wcy5lbmQpIHtcblx0XHRcdFx0XHRuZXdQcm9wcy5lbmQuYWRkKGRhdGVEZWx0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGR1cmF0aW9uRGVsdGEpIHtcblx0XHRcdFx0bmV3UHJvcHMuZW5kLmFkZChkdXJhdGlvbkRlbHRhKTsgLy8gZW5kIGFscmVhZHkgZW5zdXJlZCBhYm92ZVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiB0aGUgZGF0ZXMgaGF2ZSBjaGFuZ2VkLCBhbmQgd2Uga25vdyBpdCBpcyBpbXBvc3NpYmxlIHRvIHJlY29tcHV0ZSB0aGVcblx0XHRcdC8vIHRpbWV6b25lIG9mZnNldHMsIHN0cmlwIHRoZSB6b25lLlxuXHRcdFx0aWYgKFxuXHRcdFx0XHRpc0FtYmlnVGltZXpvbmUgJiZcblx0XHRcdFx0IW5ld1Byb3BzLmFsbERheSAmJlxuXHRcdFx0XHQoZGF0ZURlbHRhIHx8IGR1cmF0aW9uRGVsdGEpXG5cdFx0XHQpIHtcblx0XHRcdFx0bmV3UHJvcHMuc3RhcnQuc3RyaXBab25lKCk7XG5cdFx0XHRcdGlmIChuZXdQcm9wcy5lbmQpIHtcblx0XHRcdFx0XHRuZXdQcm9wcy5lbmQuc3RyaXBab25lKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0JC5leHRlbmQoZXZlbnQsIG1pc2NQcm9wcywgbmV3UHJvcHMpOyAvLyBjb3B5IG92ZXIgbWlzYyBwcm9wcywgdGhlbiBkYXRlLXJlbGF0ZWQgcHJvcHNcblx0XHRcdGJhY2t1cEV2ZW50RGF0ZXMoZXZlbnQpOyAvLyByZWdlbmVyYXRlIGludGVybmFsIF9zdGFydC9fZW5kL19hbGxEYXlcblxuXHRcdFx0dW5kb0Z1bmN0aW9ucy5wdXNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkLmV4dGVuZChldmVudCwgb2xkUHJvcHMpO1xuXHRcdFx0XHRiYWNrdXBFdmVudERhdGVzKGV2ZW50KTsgLy8gcmVnZW5lcmF0ZSBpbnRlcm5hbCBfc3RhcnQvX2VuZC9fYWxsRGF5XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdW5kb0Z1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR1bmRvRnVuY3Rpb25zW2ldKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG59XG5cblxuLy8gcmV0dXJucyBhbiB1bmRvIGZ1bmN0aW9uXG5DYWxlbmRhci5wcm90b3R5cGUubXV0YXRlU2VnID0gZnVuY3Rpb24oc2VnLCBuZXdQcm9wcykge1xuXHRyZXR1cm4gdGhpcy5tdXRhdGVFdmVudChzZWcuZXZlbnQsIG5ld1Byb3BzKTtcbn07XG5cblxuLy8gaG9vayBmb3IgZXh0ZXJuYWwgbGlicyB0byBtYW5pcHVsYXRlIGV2ZW50IHByb3BlcnRpZXMgdXBvbiBjcmVhdGlvbi5cbi8vIHNob3VsZCBtYW5pcHVsYXRlIHRoZSBldmVudCBpbi1wbGFjZS5cbkNhbGVuZGFyLnByb3RvdHlwZS5ub3JtYWxpemVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG59O1xuXG5cbi8vIERvZXMgdGhlIGdpdmVuIHNwYW4gKHN0YXJ0LCBlbmQsIGFuZCBvdGhlciBsb2NhdGlvbiBpbmZvcm1hdGlvbilcbi8vIGZ1bGx5IGNvbnRhaW4gdGhlIG90aGVyP1xuQ2FsZW5kYXIucHJvdG90eXBlLnNwYW5Db250YWluc1NwYW4gPSBmdW5jdGlvbihvdXRlclNwYW4sIGlubmVyU3Bhbikge1xuXHR2YXIgZXZlbnRTdGFydCA9IG91dGVyU3Bhbi5zdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpO1xuXHR2YXIgZXZlbnRFbmQgPSB0aGlzLmdldEV2ZW50RW5kKG91dGVyU3Bhbikuc3RyaXBab25lKCk7XG5cblx0cmV0dXJuIGlubmVyU3Bhbi5zdGFydCA+PSBldmVudFN0YXJ0ICYmIGlubmVyU3Bhbi5lbmQgPD0gZXZlbnRFbmQ7XG59O1xuXG5cbi8vIFJldHVybnMgYSBsaXN0IG9mIGV2ZW50cyB0aGF0IHRoZSBnaXZlbiBldmVudCBzaG91bGQgYmUgY29tcGFyZWQgYWdhaW5zdCB3aGVuIGJlaW5nIGNvbnNpZGVyZWQgZm9yIGEgbW92ZSB0b1xuLy8gdGhlIHNwZWNpZmllZCBzcGFuLiBBdHRhY2hlZCB0byB0aGUgQ2FsZW5kYXIncyBwcm90b3R5cGUgYmVjYXVzZSBFdmVudE1hbmFnZXIgaXMgYSBtaXhpbiBmb3IgYSBDYWxlbmRhci5cbkNhbGVuZGFyLnByb3RvdHlwZS5nZXRQZWVyRXZlbnRzID0gZnVuY3Rpb24oc3BhbiwgZXZlbnQpIHtcblx0dmFyIGNhY2hlID0gdGhpcy5nZXRFdmVudENhY2hlKCk7XG5cdHZhciBwZWVyRXZlbnRzID0gW107XG5cdHZhciBpLCBvdGhlckV2ZW50O1xuXG5cdGZvciAoaSA9IDA7IGkgPCBjYWNoZS5sZW5ndGg7IGkrKykge1xuXHRcdG90aGVyRXZlbnQgPSBjYWNoZVtpXTtcblx0XHRpZiAoXG5cdFx0XHQhZXZlbnQgfHxcblx0XHRcdGV2ZW50Ll9pZCAhPT0gb3RoZXJFdmVudC5faWQgLy8gZG9uJ3QgY29tcGFyZSB0aGUgZXZlbnQgdG8gaXRzZWxmIG9yIG90aGVyIHJlbGF0ZWQgW3JlcGVhdGluZ10gZXZlbnRzXG5cdFx0KSB7XG5cdFx0XHRwZWVyRXZlbnRzLnB1c2gob3RoZXJFdmVudCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHBlZXJFdmVudHM7XG59O1xuXG5cbi8vIHVwZGF0ZXMgdGhlIFwiYmFja3VwXCIgcHJvcGVydGllcywgd2hpY2ggYXJlIHByZXNlcnZlZCBpbiBvcmRlciB0byBjb21wdXRlIGRpZmZzIGxhdGVyIG9uLlxuZnVuY3Rpb24gYmFja3VwRXZlbnREYXRlcyhldmVudCkge1xuXHRldmVudC5fYWxsRGF5ID0gZXZlbnQuYWxsRGF5O1xuXHRldmVudC5fc3RhcnQgPSBldmVudC5zdGFydC5jbG9uZSgpO1xuXHRldmVudC5fZW5kID0gZXZlbnQuZW5kID8gZXZlbnQuZW5kLmNsb25lKCkgOiBudWxsO1xufVxuXG5cbi8qIE92ZXJsYXBwaW5nIC8gQ29uc3RyYWluaW5nXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuLy8gRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgY2FuIGJlIHJlbG9jYXRlZCB0byB0aGUgZ2l2ZW4gc3BhbiAodW56b25lZCBzdGFydC9lbmQgd2l0aCBvdGhlciBtaXNjIGRhdGEpXG5DYWxlbmRhci5wcm90b3R5cGUuaXNFdmVudFNwYW5BbGxvd2VkID0gZnVuY3Rpb24oc3BhbiwgZXZlbnQpIHtcblx0dmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCB7fTtcblx0dmFyIGV2ZW50QWxsb3dGdW5jID0gdGhpcy5vcHQoJ2V2ZW50QWxsb3cnKTtcblxuXHR2YXIgY29uc3RyYWludCA9IGZpcnN0RGVmaW5lZChcblx0XHRldmVudC5jb25zdHJhaW50LFxuXHRcdHNvdXJjZS5jb25zdHJhaW50LFxuXHRcdHRoaXMub3B0KCdldmVudENvbnN0cmFpbnQnKVxuXHQpO1xuXG5cdHZhciBvdmVybGFwID0gZmlyc3REZWZpbmVkKFxuXHRcdGV2ZW50Lm92ZXJsYXAsXG5cdFx0c291cmNlLm92ZXJsYXAsXG5cdFx0dGhpcy5vcHQoJ2V2ZW50T3ZlcmxhcCcpXG5cdCk7XG5cblx0cmV0dXJuIHRoaXMuaXNTcGFuQWxsb3dlZChzcGFuLCBjb25zdHJhaW50LCBvdmVybGFwLCBldmVudCkgJiZcblx0XHQoIWV2ZW50QWxsb3dGdW5jIHx8IGV2ZW50QWxsb3dGdW5jKHNwYW4sIGV2ZW50KSAhPT0gZmFsc2UpO1xufTtcblxuXG4vLyBEZXRlcm1pbmVzIGlmIGFuIGV4dGVybmFsIGV2ZW50IGNhbiBiZSByZWxvY2F0ZWQgdG8gdGhlIGdpdmVuIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIHdpdGggb3RoZXIgbWlzYyBkYXRhKVxuQ2FsZW5kYXIucHJvdG90eXBlLmlzRXh0ZXJuYWxTcGFuQWxsb3dlZCA9IGZ1bmN0aW9uKGV2ZW50U3BhbiwgZXZlbnRMb2NhdGlvbiwgZXZlbnRQcm9wcykge1xuXHR2YXIgZXZlbnRJbnB1dDtcblx0dmFyIGV2ZW50O1xuXG5cdC8vIG5vdGU6IHZlcnkgc2ltaWxhciBsb2dpYyBpcyBpbiBWaWV3J3MgcmVwb3J0RXh0ZXJuYWxEcm9wXG5cdGlmIChldmVudFByb3BzKSB7XG5cdFx0ZXZlbnRJbnB1dCA9ICQuZXh0ZW5kKHt9LCBldmVudFByb3BzLCBldmVudExvY2F0aW9uKTtcblx0XHRldmVudCA9IHRoaXMuZXhwYW5kRXZlbnQoXG5cdFx0XHR0aGlzLmJ1aWxkRXZlbnRGcm9tSW5wdXQoZXZlbnRJbnB1dClcblx0XHQpWzBdO1xuXHR9XG5cblx0aWYgKGV2ZW50KSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNFdmVudFNwYW5BbGxvd2VkKGV2ZW50U3BhbiwgZXZlbnQpO1xuXHR9XG5cdGVsc2UgeyAvLyB0cmVhdCBpdCBhcyBhIHNlbGVjdGlvblxuXG5cdFx0cmV0dXJuIHRoaXMuaXNTZWxlY3Rpb25TcGFuQWxsb3dlZChldmVudFNwYW4pO1xuXHR9XG59O1xuXG5cbi8vIERldGVybWluZXMgdGhlIGdpdmVuIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIHdpdGggb3RoZXIgbWlzYyBkYXRhKSBjYW4gYmUgc2VsZWN0ZWQuXG5DYWxlbmRhci5wcm90b3R5cGUuaXNTZWxlY3Rpb25TcGFuQWxsb3dlZCA9IGZ1bmN0aW9uKHNwYW4pIHtcblx0dmFyIHNlbGVjdEFsbG93RnVuYyA9IHRoaXMub3B0KCdzZWxlY3RBbGxvdycpO1xuXG5cdHJldHVybiB0aGlzLmlzU3BhbkFsbG93ZWQoc3BhbiwgdGhpcy5vcHQoJ3NlbGVjdENvbnN0cmFpbnQnKSwgdGhpcy5vcHQoJ3NlbGVjdE92ZXJsYXAnKSkgJiZcblx0XHQoIXNlbGVjdEFsbG93RnVuYyB8fCBzZWxlY3RBbGxvd0Z1bmMoc3BhbikgIT09IGZhbHNlKTtcbn07XG5cblxuLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzcGFuIChjYXVzZWQgYnkgYW4gZXZlbnQgZHJvcC9yZXNpemUgb3IgYSBzZWxlY3Rpb24pIGlzIGFsbG93ZWQgdG8gZXhpc3Rcbi8vIGFjY29yZGluZyB0byB0aGUgY29uc3RyYWludC9vdmVybGFwIHNldHRpbmdzLlxuLy8gYGV2ZW50YCBpcyBub3QgcmVxdWlyZWQgaWYgY2hlY2tpbmcgYSBzZWxlY3Rpb24uXG5DYWxlbmRhci5wcm90b3R5cGUuaXNTcGFuQWxsb3dlZCA9IGZ1bmN0aW9uKHNwYW4sIGNvbnN0cmFpbnQsIG92ZXJsYXAsIGV2ZW50KSB7XG5cdHZhciBjb25zdHJhaW50RXZlbnRzO1xuXHR2YXIgYW55Q29udGFpbm1lbnQ7XG5cdHZhciBwZWVyRXZlbnRzO1xuXHR2YXIgaSwgcGVlckV2ZW50O1xuXHR2YXIgcGVlck92ZXJsYXA7XG5cblx0Ly8gdGhlIHJhbmdlIG11c3QgYmUgZnVsbHkgY29udGFpbmVkIGJ5IGF0IGxlYXN0IG9uZSBvZiBwcm9kdWNlZCBjb25zdHJhaW50IGV2ZW50c1xuXHRpZiAoY29uc3RyYWludCAhPSBudWxsKSB7XG5cblx0XHQvLyBub3QgdHJlYXRlZCBhcyBhbiBldmVudCEgaW50ZXJtZWRpYXRlIGRhdGEgc3RydWN0dXJlXG5cdFx0Ly8gVE9ETzogdXNlIHJhbmdlcyBpbiB0aGUgZnV0dXJlXG5cdFx0Y29uc3RyYWludEV2ZW50cyA9IHRoaXMuY29uc3RyYWludFRvRXZlbnRzKGNvbnN0cmFpbnQpO1xuXHRcdGlmIChjb25zdHJhaW50RXZlbnRzKSB7IC8vIG5vdCBpbnZhbGlkXG5cblx0XHRcdGFueUNvbnRhaW5tZW50ID0gZmFsc2U7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgY29uc3RyYWludEV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodGhpcy5zcGFuQ29udGFpbnNTcGFuKGNvbnN0cmFpbnRFdmVudHNbaV0sIHNwYW4pKSB7XG5cdFx0XHRcdFx0YW55Q29udGFpbm1lbnQgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICghYW55Q29udGFpbm1lbnQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHBlZXJFdmVudHMgPSB0aGlzLmdldFBlZXJFdmVudHMoc3BhbiwgZXZlbnQpO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBwZWVyRXZlbnRzLmxlbmd0aDsgaSsrKSAge1xuXHRcdHBlZXJFdmVudCA9IHBlZXJFdmVudHNbaV07XG5cblx0XHQvLyB0aGVyZSBuZWVkcyB0byBiZSBhbiBhY3R1YWwgaW50ZXJzZWN0aW9uIGJlZm9yZSBkaXNhbGxvd2luZyBhbnl0aGluZ1xuXHRcdGlmICh0aGlzLmV2ZW50SW50ZXJzZWN0c1JhbmdlKHBlZXJFdmVudCwgc3BhbikpIHtcblxuXHRcdFx0Ly8gZXZhbHVhdGUgb3ZlcmxhcCBmb3IgdGhlIGdpdmVuIHJhbmdlIGFuZCBzaG9ydC1jaXJjdWl0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKG92ZXJsYXAgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIGlmIHRoZSBldmVudCdzIG92ZXJsYXAgaXMgYSB0ZXN0IGZ1bmN0aW9uLCBwYXNzIHRoZSBwZWVyIGV2ZW50IGluIHF1ZXN0aW9uIGFzIHRoZSBmaXJzdCBwYXJhbVxuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIG92ZXJsYXAgPT09ICdmdW5jdGlvbicgJiYgIW92ZXJsYXAocGVlckV2ZW50LCBldmVudCkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiB3ZSBhcmUgY29tcHV0aW5nIGlmIHRoZSBnaXZlbiByYW5nZSBpcyBhbGxvd2FibGUgZm9yIGFuIGV2ZW50LCBjb25zaWRlciB0aGUgb3RoZXIgZXZlbnQnc1xuXHRcdFx0Ly8gRXZlbnRPYmplY3Qtc3BlY2lmaWMgb3IgU291cmNlLXNwZWNpZmljIGBvdmVybGFwYCBwcm9wZXJ0eVxuXHRcdFx0aWYgKGV2ZW50KSB7XG5cdFx0XHRcdHBlZXJPdmVybGFwID0gZmlyc3REZWZpbmVkKFxuXHRcdFx0XHRcdHBlZXJFdmVudC5vdmVybGFwLFxuXHRcdFx0XHRcdChwZWVyRXZlbnQuc291cmNlIHx8IHt9KS5vdmVybGFwXG5cdFx0XHRcdFx0Ly8gd2UgYWxyZWFkeSBjb25zaWRlcmVkIHRoZSBnbG9iYWwgYGV2ZW50T3ZlcmxhcGBcblx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKHBlZXJPdmVybGFwID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiB0aGUgcGVlciBldmVudCdzIG92ZXJsYXAgaXMgYSB0ZXN0IGZ1bmN0aW9uLCBwYXNzIHRoZSBzdWJqZWN0IGV2ZW50IGFzIHRoZSBmaXJzdCBwYXJhbVxuXHRcdFx0XHRpZiAodHlwZW9mIHBlZXJPdmVybGFwID09PSAnZnVuY3Rpb24nICYmICFwZWVyT3ZlcmxhcChldmVudCwgcGVlckV2ZW50KSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuXG4vLyBHaXZlbiBhbiBldmVudCBpbnB1dCBmcm9tIHRoZSBBUEksIHByb2R1Y2VzIGFuIGFycmF5IG9mIGV2ZW50IG9iamVjdHMuIFBvc3NpYmxlIGV2ZW50IGlucHV0czpcbi8vICdidXNpbmVzc0hvdXJzJ1xuLy8gQW4gZXZlbnQgSUQgKG51bWJlciBvciBzdHJpbmcpXG4vLyBBbiBvYmplY3Qgd2l0aCBzcGVjaWZpYyBzdGFydC9lbmQgZGF0ZXMgb3IgYSByZWN1cnJpbmcgZXZlbnQgKGxpa2Ugd2hhdCBidXNpbmVzc0hvdXJzIGFjY2VwdHMpXG5DYWxlbmRhci5wcm90b3R5cGUuY29uc3RyYWludFRvRXZlbnRzID0gZnVuY3Rpb24oY29uc3RyYWludElucHV0KSB7XG5cblx0aWYgKGNvbnN0cmFpbnRJbnB1dCA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q3VycmVudEJ1c2luZXNzSG91ckV2ZW50cygpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBjb25zdHJhaW50SW5wdXQgPT09ICdvYmplY3QnKSB7XG5cdFx0aWYgKGNvbnN0cmFpbnRJbnB1dC5zdGFydCAhPSBudWxsKSB7IC8vIG5lZWRzIHRvIGJlIGV2ZW50LWxpa2UgaW5wdXRcblx0XHRcdHJldHVybiB0aGlzLmV4cGFuZEV2ZW50KHRoaXMuYnVpbGRFdmVudEZyb21JbnB1dChjb25zdHJhaW50SW5wdXQpKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDsgLy8gaW52YWxpZFxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzLmNsaWVudEV2ZW50cyhjb25zdHJhaW50SW5wdXQpOyAvLyBwcm9iYWJseSBhbiBJRFxufTtcblxuXG4vLyBEb2VzIHRoZSBldmVudCdzIGRhdGUgcmFuZ2UgaW50ZXJzZWN0IHdpdGggdGhlIGdpdmVuIHJhbmdlP1xuLy8gc3RhcnQvZW5kIGFscmVhZHkgYXNzdW1lZCB0byBoYXZlIHN0cmlwcGVkIHpvbmVzIDooXG5DYWxlbmRhci5wcm90b3R5cGUuZXZlbnRJbnRlcnNlY3RzUmFuZ2UgPSBmdW5jdGlvbihldmVudCwgcmFuZ2UpIHtcblx0dmFyIGV2ZW50U3RhcnQgPSBldmVudC5zdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpO1xuXHR2YXIgZXZlbnRFbmQgPSB0aGlzLmdldEV2ZW50RW5kKGV2ZW50KS5zdHJpcFpvbmUoKTtcblxuXHRyZXR1cm4gcmFuZ2Uuc3RhcnQgPCBldmVudEVuZCAmJiByYW5nZS5lbmQgPiBldmVudFN0YXJ0O1xufTtcblxuXG4vKiBCdXNpbmVzcyBIb3Vyc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG52YXIgQlVTSU5FU1NfSE9VUl9FVkVOVF9ERUZBVUxUUyA9IHtcblx0aWQ6ICdfZmNCdXNpbmVzc0hvdXJzJywgLy8gd2lsbCByZWxhdGUgZXZlbnRzIGZyb20gZGlmZmVyZW50IGNhbGxzIHRvIGV4cGFuZEV2ZW50XG5cdHN0YXJ0OiAnMDk6MDAnLFxuXHRlbmQ6ICcxNzowMCcsXG5cdGRvdzogWyAxLCAyLCAzLCA0LCA1IF0sIC8vIG1vbmRheSAtIGZyaWRheVxuXHRyZW5kZXJpbmc6ICdpbnZlcnNlLWJhY2tncm91bmQnXG5cdC8vIGNsYXNzTmFtZXMgYXJlIGRlZmluZWQgaW4gYnVzaW5lc3NIb3Vyc1NlZ0NsYXNzZXNcbn07XG5cbi8vIFJldHVybiBldmVudHMgb2JqZWN0cyBmb3IgYnVzaW5lc3MgaG91cnMgd2l0aGluIHRoZSBjdXJyZW50IHZpZXcuXG4vLyBBYnVzZSBvZiBvdXIgZXZlbnQgc3lzdGVtIDooXG5DYWxlbmRhci5wcm90b3R5cGUuZ2V0Q3VycmVudEJ1c2luZXNzSG91ckV2ZW50cyA9IGZ1bmN0aW9uKHdob2xlRGF5KSB7XG5cdHJldHVybiB0aGlzLmNvbXB1dGVCdXNpbmVzc0hvdXJFdmVudHMod2hvbGVEYXksIHRoaXMub3B0KCdidXNpbmVzc0hvdXJzJykpO1xufTtcblxuLy8gR2l2ZW4gYSByYXcgaW5wdXQgdmFsdWUgZnJvbSBvcHRpb25zLCByZXR1cm4gZXZlbnRzIG9iamVjdHMgZm9yIGJ1c2luZXNzIGhvdXJzIHdpdGhpbiB0aGUgY3VycmVudCB2aWV3LlxuQ2FsZW5kYXIucHJvdG90eXBlLmNvbXB1dGVCdXNpbmVzc0hvdXJFdmVudHMgPSBmdW5jdGlvbih3aG9sZURheSwgaW5wdXQpIHtcblx0aWYgKGlucHV0ID09PSB0cnVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kQnVzaW5lc3NIb3VyRXZlbnRzKHdob2xlRGF5LCBbIHt9IF0pO1xuXHR9XG5cdGVsc2UgaWYgKCQuaXNQbGFpbk9iamVjdChpbnB1dCkpIHtcblx0XHRyZXR1cm4gdGhpcy5leHBhbmRCdXNpbmVzc0hvdXJFdmVudHMod2hvbGVEYXksIFsgaW5wdXQgXSk7XG5cdH1cblx0ZWxzZSBpZiAoJC5pc0FycmF5KGlucHV0KSkge1xuXHRcdHJldHVybiB0aGlzLmV4cGFuZEJ1c2luZXNzSG91ckV2ZW50cyh3aG9sZURheSwgaW5wdXQsIHRydWUpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdHJldHVybiBbXTtcblx0fVxufTtcblxuLy8gaW5wdXRzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5IG9mIG9iamVjdHMuXG4vLyBpZiBpZ25vcmVOb0RvdyBpcyB0cnVlLCB3aWxsIGlnbm9yZSBlbnRyaWVzIHRoYXQgZG9uJ3Qgc3BlY2lmeSBhIGRheS1vZi13ZWVrIChkb3cpIGtleS5cbkNhbGVuZGFyLnByb3RvdHlwZS5leHBhbmRCdXNpbmVzc0hvdXJFdmVudHMgPSBmdW5jdGlvbih3aG9sZURheSwgaW5wdXRzLCBpZ25vcmVOb0Rvdykge1xuXHR2YXIgdmlldyA9IHRoaXMuZ2V0VmlldygpO1xuXHR2YXIgZXZlbnRzID0gW107XG5cdHZhciBpLCBpbnB1dDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aW5wdXQgPSBpbnB1dHNbaV07XG5cblx0XHRpZiAoaWdub3JlTm9Eb3cgJiYgIWlucHV0LmRvdykge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Ly8gZ2l2ZSBkZWZhdWx0cy4gd2lsbCBtYWtlIGEgY29weVxuXHRcdGlucHV0ID0gJC5leHRlbmQoe30sIEJVU0lORVNTX0hPVVJfRVZFTlRfREVGQVVMVFMsIGlucHV0KTtcblxuXHRcdC8vIGlmIGEgd2hvbGUtZGF5IHNlcmllcyBpcyByZXF1ZXN0ZWQsIGNsZWFyIHRoZSBzdGFydC9lbmQgdGltZXNcblx0XHRpZiAod2hvbGVEYXkpIHtcblx0XHRcdGlucHV0LnN0YXJ0ID0gbnVsbDtcblx0XHRcdGlucHV0LmVuZCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0ZXZlbnRzLnB1c2guYXBwbHkoZXZlbnRzLCAvLyBhcHBlbmRcblx0XHRcdHRoaXMuZXhwYW5kRXZlbnQoXG5cdFx0XHRcdHRoaXMuYnVpbGRFdmVudEZyb21JbnB1dChpbnB1dCksXG5cdFx0XHRcdHZpZXcuYWN0aXZlUmFuZ2Uuc3RhcnQsXG5cdFx0XHRcdHZpZXcuYWN0aXZlUmFuZ2UuZW5kXG5cdFx0XHQpXG5cdFx0KTtcblx0fVxuXG5cdHJldHVybiBldmVudHM7XG59O1xuXG47O1xuXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgdGhlIFwiYmFzaWNcIiB2aWV3cywgYXMgd2VsbCBhcyBtb250aCB2aWV3LiBSZW5kZXJzIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNlbGxzLlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBJdCBpcyBhIG1hbmFnZXIgZm9yIGEgRGF5R3JpZCBzdWJjb21wb25lbnQsIHdoaWNoIGRvZXMgbW9zdCBvZiB0aGUgaGVhdnkgbGlmdGluZy5cbi8vIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXG5cbnZhciBCYXNpY1ZpZXcgPSBGQy5CYXNpY1ZpZXcgPSBWaWV3LmV4dGVuZCh7XG5cblx0c2Nyb2xsZXI6IG51bGwsXG5cblx0ZGF5R3JpZENsYXNzOiBEYXlHcmlkLCAvLyBjbGFzcyB0aGUgZGF5R3JpZCB3aWxsIGJlIGluc3RhbnRpYXRlZCBmcm9tIChvdmVycmlkYWJsZSBieSBzdWJjbGFzc2VzKVxuXHRkYXlHcmlkOiBudWxsLCAvLyB0aGUgbWFpbiBzdWJjb21wb25lbnQgdGhhdCBkb2VzIG1vc3Qgb2YgdGhlIGhlYXZ5IGxpZnRpbmdcblxuXHRkYXlOdW1iZXJzVmlzaWJsZTogZmFsc2UsIC8vIGRpc3BsYXkgZGF5IG51bWJlcnMgb24gZWFjaCBkYXkgY2VsbD9cblx0Y29sV2Vla051bWJlcnNWaXNpYmxlOiBmYWxzZSwgLy8gZGlzcGxheSB3ZWVrIG51bWJlcnMgYWxvbmcgdGhlIHNpZGU/XG5cdGNlbGxXZWVrTnVtYmVyc1Zpc2libGU6IGZhbHNlLCAvLyBkaXNwbGF5IHdlZWsgbnVtYmVycyBpbiBkYXkgY2VsbD9cblxuXHR3ZWVrTnVtYmVyV2lkdGg6IG51bGwsIC8vIHdpZHRoIG9mIGFsbCB0aGUgd2Vlay1udW1iZXIgY2VsbHMgcnVubmluZyBkb3duIHRoZSBzaWRlXG5cblx0aGVhZENvbnRhaW5lckVsOiBudWxsLCAvLyBkaXYgdGhhdCBob2xkJ3MgdGhlIGRheUdyaWQncyByZW5kZXJlZCBkYXRlIGhlYWRlclxuXHRoZWFkUm93RWw6IG51bGwsIC8vIHRoZSBmYWtlIHJvdyBlbGVtZW50IG9mIHRoZSBkYXktb2Ytd2VlayBoZWFkZXJcblxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5R3JpZCA9IHRoaXMuaW5zdGFudGlhdGVEYXlHcmlkKCk7XG5cblx0XHR0aGlzLnNjcm9sbGVyID0gbmV3IFNjcm9sbGVyKHtcblx0XHRcdG92ZXJmbG93WDogJ2hpZGRlbicsXG5cdFx0XHRvdmVyZmxvd1k6ICdhdXRvJ1xuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBEYXlHcmlkIG9iamVjdCB0aGlzIHZpZXcgbmVlZHMuIERyYXdzIGZyb20gdGhpcy5kYXlHcmlkQ2xhc3Ncblx0aW5zdGFudGlhdGVEYXlHcmlkOiBmdW5jdGlvbigpIHtcblx0XHQvLyBnZW5lcmF0ZSBhIHN1YmNsYXNzIG9uIHRoZSBmbHkgd2l0aCBCYXNpY1ZpZXctc3BlY2lmaWMgYmVoYXZpb3Jcblx0XHQvLyBUT0RPOiBjYWNoZSB0aGlzIHN1YmNsYXNzXG5cdFx0dmFyIHN1YmNsYXNzID0gdGhpcy5kYXlHcmlkQ2xhc3MuZXh0ZW5kKGJhc2ljRGF5R3JpZE1ldGhvZHMpO1xuXG5cdFx0cmV0dXJuIG5ldyBzdWJjbGFzcyh0aGlzKTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIHRoZSBkYXRlIHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZC5cblx0YnVpbGRSZW5kZXJSYW5nZTogZnVuY3Rpb24oY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0KSB7XG5cdFx0dmFyIHJlbmRlclJhbmdlID0gVmlldy5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0Ly8geWVhciBhbmQgbW9udGggdmlld3Mgc2hvdWxkIGJlIGFsaWduZWQgd2l0aCB3ZWVrcy4gdGhpcyBpcyBhbHJlYWR5IGRvbmUgZm9yIHdlZWtcblx0XHRpZiAoL14oeWVhcnxtb250aCkkLy50ZXN0KGN1cnJlbnRSYW5nZVVuaXQpKSB7XG5cdFx0XHRyZW5kZXJSYW5nZS5zdGFydC5zdGFydE9mKCd3ZWVrJyk7XG5cblx0XHRcdC8vIG1ha2UgZW5kLW9mLXdlZWsgaWYgbm90IGFscmVhZHlcblx0XHRcdGlmIChyZW5kZXJSYW5nZS5lbmQud2Vla2RheSgpKSB7XG5cdFx0XHRcdHJlbmRlclJhbmdlLmVuZC5hZGQoMSwgJ3dlZWsnKS5zdGFydE9mKCd3ZWVrJyk7IC8vIGV4Y2x1c2l2ZWx5IG1vdmUgYmFja3dhcmRzXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMudHJpbUhpZGRlbkRheXMocmVuZGVyUmFuZ2UpO1xuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgdmlldyBpbnRvIGB0aGlzLmVsYCwgd2hpY2ggc2hvdWxkIGFscmVhZHkgYmUgYXNzaWduZWRcblx0cmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dGhpcy5kYXlHcmlkLmJyZWFrT25XZWVrcyA9IC95ZWFyfG1vbnRofHdlZWsvLnRlc3QodGhpcy5jdXJyZW50UmFuZ2VVbml0KTsgLy8gZG8gYmVmb3JlIEdyaWQ6OnNldFJhbmdlXG5cdFx0dGhpcy5kYXlHcmlkLnNldFJhbmdlKHRoaXMucmVuZGVyUmFuZ2UpO1xuXG5cdFx0dGhpcy5kYXlOdW1iZXJzVmlzaWJsZSA9IHRoaXMuZGF5R3JpZC5yb3dDbnQgPiAxOyAvLyBUT0RPOiBtYWtlIGdyaWQgcmVzcG9uc2libGVcblx0XHRpZiAodGhpcy5vcHQoJ3dlZWtOdW1iZXJzJykpIHtcblx0XHRcdGlmICh0aGlzLm9wdCgnd2Vla051bWJlcnNXaXRoaW5EYXlzJykpIHtcblx0XHRcdFx0dGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLmNlbGxXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUgPSB0cnVlO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0dGhpcy5kYXlHcmlkLm51bWJlcnNWaXNpYmxlID0gdGhpcy5kYXlOdW1iZXJzVmlzaWJsZSB8fFxuXHRcdFx0dGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlIHx8IHRoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlO1xuXG5cdFx0dGhpcy5lbC5hZGRDbGFzcygnZmMtYmFzaWMtdmlldycpLmh0bWwodGhpcy5yZW5kZXJTa2VsZXRvbkh0bWwoKSk7XG5cdFx0dGhpcy5yZW5kZXJIZWFkKCk7XG5cblx0XHR0aGlzLnNjcm9sbGVyLnJlbmRlcigpO1xuXHRcdHZhciBkYXlHcmlkQ29udGFpbmVyRWwgPSB0aGlzLnNjcm9sbGVyLmVsLmFkZENsYXNzKCdmYy1kYXktZ3JpZC1jb250YWluZXInKTtcblx0XHR2YXIgZGF5R3JpZEVsID0gJCgnPGRpdiBjbGFzcz1cImZjLWRheS1ncmlkXCIgLz4nKS5hcHBlbmRUbyhkYXlHcmlkQ29udGFpbmVyRWwpO1xuXHRcdHRoaXMuZWwuZmluZCgnLmZjLWJvZHkgPiB0ciA+IHRkJykuYXBwZW5kKGRheUdyaWRDb250YWluZXJFbCk7XG5cblx0XHR0aGlzLmRheUdyaWQuc2V0RWxlbWVudChkYXlHcmlkRWwpO1xuXHRcdHRoaXMuZGF5R3JpZC5yZW5kZXJEYXRlcyh0aGlzLmhhc1JpZ2lkUm93cygpKTtcblx0fSxcblxuXG5cdC8vIHJlbmRlciB0aGUgZGF5LW9mLXdlZWsgaGVhZGVyc1xuXHRyZW5kZXJIZWFkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhlYWRDb250YWluZXJFbCA9XG5cdFx0XHR0aGlzLmVsLmZpbmQoJy5mYy1oZWFkLWNvbnRhaW5lcicpXG5cdFx0XHRcdC5odG1sKHRoaXMuZGF5R3JpZC5yZW5kZXJIZWFkSHRtbCgpKTtcblx0XHR0aGlzLmhlYWRSb3dFbCA9IHRoaXMuaGVhZENvbnRhaW5lckVsLmZpbmQoJy5mYy1yb3cnKTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyB0aGUgY29udGVudCBvZiB0aGUgdmlldy4gU2luY2Ugd2UgaGF2ZW4ndCBzZXBhcmF0ZWQgc2tlbGV0b24gcmVuZGVyaW5nIGZyb20gZGF0ZSByZW5kZXJpbmcsXG5cdC8vIGFsd2F5cyBjb21wbGV0ZWx5IGtpbGwgdGhlIGRheUdyaWQncyByZW5kZXJpbmcuXG5cdHVucmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5R3JpZC51bnJlbmRlckRhdGVzKCk7XG5cdFx0dGhpcy5kYXlHcmlkLnJlbW92ZUVsZW1lbnQoKTtcblx0XHR0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTtcblx0fSxcblxuXG5cdHJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5R3JpZC5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cdH0sXG5cblxuXHR1bnJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5R3JpZC51bnJlbmRlckJ1c2luZXNzSG91cnMoKTtcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyB0aGUgSFRNTCBza2VsZXRvbiBmb3IgdGhlIHZpZXcuXG5cdC8vIFRoZSBkYXktZ3JpZCBjb21wb25lbnQgd2lsbCByZW5kZXIgaW5zaWRlIG9mIGEgY29udGFpbmVyIGRlZmluZWQgYnkgdGhpcyBIVE1MLlxuXHRyZW5kZXJTa2VsZXRvbkh0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAnJyArXG5cdFx0XHQnPHRhYmxlPicgK1xuXHRcdFx0XHQnPHRoZWFkIGNsYXNzPVwiZmMtaGVhZFwiPicgK1xuXHRcdFx0XHRcdCc8dHI+JyArXG5cdFx0XHRcdFx0XHQnPHRkIGNsYXNzPVwiZmMtaGVhZC1jb250YWluZXIgJyArIHRoaXMud2lkZ2V0SGVhZGVyQ2xhc3MgKyAnXCI+PC90ZD4nICtcblx0XHRcdFx0XHQnPC90cj4nICtcblx0XHRcdFx0JzwvdGhlYWQ+JyArXG5cdFx0XHRcdCc8dGJvZHkgY2xhc3M9XCJmYy1ib2R5XCI+JyArXG5cdFx0XHRcdFx0Jzx0cj4nICtcblx0XHRcdFx0XHRcdCc8dGQgY2xhc3M9XCInICsgdGhpcy53aWRnZXRDb250ZW50Q2xhc3MgKyAnXCI+PC90ZD4nICtcblx0XHRcdFx0XHQnPC90cj4nICtcblx0XHRcdFx0JzwvdGJvZHk+JyArXG5cdFx0XHQnPC90YWJsZT4nO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIGFuIEhUTUwgYXR0cmlidXRlIHN0cmluZyBmb3Igc2V0dGluZyB0aGUgd2lkdGggb2YgdGhlIHdlZWsgbnVtYmVyIGNvbHVtbiwgaWYgaXQgaXMga25vd25cblx0d2Vla051bWJlclN0eWxlQXR0cjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMud2Vla051bWJlcldpZHRoICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gJ3N0eWxlPVwid2lkdGg6JyArIHRoaXMud2Vla051bWJlcldpZHRoICsgJ3B4XCInO1xuXHRcdH1cblx0XHRyZXR1cm4gJyc7XG5cdH0sXG5cblxuXHQvLyBEZXRlcm1pbmVzIHdoZXRoZXIgZWFjaCByb3cgc2hvdWxkIGhhdmUgYSBjb25zdGFudCBoZWlnaHRcblx0aGFzUmlnaWRSb3dzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZXZlbnRMaW1pdCA9IHRoaXMub3B0KCdldmVudExpbWl0Jyk7XG5cdFx0cmV0dXJuIGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInO1xuXHR9LFxuXG5cblx0LyogRGltZW5zaW9uc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVmcmVzaGVzIHRoZSBob3Jpem9udGFsIGRpbWVuc2lvbnMgb2YgdGhlIHZpZXdcblx0dXBkYXRlV2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xuXHRcdFx0Ly8gTWFrZSBzdXJlIGFsbCB3ZWVrIG51bWJlciBjZWxscyBydW5uaW5nIGRvd24gdGhlIHNpZGUgaGF2ZSB0aGUgc2FtZSB3aWR0aC5cblx0XHRcdC8vIFJlY29yZCB0aGUgd2lkdGggZm9yIGNlbGxzIGNyZWF0ZWQgbGF0ZXIuXG5cdFx0XHR0aGlzLndlZWtOdW1iZXJXaWR0aCA9IG1hdGNoQ2VsbFdpZHRocyhcblx0XHRcdFx0dGhpcy5lbC5maW5kKCcuZmMtd2Vlay1udW1iZXInKVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBBZGp1c3RzIHRoZSB2ZXJ0aWNhbCBkaW1lbnNpb25zIG9mIHRoZSB2aWV3IHRvIHRoZSBzcGVjaWZpZWQgdmFsdWVzXG5cdHNldEhlaWdodDogZnVuY3Rpb24odG90YWxIZWlnaHQsIGlzQXV0bykge1xuXHRcdHZhciBldmVudExpbWl0ID0gdGhpcy5vcHQoJ2V2ZW50TGltaXQnKTtcblx0XHR2YXIgc2Nyb2xsZXJIZWlnaHQ7XG5cdFx0dmFyIHNjcm9sbGJhcldpZHRocztcblxuXHRcdC8vIHJlc2V0IGFsbCBoZWlnaHRzIHRvIGJlIG5hdHVyYWxcblx0XHR0aGlzLnNjcm9sbGVyLmNsZWFyKCk7XG5cdFx0dW5jb21wZW5zYXRlU2Nyb2xsKHRoaXMuaGVhZFJvd0VsKTtcblxuXHRcdHRoaXMuZGF5R3JpZC5yZW1vdmVTZWdQb3BvdmVyKCk7IC8vIGtpbGwgdGhlIFwibW9yZVwiIHBvcG92ZXIgaWYgZGlzcGxheWVkXG5cblx0XHQvLyBpcyB0aGUgZXZlbnQgbGltaXQgYSBjb25zdGFudCBsZXZlbCBudW1iZXI/XG5cdFx0aWYgKGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgPT09ICdudW1iZXInKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQubGltaXRSb3dzKGV2ZW50TGltaXQpOyAvLyBsaW1pdCB0aGUgbGV2ZWxzIGZpcnN0IHNvIHRoZSBoZWlnaHQgY2FuIHJlZGlzdHJpYnV0ZSBhZnRlclxuXHRcdH1cblxuXHRcdC8vIGRpc3RyaWJ1dGUgdGhlIGhlaWdodCB0byB0aGUgcm93c1xuXHRcdC8vICh0b3RhbEhlaWdodCBpcyBhIFwicmVjb21tZW5kZWRcIiB2YWx1ZSBpZiBpc0F1dG8pXG5cdFx0c2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XG5cdFx0dGhpcy5zZXRHcmlkSGVpZ2h0KHNjcm9sbGVySGVpZ2h0LCBpc0F1dG8pO1xuXG5cdFx0Ly8gaXMgdGhlIGV2ZW50IGxpbWl0IGR5bmFtaWNhbGx5IGNhbGN1bGF0ZWQ/XG5cdFx0aWYgKGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQubGltaXRSb3dzKGV2ZW50TGltaXQpOyAvLyBsaW1pdCB0aGUgbGV2ZWxzIGFmdGVyIHRoZSBncmlkJ3Mgcm93IGhlaWdodHMgaGF2ZSBiZWVuIHNldFxuXHRcdH1cblxuXHRcdGlmICghaXNBdXRvKSB7IC8vIHNob3VsZCB3ZSBmb3JjZSBkaW1lbnNpb25zIG9mIHRoZSBzY3JvbGwgY29udGFpbmVyP1xuXG5cdFx0XHR0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XG5cdFx0XHRzY3JvbGxiYXJXaWR0aHMgPSB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbGJhcldpZHRocygpO1xuXG5cdFx0XHRpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQgfHwgc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7IC8vIHVzaW5nIHNjcm9sbGJhcnM/XG5cblx0XHRcdFx0Y29tcGVuc2F0ZVNjcm9sbCh0aGlzLmhlYWRSb3dFbCwgc2Nyb2xsYmFyV2lkdGhzKTtcblxuXHRcdFx0XHQvLyBkb2luZyB0aGUgc2Nyb2xsYmFyIGNvbXBlbnNhdGlvbiBtaWdodCBoYXZlIGNyZWF0ZWQgdGV4dCBvdmVyZmxvdyB3aGljaCBjcmVhdGVkIG1vcmUgaGVpZ2h0LiByZWRvXG5cdFx0XHRcdHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xuXHRcdFx0XHR0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGd1YXJhbnRlZXMgdGhlIHNhbWUgc2Nyb2xsYmFyIHdpZHRoc1xuXHRcdFx0dGhpcy5zY3JvbGxlci5sb2NrT3ZlcmZsb3coc2Nyb2xsYmFyV2lkdGhzKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBnaXZlbiBhIGRlc2lyZWQgdG90YWwgaGVpZ2h0IG9mIHRoZSB2aWV3LCByZXR1cm5zIHdoYXQgdGhlIGhlaWdodCBvZiB0aGUgc2Nyb2xsZXIgc2hvdWxkIGJlXG5cdGNvbXB1dGVTY3JvbGxlckhlaWdodDogZnVuY3Rpb24odG90YWxIZWlnaHQpIHtcblx0XHRyZXR1cm4gdG90YWxIZWlnaHQgLVxuXHRcdFx0c3VidHJhY3RJbm5lckVsSGVpZ2h0KHRoaXMuZWwsIHRoaXMuc2Nyb2xsZXIuZWwpOyAvLyBldmVyeXRoaW5nIHRoYXQncyBOT1QgdGhlIHNjcm9sbGVyXG5cdH0sXG5cblxuXHQvLyBTZXRzIHRoZSBoZWlnaHQgb2YganVzdCB0aGUgRGF5R3JpZCBjb21wb25lbnQgaW4gdGhpcyB2aWV3XG5cdHNldEdyaWRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCwgaXNBdXRvKSB7XG5cdFx0aWYgKGlzQXV0bykge1xuXHRcdFx0dW5kaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMpOyAvLyBsZXQgdGhlIHJvd3MgYmUgdGhlaXIgbmF0dXJhbCBoZWlnaHQgd2l0aCBubyBleHBhbmRpbmdcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRkaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMsIGhlaWdodCwgdHJ1ZSk7IC8vIHRydWUgPSBjb21wZW5zYXRlIGZvciBoZWlnaHQtaG9nZ2luZyByb3dzXG5cdFx0fVxuXHR9LFxuXG5cblx0LyogU2Nyb2xsXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRjb21wdXRlSW5pdGlhbERhdGVTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7IHRvcDogMCB9O1xuXHR9LFxuXG5cblx0cXVlcnlEYXRlU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4geyB0b3A6IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsVG9wKCkgfTtcblx0fSxcblxuXG5cdGFwcGx5RGF0ZVNjcm9sbDogZnVuY3Rpb24oc2Nyb2xsKSB7XG5cdFx0aWYgKHNjcm9sbC50b3AgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zY3JvbGxlci5zZXRTY3JvbGxUb3Aoc2Nyb2xsLnRvcCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0LyogSGl0IEFyZWFzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdC8vIGZvcndhcmQgYWxsIGhpdC1yZWxhdGVkIG1ldGhvZCBjYWxscyB0byBkYXlHcmlkXG5cblxuXHRoaXRzTmVlZGVkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQuaGl0c05lZWRlZCgpO1xuXHR9LFxuXG5cblx0aGl0c05vdE5lZWRlZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kYXlHcmlkLmhpdHNOb3ROZWVkZWQoKTtcblx0fSxcblxuXG5cdHByZXBhcmVIaXRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQucHJlcGFyZUhpdHMoKTtcblx0fSxcblxuXG5cdHJlbGVhc2VIaXRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQucmVsZWFzZUhpdHMoKTtcblx0fSxcblxuXG5cdHF1ZXJ5SGl0OiBmdW5jdGlvbihsZWZ0LCB0b3ApIHtcblx0XHRyZXR1cm4gdGhpcy5kYXlHcmlkLnF1ZXJ5SGl0KGxlZnQsIHRvcCk7XG5cdH0sXG5cblxuXHRnZXRIaXRTcGFuOiBmdW5jdGlvbihoaXQpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXlHcmlkLmdldEhpdFNwYW4oaGl0KTtcblx0fSxcblxuXG5cdGdldEhpdEVsOiBmdW5jdGlvbihoaXQpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXlHcmlkLmdldEhpdEVsKGhpdCk7XG5cdH0sXG5cblxuXHQvKiBFdmVudHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgdGhlIGdpdmVuIGV2ZW50cyBvbnRvIHRoZSB2aWV3IGFuZCBwb3B1bGF0ZXMgdGhlIHNlZ21lbnRzIGFycmF5XG5cdHJlbmRlckV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnJlbmRlckV2ZW50cyhldmVudHMpO1xuXG5cdFx0dGhpcy51cGRhdGVIZWlnaHQoKTsgLy8gbXVzdCBjb21wZW5zYXRlIGZvciBldmVudHMgdGhhdCBvdmVyZmxvdyB0aGUgcm93XG5cdH0sXG5cblxuXHQvLyBSZXRyaWV2ZXMgYWxsIHNlZ21lbnQgb2JqZWN0cyB0aGF0IGFyZSByZW5kZXJlZCBpbiB0aGUgdmlld1xuXHRnZXRFdmVudFNlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRheUdyaWQuZ2V0RXZlbnRTZWdzKCk7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYWxsIGV2ZW50IGVsZW1lbnRzIGFuZCBjbGVhcnMgaW50ZXJuYWwgc2VnbWVudCBkYXRhXG5cdHVucmVuZGVyRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJFdmVudHMoKTtcblxuXHRcdC8vIHdlIERPTidUIG5lZWQgdG8gY2FsbCB1cGRhdGVIZWlnaHQoKSBiZWNhdXNlXG5cdFx0Ly8gYSByZW5kZXJFdmVudHMoKSBjYWxsIGFsd2F5cyBoYXBwZW5zIGFmdGVyIHRoaXMsIHdoaWNoIHdpbGwgZXZlbnR1YWxseSBjYWxsIHVwZGF0ZUhlaWdodCgpXG5cdH0sXG5cblxuXHQvKiBEcmFnZ2luZyAoZm9yIGJvdGggZXZlbnRzIGFuZCBleHRlcm5hbCBlbGVtZW50cylcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEEgcmV0dXJuZWQgdmFsdWUgb2YgYHRydWVgIHNpZ25hbHMgdGhhdCBhIG1vY2sgXCJoZWxwZXJcIiBldmVudCBoYXMgYmVlbiByZW5kZXJlZC5cblx0cmVuZGVyRHJhZzogZnVuY3Rpb24oZHJvcExvY2F0aW9uLCBzZWcpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXlHcmlkLnJlbmRlckRyYWcoZHJvcExvY2F0aW9uLCBzZWcpO1xuXHR9LFxuXG5cblx0dW5yZW5kZXJEcmFnOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJEcmFnKCk7XG5cdH0sXG5cblxuXHQvKiBTZWxlY3Rpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvblxuXHRyZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHR0aGlzLmRheUdyaWQucmVuZGVyU2VsZWN0aW9uKHNwYW4pO1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb25zIG9mIGEgc2VsZWN0aW9uXG5cdHVucmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJTZWxlY3Rpb24oKTtcblx0fVxuXG59KTtcblxuXG4vLyBNZXRob2RzIHRoYXQgd2lsbCBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBiZWhhdmlvciBvZiB0aGUgQmFzaWNWaWV3J3MgZGF5R3JpZFxudmFyIGJhc2ljRGF5R3JpZE1ldGhvZHMgPSB7XG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCB3aWxsIGdvIGJlZm9yZSB0aGUgZGF5LW9mIHdlZWsgaGVhZGVyIGNlbGxzXG5cdHJlbmRlckhlYWRJbnRyb0h0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0aWYgKHZpZXcuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XG5cdFx0XHRyZXR1cm4gJycgK1xuXHRcdFx0XHQnPHRoIGNsYXNzPVwiZmMtd2Vlay1udW1iZXIgJyArIHZpZXcud2lkZ2V0SGVhZGVyQ2xhc3MgKyAnXCIgJyArIHZpZXcud2Vla051bWJlclN0eWxlQXR0cigpICsgJz4nICtcblx0XHRcdFx0XHQnPHNwYW4+JyArIC8vIG5lZWRlZCBmb3IgbWF0Y2hDZWxsV2lkdGhzXG5cdFx0XHRcdFx0XHRodG1sRXNjYXBlKHZpZXcub3B0KCd3ZWVrTnVtYmVyVGl0bGUnKSkgK1xuXHRcdFx0XHRcdCc8L3NwYW4+JyArXG5cdFx0XHRcdCc8L3RoPic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICcnO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgY29udGVudC1za2VsZXRvbiBjZWxscyB0aGF0IGRpc3BsYXkgdGhlIGRheS93ZWVrIG51bWJlcnNcblx0cmVuZGVyTnVtYmVySW50cm9IdG1sOiBmdW5jdGlvbihyb3cpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgd2Vla1N0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIDApO1xuXG5cdFx0aWYgKHZpZXcuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XG5cdFx0XHRyZXR1cm4gJycgK1xuXHRcdFx0XHQnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXJcIiAnICsgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPicgK1xuXHRcdFx0XHRcdHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbCggLy8gYXNpZGUgZnJvbSBsaW5rLCBpbXBvcnRhbnQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xuXHRcdFx0XHRcdFx0eyBkYXRlOiB3ZWVrU3RhcnQsIHR5cGU6ICd3ZWVrJywgZm9yY2VPZmY6IHRoaXMuY29sQ250ID09PSAxIH0sXG5cdFx0XHRcdFx0XHR3ZWVrU3RhcnQuZm9ybWF0KCd3JykgLy8gaW5uZXIgSFRNTFxuXHRcdFx0XHRcdCkgK1xuXHRcdFx0XHQnPC90ZD4nO1xuXHRcdH1cblxuXHRcdHJldHVybiAnJztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIHRoZSBkYXkgYmcgY2VsbHMgZm9yIGVhY2ggZGF5LXJvd1xuXHRyZW5kZXJCZ0ludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRpZiAodmlldy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcblx0XHRcdHJldHVybiAnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXIgJyArIHZpZXcud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiICcgK1xuXHRcdFx0XHR2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xuXHRcdH1cblxuXHRcdHJldHVybiAnJztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGV2ZXJ5IG90aGVyIHR5cGUgb2Ygcm93IGdlbmVyYXRlZCBieSBEYXlHcmlkLlxuXHQvLyBBZmZlY3RzIGhlbHBlci1za2VsZXRvbiBhbmQgaGlnaGxpZ2h0LXNrZWxldG9uIHJvd3MuXG5cdHJlbmRlckludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRpZiAodmlldy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcblx0XHRcdHJldHVybiAnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXJcIiAnICsgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPjwvdGQ+Jztcblx0XHR9XG5cblx0XHRyZXR1cm4gJyc7XG5cdH1cblxufTtcblxuOztcblxuLyogQSBtb250aCB2aWV3IHdpdGggZGF5IGNlbGxzIHJ1bm5pbmcgaW4gcm93cyAob25lLXBlci13ZWVrKSBhbmQgY29sdW1uc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbnZhciBNb250aFZpZXcgPSBGQy5Nb250aFZpZXcgPSBCYXNpY1ZpZXcuZXh0ZW5kKHtcblxuXG5cdC8vIENvbXB1dGVzIHRoZSBkYXRlIHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZC5cblx0YnVpbGRSZW5kZXJSYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlbmRlclJhbmdlID0gQmFzaWNWaWV3LnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIHJvd0NudDtcblxuXHRcdC8vIGVuc3VyZSA2IHdlZWtzXG5cdFx0aWYgKHRoaXMuaXNGaXhlZFdlZWtzKCkpIHtcblx0XHRcdHJvd0NudCA9IE1hdGguY2VpbCggLy8gY291bGQgYmUgcGFydGlhbCB3ZWVrcyBkdWUgdG8gaGlkZGVuRGF5c1xuXHRcdFx0XHRyZW5kZXJSYW5nZS5lbmQuZGlmZihyZW5kZXJSYW5nZS5zdGFydCwgJ3dlZWtzJywgdHJ1ZSkgLy8gZG9udFJvdW5kPXRydWVcblx0XHRcdCk7XG5cdFx0XHRyZW5kZXJSYW5nZS5lbmQuYWRkKDYgLSByb3dDbnQsICd3ZWVrcycpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZW5kZXJSYW5nZTtcblx0fSxcblxuXG5cdC8vIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBCYXNpY1ZpZXcgYmVoYXZpb3IgdG8gaGF2ZSBzcGVjaWFsIG11bHRpLXdlZWsgYXV0by1oZWlnaHQgbG9naWNcblx0c2V0R3JpZEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0LCBpc0F1dG8pIHtcblxuXHRcdC8vIGlmIGF1dG8sIG1ha2UgdGhlIGhlaWdodCBvZiBlYWNoIHJvdyB0aGUgaGVpZ2h0IHRoYXQgaXQgd291bGQgYmUgaWYgdGhlcmUgd2VyZSA2IHdlZWtzXG5cdFx0aWYgKGlzQXV0bykge1xuXHRcdFx0aGVpZ2h0ICo9IHRoaXMucm93Q250IC8gNjtcblx0XHR9XG5cblx0XHRkaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMsIGhlaWdodCwgIWlzQXV0byk7IC8vIGlmIGF1dG8sIGRvbid0IGNvbXBlbnNhdGUgZm9yIGhlaWdodC1ob2dnaW5nIHJvd3Ncblx0fSxcblxuXG5cdGlzRml4ZWRXZWVrczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0KCdmaXhlZFdlZWtDb3VudCcpO1xuXHR9XG5cbn0pO1xuXG47O1xuXG5mY1ZpZXdzLmJhc2ljID0ge1xuXHQnY2xhc3MnOiBCYXNpY1ZpZXdcbn07XG5cbmZjVmlld3MuYmFzaWNEYXkgPSB7XG5cdHR5cGU6ICdiYXNpYycsXG5cdGR1cmF0aW9uOiB7IGRheXM6IDEgfVxufTtcblxuZmNWaWV3cy5iYXNpY1dlZWsgPSB7XG5cdHR5cGU6ICdiYXNpYycsXG5cdGR1cmF0aW9uOiB7IHdlZWtzOiAxIH1cbn07XG5cbmZjVmlld3MubW9udGggPSB7XG5cdCdjbGFzcyc6IE1vbnRoVmlldyxcblx0ZHVyYXRpb246IHsgbW9udGhzOiAxIH0sIC8vIGltcG9ydGFudCBmb3IgcHJldi9uZXh0XG5cdGRlZmF1bHRzOiB7XG5cdFx0Zml4ZWRXZWVrQ291bnQ6IHRydWVcblx0fVxufTtcbjs7XG5cbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciBhbGwgYWdlbmRhLXJlbGF0ZWQgdmlld3MuIERpc3BsYXlzIG9uZSBtb3JlIGNvbHVtbnMgd2l0aCB0aW1lIHNsb3RzIHJ1bm5pbmcgdmVydGljYWxseS5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gSXMgYSBtYW5hZ2VyIGZvciB0aGUgVGltZUdyaWQgc3ViY29tcG9uZW50IGFuZCBwb3NzaWJseSB0aGUgRGF5R3JpZCBzdWJjb21wb25lbnQgKGlmIGFsbERheVNsb3QgaXMgb24pLlxuLy8gUmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cblxudmFyIEFnZW5kYVZpZXcgPSBGQy5BZ2VuZGFWaWV3ID0gVmlldy5leHRlbmQoe1xuXG5cdHNjcm9sbGVyOiBudWxsLFxuXG5cdHRpbWVHcmlkQ2xhc3M6IFRpbWVHcmlkLCAvLyBjbGFzcyB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSB0aW1lR3JpZC4gc3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGVcblx0dGltZUdyaWQ6IG51bGwsIC8vIHRoZSBtYWluIHRpbWUtZ3JpZCBzdWJjb21wb25lbnQgb2YgdGhpcyB2aWV3XG5cblx0ZGF5R3JpZENsYXNzOiBEYXlHcmlkLCAvLyBjbGFzcyB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBkYXlHcmlkLiBzdWJjbGFzc2VzIGNhbiBvdmVycmlkZVxuXHRkYXlHcmlkOiBudWxsLCAvLyB0aGUgXCJhbGwtZGF5XCIgc3ViY29tcG9uZW50LiBpZiBhbGwtZGF5IGlzIHR1cm5lZCBvZmYsIHRoaXMgd2lsbCBiZSBudWxsXG5cblx0YXhpc1dpZHRoOiBudWxsLCAvLyB0aGUgd2lkdGggb2YgdGhlIHRpbWUgYXhpcyBydW5uaW5nIGRvd24gdGhlIHNpZGVcblxuXHRoZWFkQ29udGFpbmVyRWw6IG51bGwsIC8vIGRpdiB0aGF0IGhvbGQncyB0aGUgdGltZUdyaWQncyByZW5kZXJlZCBkYXRlIGhlYWRlclxuXHRub1Njcm9sbFJvd0VsczogbnVsbCwgLy8gc2V0IG9mIGZha2Ugcm93IGVsZW1lbnRzIHRoYXQgbXVzdCBjb21wZW5zYXRlIHdoZW4gc2Nyb2xsZXIgaGFzIHNjcm9sbGJhcnNcblxuXHQvLyB3aGVuIHRoZSB0aW1lLWdyaWQgaXNuJ3QgdGFsbCBlbm91Z2ggdG8gb2NjdXB5IHRoZSBnaXZlbiBoZWlnaHQsIHdlIHJlbmRlciBhbiA8aHI+IHVuZGVybmVhdGhcblx0Ym90dG9tUnVsZUVsOiBudWxsLFxuXG5cdC8vIGluZGljYXRlcyB0aGF0IG1pblRpbWUvbWF4VGltZSBhZmZlY3RzIHJlbmRlcmluZ1xuXHR1c2VzTWluTWF4VGltZTogdHJ1ZSxcblxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGltZUdyaWQgPSB0aGlzLmluc3RhbnRpYXRlVGltZUdyaWQoKTtcblxuXHRcdGlmICh0aGlzLm9wdCgnYWxsRGF5U2xvdCcpKSB7IC8vIHNob3VsZCB3ZSBkaXNwbGF5IHRoZSBcImFsbC1kYXlcIiBhcmVhP1xuXHRcdFx0dGhpcy5kYXlHcmlkID0gdGhpcy5pbnN0YW50aWF0ZURheUdyaWQoKTsgLy8gdGhlIGFsbC1kYXkgc3ViY29tcG9uZW50IG9mIHRoaXMgdmlld1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsZXIoe1xuXHRcdFx0b3ZlcmZsb3dYOiAnaGlkZGVuJyxcblx0XHRcdG92ZXJmbG93WTogJ2F1dG8nXG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvLyBJbnN0YW50aWF0ZXMgdGhlIFRpbWVHcmlkIG9iamVjdCB0aGlzIHZpZXcgbmVlZHMuIERyYXdzIGZyb20gdGhpcy50aW1lR3JpZENsYXNzXG5cdGluc3RhbnRpYXRlVGltZUdyaWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdWJjbGFzcyA9IHRoaXMudGltZUdyaWRDbGFzcy5leHRlbmQoYWdlbmRhVGltZUdyaWRNZXRob2RzKTtcblxuXHRcdHJldHVybiBuZXcgc3ViY2xhc3ModGhpcyk7XG5cdH0sXG5cblxuXHQvLyBJbnN0YW50aWF0ZXMgdGhlIERheUdyaWQgb2JqZWN0IHRoaXMgdmlldyBtaWdodCBuZWVkLiBEcmF3cyBmcm9tIHRoaXMuZGF5R3JpZENsYXNzXG5cdGluc3RhbnRpYXRlRGF5R3JpZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHN1YmNsYXNzID0gdGhpcy5kYXlHcmlkQ2xhc3MuZXh0ZW5kKGFnZW5kYURheUdyaWRNZXRob2RzKTtcblxuXHRcdHJldHVybiBuZXcgc3ViY2xhc3ModGhpcyk7XG5cdH0sXG5cblxuXHQvKiBSZW5kZXJpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgdGhlIHZpZXcgaW50byBgdGhpcy5lbGAsIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gYXNzaWduZWRcblx0cmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dGhpcy50aW1lR3JpZC5zZXRSYW5nZSh0aGlzLnJlbmRlclJhbmdlKTtcblxuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5zZXRSYW5nZSh0aGlzLnJlbmRlclJhbmdlKTtcblx0XHR9XG5cblx0XHR0aGlzLmVsLmFkZENsYXNzKCdmYy1hZ2VuZGEtdmlldycpLmh0bWwodGhpcy5yZW5kZXJTa2VsZXRvbkh0bWwoKSk7XG5cdFx0dGhpcy5yZW5kZXJIZWFkKCk7XG5cblx0XHR0aGlzLnNjcm9sbGVyLnJlbmRlcigpO1xuXHRcdHZhciB0aW1lR3JpZFdyYXBFbCA9IHRoaXMuc2Nyb2xsZXIuZWwuYWRkQ2xhc3MoJ2ZjLXRpbWUtZ3JpZC1jb250YWluZXInKTtcblx0XHR2YXIgdGltZUdyaWRFbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy10aW1lLWdyaWRcIiAvPicpLmFwcGVuZFRvKHRpbWVHcmlkV3JhcEVsKTtcblx0XHR0aGlzLmVsLmZpbmQoJy5mYy1ib2R5ID4gdHIgPiB0ZCcpLmFwcGVuZCh0aW1lR3JpZFdyYXBFbCk7XG5cblx0XHR0aGlzLnRpbWVHcmlkLnNldEVsZW1lbnQodGltZUdyaWRFbCk7XG5cdFx0dGhpcy50aW1lR3JpZC5yZW5kZXJEYXRlcygpO1xuXG5cdFx0Ly8gdGhlIDxocj4gdGhhdCBzb21ldGltZXMgZGlzcGxheXMgdW5kZXIgdGhlIHRpbWUtZ3JpZFxuXHRcdHRoaXMuYm90dG9tUnVsZUVsID0gJCgnPGhyIGNsYXNzPVwiZmMtZGl2aWRlciAnICsgdGhpcy53aWRnZXRIZWFkZXJDbGFzcyArICdcIi8+Jylcblx0XHRcdC5hcHBlbmRUbyh0aGlzLnRpbWVHcmlkLmVsKTsgLy8gaW5qZWN0IGl0IGludG8gdGhlIHRpbWUtZ3JpZFxuXG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnNldEVsZW1lbnQodGhpcy5lbC5maW5kKCcuZmMtZGF5LWdyaWQnKSk7XG5cdFx0XHR0aGlzLmRheUdyaWQucmVuZGVyRGF0ZXMoKTtcblxuXHRcdFx0Ly8gaGF2ZSB0aGUgZGF5LWdyaWQgZXh0ZW5kIGl0J3MgY29vcmRpbmF0ZSBhcmVhIG92ZXIgdGhlIDxocj4gZGl2aWRpbmcgdGhlIHR3byBncmlkc1xuXHRcdFx0dGhpcy5kYXlHcmlkLmJvdHRvbUNvb3JkUGFkZGluZyA9IHRoaXMuZGF5R3JpZC5lbC5uZXh0KCdocicpLm91dGVySGVpZ2h0KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5ub1Njcm9sbFJvd0VscyA9IHRoaXMuZWwuZmluZCgnLmZjLXJvdzpub3QoLmZjLXNjcm9sbGVyICopJyk7IC8vIGZha2Ugcm93cyBub3Qgd2l0aGluIHRoZSBzY3JvbGxlclxuXHR9LFxuXG5cblx0Ly8gcmVuZGVyIHRoZSBkYXktb2Ytd2VlayBoZWFkZXJzXG5cdHJlbmRlckhlYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVhZENvbnRhaW5lckVsID1cblx0XHRcdHRoaXMuZWwuZmluZCgnLmZjLWhlYWQtY29udGFpbmVyJylcblx0XHRcdFx0Lmh0bWwodGhpcy50aW1lR3JpZC5yZW5kZXJIZWFkSHRtbCgpKTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyB0aGUgY29udGVudCBvZiB0aGUgdmlldy4gU2luY2Ugd2UgaGF2ZW4ndCBzZXBhcmF0ZWQgc2tlbGV0b24gcmVuZGVyaW5nIGZyb20gZGF0ZSByZW5kZXJpbmcsXG5cdC8vIGFsd2F5cyBjb21wbGV0ZWx5IGtpbGwgZWFjaCBncmlkJ3MgcmVuZGVyaW5nLlxuXHR1bnJlbmRlckRhdGVzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnVucmVuZGVyRGF0ZXMoKTtcblx0XHR0aGlzLnRpbWVHcmlkLnJlbW92ZUVsZW1lbnQoKTtcblxuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC51bnJlbmRlckRhdGVzKCk7XG5cdFx0XHR0aGlzLmRheUdyaWQucmVtb3ZlRWxlbWVudCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpO1xuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIHRoZSBIVE1MIHNrZWxldG9uIGZvciB0aGUgdmlldy5cblx0Ly8gVGhlIGRheS1ncmlkIGFuZCB0aW1lLWdyaWQgY29tcG9uZW50cyB3aWxsIHJlbmRlciBpbnNpZGUgY29udGFpbmVycyBkZWZpbmVkIGJ5IHRoaXMgSFRNTC5cblx0cmVuZGVyU2tlbGV0b25IdG1sOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0Jzx0YWJsZT4nICtcblx0XHRcdFx0Jzx0aGVhZCBjbGFzcz1cImZjLWhlYWRcIj4nICtcblx0XHRcdFx0XHQnPHRyPicgK1xuXHRcdFx0XHRcdFx0Jzx0ZCBjbGFzcz1cImZjLWhlYWQtY29udGFpbmVyICcgKyB0aGlzLndpZGdldEhlYWRlckNsYXNzICsgJ1wiPjwvdGQ+JyArXG5cdFx0XHRcdFx0JzwvdHI+JyArXG5cdFx0XHRcdCc8L3RoZWFkPicgK1xuXHRcdFx0XHQnPHRib2R5IGNsYXNzPVwiZmMtYm9keVwiPicgK1xuXHRcdFx0XHRcdCc8dHI+JyArXG5cdFx0XHRcdFx0XHQnPHRkIGNsYXNzPVwiJyArIHRoaXMud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHRcdFx0XHQodGhpcy5kYXlHcmlkID9cblx0XHRcdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWRheS1ncmlkXCIvPicgK1xuXHRcdFx0XHRcdFx0XHRcdCc8aHIgY2xhc3M9XCJmYy1kaXZpZGVyICcgKyB0aGlzLndpZGdldEhlYWRlckNsYXNzICsgJ1wiLz4nIDpcblx0XHRcdFx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdFx0XHRcdCkgK1xuXHRcdFx0XHRcdFx0JzwvdGQ+JyArXG5cdFx0XHRcdFx0JzwvdHI+JyArXG5cdFx0XHRcdCc8L3Rib2R5PicgK1xuXHRcdFx0JzwvdGFibGU+Jztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyBhbiBIVE1MIGF0dHJpYnV0ZSBzdHJpbmcgZm9yIHNldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSBheGlzLCBpZiBpdCBpcyBrbm93blxuXHRheGlzU3R5bGVBdHRyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5heGlzV2lkdGggIT09IG51bGwpIHtcblx0XHRcdCByZXR1cm4gJ3N0eWxlPVwid2lkdGg6JyArIHRoaXMuYXhpc1dpZHRoICsgJ3B4XCInO1xuXHRcdH1cblx0XHRyZXR1cm4gJyc7XG5cdH0sXG5cblxuXHQvKiBCdXNpbmVzcyBIb3Vyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQucmVuZGVyQnVzaW5lc3NIb3VycygpO1xuXHRcdH1cblx0fSxcblxuXG5cdHVucmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC51bnJlbmRlckJ1c2luZXNzSG91cnMoKTtcblxuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC51bnJlbmRlckJ1c2luZXNzSG91cnMoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBOb3cgSW5kaWNhdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRnZXROb3dJbmRpY2F0b3JVbml0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50aW1lR3JpZC5nZXROb3dJbmRpY2F0b3JVbml0KCk7XG5cdH0sXG5cblxuXHRyZW5kZXJOb3dJbmRpY2F0b3I6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnJlbmRlck5vd0luZGljYXRvcihkYXRlKTtcblx0fSxcblxuXG5cdHVucmVuZGVyTm93SW5kaWNhdG9yOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnVucmVuZGVyTm93SW5kaWNhdG9yKCk7XG5cdH0sXG5cblxuXHQvKiBEaW1lbnNpb25zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHR1cGRhdGVTaXplOiBmdW5jdGlvbihpc1Jlc2l6ZSkge1xuXHRcdHRoaXMudGltZUdyaWQudXBkYXRlU2l6ZShpc1Jlc2l6ZSk7XG5cblx0XHRWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplLmNhbGwodGhpcywgaXNSZXNpemUpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2Rcblx0fSxcblxuXG5cdC8vIFJlZnJlc2hlcyB0aGUgaG9yaXpvbnRhbCBkaW1lbnNpb25zIG9mIHRoZSB2aWV3XG5cdHVwZGF0ZVdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHQvLyBtYWtlIGFsbCBheGlzIGNlbGxzIGxpbmUgdXAsIGFuZCByZWNvcmQgdGhlIHdpZHRoIHNvIG5ld2x5IGNyZWF0ZWQgYXhpcyBjZWxscyB3aWxsIGhhdmUgaXRcblx0XHR0aGlzLmF4aXNXaWR0aCA9IG1hdGNoQ2VsbFdpZHRocyh0aGlzLmVsLmZpbmQoJy5mYy1heGlzJykpO1xuXHR9LFxuXG5cblx0Ly8gQWRqdXN0cyB0aGUgdmVydGljYWwgZGltZW5zaW9ucyBvZiB0aGUgdmlldyB0byB0aGUgc3BlY2lmaWVkIHZhbHVlc1xuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKHRvdGFsSGVpZ2h0LCBpc0F1dG8pIHtcblx0XHR2YXIgZXZlbnRMaW1pdDtcblx0XHR2YXIgc2Nyb2xsZXJIZWlnaHQ7XG5cdFx0dmFyIHNjcm9sbGJhcldpZHRocztcblxuXHRcdC8vIHJlc2V0IGFsbCBkaW1lbnNpb25zIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHN0YXRlXG5cdFx0dGhpcy5ib3R0b21SdWxlRWwuaGlkZSgpOyAvLyAuc2hvdygpIHdpbGwgYmUgY2FsbGVkIGxhdGVyIGlmIHRoaXMgPGhyPiBpcyBuZWNlc3Nhcnlcblx0XHR0aGlzLnNjcm9sbGVyLmNsZWFyKCk7IC8vIHNldHMgaGVpZ2h0IHRvICdhdXRvJyBhbmQgY2xlYXJzIG92ZXJmbG93XG5cdFx0dW5jb21wZW5zYXRlU2Nyb2xsKHRoaXMubm9TY3JvbGxSb3dFbHMpO1xuXG5cdFx0Ly8gbGltaXQgbnVtYmVyIG9mIGV2ZW50cyBpbiB0aGUgYWxsLWRheSBhcmVhXG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnJlbW92ZVNlZ1BvcG92ZXIoKTsgLy8ga2lsbCB0aGUgXCJtb3JlXCIgcG9wb3ZlciBpZiBkaXNwbGF5ZWRcblxuXHRcdFx0ZXZlbnRMaW1pdCA9IHRoaXMub3B0KCdldmVudExpbWl0Jyk7XG5cdFx0XHRpZiAoZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCAhPT0gJ251bWJlcicpIHtcblx0XHRcdFx0ZXZlbnRMaW1pdCA9IEFHRU5EQV9BTExfREFZX0VWRU5UX0xJTUlUOyAvLyBtYWtlIHN1cmUgXCJhdXRvXCIgZ29lcyB0byBhIHJlYWwgbnVtYmVyXG5cdFx0XHR9XG5cdFx0XHRpZiAoZXZlbnRMaW1pdCkge1xuXHRcdFx0XHR0aGlzLmRheUdyaWQubGltaXRSb3dzKGV2ZW50TGltaXQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghaXNBdXRvKSB7IC8vIHNob3VsZCB3ZSBmb3JjZSBkaW1lbnNpb25zIG9mIHRoZSBzY3JvbGwgY29udGFpbmVyP1xuXG5cdFx0XHRzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcblx0XHRcdHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcblx0XHRcdHNjcm9sbGJhcldpZHRocyA9IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XG5cblx0XHRcdGlmIChzY3JvbGxiYXJXaWR0aHMubGVmdCB8fCBzY3JvbGxiYXJXaWR0aHMucmlnaHQpIHsgLy8gdXNpbmcgc2Nyb2xsYmFycz9cblxuXHRcdFx0XHQvLyBtYWtlIHRoZSBhbGwtZGF5IGFuZCBoZWFkZXIgcm93cyBsaW5lcyB1cFxuXHRcdFx0XHRjb21wZW5zYXRlU2Nyb2xsKHRoaXMubm9TY3JvbGxSb3dFbHMsIHNjcm9sbGJhcldpZHRocyk7XG5cblx0XHRcdFx0Ly8gdGhlIHNjcm9sbGJhciBjb21wZW5zYXRpb24gbWlnaHQgaGF2ZSBjaGFuZ2VkIHRleHQgZmxvdywgd2hpY2ggbWlnaHQgYWZmZWN0IGhlaWdodCwgc28gcmVjYWxjdWxhdGVcblx0XHRcdFx0Ly8gYW5kIHJlYXBwbHkgdGhlIGRlc2lyZWQgaGVpZ2h0IHRvIHRoZSBzY3JvbGxlci5cblx0XHRcdFx0c2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ3VhcmFudGVlcyB0aGUgc2FtZSBzY3JvbGxiYXIgd2lkdGhzXG5cdFx0XHR0aGlzLnNjcm9sbGVyLmxvY2tPdmVyZmxvdyhzY3JvbGxiYXJXaWR0aHMpO1xuXG5cdFx0XHQvLyBpZiB0aGVyZSdzIGFueSBzcGFjZSBiZWxvdyB0aGUgc2xhdHMsIHNob3cgdGhlIGhvcml6b250YWwgcnVsZS5cblx0XHRcdC8vIHRoaXMgd29uJ3QgY2F1c2UgYW55IG5ldyBvdmVyZmxvdywgYmVjYXVzZSBsb2NrT3ZlcmZsb3cgYWxyZWFkeSBjYWxsZWQuXG5cdFx0XHRpZiAodGhpcy50aW1lR3JpZC5nZXRUb3RhbFNsYXRIZWlnaHQoKSA8IHNjcm9sbGVySGVpZ2h0KSB7XG5cdFx0XHRcdHRoaXMuYm90dG9tUnVsZUVsLnNob3coKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBnaXZlbiBhIGRlc2lyZWQgdG90YWwgaGVpZ2h0IG9mIHRoZSB2aWV3LCByZXR1cm5zIHdoYXQgdGhlIGhlaWdodCBvZiB0aGUgc2Nyb2xsZXIgc2hvdWxkIGJlXG5cdGNvbXB1dGVTY3JvbGxlckhlaWdodDogZnVuY3Rpb24odG90YWxIZWlnaHQpIHtcblx0XHRyZXR1cm4gdG90YWxIZWlnaHQgLVxuXHRcdFx0c3VidHJhY3RJbm5lckVsSGVpZ2h0KHRoaXMuZWwsIHRoaXMuc2Nyb2xsZXIuZWwpOyAvLyBldmVyeXRoaW5nIHRoYXQncyBOT1QgdGhlIHNjcm9sbGVyXG5cdH0sXG5cblxuXHQvKiBTY3JvbGxcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIENvbXB1dGVzIHRoZSBpbml0aWFsIHByZS1jb25maWd1cmVkIHNjcm9sbCBzdGF0ZSBwcmlvciB0byBhbGxvd2luZyB0aGUgdXNlciB0byBjaGFuZ2UgaXRcblx0Y29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2Nyb2xsVGltZSA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm9wdCgnc2Nyb2xsVGltZScpKTtcblx0XHR2YXIgdG9wID0gdGhpcy50aW1lR3JpZC5jb21wdXRlVGltZVRvcChzY3JvbGxUaW1lKTtcblxuXHRcdC8vIHpvb20gY2FuIGdpdmUgd2VpcmQgZmxvYXRpbmctcG9pbnQgdmFsdWVzLiByYXRoZXIgc2Nyb2xsIGEgbGl0dGxlIGJpdCBmdXJ0aGVyXG5cdFx0dG9wID0gTWF0aC5jZWlsKHRvcCk7XG5cblx0XHRpZiAodG9wKSB7XG5cdFx0XHR0b3ArKzsgLy8gdG8gb3ZlcmNvbWUgdG9wIGJvcmRlciB0aGF0IHNsb3RzIGJleW9uZCB0aGUgZmlyc3QgaGF2ZS4gbG9va3MgYmV0dGVyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgdG9wOiB0b3AgfTtcblx0fSxcblxuXG5cdHF1ZXJ5RGF0ZVNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHsgdG9wOiB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbFRvcCgpIH07XG5cdH0sXG5cblxuXHRhcHBseURhdGVTY3JvbGw6IGZ1bmN0aW9uKHNjcm9sbCkge1xuXHRcdGlmIChzY3JvbGwudG9wICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2Nyb2xsZXIuc2V0U2Nyb2xsVG9wKHNjcm9sbC50b3ApO1xuXHRcdH1cblx0fSxcblxuXG5cdC8qIEhpdCBBcmVhc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQvLyBmb3J3YXJkIGFsbCBoaXQtcmVsYXRlZCBtZXRob2QgY2FsbHMgdG8gdGhlIGdyaWRzIChkYXlHcmlkIG1pZ2h0IG5vdCBiZSBkZWZpbmVkKVxuXG5cblx0aGl0c05lZWRlZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC5oaXRzTmVlZGVkKCk7XG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLmhpdHNOZWVkZWQoKTtcblx0XHR9XG5cdH0sXG5cblxuXHRoaXRzTm90TmVlZGVkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpbWVHcmlkLmhpdHNOb3ROZWVkZWQoKTtcblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQuaGl0c05vdE5lZWRlZCgpO1xuXHRcdH1cblx0fSxcblxuXG5cdHByZXBhcmVIaXRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnByZXBhcmVIaXRzKCk7XG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnByZXBhcmVIaXRzKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0cmVsZWFzZUhpdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGltZUdyaWQucmVsZWFzZUhpdHMoKTtcblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQucmVsZWFzZUhpdHMoKTtcblx0XHR9XG5cdH0sXG5cblxuXHRxdWVyeUhpdDogZnVuY3Rpb24obGVmdCwgdG9wKSB7XG5cdFx0dmFyIGhpdCA9IHRoaXMudGltZUdyaWQucXVlcnlIaXQobGVmdCwgdG9wKTtcblxuXHRcdGlmICghaGl0ICYmIHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0aGl0ID0gdGhpcy5kYXlHcmlkLnF1ZXJ5SGl0KGxlZnQsIHRvcCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhpdDtcblx0fSxcblxuXG5cdGdldEhpdFNwYW46IGZ1bmN0aW9uKGhpdCkge1xuXHRcdC8vIFRPRE86IGhpdC5jb21wb25lbnQgaXMgc2V0IGFzIGEgaGFjayB0byBpZGVudGlmeSB3aGVyZSB0aGUgaGl0IGNhbWUgZnJvbVxuXHRcdHJldHVybiBoaXQuY29tcG9uZW50LmdldEhpdFNwYW4oaGl0KTtcblx0fSxcblxuXG5cdGdldEhpdEVsOiBmdW5jdGlvbihoaXQpIHtcblx0XHQvLyBUT0RPOiBoaXQuY29tcG9uZW50IGlzIHNldCBhcyBhIGhhY2sgdG8gaWRlbnRpZnkgd2hlcmUgdGhlIGhpdCBjYW1lIGZyb21cblx0XHRyZXR1cm4gaGl0LmNvbXBvbmVudC5nZXRIaXRFbChoaXQpO1xuXHR9LFxuXG5cblx0LyogRXZlbnRzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGV2ZW50cyBvbnRvIHRoZSB2aWV3IGFuZCBwb3B1bGF0ZXMgdGhlIFZpZXcncyBzZWdtZW50IGFycmF5XG5cdHJlbmRlckV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0dmFyIGRheUV2ZW50cyA9IFtdO1xuXHRcdHZhciB0aW1lZEV2ZW50cyA9IFtdO1xuXHRcdHZhciBkYXlTZWdzID0gW107XG5cdFx0dmFyIHRpbWVkU2Vncztcblx0XHR2YXIgaTtcblxuXHRcdC8vIHNlcGFyYXRlIHRoZSBldmVudHMgaW50byBhbGwtZGF5IGFuZCB0aW1lZFxuXHRcdGZvciAoaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChldmVudHNbaV0uYWxsRGF5KSB7XG5cdFx0XHRcdGRheUV2ZW50cy5wdXNoKGV2ZW50c1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGltZWRFdmVudHMucHVzaChldmVudHNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHJlbmRlciB0aGUgZXZlbnRzIGluIHRoZSBzdWJjb21wb25lbnRzXG5cdFx0dGltZWRTZWdzID0gdGhpcy50aW1lR3JpZC5yZW5kZXJFdmVudHModGltZWRFdmVudHMpO1xuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdGRheVNlZ3MgPSB0aGlzLmRheUdyaWQucmVuZGVyRXZlbnRzKGRheUV2ZW50cyk7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIGFsbC1kYXkgYXJlYSBpcyBmbGV4aWJsZSBhbmQgbWlnaHQgaGF2ZSBhIGxvdCBvZiBldmVudHMsIHNvIHNoaWZ0IHRoZSBoZWlnaHRcblx0XHR0aGlzLnVwZGF0ZUhlaWdodCgpO1xuXHR9LFxuXG5cblx0Ly8gUmV0cmlldmVzIGFsbCBzZWdtZW50IG9iamVjdHMgdGhhdCBhcmUgcmVuZGVyZWQgaW4gdGhlIHZpZXdcblx0Z2V0RXZlbnRTZWdzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50aW1lR3JpZC5nZXRFdmVudFNlZ3MoKS5jb25jYXQoXG5cdFx0XHR0aGlzLmRheUdyaWQgPyB0aGlzLmRheUdyaWQuZ2V0RXZlbnRTZWdzKCkgOiBbXVxuXHRcdCk7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYWxsIGV2ZW50IGVsZW1lbnRzIGFuZCBjbGVhcnMgaW50ZXJuYWwgc2VnbWVudCBkYXRhXG5cdHVucmVuZGVyRXZlbnRzOiBmdW5jdGlvbigpIHtcblxuXHRcdC8vIHVucmVuZGVyIHRoZSBldmVudHMgaW4gdGhlIHN1YmNvbXBvbmVudHNcblx0XHR0aGlzLnRpbWVHcmlkLnVucmVuZGVyRXZlbnRzKCk7XG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnVucmVuZGVyRXZlbnRzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgRE9OJ1QgbmVlZCB0byBjYWxsIHVwZGF0ZUhlaWdodCgpIGJlY2F1c2Vcblx0XHQvLyBhIHJlbmRlckV2ZW50cygpIGNhbGwgYWx3YXlzIGhhcHBlbnMgYWZ0ZXIgdGhpcywgd2hpY2ggd2lsbCBldmVudHVhbGx5IGNhbGwgdXBkYXRlSGVpZ2h0KClcblx0fSxcblxuXG5cdC8qIERyYWdnaW5nIChmb3IgZXZlbnRzIGFuZCBleHRlcm5hbCBlbGVtZW50cylcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEEgcmV0dXJuZWQgdmFsdWUgb2YgYHRydWVgIHNpZ25hbHMgdGhhdCBhIG1vY2sgXCJoZWxwZXJcIiBldmVudCBoYXMgYmVlbiByZW5kZXJlZC5cblx0cmVuZGVyRHJhZzogZnVuY3Rpb24oZHJvcExvY2F0aW9uLCBzZWcpIHtcblx0XHRpZiAoZHJvcExvY2F0aW9uLnN0YXJ0Lmhhc1RpbWUoKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMudGltZUdyaWQucmVuZGVyRHJhZyhkcm9wTG9jYXRpb24sIHNlZyk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF5R3JpZC5yZW5kZXJEcmFnKGRyb3BMb2NhdGlvbiwgc2VnKTtcblx0XHR9XG5cdH0sXG5cblxuXHR1bnJlbmRlckRyYWc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGltZUdyaWQudW5yZW5kZXJEcmFnKCk7XG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnVucmVuZGVyRHJhZygpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8qIFNlbGVjdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgc2VsZWN0aW9uXG5cdHJlbmRlclNlbGVjdGlvbjogZnVuY3Rpb24oc3Bhbikge1xuXHRcdGlmIChzcGFuLnN0YXJ0Lmhhc1RpbWUoKSB8fCBzcGFuLmVuZC5oYXNUaW1lKCkpIHtcblx0XHRcdHRoaXMudGltZUdyaWQucmVuZGVyU2VsZWN0aW9uKHNwYW4pO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5yZW5kZXJTZWxlY3Rpb24oc3Bhbik7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb25zIG9mIGEgc2VsZWN0aW9uXG5cdHVucmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnVucmVuZGVyU2VsZWN0aW9uKCk7XG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnVucmVuZGVyU2VsZWN0aW9uKCk7XG5cdFx0fVxuXHR9XG5cbn0pO1xuXG5cbi8vIE1ldGhvZHMgdGhhdCB3aWxsIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIGJlaGF2aW9yIG9mIHRoZSBBZ2VuZGFWaWV3J3MgdGltZUdyaWRcbi8vIFRPRE86IG1vdmUgaW50byBUaW1lR3JpZFxudmFyIGFnZW5kYVRpbWVHcmlkTWV0aG9kcyA9IHtcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IHdpbGwgZ28gYmVmb3JlIHRoZSBkYXktb2Ygd2VlayBoZWFkZXIgY2VsbHNcblx0cmVuZGVySGVhZEludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIHdlZWtUZXh0O1xuXG5cdFx0aWYgKHZpZXcub3B0KCd3ZWVrTnVtYmVycycpKSB7XG5cdFx0XHR3ZWVrVGV4dCA9IHRoaXMuc3RhcnQuZm9ybWF0KHZpZXcub3B0KCdzbWFsbFdlZWtGb3JtYXQnKSk7XG5cblx0XHRcdHJldHVybiAnJyArXG5cdFx0XHRcdCc8dGggY2xhc3M9XCJmYy1heGlzIGZjLXdlZWstbnVtYmVyICcgKyB2aWV3LndpZGdldEhlYWRlckNsYXNzICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+JyArXG5cdFx0XHRcdFx0dmlldy5idWlsZEdvdG9BbmNob3JIdG1sKCAvLyBhc2lkZSBmcm9tIGxpbmssIGltcG9ydGFudCBmb3IgbWF0Y2hDZWxsV2lkdGhzXG5cdFx0XHRcdFx0XHR7IGRhdGU6IHRoaXMuc3RhcnQsIHR5cGU6ICd3ZWVrJywgZm9yY2VPZmY6IHRoaXMuY29sQ250ID4gMSB9LFxuXHRcdFx0XHRcdFx0aHRtbEVzY2FwZSh3ZWVrVGV4dCkgLy8gaW5uZXIgSFRNTFxuXHRcdFx0XHRcdCkgK1xuXHRcdFx0XHQnPC90aD4nO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiAnPHRoIGNsYXNzPVwiZmMtYXhpcyAnICsgdmlldy53aWRnZXRIZWFkZXJDbGFzcyArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGg+Jztcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSB0aGUgYmcgb2YgdGhlIFRpbWVHcmlkIHNsb3QgYXJlYS4gTG9uZyB2ZXJ0aWNhbCBjb2x1bW4uXG5cdHJlbmRlckJnSW50cm9IdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdHJldHVybiAnPHRkIGNsYXNzPVwiZmMtYXhpcyAnICsgdmlldy53aWRnZXRDb250ZW50Q2xhc3MgKyAnXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz48L3RkPic7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSBhbGwgb3RoZXIgdHlwZXMgb2YgY2VsbHMuXG5cdC8vIEFmZmVjdHMgY29udGVudC1za2VsZXRvbiwgaGVscGVyLXNrZWxldG9uLCBoaWdobGlnaHQtc2tlbGV0b24gZm9yIGJvdGggdGhlIHRpbWUtZ3JpZCBhbmQgZGF5LWdyaWQuXG5cdHJlbmRlckludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRyZXR1cm4gJzx0ZCBjbGFzcz1cImZjLWF4aXNcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGQ+Jztcblx0fVxuXG59O1xuXG5cbi8vIE1ldGhvZHMgdGhhdCB3aWxsIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIGJlaGF2aW9yIG9mIHRoZSBBZ2VuZGFWaWV3J3MgZGF5R3JpZFxudmFyIGFnZW5kYURheUdyaWRNZXRob2RzID0ge1xuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgdGhlIGFsbC1kYXkgY2VsbHNcblx0cmVuZGVyQmdJbnRyb0h0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0cmV0dXJuICcnICtcblx0XHRcdCc8dGQgY2xhc3M9XCJmYy1heGlzICcgKyB2aWV3LndpZGdldENvbnRlbnRDbGFzcyArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPicgK1xuXHRcdFx0XHQnPHNwYW4+JyArIC8vIG5lZWRlZCBmb3IgbWF0Y2hDZWxsV2lkdGhzXG5cdFx0XHRcdFx0dmlldy5nZXRBbGxEYXlIdG1sKCkgK1xuXHRcdFx0XHQnPC9zcGFuPicgK1xuXHRcdFx0JzwvdGQ+Jztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGFsbCBvdGhlciB0eXBlcyBvZiBjZWxscy5cblx0Ly8gQWZmZWN0cyBjb250ZW50LXNrZWxldG9uLCBoZWxwZXItc2tlbGV0b24sIGhpZ2hsaWdodC1za2VsZXRvbiBmb3IgYm90aCB0aGUgdGltZS1ncmlkIGFuZCBkYXktZ3JpZC5cblx0cmVuZGVySW50cm9IdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdHJldHVybiAnPHRkIGNsYXNzPVwiZmMtYXhpc1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xuXHR9XG5cbn07XG5cbjs7XG5cbnZhciBBR0VOREFfQUxMX0RBWV9FVkVOVF9MSU1JVCA9IDU7XG5cbi8vIHBvdGVudGlhbCBuaWNlIHZhbHVlcyBmb3IgdGhlIHNsb3QtZHVyYXRpb24gYW5kIGludGVydmFsLWR1cmF0aW9uXG4vLyBmcm9tIGxhcmdlc3QgdG8gc21hbGxlc3RcbnZhciBBR0VOREFfU1RPQ0tfU1VCX0RVUkFUSU9OUyA9IFtcblx0eyBob3VyczogMSB9LFxuXHR7IG1pbnV0ZXM6IDMwIH0sXG5cdHsgbWludXRlczogMTUgfSxcblx0eyBzZWNvbmRzOiAzMCB9LFxuXHR7IHNlY29uZHM6IDE1IH1cbl07XG5cbmZjVmlld3MuYWdlbmRhID0ge1xuXHQnY2xhc3MnOiBBZ2VuZGFWaWV3LFxuXHRkZWZhdWx0czoge1xuXHRcdGFsbERheVNsb3Q6IHRydWUsXG5cdFx0c2xvdER1cmF0aW9uOiAnMDA6MzA6MDAnLFxuXHRcdHNsb3RFdmVudE92ZXJsYXA6IHRydWUgLy8gYSBiYWQgbmFtZS4gY29uZnVzZWQgd2l0aCBvdmVybGFwL2NvbnN0cmFpbnQgc3lzdGVtXG5cdH1cbn07XG5cbmZjVmlld3MuYWdlbmRhRGF5ID0ge1xuXHR0eXBlOiAnYWdlbmRhJyxcblx0ZHVyYXRpb246IHsgZGF5czogMSB9XG59O1xuXG5mY1ZpZXdzLmFnZW5kYVdlZWsgPSB7XG5cdHR5cGU6ICdhZ2VuZGEnLFxuXHRkdXJhdGlvbjogeyB3ZWVrczogMSB9XG59O1xuOztcblxuLypcblJlc3BvbnNpYmxlIGZvciB0aGUgc2Nyb2xsZXIsIGFuZCBmb3J3YXJkaW5nIGV2ZW50LXJlbGF0ZWQgYWN0aW9ucyBpbnRvIHRoZSBcImdyaWRcIlxuKi9cbnZhciBMaXN0VmlldyA9IFZpZXcuZXh0ZW5kKHtcblxuXHRncmlkOiBudWxsLFxuXHRzY3JvbGxlcjogbnVsbCxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmdyaWQgPSBuZXcgTGlzdFZpZXdHcmlkKHRoaXMpO1xuXHRcdHRoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsZXIoe1xuXHRcdFx0b3ZlcmZsb3dYOiAnaGlkZGVuJyxcblx0XHRcdG92ZXJmbG93WTogJ2F1dG8nXG5cdFx0fSk7XG5cdH0sXG5cblx0cmVuZGVyU2tlbGV0b246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWwuYWRkQ2xhc3MoXG5cdFx0XHQnZmMtbGlzdC12aWV3ICcgK1xuXHRcdFx0dGhpcy53aWRnZXRDb250ZW50Q2xhc3Ncblx0XHQpO1xuXG5cdFx0dGhpcy5zY3JvbGxlci5yZW5kZXIoKTtcblx0XHR0aGlzLnNjcm9sbGVyLmVsLmFwcGVuZFRvKHRoaXMuZWwpO1xuXG5cdFx0dGhpcy5ncmlkLnNldEVsZW1lbnQodGhpcy5zY3JvbGxlci5zY3JvbGxFbCk7XG5cdH0sXG5cblx0dW5yZW5kZXJTa2VsZXRvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zY3JvbGxlci5kZXN0cm95KCk7IC8vIHdpbGwgcmVtb3ZlIHRoZSBHcmlkIHRvb1xuXHR9LFxuXG5cdHNldEhlaWdodDogZnVuY3Rpb24odG90YWxIZWlnaHQsIGlzQXV0bykge1xuXHRcdHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KSk7XG5cdH0sXG5cblx0Y29tcHV0ZVNjcm9sbGVySGVpZ2h0OiBmdW5jdGlvbih0b3RhbEhlaWdodCkge1xuXHRcdHJldHVybiB0b3RhbEhlaWdodCAtXG5cdFx0XHRzdWJ0cmFjdElubmVyRWxIZWlnaHQodGhpcy5lbCwgdGhpcy5zY3JvbGxlci5lbCk7IC8vIGV2ZXJ5dGhpbmcgdGhhdCdzIE5PVCB0aGUgc2Nyb2xsZXJcblx0fSxcblxuXHRyZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5ncmlkLnNldFJhbmdlKHRoaXMucmVuZGVyUmFuZ2UpOyAvLyBuZWVkcyB0byBwcm9jZXNzIHJhbmdlLXJlbGF0ZWQgb3B0aW9uc1xuXHR9LFxuXG5cdHJlbmRlckV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0dGhpcy5ncmlkLnJlbmRlckV2ZW50cyhldmVudHMpO1xuXHR9LFxuXG5cdHVucmVuZGVyRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmdyaWQudW5yZW5kZXJFdmVudHMoKTtcblx0fSxcblxuXHRpc0V2ZW50UmVzaXphYmxlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRpc0V2ZW50RHJhZ2dhYmxlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG59KTtcblxuLypcblJlc3BvbnNpYmxlIGZvciBldmVudCByZW5kZXJpbmcgYW5kIHVzZXItaW50ZXJhY3Rpb24uXG5JdHMgXCJlbFwiIGlzIHRoZSBpbm5lci1jb250ZW50IG9mIHRoZSBhYm92ZSB2aWV3J3Mgc2Nyb2xsZXIuXG4qL1xudmFyIExpc3RWaWV3R3JpZCA9IEdyaWQuZXh0ZW5kKHtcblxuXHRzZWdTZWxlY3RvcjogJy5mYy1saXN0LWl0ZW0nLCAvLyB3aGljaCBlbGVtZW50cyBhY2NlcHQgZXZlbnQgYWN0aW9uc1xuXHRoYXNEYXlJbnRlcmFjdGlvbnM6IGZhbHNlLCAvLyBubyBkYXkgc2VsZWN0aW9uIG9yIGRheSBjbGlja2luZ1xuXG5cdC8vIHNsaWNlcyBieSBkYXlcblx0c3BhblRvU2VnczogZnVuY3Rpb24oc3Bhbikge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBkYXlTdGFydCA9IHZpZXcucmVuZGVyUmFuZ2Uuc3RhcnQuY2xvbmUoKS50aW1lKDApOyAvLyB0aW1lZCwgc28gc2VncyBnZXQgdGltZXMhXG5cdFx0dmFyIGRheUluZGV4ID0gMDtcblx0XHR2YXIgc2VnO1xuXHRcdHZhciBzZWdzID0gW107XG5cblx0XHR3aGlsZSAoZGF5U3RhcnQgPCB2aWV3LnJlbmRlclJhbmdlLmVuZCkge1xuXG5cdFx0XHRzZWcgPSBpbnRlcnNlY3RSYW5nZXMoc3Bhbiwge1xuXHRcdFx0XHRzdGFydDogZGF5U3RhcnQsXG5cdFx0XHRcdGVuZDogZGF5U3RhcnQuY2xvbmUoKS5hZGQoMSwgJ2RheScpXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHNlZykge1xuXHRcdFx0XHRzZWcuZGF5SW5kZXggPSBkYXlJbmRleDtcblx0XHRcdFx0c2Vncy5wdXNoKHNlZyk7XG5cdFx0XHR9XG5cblx0XHRcdGRheVN0YXJ0LmFkZCgxLCAnZGF5Jyk7XG5cdFx0XHRkYXlJbmRleCsrO1xuXG5cdFx0XHQvLyBkZXRlY3Qgd2hlbiBzcGFuIHdvbid0IGdvIGZ1bGx5IGludG8gdGhlIG5leHQgZGF5LFxuXHRcdFx0Ly8gYW5kIG11dGF0ZSB0aGUgbGF0ZXN0IHNlZyB0byB0aGUgYmUgdGhlIGVuZC5cblx0XHRcdGlmIChcblx0XHRcdFx0c2VnICYmICFzZWcuaXNFbmQgJiYgc3Bhbi5lbmQuaGFzVGltZSgpICYmXG5cdFx0XHRcdHNwYW4uZW5kIDwgZGF5U3RhcnQuY2xvbmUoKS5hZGQodGhpcy52aWV3Lm5leHREYXlUaHJlc2hvbGQpXG5cdFx0XHQpIHtcblx0XHRcdFx0c2VnLmVuZCA9IHNwYW4uZW5kLmNsb25lKCk7XG5cdFx0XHRcdHNlZy5pc0VuZCA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cdC8vIGxpa2UgXCI0OjAwYW1cIlxuXHRjb21wdXRlRXZlbnRUaW1lRm9ybWF0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy52aWV3Lm9wdCgnbWVkaXVtVGltZUZvcm1hdCcpO1xuXHR9LFxuXG5cdC8vIGZvciBldmVudHMgd2l0aCBhIHVybCwgdGhlIHdob2xlIDx0cj4gc2hvdWxkIGJlIGNsaWNrYWJsZSxcblx0Ly8gYnV0IGl0J3MgaW1wb3NzaWJsZSB0byB3cmFwIHdpdGggYW4gPGE+IHRhZy4gc2ltdWxhdGUgdGhpcy5cblx0aGFuZGxlU2VnQ2xpY2s6IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHR2YXIgdXJsO1xuXG5cdFx0R3JpZC5wcm90b3R5cGUuaGFuZGxlU2VnQ2xpY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gc3VwZXIuIG1pZ2h0IHByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uXG5cblx0XHQvLyBub3QgY2xpY2tpbmcgb24gb3Igd2l0aGluIGFuIDxhPiB3aXRoIGFuIGhyZWZcblx0XHRpZiAoISQoZXYudGFyZ2V0KS5jbG9zZXN0KCdhW2hyZWZdJykubGVuZ3RoKSB7XG5cdFx0XHR1cmwgPSBzZWcuZXZlbnQudXJsO1xuXHRcdFx0aWYgKHVybCAmJiAhZXYuaXNEZWZhdWx0UHJldmVudGVkKCkpIHsgLy8ganNFdmVudCBub3QgY2FuY2VsbGVkIGluIGhhbmRsZXJcblx0XHRcdFx0d2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7IC8vIHNpbXVsYXRlIGxpbmsgY2xpY2tcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gcmV0dXJucyBsaXN0IG9mIGZvcmVncm91bmQgc2VncyB0aGF0IHdlcmUgYWN0dWFsbHkgcmVuZGVyZWRcblx0cmVuZGVyRmdTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmdTZWdFbHMoc2Vncyk7IC8vIG1pZ2h0IGZpbHRlciBhd2F5IGhpZGRlbiBldmVudHNcblxuXHRcdGlmICghc2Vncy5sZW5ndGgpIHtcblx0XHRcdHRoaXMucmVuZGVyRW1wdHlNZXNzYWdlKCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5yZW5kZXJTZWdMaXN0KHNlZ3MpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cdHJlbmRlckVtcHR5TWVzc2FnZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbC5odG1sKFxuXHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1saXN0LWVtcHR5LXdyYXAyXCI+JyArIC8vIFRPRE86IHRyeSBsZXNzIHdyYXBzXG5cdFx0XHQnPGRpdiBjbGFzcz1cImZjLWxpc3QtZW1wdHktd3JhcDFcIj4nICtcblx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtbGlzdC1lbXB0eVwiPicgK1xuXHRcdFx0XHRodG1sRXNjYXBlKHRoaXMudmlldy5vcHQoJ25vRXZlbnRzTWVzc2FnZScpKSArXG5cdFx0XHQnPC9kaXY+JyArXG5cdFx0XHQnPC9kaXY+JyArXG5cdFx0XHQnPC9kaXY+J1xuXHRcdCk7XG5cdH0sXG5cblx0Ly8gcmVuZGVyIHRoZSBldmVudCBzZWdtZW50cyBpbiB0aGUgdmlld1xuXHRyZW5kZXJTZWdMaXN0OiBmdW5jdGlvbihhbGxTZWdzKSB7XG5cdFx0dmFyIHNlZ3NCeURheSA9IHRoaXMuZ3JvdXBTZWdzQnlEYXkoYWxsU2Vncyk7IC8vIHNwYXJzZSBhcnJheVxuXHRcdHZhciBkYXlJbmRleDtcblx0XHR2YXIgZGF5U2Vncztcblx0XHR2YXIgaTtcblx0XHR2YXIgdGFibGVFbCA9ICQoJzx0YWJsZSBjbGFzcz1cImZjLWxpc3QtdGFibGVcIj48dGJvZHkvPjwvdGFibGU+Jyk7XG5cdFx0dmFyIHRib2R5RWwgPSB0YWJsZUVsLmZpbmQoJ3Rib2R5Jyk7XG5cblx0XHRmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBzZWdzQnlEYXkubGVuZ3RoOyBkYXlJbmRleCsrKSB7XG5cdFx0XHRkYXlTZWdzID0gc2Vnc0J5RGF5W2RheUluZGV4XTtcblx0XHRcdGlmIChkYXlTZWdzKSB7IC8vIHNwYXJzZSBhcnJheSwgc28gbWlnaHQgYmUgdW5kZWZpbmVkXG5cblx0XHRcdFx0Ly8gYXBwZW5kIGEgZGF5IGhlYWRlclxuXHRcdFx0XHR0Ym9keUVsLmFwcGVuZCh0aGlzLmRheUhlYWRlckh0bWwoXG5cdFx0XHRcdFx0dGhpcy52aWV3LnJlbmRlclJhbmdlLnN0YXJ0LmNsb25lKCkuYWRkKGRheUluZGV4LCAnZGF5cycpXG5cdFx0XHRcdCkpO1xuXG5cdFx0XHRcdHRoaXMuc29ydEV2ZW50U2VncyhkYXlTZWdzKTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF5U2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHRib2R5RWwuYXBwZW5kKGRheVNlZ3NbaV0uZWwpOyAvLyBhcHBlbmQgZXZlbnQgcm93XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmVsLmVtcHR5KCkuYXBwZW5kKHRhYmxlRWwpO1xuXHR9LFxuXG5cdC8vIFJldHVybnMgYSBzcGFyc2UgYXJyYXkgb2YgYXJyYXlzLCBzZWdzIGdyb3VwZWQgYnkgdGhlaXIgZGF5SW5kZXhcblx0Z3JvdXBTZWdzQnlEYXk6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR2YXIgc2Vnc0J5RGF5ID0gW107IC8vIHNwYXJzZSBhcnJheVxuXHRcdHZhciBpLCBzZWc7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnID0gc2Vnc1tpXTtcblx0XHRcdChzZWdzQnlEYXlbc2VnLmRheUluZGV4XSB8fCAoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gPSBbXSkpXG5cdFx0XHRcdC5wdXNoKHNlZyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ3NCeURheTtcblx0fSxcblxuXHQvLyBnZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIHRoZSBkYXkgaGVhZGVycyB0aGF0IGxpdmUgYW1vbmdzdCB0aGUgZXZlbnQgcm93c1xuXHRkYXlIZWFkZXJIdG1sOiBmdW5jdGlvbihkYXlEYXRlKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIG1haW5Gb3JtYXQgPSB2aWV3Lm9wdCgnbGlzdERheUZvcm1hdCcpO1xuXHRcdHZhciBhbHRGb3JtYXQgPSB2aWV3Lm9wdCgnbGlzdERheUFsdEZvcm1hdCcpO1xuXG5cdFx0cmV0dXJuICc8dHIgY2xhc3M9XCJmYy1saXN0LWhlYWRpbmdcIiBkYXRhLWRhdGU9XCInICsgZGF5RGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSArICdcIj4nICtcblx0XHRcdCc8dGQgY2xhc3M9XCInICsgdmlldy53aWRnZXRIZWFkZXJDbGFzcyArICdcIiBjb2xzcGFuPVwiM1wiPicgK1xuXHRcdFx0XHQobWFpbkZvcm1hdCA/XG5cdFx0XHRcdFx0dmlldy5idWlsZEdvdG9BbmNob3JIdG1sKFxuXHRcdFx0XHRcdFx0ZGF5RGF0ZSxcblx0XHRcdFx0XHRcdHsgJ2NsYXNzJzogJ2ZjLWxpc3QtaGVhZGluZy1tYWluJyB9LFxuXHRcdFx0XHRcdFx0aHRtbEVzY2FwZShkYXlEYXRlLmZvcm1hdChtYWluRm9ybWF0KSkgLy8gaW5uZXIgSFRNTFxuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdCcnKSArXG5cdFx0XHRcdChhbHRGb3JtYXQgP1xuXHRcdFx0XHRcdHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbChcblx0XHRcdFx0XHRcdGRheURhdGUsXG5cdFx0XHRcdFx0XHR7ICdjbGFzcyc6ICdmYy1saXN0LWhlYWRpbmctYWx0JyB9LFxuXHRcdFx0XHRcdFx0aHRtbEVzY2FwZShkYXlEYXRlLmZvcm1hdChhbHRGb3JtYXQpKSAvLyBpbm5lciBIVE1MXG5cdFx0XHRcdFx0KSA6XG5cdFx0XHRcdFx0JycpICtcblx0XHRcdCc8L3RkPicgK1xuXHRcdCc8L3RyPic7XG5cdH0sXG5cblx0Ly8gZ2VuZXJhdGVzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSBldmVudCByb3dcblx0ZmdTZWdIdG1sOiBmdW5jdGlvbihzZWcpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgY2xhc3NlcyA9IFsgJ2ZjLWxpc3QtaXRlbScgXS5jb25jYXQodGhpcy5nZXRTZWdDdXN0b21DbGFzc2VzKHNlZykpO1xuXHRcdHZhciBiZ0NvbG9yID0gdGhpcy5nZXRTZWdCYWNrZ3JvdW5kQ29sb3Ioc2VnKTtcblx0XHR2YXIgZXZlbnQgPSBzZWcuZXZlbnQ7XG5cdFx0dmFyIHVybCA9IGV2ZW50LnVybDtcblx0XHR2YXIgdGltZUh0bWw7XG5cblx0XHRpZiAoZXZlbnQuYWxsRGF5KSB7XG5cdFx0XHR0aW1lSHRtbCA9IHZpZXcuZ2V0QWxsRGF5SHRtbCgpO1xuXHRcdH1cblx0XHRlbHNlIGlmICh2aWV3LmlzTXVsdGlEYXlFdmVudChldmVudCkpIHsgLy8gaWYgdGhlIGV2ZW50IGFwcGVhcnMgdG8gc3BhbiBtb3JlIHRoYW4gb25lIGRheVxuXHRcdFx0aWYgKHNlZy5pc1N0YXJ0IHx8IHNlZy5pc0VuZCkgeyAvLyBvdXRlciBzZWdtZW50IHRoYXQgcHJvYmFibHkgbGFzdHMgcGFydCBvZiB0aGUgZGF5XG5cdFx0XHRcdHRpbWVIdG1sID0gaHRtbEVzY2FwZSh0aGlzLmdldEV2ZW50VGltZVRleHQoc2VnKSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHsgLy8gaW5uZXIgc2VnbWVudCB0aGF0IGxhc3RzIHRoZSB3aG9sZSBkYXlcblx0XHRcdFx0dGltZUh0bWwgPSB2aWV3LmdldEFsbERheUh0bWwoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBEaXNwbGF5IHRoZSBub3JtYWwgdGltZSB0ZXh0IGZvciB0aGUgKmV2ZW50J3MqIHRpbWVzXG5cdFx0XHR0aW1lSHRtbCA9IGh0bWxFc2NhcGUodGhpcy5nZXRFdmVudFRpbWVUZXh0KGV2ZW50KSk7XG5cdFx0fVxuXG5cdFx0aWYgKHVybCkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmYy1oYXMtdXJsJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICc8dHIgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCI+JyArXG5cdFx0XHQodGhpcy5kaXNwbGF5RXZlbnRUaW1lID9cblx0XHRcdFx0Jzx0ZCBjbGFzcz1cImZjLWxpc3QtaXRlbS10aW1lICcgKyB2aWV3LndpZGdldENvbnRlbnRDbGFzcyArICdcIj4nICtcblx0XHRcdFx0XHQodGltZUh0bWwgfHwgJycpICtcblx0XHRcdFx0JzwvdGQ+JyA6XG5cdFx0XHRcdCcnKSArXG5cdFx0XHQnPHRkIGNsYXNzPVwiZmMtbGlzdC1pdGVtLW1hcmtlciAnICsgdmlldy53aWRnZXRDb250ZW50Q2xhc3MgKyAnXCI+JyArXG5cdFx0XHRcdCc8c3BhbiBjbGFzcz1cImZjLWV2ZW50LWRvdFwiJyArXG5cdFx0XHRcdChiZ0NvbG9yID9cblx0XHRcdFx0XHQnIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgYmdDb2xvciArICdcIicgOlxuXHRcdFx0XHRcdCcnKSArXG5cdFx0XHRcdCc+PC9zcGFuPicgK1xuXHRcdFx0JzwvdGQ+JyArXG5cdFx0XHQnPHRkIGNsYXNzPVwiZmMtbGlzdC1pdGVtLXRpdGxlICcgKyB2aWV3LndpZGdldENvbnRlbnRDbGFzcyArICdcIj4nICtcblx0XHRcdFx0JzxhJyArICh1cmwgPyAnIGhyZWY9XCInICsgaHRtbEVzY2FwZSh1cmwpICsgJ1wiJyA6ICcnKSArICc+JyArXG5cdFx0XHRcdFx0aHRtbEVzY2FwZShzZWcuZXZlbnQudGl0bGUgfHwgJycpICtcblx0XHRcdFx0JzwvYT4nICtcblx0XHRcdCc8L3RkPicgK1xuXHRcdCc8L3RyPic7XG5cdH1cblxufSk7XG5cbjs7XG5cbmZjVmlld3MubGlzdCA9IHtcblx0J2NsYXNzJzogTGlzdFZpZXcsXG5cdGJ1dHRvblRleHRLZXk6ICdsaXN0JywgLy8gd2hhdCB0byBsb29rdXAgaW4gbG9jYWxlIGZpbGVzXG5cdGRlZmF1bHRzOiB7XG5cdFx0YnV0dG9uVGV4dDogJ2xpc3QnLCAvLyB0ZXh0IHRvIGRpc3BsYXkgZm9yIEVuZ2xpc2hcblx0XHRsaXN0RGF5Rm9ybWF0OiAnTEwnLCAvLyBsaWtlIFwiSmFudWFyeSAxLCAyMDE2XCJcblx0XHRub0V2ZW50c01lc3NhZ2U6ICdObyBldmVudHMgdG8gZGlzcGxheSdcblx0fVxufTtcblxuZmNWaWV3cy5saXN0RGF5ID0ge1xuXHR0eXBlOiAnbGlzdCcsXG5cdGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcblx0ZGVmYXVsdHM6IHtcblx0XHRsaXN0RGF5Rm9ybWF0OiAnZGRkZCcgLy8gZGF5LW9mLXdlZWsgaXMgYWxsIHdlIG5lZWQuIGZ1bGwgZGF0ZSBpcyBwcm9iYWJseSBpbiBoZWFkZXJcblx0fVxufTtcblxuZmNWaWV3cy5saXN0V2VlayA9IHtcblx0dHlwZTogJ2xpc3QnLFxuXHRkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxuXHRkZWZhdWx0czoge1xuXHRcdGxpc3REYXlGb3JtYXQ6ICdkZGRkJywgLy8gZGF5LW9mLXdlZWsgaXMgbW9yZSBpbXBvcnRhbnRcblx0XHRsaXN0RGF5QWx0Rm9ybWF0OiAnTEwnXG5cdH1cbn07XG5cbmZjVmlld3MubGlzdE1vbnRoID0ge1xuXHR0eXBlOiAnbGlzdCcsXG5cdGR1cmF0aW9uOiB7IG1vbnRoOiAxIH0sXG5cdGRlZmF1bHRzOiB7XG5cdFx0bGlzdERheUFsdEZvcm1hdDogJ2RkZGQnIC8vIGRheS1vZi13ZWVrIGlzIG5pY2UtdG8taGF2ZVxuXHR9XG59O1xuXG5mY1ZpZXdzLmxpc3RZZWFyID0ge1xuXHR0eXBlOiAnbGlzdCcsXG5cdGR1cmF0aW9uOiB7IHllYXI6IDEgfSxcblx0ZGVmYXVsdHM6IHtcblx0XHRsaXN0RGF5QWx0Rm9ybWF0OiAnZGRkZCcgLy8gZGF5LW9mLXdlZWsgaXMgbmljZS10by1oYXZlXG5cdH1cbn07XG5cbjs7XG5cclxucmV0dXJuIEZDOyAvLyBleHBvcnQgZm9yIE5vZGUvQ29tbW9uSlNcclxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2Z1bGxjYWxlbmRhci5qc1xuLy8gbW9kdWxlIGlkID0gNTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIl0sInNvdXJjZVJvb3QiOiIifQ==