webpackJsonp([183],{

/***/ 123:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(181).then((function(require) {
	data = __webpack_require__(592);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 124:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(180).then((function(require) {
	data = __webpack_require__(593);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 125:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(179).then((function(require) {
	data = __webpack_require__(594);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 126:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(178).then((function(require) {
	data = __webpack_require__(595);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 127:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(177).then((function(require) {
	data = __webpack_require__(596);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 128:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(176).then((function(require) {
	data = __webpack_require__(597);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 129:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(175).then((function(require) {
	data = __webpack_require__(598);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 130:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(174).then((function(require) {
	data = __webpack_require__(599);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 131:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(173).then((function(require) {
	data = __webpack_require__(600);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 132:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(172).then((function(require) {
	data = __webpack_require__(601);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 133:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(171).then((function(require) {
	data = __webpack_require__(602);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 134:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(170).then((function(require) {
	data = __webpack_require__(603);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 135:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(169).then((function(require) {
	data = __webpack_require__(604);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 136:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(168).then((function(require) {
	data = __webpack_require__(605);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 137:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(167).then((function(require) {
	data = __webpack_require__(606);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 138:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(166).then((function(require) {
	data = __webpack_require__(607);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 139:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(165).then((function(require) {
	data = __webpack_require__(608);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 140:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(164).then((function(require) {
	data = __webpack_require__(609);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 141:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(163).then((function(require) {
	data = __webpack_require__(610);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 142:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(162).then((function(require) {
	data = __webpack_require__(611);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 143:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(161).then((function(require) {
	data = __webpack_require__(612);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 144:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(160).then((function(require) {
	data = __webpack_require__(613);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 145:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(159).then((function(require) {
	data = __webpack_require__(614);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 146:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(158).then((function(require) {
	data = __webpack_require__(615);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 147:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(2).then((function(require) {
	data = __webpack_require__(616);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 148:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(157).then((function(require) {
	data = __webpack_require__(617);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 149:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(156).then((function(require) {
	data = __webpack_require__(618);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 150:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(155).then((function(require) {
	data = __webpack_require__(619);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 151:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(154).then((function(require) {
	data = __webpack_require__(620);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 152:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(153).then((function(require) {
	data = __webpack_require__(621);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 153:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(152).then((function(require) {
	data = __webpack_require__(622);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 154:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(151).then((function(require) {
	data = __webpack_require__(623);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 155:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(150).then((function(require) {
	data = __webpack_require__(624);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 156:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(149).then((function(require) {
	data = __webpack_require__(625);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 157:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(148).then((function(require) {
	data = __webpack_require__(626);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 158:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(147).then((function(require) {
	data = __webpack_require__(627);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 159:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(146).then((function(require) {
	data = __webpack_require__(628);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 160:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(145).then((function(require) {
	data = __webpack_require__(629);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 161:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(144).then((function(require) {
	data = __webpack_require__(630);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 162:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(143).then((function(require) {
	data = __webpack_require__(631);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 163:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(142).then((function(require) {
	data = __webpack_require__(632);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 164:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(141).then((function(require) {
	data = __webpack_require__(633);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 165:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(140).then((function(require) {
	data = __webpack_require__(634);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 166:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(139).then((function(require) {
	data = __webpack_require__(635);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 167:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(138).then((function(require) {
	data = __webpack_require__(636);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 168:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(137).then((function(require) {
	data = __webpack_require__(637);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 169:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(136).then((function(require) {
	data = __webpack_require__(638);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 170:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(135).then((function(require) {
	data = __webpack_require__(639);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 171:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(134).then((function(require) {
	data = __webpack_require__(640);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 172:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(133).then((function(require) {
	data = __webpack_require__(641);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 173:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(132).then((function(require) {
	data = __webpack_require__(642);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 174:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(131).then((function(require) {
	data = __webpack_require__(643);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 175:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(130).then((function(require) {
	data = __webpack_require__(644);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 176:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(129).then((function(require) {
	data = __webpack_require__(645);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 177:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(128).then((function(require) {
	data = __webpack_require__(646);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 178:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(127).then((function(require) {
	data = __webpack_require__(647);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 179:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(126).then((function(require) {
	data = __webpack_require__(648);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 180:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(125).then((function(require) {
	data = __webpack_require__(649);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 181:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(124).then((function(require) {
	data = __webpack_require__(650);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 182:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(123).then((function(require) {
	data = __webpack_require__(651);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 183:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(122).then((function(require) {
	data = __webpack_require__(652);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 184:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(121).then((function(require) {
	data = __webpack_require__(653);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 185:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(1).then((function(require) {
	data = __webpack_require__(654);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 186:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(120).then((function(require) {
	data = __webpack_require__(655);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 187:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(0).then((function(require) {
	data = __webpack_require__(656);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 188:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(119).then((function(require) {
	data = __webpack_require__(657);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 189:
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(118).then((function(require) {
	data = __webpack_require__(658);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i < l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),

/***/ 305:
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 123,
	"./af.js": 123,
	"./ar": 130,
	"./ar-dz": 124,
	"./ar-dz.js": 124,
	"./ar-kw": 125,
	"./ar-kw.js": 125,
	"./ar-ly": 126,
	"./ar-ly.js": 126,
	"./ar-ma": 127,
	"./ar-ma.js": 127,
	"./ar-sa": 128,
	"./ar-sa.js": 128,
	"./ar-tn": 129,
	"./ar-tn.js": 129,
	"./ar.js": 130,
	"./bg": 131,
	"./bg.js": 131,
	"./ca": 132,
	"./ca.js": 132,
	"./cs": 133,
	"./cs.js": 133,
	"./da": 134,
	"./da.js": 134,
	"./de": 137,
	"./de-at": 135,
	"./de-at.js": 135,
	"./de-ch": 136,
	"./de-ch.js": 136,
	"./de.js": 137,
	"./el": 138,
	"./el.js": 138,
	"./en-au": 139,
	"./en-au.js": 139,
	"./en-ca": 140,
	"./en-ca.js": 140,
	"./en-gb": 141,
	"./en-gb.js": 141,
	"./en-ie": 142,
	"./en-ie.js": 142,
	"./en-nz": 143,
	"./en-nz.js": 143,
	"./es": 145,
	"./es-do": 144,
	"./es-do.js": 144,
	"./es.js": 145,
	"./et": 146,
	"./et.js": 146,
	"./eu": 147,
	"./eu.js": 147,
	"./fa": 148,
	"./fa.js": 148,
	"./fi": 149,
	"./fi.js": 149,
	"./fr": 152,
	"./fr-ca": 150,
	"./fr-ca.js": 150,
	"./fr-ch": 151,
	"./fr-ch.js": 151,
	"./fr.js": 152,
	"./gl": 153,
	"./gl.js": 153,
	"./he": 154,
	"./he.js": 154,
	"./hi": 155,
	"./hi.js": 155,
	"./hr": 156,
	"./hr.js": 156,
	"./hu": 157,
	"./hu.js": 157,
	"./id": 158,
	"./id.js": 158,
	"./is": 159,
	"./is.js": 159,
	"./it": 160,
	"./it.js": 160,
	"./ja": 161,
	"./ja.js": 161,
	"./kk": 162,
	"./kk.js": 162,
	"./ko": 163,
	"./ko.js": 163,
	"./lb": 164,
	"./lb.js": 164,
	"./lt": 165,
	"./lt.js": 165,
	"./lv": 166,
	"./lv.js": 166,
	"./mk": 167,
	"./mk.js": 167,
	"./ms": 169,
	"./ms-my": 168,
	"./ms-my.js": 168,
	"./ms.js": 169,
	"./nb": 170,
	"./nb.js": 170,
	"./nl": 172,
	"./nl-be": 171,
	"./nl-be.js": 171,
	"./nl.js": 172,
	"./nn": 173,
	"./nn.js": 173,
	"./pl": 174,
	"./pl.js": 174,
	"./pt": 176,
	"./pt-br": 175,
	"./pt-br.js": 175,
	"./pt.js": 176,
	"./ro": 177,
	"./ro.js": 177,
	"./ru": 178,
	"./ru.js": 178,
	"./sk": 179,
	"./sk.js": 179,
	"./sl": 180,
	"./sl.js": 180,
	"./sr": 182,
	"./sr-cyrl": 181,
	"./sr-cyrl.js": 181,
	"./sr.js": 182,
	"./sv": 183,
	"./sv.js": 183,
	"./th": 184,
	"./th.js": 184,
	"./tr": 185,
	"./tr.js": 185,
	"./uk": 186,
	"./uk.js": 186,
	"./vi": 187,
	"./vi.js": 187,
	"./zh-cn": 188,
	"./zh-cn.js": 188,
	"./zh-tw": 189,
	"./zh-tw.js": 189
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 305;

/***/ }),

/***/ 351:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(588);

var _convertToFC = __webpack_require__(353);

var _convertToFC2 = _interopRequireDefault(_convertToFC);

var _displayEvent = __webpack_require__(354);

var _displayEvent2 = _interopRequireDefault(_displayEvent);

var _locationHistory = __webpack_require__(121);

var _locationHistory2 = _interopRequireDefault(_locationHistory);

var _responses = __webpack_require__(79);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var queryRegExp = /calendar\/?(?:\/*event\/+([0-9]+))?/;

var begin = function begin(momentLang) {
  var calendarOptions = {
    editable: false,
    header: {
      left: 'prev,next today',
      center: 'title',
      right: 'month,agendaWeek,agendaDay'
    },
    lang: momentLang,
    events: function events(start, end, timezone, callback) {
      socket.emit('plugins.calendar.getEventsByDate', {
        startDate: start.valueOf(),
        endDate: end.valueOf()
      }, function (err, events) {
        if (err) {
          if (err.message) {
            app.alertError(err);
          }
          throw err;
        }

        callback((0, _convertToFC2.default)(events));
      });
    },
    eventClick: function eventClick(_ref, e) {
      var original = _ref.original,
          pid = _ref.id;

      e.preventDefault();
      e.stopPropagation();
      (0, _displayEvent2.default)(original);
      if (original.external) {
        // TODO
      } else {
        if (original.repeats) {
          ajaxify.updateHistory('calendar/event/' + pid + '/' + original.day);
        } else {
          ajaxify.updateHistory('calendar/event/' + pid);
        }
      }
    },
    timezone: 'local'
  };

  var shouldHandle = false;

  _locationHistory2.default.listen(function (state, data) {
    if (state.prev.startsWith('calendar') && state.current.startsWith('calendar')) {
      data.url = null; // eslint-disable-line no-param-reassign
      shouldHandle = true;
    } else {
      shouldHandle = false;
    }
  });

  var init = function init() {
    var $calendar = $('#calendar');

    if ($calendar && !shouldHandle) {
      $calendar.fullCalendar(calendarOptions);
      var btn = $('#plugin-calendar-cal-only-yes');
      btn.on('click', function (e) {
        e.preventDefault();
        $calendar.toggleClass('plugin-calendar-cal-only-yes');
        btn.toggleClass('active');
      }).detach().appendTo($calendar.find('.fc-toolbar .fc-right'));
    }

    var $display = $('#plugin-calendar-cal-event-display');
    if ($display) {
      $display.on('click', '.dismiss', function () {
        $display.modal('hide');
        ajaxify.updateHistory('calendar');
      });
    }

    var matches = location.pathname.match(queryRegExp);
    var pid = matches && parseInt(matches[1], 10);
    if (pid) {
      var el = $calendar.data('fullCalendar').getEventCache().find(function (x) {
        return x.id === pid;
      });

      if (shouldHandle) {
        var event = el && el.original;
        if (event) {
          (0, _displayEvent2.default)(event);
        } else {
          history.replaceState({}, '', RELATIVE_PATH + '/calendar');
        }
      } else {
        (0, _responses.setupDTP)($display.find('[data-day]'), window.calendarEventData.day);
      }
      $calendar.fullCalendar('gotoDate', el ? el.start : window.calendarEventData.day || window.calendarEventData.startDate);
    } else if (shouldHandle) {
      $display.modal('hide');
    }
  };

  $(document).ready(init);
  $(window).on('action:ajaxify.end', init);
};

__webpack_require__.p = RELATIVE_PATH + '/plugins/nodebb-plugin-calendar/bundles/'; // eslint-disable-line

var lang = config.userLang || config.defaultLang;
var momentLang = lang.toLowerCase().replace(/_/g, '-');

try {
  if (momentLang === 'en-us') {
    begin('en-us');
  } else {
    __webpack_require__(305)("./" + momentLang)(function () {
      // eslint-disable-line
      begin(momentLang);
    });
  }
} catch (e) {
  try {
    __webpack_require__(305)("./" + momentLang.split('-')[0])(function () {
      // eslint-disable-line
      begin(momentLang);
    });
  } catch (er) {
    begin('en-us');
    throw Error('Could not load locale data (' + momentLang + ') for fullcalendar');
  }
}

/***/ }),

/***/ 353:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var mapper = function mapper(event) {
  var newEvent = {
    id: event.pid,
    title: event.name,
    allDay: event.allday,
    start: event.startDate,
    end: event.endDate + 1,
    className: [],
    original: event
  };

  if (event.external) {
    newEvent.className = ['plugin-calendar-cal-event-external'];
  } else {
    newEvent.className = ['plugin-calendar-cal-event-category-' + event.cid, 'plugin-calendar-cal-event-response-' + (event.responses[app.user.uid] || 'no'), event.topicDeleted ? 'plugin-calendar-cal-event-topic-deleted' : ''];
  }

  return newEvent;
};

var convertToFC = function convertToFC(events) {
  return events.map(mapper);
};

exports.default = convertToFC;

/***/ }),

/***/ 354:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _templates = __webpack_require__(361);

var _responses = __webpack_require__(79);

var displayEvent = function displayEvent(event, cb) {
  var content = (0, _templates.eventTemplate)({ event: event, uid: app.user.uid });
  var pid = event.pid;

  var div = $(content);
  var $display = $('#plugin-calendar-cal-event-display');
  var $goToPost = $display.find('.modal-footer a.btn-primary.gotopost');
  var $goToUrl = $display.find('.modal-footer a.btn-primary.gotourl');
  $display.modal('hide').find('.modal-body .posts').empty().append(div);
  if (event.external) {
    $goToPost.hide();

    if (event.url) {
      $goToUrl.show().attr('href', event.url);
    } else {
      $goToUrl.hide();
    }
  } else {
    $goToUrl.hide();
    $goToPost.show().attr('href', RELATIVE_PATH + '/post/' + pid);
  }
  $display.find('.modal-body').attr('data-pid', pid);
  if (!event.external && event.repeats) {
    $display.find('[data-day]').attr('data-day', event.day);
  }
  $display.modal('show');

  (0, _responses.setupPost)({ pid: pid }, function () {
    $(window).trigger('action:calendar.event.display', { pid: pid, day: event.day, modal: $display });

    if (typeof cb === 'function') {
      cb({ content: content, parsed: event });
    }
  });
};

exports.default = displayEvent;

/***/ }),

/***/ 361:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.eventTemplate = undefined;

var _defineProperty2 = __webpack_require__(308);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var makeListElement = function makeListElement(n) {
  var li = '<li data-value="' + n + '">[[moment:time-duration, ' + n + ']]</li>';
  return li;
};

var eventTemplate = function eventTemplate(_ref) {
  var event = _ref.event,
      isEmail = _ref.isEmail,
      uid = _ref.uid;
  var startDate = event.startDate,
      endDate = event.endDate,
      allday = event.allday;


  var response = 'no';
  if (uid && event.responses && event.responses[uid]) {
    response = event.responses[uid];
  }
  var responsesTemplate = function responsesTemplate() {
    return '\n<div class="plugin-calendar-event-responses" data-day="' + (event.day || '') + '">\n  <i class="fa fa-reply" aria-hidden="true"></i>\n  <div class="col-xs-12 col-sm-6">\n    ' + (event.repeats ? '\n    <div class="input-group plugin-calendar-event-responses-day">\n      <input class="form-control" title="[[calendar:select_day]]" type="text">\n      <span class="input-group-addon">\n        <i class="fa fa-calendar-check-o"></i>\n      </span>\n    </div>\n    ' : '') + '\n    ' + (uid === 0 ? '' : '\n    <div class="plugin-calendar-event-responses-user btn-group">\n      ' + function () {
      var active = (0, _defineProperty3.default)({
        no: '',
        maybe: '',
        yes: ''
      }, response, 'active');

      return '\n      <button data-value="no" type="button" class="btn btn-sm btn-danger ' + active.no + '">\n        [[calendar:response_no]]\n      </button>\n      <button data-value="maybe" type="button" class="btn btn-sm btn-default ' + active.maybe + '">\n        [[calendar:response_maybe]]\n      </button>\n      <button data-value="yes" type="button" class="btn btn-sm btn-success ' + active.yes + '">\n        [[calendar:response_yes]]\n      </button>\n        ';
    }() + '\n    </div>\n    ') + '\n    <div class="panel-group plugin-calendar-event-responses-lists" data-loaded="false">\n      <div class="panel panel-default closed">\n        <div class="panel-heading">\n          <a role="button" data-toggle="collapse" href="#"\n          class="btn btn-sm btn-info" aria-expanded="true">\n            <i class="fa fa-chevron-down pull-right"></i>\n            [[calendar:response_yes]]\n          </a>\n        </div>\n        <div class="panel-collapse">\n          <div class="panel-body">\n            <ul class="plugin-calendar-event-responses-list-yes">\n              <!-- yes responses go here -->\n            </ul>\n          </div>\n        </div>\n      </div>\n      <div class="panel panel-default closed">\n        <div class="panel-heading">\n          <a role="button" data-toggle="collapse" href="#"\n          class="btn btn-sm btn-link" aria-expanded="true">\n            <i class="fa fa-chevron-down pull-right"></i>\n            [[calendar:response_maybe]]\n          </a>\n        </div>\n        <div class="panel-collapse">\n          <div class="panel-body">\n            <ul class="plugin-calendar-event-responses-list-maybe">\n              <!-- maybe responses go here -->\n            </ul>\n          </div>\n        </div>\n      </div>\n      <div class="panel panel-default closed">\n        <div class="panel-heading">\n          <a role="button" data-toggle="collapse" href="#"\n          class="btn btn-sm btn-warning" aria-expanded="true">\n            <i class="fa fa-chevron-down pull-right"></i>\n            [[calendar:response_no]]\n          </a>\n        </div>\n        <div class="panel-collapse">\n          <div class="panel-body">\n            <ul class="plugin-calendar-event-responses-list-no">\n              <!-- no responses go here -->\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>';
  };
  var responses = isEmail ? '\n  <div class="plugin-calendar-event-responses">\n    <i class="fa fa-reply" aria-hidden="true"></i>\n    [[calendar:you_responded, [[calendar:response_' + response + ']]]]\n  </div>\n  ' : responsesTemplate();

  if (event.external) {
    responses = '';
  }

  var html = '\n<div class="plugin-calendar-event panel panel-success" data-translated="false">\n  <div class="plugin-calendar-event-name panel-heading">\n    ' + event.name + '\n  </div>\n  <div class="panel-body">\n    <div class="plugin-calendar-event-date">\n      <i class="fa fa-clock-o" aria-hidden="true"></i>\n      <a\n        title="[[moment:time-date-view, utc, ' + startDate + ', ' + endDate + ', ' + allday + ']] UTC"\n        class="plugin-calendar-time-date-view"\n      >[[moment:time-date-view, local, ' + startDate + ', ' + endDate + ', ' + allday + ']]</a>\n    </div>\n    ' + (event.external ? '\n    <div class="plugin-calendar-event-location">\n      <i class="fa fa-location-arrow" aria-hidden="true"></i>\n      <span>External: ' + event.source + '<span>\n    </div>\n    ' : '') + '\n    ' + (event.location ? '\n    <div class="plugin-calendar-event-location">\n      <i class="fa fa-location-arrow" aria-hidden="true"></i>\n      <span>' + event.location + '<span>\n    </div>\n    ' : '') + '\n    ' + (event.description ? '\n    <div class="plugin-calendar-event-description">\n      <i class="fa fa-info-circle" aria-hidden="true"></i>\n      <div>' + event.description + '</div>\n    </div>\n    ' : '') + '\n    ' + (!event.external && event.reminders.length ? '\n    <div class="plugin-calendar-event-reminders">\n      <i class="fa fa-bell" aria-hidden="true"></i>\n      <ul>\n        ' + event.reminders.sort(function (a, b) {
    return a - b;
  }).map(makeListElement).join('\n') + '\n      </ul>\n    </div>\n    ' : '') + '\n    ' + function () {
    if (event.repeats) {
      var key = ['day', 'week', 'month', 'year'].find(function (x) {
        return event.repeats.every[x];
      });
      if (key) {
        return '<div class="plugin-calendar-event-repeats">\n            <i class="fa fa-repeat" aria-hidden="true"></i>\n            <span>[[calendar:every_' + key + ']]</span>\n          </div>';
      }
      if (event.repeats.every.daysOfWeek) {
        var days = event.repeats.every.daysOfWeek.map(function (day) {
          return '[[moment:locale-data, _weekdaysShort, ' + day + ']]';
        }).join(', ');
        var endDateText = '[[moment:time-date-view, utc, ' + event.repeats.endDate + ', ' + (event.repeats.endDate + ', true]]');
        return '<div class="plugin-calendar-event-repeats">\n            <i class="fa fa-repeat" aria-hidden="true"></i>\n            <span>\n              ' + (Number.isFinite(event.repeats.endDate) ? '\n              [[calendar:repeats_weekly_on_until, ' + endDateText + ']] ' + days + '\n              ' : '\n              [[calendar:repeats_weekly_on_forever]] ' + days + '\n              ') + '\n            </span>\n          </div>';
      }
    }
    return '';
  }() + '\n    ' + (event.mandatory ? '\n    <div class="plugin-calendar-event-mandatory">\n      <i class="fa fa-exclamation-circle" aria-hidden="true"></i>\n      <span>[[calendar:mandatory]]</span>\n    </div>\n    ' : responses) + '\n  </div>\n</div>';

  return html;
};

exports.eventTemplate = eventTemplate;

/***/ }),

/***/ 588:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_moment__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_moment__);
/*!
 * FullCalendar v3.4.0
 * Docs & License: https://fullcalendar.io/
 * (c) 2017 Adam Shaw
 */


(function(factory) {
  factory(jQuery, __WEBPACK_IMPORTED_MODULE_0_moment___default.a);
})(function($, moment) {

;;

var FC = $.fullCalendar = {
	version: "3.4.0",
	// When introducing internal API incompatibilities (where fullcalendar plugins would break),
	// the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)
	// and the below integer should be incremented.
	internalApiVersion: 9
};
var fcViews = FC.views = {};


$.fn.fullCalendar = function(options) {
	var args = Array.prototype.slice.call(arguments, 1); // for a possible method call
	var res = this; // what this function will return (this jQuery object by default)

	this.each(function(i, _element) { // loop each DOM element involved
		var element = $(_element);
		var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)
		var singleRes; // the returned value of this single method call

		// a method call
		if (typeof options === 'string') {
			if (calendar && $.isFunction(calendar[options])) {
				singleRes = calendar[options].apply(calendar, args);
				if (!i) {
					res = singleRes; // record the first method call result
				}
				if (options === 'destroy') { // for the destroy method, must remove Calendar object data
					element.removeData('fullCalendar');
				}
			}
		}
		// a new calendar initialization
		else if (!calendar) { // don't initialize twice
			calendar = new Calendar(element, options);
			element.data('fullCalendar', calendar);
			calendar.render();
		}
	});

	return res;
};


var complexOptions = [ // names of options that are objects whose properties should be combined
	'header',
	'footer',
	'buttonText',
	'buttonIcons',
	'themeButtonIcons'
];


// Merges an array of option objects into a single object
function mergeOptions(optionObjs) {
	return mergeProps(optionObjs, complexOptions);
}

;;

// exports
FC.intersectRanges = intersectRanges;
FC.applyAll = applyAll;
FC.debounce = debounce;
FC.isInt = isInt;
FC.htmlEscape = htmlEscape;
FC.cssToStr = cssToStr;
FC.proxy = proxy;
FC.capitaliseFirstLetter = capitaliseFirstLetter;


/* FullCalendar-specific DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/


// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
function compensateScroll(rowEls, scrollbarWidths) {
	if (scrollbarWidths.left) {
		rowEls.css({
			'border-left-width': 1,
			'margin-left': scrollbarWidths.left - 1
		});
	}
	if (scrollbarWidths.right) {
		rowEls.css({
			'border-right-width': 1,
			'margin-right': scrollbarWidths.right - 1
		});
	}
}


// Undoes compensateScroll and restores all borders/margins
function uncompensateScroll(rowEls) {
	rowEls.css({
		'margin-left': '',
		'margin-right': '',
		'border-left-width': '',
		'border-right-width': ''
	});
}


// Make the mouse cursor express that an event is not allowed in the current area
function disableCursor() {
	$('body').addClass('fc-not-allowed');
}


// Returns the mouse cursor to its original look
function enableCursor() {
	$('body').removeClass('fc-not-allowed');
}


// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and 
// reduces the available height.
function distributeHeight(els, availableHeight, shouldRedistribute) {

	// *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
	// and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.

	var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
	var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
	var flexEls = []; // elements that are allowed to expand. array of DOM nodes
	var flexOffsets = []; // amount of vertical space it takes up
	var flexHeights = []; // actual css height
	var usedHeight = 0;

	undistributeHeight(els); // give all elements their natural height

	// find elements that are below the recommended height (expandable).
	// important to query for heights in a single first pass (to avoid reflow oscillation).
	els.each(function(i, el) {
		var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
		var naturalOffset = $(el).outerHeight(true);

		if (naturalOffset < minOffset) {
			flexEls.push(el);
			flexOffsets.push(naturalOffset);
			flexHeights.push($(el).height());
		}
		else {
			// this element stretches past recommended height (non-expandable). mark the space as occupied.
			usedHeight += naturalOffset;
		}
	});

	// readjust the recommended height to only consider the height available to non-maxed-out rows.
	if (shouldRedistribute) {
		availableHeight -= usedHeight;
		minOffset1 = Math.floor(availableHeight / flexEls.length);
		minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
	}

	// assign heights to all expandable elements
	$(flexEls).each(function(i, el) {
		var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
		var naturalOffset = flexOffsets[i];
		var naturalHeight = flexHeights[i];
		var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding

		if (naturalOffset < minOffset) { // we check this again because redistribution might have changed things
			$(el).height(newHeight);
		}
	});
}


// Undoes distrubuteHeight, restoring all els to their natural height
function undistributeHeight(els) {
	els.height('');
}


// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
function matchCellWidths(els) {
	var maxInnerWidth = 0;

	els.find('> *').each(function(i, innerEl) {
		var innerWidth = $(innerEl).outerWidth();
		if (innerWidth > maxInnerWidth) {
			maxInnerWidth = innerWidth;
		}
	});

	maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance

	els.width(maxInnerWidth);

	return maxInnerWidth;
}


// Given one element that resides inside another,
// Subtracts the height of the inner element from the outer element.
function subtractInnerElHeight(outerEl, innerEl) {
	var both = outerEl.add(innerEl);
	var diff;

	// effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
	both.css({
		position: 'relative', // cause a reflow, which will force fresh dimension recalculation
		left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
	});
	diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions
	both.css({ position: '', left: '' }); // undo hack

	return diff;
}


/* Element Geom Utilities
----------------------------------------------------------------------------------------------------------------------*/

FC.getOuterRect = getOuterRect;
FC.getClientRect = getClientRect;
FC.getContentRect = getContentRect;
FC.getScrollbarWidths = getScrollbarWidths;


// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51
function getScrollParent(el) {
	var position = el.css('position'),
		scrollParent = el.parents().filter(function() {
			var parent = $(this);
			return (/(auto|scroll)/).test(
				parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x')
			);
		}).eq(0);

	return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
}


// Queries the outer bounding area of a jQuery element.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getOuterRect(el, origin) {
	var offset = el.offset();
	var left = offset.left - (origin ? origin.left : 0);
	var top = offset.top - (origin ? origin.top : 0);

	return {
		left: left,
		right: left + el.outerWidth(),
		top: top,
		bottom: top + el.outerHeight()
	};
}


// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
// WARNING: given element can't have borders
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getClientRect(el, origin) {
	var offset = el.offset();
	var scrollbarWidths = getScrollbarWidths(el);
	var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);
	var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);

	return {
		left: left,
		right: left + el[0].clientWidth, // clientWidth includes padding but NOT scrollbars
		top: top,
		bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars
	};
}


// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getContentRect(el, origin) {
	var offset = el.offset(); // just outside of border, margin not included
	var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -
		(origin ? origin.left : 0);
	var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -
		(origin ? origin.top : 0);

	return {
		left: left,
		right: left + el.width(),
		top: top,
		bottom: top + el.height()
	};
}


// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.
// WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getScrollbarWidths(el) {
	var leftRightWidth = el[0].offsetWidth - el[0].clientWidth;
	var bottomWidth = el[0].offsetHeight - el[0].clientHeight;
	var widths;

	leftRightWidth = sanitizeScrollbarWidth(leftRightWidth);
	bottomWidth = sanitizeScrollbarWidth(bottomWidth);

	widths = { left: 0, right: 0, top: 0, bottom: bottomWidth };

	if (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') { // is the scrollbar on the left side?
		widths.left = leftRightWidth;
	}
	else {
		widths.right = leftRightWidth;
	}

	return widths;
}


// The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to
// retina displays, rounding, and IE11. Massage them into a usable value.
function sanitizeScrollbarWidth(width) {
	width = Math.max(0, width); // no negatives
	width = Math.round(width);
	return width;
}


// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side

var _isLeftRtlScrollbars = null;

function getIsLeftRtlScrollbars() { // responsible for caching the computation
	if (_isLeftRtlScrollbars === null) {
		_isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
	}
	return _isLeftRtlScrollbars;
}

function computeIsLeftRtlScrollbars() { // creates an offscreen test element, then removes it
	var el = $('<div><div/></div>')
		.css({
			position: 'absolute',
			top: -1000,
			left: 0,
			border: 0,
			padding: 0,
			overflow: 'scroll',
			direction: 'rtl'
		})
		.appendTo('body');
	var innerEl = el.children();
	var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?
	el.remove();
	return res;
}


// Retrieves a jQuery element's computed CSS value as a floating-point number.
// If the queried value is non-numeric (ex: IE can return "medium" for border width), will just return zero.
function getCssFloat(el, prop) {
	return parseFloat(el.css(prop)) || 0;
}


/* Mouse / Touch Utilities
----------------------------------------------------------------------------------------------------------------------*/

FC.preventDefault = preventDefault;


// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
function isPrimaryMouseButton(ev) {
	return ev.which == 1 && !ev.ctrlKey;
}


function getEvX(ev) {
	var touches = ev.originalEvent.touches;

	// on mobile FF, pageX for touch events is present, but incorrect,
	// so, look at touch coordinates first.
	if (touches && touches.length) {
		return touches[0].pageX;
	}

	return ev.pageX;
}


function getEvY(ev) {
	var touches = ev.originalEvent.touches;

	// on mobile FF, pageX for touch events is present, but incorrect,
	// so, look at touch coordinates first.
	if (touches && touches.length) {
		return touches[0].pageY;
	}

	return ev.pageY;
}


function getEvIsTouch(ev) {
	return /^touch/.test(ev.type);
}


function preventSelection(el) {
	el.addClass('fc-unselectable')
		.on('selectstart', preventDefault);
}


function allowSelection(el) {
	el.removeClass('fc-unselectable')
		.off('selectstart', preventDefault);
}


// Stops a mouse/touch event from doing it's native browser action
function preventDefault(ev) {
	ev.preventDefault();
}


/* General Geometry Utils
----------------------------------------------------------------------------------------------------------------------*/

FC.intersectRects = intersectRects;

// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
function intersectRects(rect1, rect2) {
	var res = {
		left: Math.max(rect1.left, rect2.left),
		right: Math.min(rect1.right, rect2.right),
		top: Math.max(rect1.top, rect2.top),
		bottom: Math.min(rect1.bottom, rect2.bottom)
	};

	if (res.left < res.right && res.top < res.bottom) {
		return res;
	}
	return false;
}


// Returns a new point that will have been moved to reside within the given rectangle
function constrainPoint(point, rect) {
	return {
		left: Math.min(Math.max(point.left, rect.left), rect.right),
		top: Math.min(Math.max(point.top, rect.top), rect.bottom)
	};
}


// Returns a point that is the center of the given rectangle
function getRectCenter(rect) {
	return {
		left: (rect.left + rect.right) / 2,
		top: (rect.top + rect.bottom) / 2
	};
}


// Subtracts point2's coordinates from point1's coordinates, returning a delta
function diffPoints(point1, point2) {
	return {
		left: point1.left - point2.left,
		top: point1.top - point2.top
	};
}


/* Object Ordering by Field
----------------------------------------------------------------------------------------------------------------------*/

FC.parseFieldSpecs = parseFieldSpecs;
FC.compareByFieldSpecs = compareByFieldSpecs;
FC.compareByFieldSpec = compareByFieldSpec;
FC.flexibleCompare = flexibleCompare;


function parseFieldSpecs(input) {
	var specs = [];
	var tokens = [];
	var i, token;

	if (typeof input === 'string') {
		tokens = input.split(/\s*,\s*/);
	}
	else if (typeof input === 'function') {
		tokens = [ input ];
	}
	else if ($.isArray(input)) {
		tokens = input;
	}

	for (i = 0; i < tokens.length; i++) {
		token = tokens[i];

		if (typeof token === 'string') {
			specs.push(
				token.charAt(0) == '-' ?
					{ field: token.substring(1), order: -1 } :
					{ field: token, order: 1 }
			);
		}
		else if (typeof token === 'function') {
			specs.push({ func: token });
		}
	}

	return specs;
}


function compareByFieldSpecs(obj1, obj2, fieldSpecs) {
	var i;
	var cmp;

	for (i = 0; i < fieldSpecs.length; i++) {
		cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);
		if (cmp) {
			return cmp;
		}
	}

	return 0;
}


function compareByFieldSpec(obj1, obj2, fieldSpec) {
	if (fieldSpec.func) {
		return fieldSpec.func(obj1, obj2);
	}
	return flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) *
		(fieldSpec.order || 1);
}


function flexibleCompare(a, b) {
	if (!a && !b) {
		return 0;
	}
	if (b == null) {
		return -1;
	}
	if (a == null) {
		return 1;
	}
	if ($.type(a) === 'string' || $.type(b) === 'string') {
		return String(a).localeCompare(String(b));
	}
	return a - b;
}


/* FullCalendar-specific Misc Utilities
----------------------------------------------------------------------------------------------------------------------*/


// Computes the intersection of the two ranges. Will return fresh date clones in a range.
// Returns undefined if no intersection.
// Expects all dates to be normalized to the same timezone beforehand.
// TODO: move to date section?
function intersectRanges(subjectRange, constraintRange) {
	var subjectStart = subjectRange.start;
	var subjectEnd = subjectRange.end;
	var constraintStart = constraintRange.start;
	var constraintEnd = constraintRange.end;
	var segStart, segEnd;
	var isStart, isEnd;

	if (subjectEnd > constraintStart && subjectStart < constraintEnd) { // in bounds at all?

		if (subjectStart >= constraintStart) {
			segStart = subjectStart.clone();
			isStart = true;
		}
		else {
			segStart = constraintStart.clone();
			isStart =  false;
		}

		if (subjectEnd <= constraintEnd) {
			segEnd = subjectEnd.clone();
			isEnd = true;
		}
		else {
			segEnd = constraintEnd.clone();
			isEnd = false;
		}

		return {
			start: segStart,
			end: segEnd,
			isStart: isStart,
			isEnd: isEnd
		};
	}
}


/* Date Utilities
----------------------------------------------------------------------------------------------------------------------*/

FC.computeGreatestUnit = computeGreatestUnit;
FC.divideRangeByDuration = divideRangeByDuration;
FC.divideDurationByDuration = divideDurationByDuration;
FC.multiplyDuration = multiplyDuration;
FC.durationHasTime = durationHasTime;

var dayIDs = [ 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat' ];
var unitsDesc = [ 'year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond' ]; // descending


// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
function diffDayTime(a, b) {
	return moment.duration({
		days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),
		ms: a.time() - b.time() // time-of-day from day start. disregards timezone
	});
}


// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.
function diffDay(a, b) {
	return moment.duration({
		days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')
	});
}


// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.
function diffByUnit(a, b, unit) {
	return moment.duration(
		Math.round(a.diff(b, unit, true)), // returnFloat=true
		unit
	);
}


// Computes the unit name of the largest whole-unit period of time.
// For example, 48 hours will be "days" whereas 49 hours will be "hours".
// Accepts start/end, a range object, or an original duration object.
function computeGreatestUnit(start, end) {
	var i, unit;
	var val;

	for (i = 0; i < unitsDesc.length; i++) {
		unit = unitsDesc[i];
		val = computeRangeAs(unit, start, end);

		if (val >= 1 && isInt(val)) {
			break;
		}
	}

	return unit; // will be "milliseconds" if nothing else matches
}


// like computeGreatestUnit, but has special abilities to interpret the source input for clues
function computeDurationGreatestUnit(duration, durationInput) {
	var unit = computeGreatestUnit(duration);

	// prevent days:7 from being interpreted as a week
	if (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {
		unit = 'day';
	}

	return unit;
}


// Computes the number of units (like "hours") in the given range.
// Range can be a {start,end} object, separate start/end args, or a Duration.
// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling
// of month-diffing logic (which tends to vary from version to version).
function computeRangeAs(unit, start, end) {

	if (end != null) { // given start, end
		return end.diff(start, unit, true);
	}
	else if (moment.isDuration(start)) { // given duration
		return start.as(unit);
	}
	else { // given { start, end } range object
		return start.end.diff(start.start, unit, true);
	}
}


// Intelligently divides a range (specified by a start/end params) by a duration
function divideRangeByDuration(start, end, dur) {
	var months;

	if (durationHasTime(dur)) {
		return (end - start) / dur;
	}
	months = dur.asMonths();
	if (Math.abs(months) >= 1 && isInt(months)) {
		return end.diff(start, 'months', true) / months;
	}
	return end.diff(start, 'days', true) / dur.asDays();
}


// Intelligently divides one duration by another
function divideDurationByDuration(dur1, dur2) {
	var months1, months2;

	if (durationHasTime(dur1) || durationHasTime(dur2)) {
		return dur1 / dur2;
	}
	months1 = dur1.asMonths();
	months2 = dur2.asMonths();
	if (
		Math.abs(months1) >= 1 && isInt(months1) &&
		Math.abs(months2) >= 1 && isInt(months2)
	) {
		return months1 / months2;
	}
	return dur1.asDays() / dur2.asDays();
}


// Intelligently multiplies a duration by a number
function multiplyDuration(dur, n) {
	var months;

	if (durationHasTime(dur)) {
		return moment.duration(dur * n);
	}
	months = dur.asMonths();
	if (Math.abs(months) >= 1 && isInt(months)) {
		return moment.duration({ months: months * n });
	}
	return moment.duration({ days: dur.asDays() * n });
}


function cloneRange(range) {
	return {
		start: range.start.clone(),
		end: range.end.clone()
	};
}


// Trims the beginning and end of inner range to be completely within outerRange.
// Returns a new range object.
function constrainRange(innerRange, outerRange) {
	innerRange = cloneRange(innerRange);

	if (outerRange.start) {
		// needs to be inclusively before outerRange's end
		innerRange.start = constrainDate(innerRange.start, outerRange);
	}

	if (outerRange.end) {
		innerRange.end = minMoment(innerRange.end, outerRange.end);
	}

	return innerRange;
}


// If the given date is not within the given range, move it inside.
// (If it's past the end, make it one millisecond before the end).
// Always returns a new moment.
function constrainDate(date, range) {
	date = date.clone();

	if (range.start) {
		date = maxMoment(date, range.start);
	}

	if (range.end && date >= range.end) {
		date = range.end.clone().subtract(1);
	}

	return date;
}


function isDateWithinRange(date, range) {
	return (!range.start || date >= range.start) &&
		(!range.end || date < range.end);
}


// TODO: deal with repeat code in intersectRanges
// constraintRange can have unspecified start/end, an open-ended range.
function doRangesIntersect(subjectRange, constraintRange) {
	return (!constraintRange.start || subjectRange.end >= constraintRange.start) &&
		(!constraintRange.end || subjectRange.start < constraintRange.end);
}


function isRangeWithinRange(innerRange, outerRange) {
	return (!outerRange.start || innerRange.start >= outerRange.start) &&
		(!outerRange.end || innerRange.end <= outerRange.end);
}


function isRangesEqual(range0, range1) {
	return ((range0.start && range1.start && range0.start.isSame(range1.start)) || (!range0.start && !range1.start)) &&
		((range0.end && range1.end && range0.end.isSame(range1.end)) || (!range0.end && !range1.end));
}


// Returns the moment that's earlier in time. Always a copy.
function minMoment(mom1, mom2) {
	return (mom1.isBefore(mom2) ? mom1 : mom2).clone();
}


// Returns the moment that's later in time. Always a copy.
function maxMoment(mom1, mom2) {
	return (mom1.isAfter(mom2) ? mom1 : mom2).clone();
}


// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)
function durationHasTime(dur) {
	return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
}


function isNativeDate(input) {
	return  Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
}


// Returns a boolean about whether the given input is a time string, like "06:40:00" or "06:00"
function isTimeString(str) {
	return /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
}


/* Logging and Debug
----------------------------------------------------------------------------------------------------------------------*/

FC.log = function() {
	var console = window.console;

	if (console && console.log) {
		return console.log.apply(console, arguments);
	}
};

FC.warn = function() {
	var console = window.console;

	if (console && console.warn) {
		return console.warn.apply(console, arguments);
	}
	else {
		return FC.log.apply(FC, arguments);
	}
};


/* General Utilities
----------------------------------------------------------------------------------------------------------------------*/

var hasOwnPropMethod = {}.hasOwnProperty;


// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
function mergeProps(propObjs, complexProps) {
	var dest = {};
	var i, name;
	var complexObjs;
	var j, val;
	var props;

	if (complexProps) {
		for (i = 0; i < complexProps.length; i++) {
			name = complexProps[i];
			complexObjs = [];

			// collect the trailing object values, stopping when a non-object is discovered
			for (j = propObjs.length - 1; j >= 0; j--) {
				val = propObjs[j][name];

				if (typeof val === 'object') {
					complexObjs.unshift(val);
				}
				else if (val !== undefined) {
					dest[name] = val; // if there were no objects, this value will be used
					break;
				}
			}

			// if the trailing values were objects, use the merged value
			if (complexObjs.length) {
				dest[name] = mergeProps(complexObjs);
			}
		}
	}

	// copy values into the destination, going from last to first
	for (i = propObjs.length - 1; i >= 0; i--) {
		props = propObjs[i];

		for (name in props) {
			if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign
				dest[name] = props[name];
			}
		}
	}

	return dest;
}


// Create an object that has the given prototype. Just like Object.create
function createObject(proto) {
	var f = function() {};
	f.prototype = proto;
	return new f();
}
FC.createObject = createObject;


function copyOwnProps(src, dest) {
	for (var name in src) {
		if (hasOwnProp(src, name)) {
			dest[name] = src[name];
		}
	}
}


function hasOwnProp(obj, name) {
	return hasOwnPropMethod.call(obj, name);
}


// Is the given value a non-object non-function value?
function isAtomic(val) {
	return /undefined|null|boolean|number|string/.test($.type(val));
}


function applyAll(functions, thisObj, args) {
	if ($.isFunction(functions)) {
		functions = [ functions ];
	}
	if (functions) {
		var i;
		var ret;
		for (i=0; i<functions.length; i++) {
			ret = functions[i].apply(thisObj, args) || ret;
		}
		return ret;
	}
}


function firstDefined() {
	for (var i=0; i<arguments.length; i++) {
		if (arguments[i] !== undefined) {
			return arguments[i];
		}
	}
}


function htmlEscape(s) {
	return (s + '').replace(/&/g, '&amp;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/'/g, '&#039;')
		.replace(/"/g, '&quot;')
		.replace(/\n/g, '<br />');
}


function stripHtmlEntities(text) {
	return text.replace(/&.*?;/g, '');
}


// Given a hash of CSS properties, returns a string of CSS.
// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
function cssToStr(cssProps) {
	var statements = [];

	$.each(cssProps, function(name, val) {
		if (val != null) {
			statements.push(name + ':' + val);
		}
	});

	return statements.join(';');
}


// Given an object hash of HTML attribute names to values,
// generates a string that can be injected between < > in HTML
function attrsToStr(attrs) {
	var parts = [];

	$.each(attrs, function(name, val) {
		if (val != null) {
			parts.push(name + '="' + htmlEscape(val) + '"');
		}
	});

	return parts.join(' ');
}


function capitaliseFirstLetter(str) {
	return str.charAt(0).toUpperCase() + str.slice(1);
}


function compareNumbers(a, b) { // for .sort()
	return a - b;
}


function isInt(n) {
	return n % 1 === 0;
}


// Returns a method bound to the given object context.
// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with
// different contexts as identical when binding/unbinding events.
function proxy(obj, methodName) {
	var method = obj[methodName];

	return function() {
		return method.apply(obj, arguments);
	};
}


// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
function debounce(func, wait, immediate) {
	var timeout, args, context, timestamp, result;

	var later = function() {
		var last = +new Date() - timestamp;
		if (last < wait) {
			timeout = setTimeout(later, wait - last);
		}
		else {
			timeout = null;
			if (!immediate) {
				result = func.apply(context, args);
				context = args = null;
			}
		}
	};

	return function() {
		context = this;
		args = arguments;
		timestamp = +new Date();
		var callNow = immediate && !timeout;
		if (!timeout) {
			timeout = setTimeout(later, wait);
		}
		if (callNow) {
			result = func.apply(context, args);
			context = args = null;
		}
		return result;
	};
}

;;

/*
GENERAL NOTE on moments throughout the *entire rest* of the codebase:
All moments are assumed to be ambiguously-zoned unless otherwise noted,
with the NOTABLE EXCEOPTION of start/end dates that live on *Event Objects*.
Ambiguously-TIMED moments are assumed to be ambiguously-zoned by nature.
*/

var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
var ambigTimeOrZoneRegex =
	/^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
var newMomentProto = moment.fn; // where we will attach our new methods
var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods

// tell momentjs to transfer these properties upon clone
var momentProperties = moment.momentProperties;
momentProperties.push('_fullCalendar');
momentProperties.push('_ambigTime');
momentProperties.push('_ambigZone');


// Creating
// -------------------------------------------------------------------------------------------------

// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
FC.moment = function() {
	return makeMoment(arguments);
};

// Sames as FC.moment, but forces the resulting moment to be in the UTC timezone.
FC.moment.utc = function() {
	var mom = makeMoment(arguments, true);

	// Force it into UTC because makeMoment doesn't guarantee it
	// (if given a pre-existing moment for example)
	if (mom.hasTime()) { // don't give ambiguously-timed moments a UTC zone
		mom.utc();
	}

	return mom;
};

// Same as FC.moment, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
FC.moment.parseZone = function() {
	return makeMoment(arguments, true, true);
};

// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
function makeMoment(args, parseAsUTC, parseZone) {
	var input = args[0];
	var isSingleString = args.length == 1 && typeof input === 'string';
	var isAmbigTime;
	var isAmbigZone;
	var ambigMatch;
	var mom;

	if (moment.isMoment(input) || isNativeDate(input) || input === undefined) {
		mom = moment.apply(null, args);
	}
	else { // "parsing" is required
		isAmbigTime = false;
		isAmbigZone = false;

		if (isSingleString) {
			if (ambigDateOfMonthRegex.test(input)) {
				// accept strings like '2014-05', but convert to the first of the month
				input += '-01';
				args = [ input ]; // for when we pass it on to moment's constructor
				isAmbigTime = true;
				isAmbigZone = true;
			}
			else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
				isAmbigTime = !ambigMatch[5]; // no time part?
				isAmbigZone = true;
			}
		}
		else if ($.isArray(input)) {
			// arrays have no timezone information, so assume ambiguous zone
			isAmbigZone = true;
		}
		// otherwise, probably a string with a format

		if (parseAsUTC || isAmbigTime) {
			mom = moment.utc.apply(moment, args);
		}
		else {
			mom = moment.apply(null, args);
		}

		if (isAmbigTime) {
			mom._ambigTime = true;
			mom._ambigZone = true; // ambiguous time always means ambiguous zone
		}
		else if (parseZone) { // let's record the inputted zone somehow
			if (isAmbigZone) {
				mom._ambigZone = true;
			}
			else if (isSingleString) {
				mom.utcOffset(input); // if not a valid zone, will assign UTC
			}
		}
	}

	mom._fullCalendar = true; // flag for extended functionality

	return mom;
}


// Week Number
// -------------------------------------------------------------------------------------------------


// Returns the week number, considering the locale's custom week number calcuation
// `weeks` is an alias for `week`
newMomentProto.week = newMomentProto.weeks = function(input) {
	var weekCalc = this._locale._fullCalendar_weekCalc;

	if (input == null && typeof weekCalc === 'function') { // custom function only works for getter
		return weekCalc(this);
	}
	else if (weekCalc === 'ISO') {
		return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter
	}

	return oldMomentProto.week.apply(this, arguments); // local getter/setter
};


// Time-of-day
// -------------------------------------------------------------------------------------------------

// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
newMomentProto.time = function(time) {

	// Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
	// `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
	if (!this._fullCalendar) {
		return oldMomentProto.time.apply(this, arguments);
	}

	if (time == null) { // getter
		return moment.duration({
			hours: this.hours(),
			minutes: this.minutes(),
			seconds: this.seconds(),
			milliseconds: this.milliseconds()
		});
	}
	else { // setter

		this._ambigTime = false; // mark that the moment now has a time

		if (!moment.isDuration(time) && !moment.isMoment(time)) {
			time = moment.duration(time);
		}

		// The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
		// Only for Duration times, not Moment times.
		var dayHours = 0;
		if (moment.isDuration(time)) {
			dayHours = Math.floor(time.asDays()) * 24;
		}

		// We need to set the individual fields.
		// Can't use startOf('day') then add duration. In case of DST at start of day.
		return this.hours(dayHours + time.hours())
			.minutes(time.minutes())
			.seconds(time.seconds())
			.milliseconds(time.milliseconds());
	}
};

// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
newMomentProto.stripTime = function() {

	if (!this._ambigTime) {

		this.utc(true); // keepLocalTime=true (for keeping *date* value)

		// set time to zero
		this.set({
			hours: 0,
			minutes: 0,
			seconds: 0,
			ms: 0
		});

		// Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
		// which clears all ambig flags.
		this._ambigTime = true;
		this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset
	}

	return this; // for chaining
};

// Returns if the moment has a non-ambiguous time (boolean)
newMomentProto.hasTime = function() {
	return !this._ambigTime;
};


// Timezone
// -------------------------------------------------------------------------------------------------

// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
newMomentProto.stripZone = function() {
	var wasAmbigTime;

	if (!this._ambigZone) {

		wasAmbigTime = this._ambigTime;

		this.utc(true); // keepLocalTime=true (for keeping date and time values)

		// the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
		this._ambigTime = wasAmbigTime || false;

		// Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
		// which clears the ambig flags.
		this._ambigZone = true;
	}

	return this; // for chaining
};

// Returns of the moment has a non-ambiguous timezone offset (boolean)
newMomentProto.hasZone = function() {
	return !this._ambigZone;
};


// implicitly marks a zone
newMomentProto.local = function(keepLocalTime) {

	// for when converting from ambiguously-zoned to local,
	// keep the time values when converting from UTC -> local
	oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);

	// ensure non-ambiguous
	// this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals
	this._ambigTime = false;
	this._ambigZone = false;

	return this; // for chaining
};


// implicitly marks a zone
newMomentProto.utc = function(keepLocalTime) {

	oldMomentProto.utc.call(this, keepLocalTime);

	// ensure non-ambiguous
	// this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals
	this._ambigTime = false;
	this._ambigZone = false;

	return this;
};


// implicitly marks a zone (will probably get called upon .utc() and .local())
newMomentProto.utcOffset = function(tzo) {

	if (tzo != null) { // setter
		// these assignments needs to happen before the original zone method is called.
		// I forget why, something to do with a browser crash.
		this._ambigTime = false;
		this._ambigZone = false;
	}

	return oldMomentProto.utcOffset.apply(this, arguments);
};


// Formatting
// -------------------------------------------------------------------------------------------------

newMomentProto.format = function() {

	if (this._fullCalendar && arguments[0]) { // an enhanced moment? and a format string provided?
		return formatDate(this, arguments[0]); // our extended formatting
	}
	if (this._ambigTime) {
		return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
	}
	if (this._ambigZone) {
		return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
	}
	if (this._fullCalendar) { // enhanced non-ambig moment?
		// moment.format() doesn't ensure english, but we want to.
		return oldMomentFormat(englishMoment(this));
	}

	return oldMomentProto.format.apply(this, arguments);
};

newMomentProto.toISOString = function() {

	if (this._ambigTime) {
		return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
	}
	if (this._ambigZone) {
		return oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
	}
	if (this._fullCalendar) { // enhanced non-ambig moment?
		// depending on browser, moment might not output english. ensure english.
		// https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22
		return oldMomentProto.toISOString.apply(englishMoment(this), arguments);
	}

	return oldMomentProto.toISOString.apply(this, arguments);
};

function englishMoment(mom) {
	if (mom.locale() !== 'en') {
		return mom.clone().locale('en');
	}
	return mom;
}

;;
(function() {

// exports
FC.formatDate = formatDate;
FC.formatRange = formatRange;
FC.oldMomentFormat = oldMomentFormat;
FC.queryMostGranularFormatUnit = queryMostGranularFormatUnit;


// Config
// ---------------------------------------------------------------------------------------------------------------------

/*
Inserted between chunks in the fake ("intermediate") formatting string.
Important that it passes as whitespace (\s) because moment often identifies non-standalone months
via a regexp with an \s.
*/
var PART_SEPARATOR = '\u000b'; // vertical tab

/*
Inserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,
but rather, a "special" token that has custom rendering (see specialTokens map).
*/
var SPECIAL_TOKEN_MARKER = '\u001f'; // information separator 1

/*
Inserted at the beginning and end of a span of text that must have non-zero numeric characters.
Handling of these markers is done in a post-processing step at the very end of text rendering.
*/
var MAYBE_MARKER = '\u001e'; // information separator 2
var MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global

/*
Addition formatting tokens we want recognized
*/
var specialTokens = {
	t: function(date) { // "a" or "p"
		return oldMomentFormat(date, 'a').charAt(0);
	},
	T: function(date) { // "A" or "P"
		return oldMomentFormat(date, 'A').charAt(0);
	}
};

/*
The first characters of formatting tokens for units that are 1 day or larger.
`value` is for ranking relative size (lower means bigger).
`unit` is a normalized unit, used for comparing moments.
*/
var largeTokenMap = {
	Y: { value: 1, unit: 'year' },
	M: { value: 2, unit: 'month' },
	W: { value: 3, unit: 'week' }, // ISO week
	w: { value: 3, unit: 'week' }, // local week
	D: { value: 4, unit: 'day' }, // day of month
	d: { value: 4, unit: 'day' } // day of week
};


// Single Date Formatting
// ---------------------------------------------------------------------------------------------------------------------

/*
Formats `date` with a Moment formatting string, but allow our non-zero areas and special token
*/
function formatDate(date, formatStr) {
	return renderFakeFormatString(
		getParsedFormatString(formatStr).fakeFormatString,
		date
	);
}

/*
Call this if you want Moment's original format method to be used
*/
function oldMomentFormat(mom, formatStr) {
	return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js
}


// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset

/*
Using a formatting string meant for a single date, generate a range string, like
"Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
If the dates are the same as far as the format string is concerned, just return a single
rendering of one date, without any separator.
*/
function formatRange(date1, date2, formatStr, separator, isRTL) {
	var localeData;

	date1 = FC.moment.parseZone(date1);
	date2 = FC.moment.parseZone(date2);

	localeData = date1.localeData();

	// Expand localized format strings, like "LL" -> "MMMM D YYYY".
	// BTW, this is not important for `formatDate` because it is impossible to put custom tokens
	// or non-zero areas in Moment's localized format strings.
	formatStr = localeData.longDateFormat(formatStr) || formatStr;

	return renderParsedFormat(
		getParsedFormatString(formatStr),
		date1,
		date2,
		separator || ' - ',
		isRTL
	);
}

/*
Renders a range with an already-parsed format string.
*/
function renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {
	var sameUnits = parsedFormat.sameUnits;
	var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons
	var unzonedDate2 = date2.clone().stripZone(); // "

	var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);
	var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);

	var leftI;
	var leftStr = '';
	var rightI;
	var rightStr = '';
	var middleI;
	var middleStr1 = '';
	var middleStr2 = '';
	var middleStr = '';

	// Start at the leftmost side of the formatting string and continue until you hit a token
	// that is not the same between dates.
	for (
		leftI = 0;
		leftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI]));
		leftI++
	) {
		leftStr += renderedParts1[leftI];
	}

	// Similarly, start at the rightmost side of the formatting string and move left
	for (
		rightI = sameUnits.length - 1;
		rightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI]));
		rightI--
	) {
		// If current chunk is on the boundary of unique date-content, and is a special-case
		// date-formatting postfix character, then don't consume it. Consider it unique date-content.
		// TODO: make configurable
		if (rightI - 1 === leftI && renderedParts1[rightI] === '.') {
			break;
		}

		rightStr = renderedParts1[rightI] + rightStr;
	}

	// The area in the middle is different for both of the dates.
	// Collect them distinctly so we can jam them together later.
	for (middleI = leftI; middleI <= rightI; middleI++) {
		middleStr1 += renderedParts1[middleI];
		middleStr2 += renderedParts2[middleI];
	}

	if (middleStr1 || middleStr2) {
		if (isRTL) {
			middleStr = middleStr2 + separator + middleStr1;
		}
		else {
			middleStr = middleStr1 + separator + middleStr2;
		}
	}

	return processMaybeMarkers(
		leftStr + middleStr + rightStr
	);
}


// Format String Parsing
// ---------------------------------------------------------------------------------------------------------------------

var parsedFormatStrCache = {};

/*
Returns a parsed format string, leveraging a cache.
*/
function getParsedFormatString(formatStr) {
	return parsedFormatStrCache[formatStr] ||
		(parsedFormatStrCache[formatStr] = parseFormatString(formatStr));
}

/*
Parses a format string into the following:
- fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.
- sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like "day"),
  that indicates how similar a range's start & end must be in order to share the same formatted text.
  If not a token, then the value is null.
  Always a flat array (not nested liked "chunks").
*/
function parseFormatString(formatStr) {
	var chunks = chunkFormatString(formatStr);
	
	return {
		fakeFormatString: buildFakeFormatString(chunks),
		sameUnits: buildSameUnits(chunks)
	};
}

/*
Break the formatting string into an array of chunks.
A 'maybe' chunk will have nested chunks.
*/
function chunkFormatString(formatStr) {
	var chunks = [];
	var match;

	// TODO: more descrimination
	// \4 is a backreference to the first character of a multi-character set.
	var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g;

	while ((match = chunker.exec(formatStr))) {
		if (match[1]) { // a literal string inside [ ... ]
			chunks.push.apply(chunks, // append
				splitStringLiteral(match[1])
			);
		}
		else if (match[2]) { // non-zero formatting inside ( ... )
			chunks.push({ maybe: chunkFormatString(match[2]) });
		}
		else if (match[3]) { // a formatting token
			chunks.push({ token: match[3] });
		}
		else if (match[5]) { // an unenclosed literal string
			chunks.push.apply(chunks, // append
				splitStringLiteral(match[5])
			);
		}
	}

	return chunks;
}

/*
Potentially splits a literal-text string into multiple parts. For special cases.
*/
function splitStringLiteral(s) {
	if (s === '. ') {
		return [ '.', ' ' ]; // for locales with periods bound to the end of each year/month/date
	}
	else {
		return [ s ];
	}
}

/*
Given chunks parsed from a real format string, generate a fake (aka "intermediate") format string with special control
characters that will eventually be given to moment for formatting, and then post-processed.
*/
function buildFakeFormatString(chunks) {
	var parts = [];
	var i, chunk;

	for (i = 0; i < chunks.length; i++) {
		chunk = chunks[i];

		if (typeof chunk === 'string') {
			parts.push('[' + chunk + ']');
		}
		else if (chunk.token) {
			if (chunk.token in specialTokens) {
				parts.push(
					SPECIAL_TOKEN_MARKER + // useful during post-processing
					'[' + chunk.token + ']' // preserve as literal text
				);
			}
			else {
				parts.push(chunk.token); // unprotected text implies a format string
			}
		}
		else if (chunk.maybe) {
			parts.push(
				MAYBE_MARKER + // useful during post-processing
				buildFakeFormatString(chunk.maybe) +
				MAYBE_MARKER
			);
		}
	}

	return parts.join(PART_SEPARATOR);
}

/*
Given parsed chunks from a real formatting string, generates an array of unit strings (like "day") that indicate
in which regard two dates must be similar in order to share range formatting text.
The `chunks` can be nested (because of "maybe" chunks), however, the returned array will be flat.
*/
function buildSameUnits(chunks) {
	var units = [];
	var i, chunk;
	var tokenInfo;

	for (i = 0; i < chunks.length; i++) {
		chunk = chunks[i];

		if (chunk.token) {
			tokenInfo = largeTokenMap[chunk.token.charAt(0)];
			units.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second
		}
		else if (chunk.maybe) {
			units.push.apply(units, // append
				buildSameUnits(chunk.maybe)
			);
		}
		else {
			units.push(null);
		}
	}

	return units;
}


// Rendering to text
// ---------------------------------------------------------------------------------------------------------------------

/*
Formats a date with a fake format string, post-processes the control characters, then returns.
*/
function renderFakeFormatString(fakeFormatString, date) {
	return processMaybeMarkers(
		renderFakeFormatStringParts(fakeFormatString, date).join('')
	);
}

/*
Formats a date into parts that will have been post-processed, EXCEPT for the "maybe" markers.
*/
function renderFakeFormatStringParts(fakeFormatString, date) {
	var parts = [];
	var fakeRender = oldMomentFormat(date, fakeFormatString);
	var fakeParts = fakeRender.split(PART_SEPARATOR);
	var i, fakePart;

	for (i = 0; i < fakeParts.length; i++) {
		fakePart = fakeParts[i];

		if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {
			parts.push(
				// the literal string IS the token's name.
				// call special token's registered function.
				specialTokens[fakePart.substring(1)](date)
			);
		}
		else {
			parts.push(fakePart);
		}
	}

	return parts;
}

/*
Accepts an almost-finally-formatted string and processes the "maybe" control characters, returning a new string.
*/
function processMaybeMarkers(s) {
	return s.replace(MAYBE_REGEXP, function(m0, m1) { // regex assumed to have 'g' flag
		if (m1.match(/[1-9]/)) { // any non-zero numeric characters?
			return m1;
		}
		else {
			return '';
		}
	});
}


// Misc Utils
// -------------------------------------------------------------------------------------------------

/*
Returns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.
*/
function queryMostGranularFormatUnit(formatStr) {
	var chunks = chunkFormatString(formatStr);
	var i, chunk;
	var candidate;
	var best;

	for (i = 0; i < chunks.length; i++) {
		chunk = chunks[i];

		if (chunk.token) {
			candidate = largeTokenMap[chunk.token.charAt(0)];
			if (candidate) {
				if (!best || candidate.value > best.value) {
					best = candidate;
				}
			}
		}
	}

	if (best) {
		return best.unit;
	}

	return null;
};

})();

// quick local references
var formatDate = FC.formatDate;
var formatRange = FC.formatRange;
var oldMomentFormat = FC.oldMomentFormat;

;;

FC.Class = Class; // export

// Class that all other classes will inherit from
function Class() { }


// Called on a class to create a subclass.
// Last argument contains instance methods. Any argument before the last are considered mixins.
Class.extend = function() {
	var len = arguments.length;
	var i;
	var members;

	for (i = 0; i < len; i++) {
		members = arguments[i];
		if (i < len - 1) { // not the last argument?
			mixIntoClass(this, members);
		}
	}

	return extendClass(this, members || {}); // members will be undefined if no arguments
};


// Adds new member variables/methods to the class's prototype.
// Can be called with another class, or a plain object hash containing new members.
Class.mixin = function(members) {
	mixIntoClass(this, members);
};


function extendClass(superClass, members) {
	var subClass;

	// ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist
	if (hasOwnProp(members, 'constructor')) {
		subClass = members.constructor;
	}
	if (typeof subClass !== 'function') {
		subClass = members.constructor = function() {
			superClass.apply(this, arguments);
		};
	}

	// build the base prototype for the subclass, which is an new object chained to the superclass's prototype
	subClass.prototype = createObject(superClass.prototype);

	// copy each member variable/method onto the the subclass's prototype
	copyOwnProps(members, subClass.prototype);

	// copy over all class variables/methods to the subclass, such as `extend` and `mixin`
	copyOwnProps(superClass, subClass);

	return subClass;
}


function mixIntoClass(theClass, members) {
	copyOwnProps(members, theClass.prototype);
}
;;

var Model = Class.extend(EmitterMixin, ListenerMixin, {

	_props: null,
	_watchers: null,
	_globalWatchArgs: null,

	constructor: function() {
		this._watchers = {};
		this._props = {};
		this.applyGlobalWatchers();
	},

	applyGlobalWatchers: function() {
		var argSets = this._globalWatchArgs || [];
		var i;

		for (i = 0; i < argSets.length; i++) {
			this.watch.apply(this, argSets[i]);
		}
	},

	has: function(name) {
		return name in this._props;
	},

	get: function(name) {
		if (name === undefined) {
			return this._props;
		}

		return this._props[name];
	},

	set: function(name, val) {
		var newProps;

		if (typeof name === 'string') {
			newProps = {};
			newProps[name] = val === undefined ? null : val;
		}
		else {
			newProps = name;
		}

		this.setProps(newProps);
	},

	reset: function(newProps) {
		var oldProps = this._props;
		var changeset = {}; // will have undefined's to signal unsets
		var name;

		for (name in oldProps) {
			changeset[name] = undefined;
		}

		for (name in newProps) {
			changeset[name] = newProps[name];
		}

		this.setProps(changeset);
	},

	unset: function(name) { // accepts a string or array of strings
		var newProps = {};
		var names;
		var i;

		if (typeof name === 'string') {
			names = [ name ];
		}
		else {
			names = name;
		}

		for (i = 0; i < names.length; i++) {
			newProps[names[i]] = undefined;
		}

		this.setProps(newProps);
	},

	setProps: function(newProps) {
		var changedProps = {};
		var changedCnt = 0;
		var name, val;

		for (name in newProps) {
			val = newProps[name];

			// a change in value?
			// if an object, don't check equality, because might have been mutated internally.
			// TODO: eventually enforce immutability.
			if (
				typeof val === 'object' ||
				val !== this._props[name]
			) {
				changedProps[name] = val;
				changedCnt++;
			}
		}

		if (changedCnt) {

			this.trigger('before:batchChange', changedProps);

			for (name in changedProps) {
				val = changedProps[name];

				this.trigger('before:change', name, val);
				this.trigger('before:change:' + name, val);
			}

			for (name in changedProps) {
				val = changedProps[name];

				if (val === undefined) {
					delete this._props[name];
				}
				else {
					this._props[name] = val;
				}

				this.trigger('change:' + name, val);
				this.trigger('change', name, val);
			}

			this.trigger('batchChange', changedProps);
		}
	},

	watch: function(name, depList, startFunc, stopFunc) {
		var _this = this;

		this.unwatch(name);

		this._watchers[name] = this._watchDeps(depList, function(deps) {
			var res = startFunc.call(_this, deps);

			if (res && res.then) {
				_this.unset(name); // put in an unset state while resolving
				res.then(function(val) {
					_this.set(name, val);
				});
			}
			else {
				_this.set(name, res);
			}
		}, function() {
			_this.unset(name);

			if (stopFunc) {
				stopFunc.call(_this);
			}
		});
	},

	unwatch: function(name) {
		var watcher = this._watchers[name];

		if (watcher) {
			delete this._watchers[name];
			watcher.teardown();
		}
	},

	_watchDeps: function(depList, startFunc, stopFunc) {
		var _this = this;
		var queuedChangeCnt = 0;
		var depCnt = depList.length;
		var satisfyCnt = 0;
		var values = {}; // what's passed as the `deps` arguments
		var bindTuples = []; // array of [ eventName, handlerFunc ] arrays
		var isCallingStop = false;

		function onBeforeDepChange(depName, val, isOptional) {
			queuedChangeCnt++;
			if (queuedChangeCnt === 1) { // first change to cause a "stop" ?
				if (satisfyCnt === depCnt) { // all deps previously satisfied?
					isCallingStop = true;
					stopFunc();
					isCallingStop = false;
				}
			}
		}

		function onDepChange(depName, val, isOptional) {

			if (val === undefined) { // unsetting a value?

				// required dependency that was previously set?
				if (!isOptional && values[depName] !== undefined) {
					satisfyCnt--;
				}

				delete values[depName];
			}
			else { // setting a value?

				// required dependency that was previously unset?
				if (!isOptional && values[depName] === undefined) {
					satisfyCnt++;
				}

				values[depName] = val;
			}

			queuedChangeCnt--;
			if (!queuedChangeCnt) { // last change to cause a "start"?

				// now finally satisfied or satisfied all along?
				if (satisfyCnt === depCnt) {

					// if the stopFunc initiated another value change, ignore it.
					// it will be processed by another change event anyway.
					if (!isCallingStop) {
						startFunc(values);
					}
				}
			}
		}

		// intercept for .on() that remembers handlers
		function bind(eventName, handler) {
			_this.on(eventName, handler);
			bindTuples.push([ eventName, handler ]);
		}

		// listen to dependency changes
		depList.forEach(function(depName) {
			var isOptional = false;

			if (depName.charAt(0) === '?') { // TODO: more DRY
				depName = depName.substring(1);
				isOptional = true;
			}

			bind('before:change:' + depName, function(val) {
				onBeforeDepChange(depName, val, isOptional);
			});

			bind('change:' + depName, function(val) {
				onDepChange(depName, val, isOptional);
			});
		});

		// process current dependency values
		depList.forEach(function(depName) {
			var isOptional = false;

			if (depName.charAt(0) === '?') { // TODO: more DRY
				depName = depName.substring(1);
				isOptional = true;
			}

			if (_this.has(depName)) {
				values[depName] = _this.get(depName);
				satisfyCnt++;
			}
			else if (isOptional) {
				satisfyCnt++;
			}
		});

		// initially satisfied
		if (satisfyCnt === depCnt) {
			startFunc(values);
		}

		return {
			teardown: function() {
				// remove all handlers
				for (var i = 0; i < bindTuples.length; i++) {
					_this.off(bindTuples[i][0], bindTuples[i][1]);
				}
				bindTuples = null;

				// was satisfied, so call stopFunc
				if (satisfyCnt === depCnt) {
					stopFunc();
				}
			},
			flash: function() {
				if (satisfyCnt === depCnt) {
					stopFunc();
					startFunc(values);
				}
			}
		};
	},

	flash: function(name) {
		var watcher = this._watchers[name];

		if (watcher) {
			watcher.flash();
		}
	}

});


Model.watch = function(/* same arguments as this.watch() */) {
	var proto = this.prototype;

	if (!proto._globalWatchArgs) {
		proto._globalWatchArgs = [];
	}

	proto._globalWatchArgs.push(arguments);
};


FC.Model = Model;


;;

var Promise = {

	construct: function(executor) {
		var deferred = $.Deferred();
		var promise = deferred.promise();

		if (typeof executor === 'function') {
			executor(
				function(val) { // resolve
					deferred.resolve(val);
					attachImmediatelyResolvingThen(promise, val);
				},
				function() { // reject
					deferred.reject();
					attachImmediatelyRejectingThen(promise);
				}
			);
		}

		return promise;
	},

	resolve: function(val) {
		var deferred = $.Deferred().resolve(val);
		var promise = deferred.promise();

		attachImmediatelyResolvingThen(promise, val);

		return promise;
	},

	reject: function() {
		var deferred = $.Deferred().reject();
		var promise = deferred.promise();

		attachImmediatelyRejectingThen(promise);

		return promise;
	}

};


function attachImmediatelyResolvingThen(promise, val) {
	promise.then = function(onResolve) {
		if (typeof onResolve === 'function') {
			onResolve(val);
		}
		return promise; // for chaining
	};
}


function attachImmediatelyRejectingThen(promise) {
	promise.then = function(onResolve, onReject) {
		if (typeof onReject === 'function') {
			onReject();
		}
		return promise; // for chaining
	};
}


FC.Promise = Promise;

;;

var TaskQueue = Class.extend(EmitterMixin, {

	q: null,
	isPaused: false,
	isRunning: false,


	constructor: function() {
		this.q = [];
	},


	queue: function(/* taskFunc, taskFunc... */) {
		this.q.push.apply(this.q, arguments); // append
		this.tryStart();
	},


	pause: function() {
		this.isPaused = true;
	},


	resume: function() {
		this.isPaused = false;
		this.tryStart();
	},


	tryStart: function() {
		if (!this.isRunning && this.canRunNext()) {
			this.isRunning = true;
			this.trigger('start');
			this.runNext();
		}
	},


	canRunNext: function() {
		return !this.isPaused && this.q.length;
	},


	runNext: function() { // does not check canRunNext
		this.runTask(this.q.shift());
	},


	runTask: function(task) {
		this.runTaskFunc(task);
	},


	runTaskFunc: function(taskFunc) {
		var _this = this;
		var res = taskFunc();

		if (res && res.then) {
			res.then(done);
		}
		else {
			done();
		}

		function done() {
			if (_this.canRunNext()) {
				_this.runNext();
			}
			else {
				_this.isRunning = false;
				_this.trigger('stop');
			}
		}
	}

});

FC.TaskQueue = TaskQueue;

;;

var RenderQueue = TaskQueue.extend({

	waitsByNamespace: null,
	waitNamespace: null,
	waitId: null,


	constructor: function(waitsByNamespace) {
		TaskQueue.call(this); // super-constructor

		this.waitsByNamespace = waitsByNamespace || {};
	},


	queue: function(taskFunc, namespace, type) {
		var task = {
			func: taskFunc,
			namespace: namespace,
			type: type
		};
		var waitMs;

		if (namespace) {
			waitMs = this.waitsByNamespace[namespace];
		}

		if (this.waitNamespace) {
			if (namespace === this.waitNamespace && waitMs != null) {
				this.delayWait(waitMs);
			}
			else {
				this.clearWait();
				this.tryStart();
			}
		}

		if (this.compoundTask(task)) { // appended to queue?

			if (!this.waitNamespace && waitMs != null) {
				this.startWait(namespace, waitMs);
			}
			else {
				this.tryStart();
			}
		}
	},


	startWait: function(namespace, waitMs) {
		this.waitNamespace = namespace;
		this.spawnWait(waitMs);
	},


	delayWait: function(waitMs) {
		clearTimeout(this.waitId);
		this.spawnWait(waitMs);
	},


	spawnWait: function(waitMs) {
		var _this = this;

		this.waitId = setTimeout(function() {
			_this.waitNamespace = null;
			_this.tryStart();
		}, waitMs);
	},


	clearWait: function() {
		if (this.waitNamespace) {
			clearTimeout(this.waitId);
			this.waitId = null;
			this.waitNamespace = null;
		}
	},


	canRunNext: function() {
		if (!TaskQueue.prototype.canRunNext.apply(this, arguments)) {
			return false;
		}

		// waiting for a certain namespace to stop receiving tasks?
		if (this.waitNamespace) {

			// if there was a different namespace task in the meantime,
			// that forces all previously-waiting tasks to suddenly execute.
			// TODO: find a way to do this in constant time.
			for (var q = this.q, i = 0; i < q.length; i++) {
				if (q[i].namespace !== this.waitNamespace) {
					return true; // allow execution
				}
			}

			return false;
		}

		return true;
	},


	runTask: function(task) {
		this.runTaskFunc(task.func);
	},


	compoundTask: function(newTask) {
		var q = this.q;
		var shouldAppend = true;
		var i, task;

		if (newTask.namespace) {

			if (newTask.type === 'destroy' || newTask.type === 'init') {

				// remove all add/remove ops with same namespace, regardless of order
				for (i = q.length - 1; i >= 0; i--) {
					task = q[i];

					if (
						task.namespace === newTask.namespace &&
						(task.type === 'add' || task.type === 'remove')
					) {
						q.splice(i, 1); // remove task
					}
				}

				if (newTask.type === 'destroy') {
					// eat away final init/destroy operation
					if (q.length) {
						task = q[q.length - 1]; // last task

						if (task.namespace === newTask.namespace) {

							// the init and our destroy cancel each other out
							if (task.type === 'init') {
								shouldAppend = false;
								q.pop();
							}
							// prefer to use the destroy operation that's already present
							else if (task.type === 'destroy') {
								shouldAppend = false;
							}
						}
					}
				}
				else if (newTask.type === 'init') {
					// eat away final init operation
					if (q.length) {
						task = q[q.length - 1]; // last task

						if (
							task.namespace === newTask.namespace &&
							task.type === 'init'
						) {
							// our init operation takes precedence
							q.pop();
						}
					}
				}
			}
		}

		if (shouldAppend) {
			q.push(newTask);
		}

		return shouldAppend;
	}

});

FC.RenderQueue = RenderQueue;

;;

var EmitterMixin = FC.EmitterMixin = {

	// jQuery-ification via $(this) allows a non-DOM object to have
	// the same event handling capabilities (including namespaces).


	on: function(types, handler) {
		$(this).on(types, this._prepareIntercept(handler));
		return this; // for chaining
	},


	one: function(types, handler) {
		$(this).one(types, this._prepareIntercept(handler));
		return this; // for chaining
	},


	_prepareIntercept: function(handler) {
		// handlers are always called with an "event" object as their first param.
		// sneak the `this` context and arguments into the extra parameter object
		// and forward them on to the original handler.
		var intercept = function(ev, extra) {
			return handler.apply(
				extra.context || this,
				extra.args || []
			);
		};

		// mimick jQuery's internal "proxy" system (risky, I know)
		// causing all functions with the same .guid to appear to be the same.
		// https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448
		// this is needed for calling .off with the original non-intercept handler.
		if (!handler.guid) {
			handler.guid = $.guid++;
		}
		intercept.guid = handler.guid;

		return intercept;
	},


	off: function(types, handler) {
		$(this).off(types, handler);

		return this; // for chaining
	},


	trigger: function(types) {
		var args = Array.prototype.slice.call(arguments, 1); // arguments after the first

		// pass in "extra" info to the intercept
		$(this).triggerHandler(types, { args: args });

		return this; // for chaining
	},


	triggerWith: function(types, context, args) {

		// `triggerHandler` is less reliant on the DOM compared to `trigger`.
		// pass in "extra" info to the intercept.
		$(this).triggerHandler(types, { context: context, args: args });

		return this; // for chaining
	}

};

;;

/*
Utility methods for easily listening to events on another object,
and more importantly, easily unlistening from them.
*/
var ListenerMixin = FC.ListenerMixin = (function() {
	var guid = 0;
	var ListenerMixin = {

		listenerId: null,

		/*
		Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.
		The `callback` will be called with the `this` context of the object that .listenTo is being called on.
		Can be called:
			.listenTo(other, eventName, callback)
		OR
			.listenTo(other, {
				eventName1: callback1,
				eventName2: callback2
			})
		*/
		listenTo: function(other, arg, callback) {
			if (typeof arg === 'object') { // given dictionary of callbacks
				for (var eventName in arg) {
					if (arg.hasOwnProperty(eventName)) {
						this.listenTo(other, eventName, arg[eventName]);
					}
				}
			}
			else if (typeof arg === 'string') {
				other.on(
					arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object
					$.proxy(callback, this) // always use `this` context
						// the usually-undesired jQuery guid behavior doesn't matter,
						// because we always unbind via namespace
				);
			}
		},

		/*
		Causes the current object to stop listening to events on the `other` object.
		`eventName` is optional. If omitted, will stop listening to ALL events on `other`.
		*/
		stopListeningTo: function(other, eventName) {
			other.off((eventName || '') + '.' + this.getListenerNamespace());
		},

		/*
		Returns a string, unique to this object, to be used for event namespacing
		*/
		getListenerNamespace: function() {
			if (this.listenerId == null) {
				this.listenerId = guid++;
			}
			return '_listener' + this.listenerId;
		}

	};
	return ListenerMixin;
})();
;;

/* A rectangular panel that is absolutely positioned over other content
------------------------------------------------------------------------------------------------------------------------
Options:
	- className (string)
	- content (HTML string or jQuery element set)
	- parentEl
	- top
	- left
	- right (the x coord of where the right edge should be. not a "CSS" right)
	- autoHide (boolean)
	- show (callback)
	- hide (callback)
*/

var Popover = Class.extend(ListenerMixin, {

	isHidden: true,
	options: null,
	el: null, // the container element for the popover. generated by this object
	margin: 10, // the space required between the popover and the edges of the scroll container


	constructor: function(options) {
		this.options = options || {};
	},


	// Shows the popover on the specified position. Renders it if not already
	show: function() {
		if (this.isHidden) {
			if (!this.el) {
				this.render();
			}
			this.el.show();
			this.position();
			this.isHidden = false;
			this.trigger('show');
		}
	},


	// Hides the popover, through CSS, but does not remove it from the DOM
	hide: function() {
		if (!this.isHidden) {
			this.el.hide();
			this.isHidden = true;
			this.trigger('hide');
		}
	},


	// Creates `this.el` and renders content inside of it
	render: function() {
		var _this = this;
		var options = this.options;

		this.el = $('<div class="fc-popover"/>')
			.addClass(options.className || '')
			.css({
				// position initially to the top left to avoid creating scrollbars
				top: 0,
				left: 0
			})
			.append(options.content)
			.appendTo(options.parentEl);

		// when a click happens on anything inside with a 'fc-close' className, hide the popover
		this.el.on('click', '.fc-close', function() {
			_this.hide();
		});

		if (options.autoHide) {
			this.listenTo($(document), 'mousedown', this.documentMousedown);
		}
	},


	// Triggered when the user clicks *anywhere* in the document, for the autoHide feature
	documentMousedown: function(ev) {
		// only hide the popover if the click happened outside the popover
		if (this.el && !$(ev.target).closest(this.el).length) {
			this.hide();
		}
	},


	// Hides and unregisters any handlers
	removeElement: function() {
		this.hide();

		if (this.el) {
			this.el.remove();
			this.el = null;
		}

		this.stopListeningTo($(document), 'mousedown');
	},


	// Positions the popover optimally, using the top/left/right options
	position: function() {
		var options = this.options;
		var origin = this.el.offsetParent().offset();
		var width = this.el.outerWidth();
		var height = this.el.outerHeight();
		var windowEl = $(window);
		var viewportEl = getScrollParent(this.el);
		var viewportTop;
		var viewportLeft;
		var viewportOffset;
		var top; // the "position" (not "offset") values for the popover
		var left; //

		// compute top and left
		top = options.top || 0;
		if (options.left !== undefined) {
			left = options.left;
		}
		else if (options.right !== undefined) {
			left = options.right - width; // derive the left value from the right value
		}
		else {
			left = 0;
		}

		if (viewportEl.is(window) || viewportEl.is(document)) { // normalize getScrollParent's result
			viewportEl = windowEl;
			viewportTop = 0; // the window is always at the top left
			viewportLeft = 0; // (and .offset() won't work if called here)
		}
		else {
			viewportOffset = viewportEl.offset();
			viewportTop = viewportOffset.top;
			viewportLeft = viewportOffset.left;
		}

		// if the window is scrolled, it causes the visible area to be further down
		viewportTop += windowEl.scrollTop();
		viewportLeft += windowEl.scrollLeft();

		// constrain to the view port. if constrained by two edges, give precedence to top/left
		if (options.viewportConstrain !== false) {
			top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
			top = Math.max(top, viewportTop + this.margin);
			left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
			left = Math.max(left, viewportLeft + this.margin);
		}

		this.el.css({
			top: top - origin.top,
			left: left - origin.left
		});
	},


	// Triggers a callback. Calls a function in the option hash of the same name.
	// Arguments beyond the first `name` are forwarded on.
	// TODO: better code reuse for this. Repeat code
	trigger: function(name) {
		if (this.options[name]) {
			this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
	}

});

;;

/*
A cache for the left/right/top/bottom/width/height values for one or more elements.
Works with both offset (from topleft document) and position (from offsetParent).

options:
- els
- isHorizontal
- isVertical
*/
var CoordCache = FC.CoordCache = Class.extend({

	els: null, // jQuery set (assumed to be siblings)
	forcedOffsetParentEl: null, // options can override the natural offsetParent
	origin: null, // {left,top} position of offsetParent of els
	boundingRect: null, // constrain cordinates to this rectangle. {left,right,top,bottom} or null
	isHorizontal: false, // whether to query for left/right/width
	isVertical: false, // whether to query for top/bottom/height

	// arrays of coordinates (offsets from topleft of document)
	lefts: null,
	rights: null,
	tops: null,
	bottoms: null,


	constructor: function(options) {
		this.els = $(options.els);
		this.isHorizontal = options.isHorizontal;
		this.isVertical = options.isVertical;
		this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;
	},


	// Queries the els for coordinates and stores them.
	// Call this method before using and of the get* methods below.
	build: function() {
		var offsetParentEl = this.forcedOffsetParentEl;
		if (!offsetParentEl && this.els.length > 0) {
			offsetParentEl = this.els.eq(0).offsetParent();
		}

		this.origin = offsetParentEl ?
			offsetParentEl.offset() :
			null;

		this.boundingRect = this.queryBoundingRect();

		if (this.isHorizontal) {
			this.buildElHorizontals();
		}
		if (this.isVertical) {
			this.buildElVerticals();
		}
	},


	// Destroys all internal data about coordinates, freeing memory
	clear: function() {
		this.origin = null;
		this.boundingRect = null;
		this.lefts = null;
		this.rights = null;
		this.tops = null;
		this.bottoms = null;
	},


	// When called, if coord caches aren't built, builds them
	ensureBuilt: function() {
		if (!this.origin) {
			this.build();
		}
	},


	// Populates the left/right internal coordinate arrays
	buildElHorizontals: function() {
		var lefts = [];
		var rights = [];

		this.els.each(function(i, node) {
			var el = $(node);
			var left = el.offset().left;
			var width = el.outerWidth();

			lefts.push(left);
			rights.push(left + width);
		});

		this.lefts = lefts;
		this.rights = rights;
	},


	// Populates the top/bottom internal coordinate arrays
	buildElVerticals: function() {
		var tops = [];
		var bottoms = [];

		this.els.each(function(i, node) {
			var el = $(node);
			var top = el.offset().top;
			var height = el.outerHeight();

			tops.push(top);
			bottoms.push(top + height);
		});

		this.tops = tops;
		this.bottoms = bottoms;
	},


	// Given a left offset (from document left), returns the index of the el that it horizontally intersects.
	// If no intersection is made, returns undefined.
	getHorizontalIndex: function(leftOffset) {
		this.ensureBuilt();

		var lefts = this.lefts;
		var rights = this.rights;
		var len = lefts.length;
		var i;

		for (i = 0; i < len; i++) {
			if (leftOffset >= lefts[i] && leftOffset < rights[i]) {
				return i;
			}
		}
	},


	// Given a top offset (from document top), returns the index of the el that it vertically intersects.
	// If no intersection is made, returns undefined.
	getVerticalIndex: function(topOffset) {
		this.ensureBuilt();

		var tops = this.tops;
		var bottoms = this.bottoms;
		var len = tops.length;
		var i;

		for (i = 0; i < len; i++) {
			if (topOffset >= tops[i] && topOffset < bottoms[i]) {
				return i;
			}
		}
	},


	// Gets the left offset (from document left) of the element at the given index
	getLeftOffset: function(leftIndex) {
		this.ensureBuilt();
		return this.lefts[leftIndex];
	},


	// Gets the left position (from offsetParent left) of the element at the given index
	getLeftPosition: function(leftIndex) {
		this.ensureBuilt();
		return this.lefts[leftIndex] - this.origin.left;
	},


	// Gets the right offset (from document left) of the element at the given index.
	// This value is NOT relative to the document's right edge, like the CSS concept of "right" would be.
	getRightOffset: function(leftIndex) {
		this.ensureBuilt();
		return this.rights[leftIndex];
	},


	// Gets the right position (from offsetParent left) of the element at the given index.
	// This value is NOT relative to the offsetParent's right edge, like the CSS concept of "right" would be.
	getRightPosition: function(leftIndex) {
		this.ensureBuilt();
		return this.rights[leftIndex] - this.origin.left;
	},


	// Gets the width of the element at the given index
	getWidth: function(leftIndex) {
		this.ensureBuilt();
		return this.rights[leftIndex] - this.lefts[leftIndex];
	},


	// Gets the top offset (from document top) of the element at the given index
	getTopOffset: function(topIndex) {
		this.ensureBuilt();
		return this.tops[topIndex];
	},


	// Gets the top position (from offsetParent top) of the element at the given position
	getTopPosition: function(topIndex) {
		this.ensureBuilt();
		return this.tops[topIndex] - this.origin.top;
	},

	// Gets the bottom offset (from the document top) of the element at the given index.
	// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
	getBottomOffset: function(topIndex) {
		this.ensureBuilt();
		return this.bottoms[topIndex];
	},


	// Gets the bottom position (from the offsetParent top) of the element at the given index.
	// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
	getBottomPosition: function(topIndex) {
		this.ensureBuilt();
		return this.bottoms[topIndex] - this.origin.top;
	},


	// Gets the height of the element at the given index
	getHeight: function(topIndex) {
		this.ensureBuilt();
		return this.bottoms[topIndex] - this.tops[topIndex];
	},


	// Bounding Rect
	// TODO: decouple this from CoordCache

	// Compute and return what the elements' bounding rectangle is, from the user's perspective.
	// Right now, only returns a rectangle if constrained by an overflow:scroll element.
	// Returns null if there are no elements
	queryBoundingRect: function() {
		var scrollParentEl;

		if (this.els.length > 0) {
			scrollParentEl = getScrollParent(this.els.eq(0));

			if (!scrollParentEl.is(document)) {
				return getClientRect(scrollParentEl);
			}
		}

		return null;
	},

	isPointInBounds: function(leftOffset, topOffset) {
		return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);
	},

	isLeftInBounds: function(leftOffset) {
		return !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);
	},

	isTopInBounds: function(topOffset) {
		return !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);
	}

});

;;

/* Tracks a drag's mouse movement, firing various handlers
----------------------------------------------------------------------------------------------------------------------*/
// TODO: use Emitter

var DragListener = FC.DragListener = Class.extend(ListenerMixin, {

	options: null,
	subjectEl: null,

	// coordinates of the initial mousedown
	originX: null,
	originY: null,

	// the wrapping element that scrolls, or MIGHT scroll if there's overflow.
	// TODO: do this for wrappers that have overflow:hidden as well.
	scrollEl: null,

	isInteracting: false,
	isDistanceSurpassed: false,
	isDelayEnded: false,
	isDragging: false,
	isTouch: false,
	isGeneric: false, // initiated by 'dragstart' (jqui)

	delay: null,
	delayTimeoutId: null,
	minDistance: null,

	shouldCancelTouchScroll: true,
	scrollAlwaysKills: false,


	constructor: function(options) {
		this.options = options || {};
	},


	// Interaction (high-level)
	// -----------------------------------------------------------------------------------------------------------------


	startInteraction: function(ev, extraOptions) {

		if (ev.type === 'mousedown') {
			if (GlobalEmitter.get().shouldIgnoreMouse()) {
				return;
			}
			else if (!isPrimaryMouseButton(ev)) {
				return;
			}
			else {
				ev.preventDefault(); // prevents native selection in most browsers
			}
		}

		if (!this.isInteracting) {

			// process options
			extraOptions = extraOptions || {};
			this.delay = firstDefined(extraOptions.delay, this.options.delay, 0);
			this.minDistance = firstDefined(extraOptions.distance, this.options.distance, 0);
			this.subjectEl = this.options.subjectEl;

			preventSelection($('body'));

			this.isInteracting = true;
			this.isTouch = getEvIsTouch(ev);
			this.isGeneric = ev.type === 'dragstart';
			this.isDelayEnded = false;
			this.isDistanceSurpassed = false;

			this.originX = getEvX(ev);
			this.originY = getEvY(ev);
			this.scrollEl = getScrollParent($(ev.target));

			this.bindHandlers();
			this.initAutoScroll();
			this.handleInteractionStart(ev);
			this.startDelay(ev);

			if (!this.minDistance) {
				this.handleDistanceSurpassed(ev);
			}
		}
	},


	handleInteractionStart: function(ev) {
		this.trigger('interactionStart', ev);
	},


	endInteraction: function(ev, isCancelled) {
		if (this.isInteracting) {
			this.endDrag(ev);

			if (this.delayTimeoutId) {
				clearTimeout(this.delayTimeoutId);
				this.delayTimeoutId = null;
			}

			this.destroyAutoScroll();
			this.unbindHandlers();

			this.isInteracting = false;
			this.handleInteractionEnd(ev, isCancelled);

			allowSelection($('body'));
		}
	},


	handleInteractionEnd: function(ev, isCancelled) {
		this.trigger('interactionEnd', ev, isCancelled || false);
	},


	// Binding To DOM
	// -----------------------------------------------------------------------------------------------------------------


	bindHandlers: function() {
		// some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,
		// so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.
		var globalEmitter = GlobalEmitter.get();

		if (this.isGeneric) {
			this.listenTo($(document), { // might only work on iOS because of GlobalEmitter's bind :(
				drag: this.handleMove,
				dragstop: this.endInteraction
			});
		}
		else if (this.isTouch) {
			this.listenTo(globalEmitter, {
				touchmove: this.handleTouchMove,
				touchend: this.endInteraction,
				scroll: this.handleTouchScroll
			});
		}
		else {
			this.listenTo(globalEmitter, {
				mousemove: this.handleMouseMove,
				mouseup: this.endInteraction
			});
		}

		this.listenTo(globalEmitter, {
			selectstart: preventDefault, // don't allow selection while dragging
			contextmenu: preventDefault // long taps would open menu on Chrome dev tools
		});
	},


	unbindHandlers: function() {
		this.stopListeningTo(GlobalEmitter.get());
		this.stopListeningTo($(document)); // for isGeneric
	},


	// Drag (high-level)
	// -----------------------------------------------------------------------------------------------------------------


	// extraOptions ignored if drag already started
	startDrag: function(ev, extraOptions) {
		this.startInteraction(ev, extraOptions); // ensure interaction began

		if (!this.isDragging) {
			this.isDragging = true;
			this.handleDragStart(ev);
		}
	},


	handleDragStart: function(ev) {
		this.trigger('dragStart', ev);
	},


	handleMove: function(ev) {
		var dx = getEvX(ev) - this.originX;
		var dy = getEvY(ev) - this.originY;
		var minDistance = this.minDistance;
		var distanceSq; // current distance from the origin, squared

		if (!this.isDistanceSurpassed) {
			distanceSq = dx * dx + dy * dy;
			if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem
				this.handleDistanceSurpassed(ev);
			}
		}

		if (this.isDragging) {
			this.handleDrag(dx, dy, ev);
		}
	},


	// Called while the mouse is being moved and when we know a legitimate drag is taking place
	handleDrag: function(dx, dy, ev) {
		this.trigger('drag', dx, dy, ev);
		this.updateAutoScroll(ev); // will possibly cause scrolling
	},


	endDrag: function(ev) {
		if (this.isDragging) {
			this.isDragging = false;
			this.handleDragEnd(ev);
		}
	},


	handleDragEnd: function(ev) {
		this.trigger('dragEnd', ev);
	},


	// Delay
	// -----------------------------------------------------------------------------------------------------------------


	startDelay: function(initialEv) {
		var _this = this;

		if (this.delay) {
			this.delayTimeoutId = setTimeout(function() {
				_this.handleDelayEnd(initialEv);
			}, this.delay);
		}
		else {
			this.handleDelayEnd(initialEv);
		}
	},


	handleDelayEnd: function(initialEv) {
		this.isDelayEnded = true;

		if (this.isDistanceSurpassed) {
			this.startDrag(initialEv);
		}
	},


	// Distance
	// -----------------------------------------------------------------------------------------------------------------


	handleDistanceSurpassed: function(ev) {
		this.isDistanceSurpassed = true;

		if (this.isDelayEnded) {
			this.startDrag(ev);
		}
	},


	// Mouse / Touch
	// -----------------------------------------------------------------------------------------------------------------


	handleTouchMove: function(ev) {

		// prevent inertia and touchmove-scrolling while dragging
		if (this.isDragging && this.shouldCancelTouchScroll) {
			ev.preventDefault();
		}

		this.handleMove(ev);
	},


	handleMouseMove: function(ev) {
		this.handleMove(ev);
	},


	// Scrolling (unrelated to auto-scroll)
	// -----------------------------------------------------------------------------------------------------------------


	handleTouchScroll: function(ev) {
		// if the drag is being initiated by touch, but a scroll happens before
		// the drag-initiating delay is over, cancel the drag
		if (!this.isDragging || this.scrollAlwaysKills) {
			this.endInteraction(ev, true); // isCancelled=true
		}
	},


	// Utils
	// -----------------------------------------------------------------------------------------------------------------


	// Triggers a callback. Calls a function in the option hash of the same name.
	// Arguments beyond the first `name` are forwarded on.
	trigger: function(name) {
		if (this.options[name]) {
			this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
		// makes _methods callable by event name. TODO: kill this
		if (this['_' + name]) {
			this['_' + name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
	}


});

;;
/*
this.scrollEl is set in DragListener
*/
DragListener.mixin({

	isAutoScroll: false,

	scrollBounds: null, // { top, bottom, left, right }
	scrollTopVel: null, // pixels per second
	scrollLeftVel: null, // pixels per second
	scrollIntervalId: null, // ID of setTimeout for scrolling animation loop

	// defaults
	scrollSensitivity: 30, // pixels from edge for scrolling to start
	scrollSpeed: 200, // pixels per second, at maximum speed
	scrollIntervalMs: 50, // millisecond wait between scroll increment


	initAutoScroll: function() {
		var scrollEl = this.scrollEl;

		this.isAutoScroll =
			this.options.scroll &&
			scrollEl &&
			!scrollEl.is(window) &&
			!scrollEl.is(document);

		if (this.isAutoScroll) {
			// debounce makes sure rapid calls don't happen
			this.listenTo(scrollEl, 'scroll', debounce(this.handleDebouncedScroll, 100));
		}
	},


	destroyAutoScroll: function() {
		this.endAutoScroll(); // kill any animation loop

		// remove the scroll handler if there is a scrollEl
		if (this.isAutoScroll) {
			this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(
		}
	},


	// Computes and stores the bounding rectangle of scrollEl
	computeScrollBounds: function() {
		if (this.isAutoScroll) {
			this.scrollBounds = getOuterRect(this.scrollEl);
			// TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
		}
	},


	// Called when the dragging is in progress and scrolling should be updated
	updateAutoScroll: function(ev) {
		var sensitivity = this.scrollSensitivity;
		var bounds = this.scrollBounds;
		var topCloseness, bottomCloseness;
		var leftCloseness, rightCloseness;
		var topVel = 0;
		var leftVel = 0;

		if (bounds) { // only scroll if scrollEl exists

			// compute closeness to edges. valid range is from 0.0 - 1.0
			topCloseness = (sensitivity - (getEvY(ev) - bounds.top)) / sensitivity;
			bottomCloseness = (sensitivity - (bounds.bottom - getEvY(ev))) / sensitivity;
			leftCloseness = (sensitivity - (getEvX(ev) - bounds.left)) / sensitivity;
			rightCloseness = (sensitivity - (bounds.right - getEvX(ev))) / sensitivity;

			// translate vertical closeness into velocity.
			// mouse must be completely in bounds for velocity to happen.
			if (topCloseness >= 0 && topCloseness <= 1) {
				topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up
			}
			else if (bottomCloseness >= 0 && bottomCloseness <= 1) {
				topVel = bottomCloseness * this.scrollSpeed;
			}

			// translate horizontal closeness into velocity
			if (leftCloseness >= 0 && leftCloseness <= 1) {
				leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left
			}
			else if (rightCloseness >= 0 && rightCloseness <= 1) {
				leftVel = rightCloseness * this.scrollSpeed;
			}
		}

		this.setScrollVel(topVel, leftVel);
	},


	// Sets the speed-of-scrolling for the scrollEl
	setScrollVel: function(topVel, leftVel) {

		this.scrollTopVel = topVel;
		this.scrollLeftVel = leftVel;

		this.constrainScrollVel(); // massages into realistic values

		// if there is non-zero velocity, and an animation loop hasn't already started, then START
		if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {
			this.scrollIntervalId = setInterval(
				proxy(this, 'scrollIntervalFunc'), // scope to `this`
				this.scrollIntervalMs
			);
		}
	},


	// Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
	constrainScrollVel: function() {
		var el = this.scrollEl;

		if (this.scrollTopVel < 0) { // scrolling up?
			if (el.scrollTop() <= 0) { // already scrolled all the way up?
				this.scrollTopVel = 0;
			}
		}
		else if (this.scrollTopVel > 0) { // scrolling down?
			if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) { // already scrolled all the way down?
				this.scrollTopVel = 0;
			}
		}

		if (this.scrollLeftVel < 0) { // scrolling left?
			if (el.scrollLeft() <= 0) { // already scrolled all the left?
				this.scrollLeftVel = 0;
			}
		}
		else if (this.scrollLeftVel > 0) { // scrolling right?
			if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) { // already scrolled all the way right?
				this.scrollLeftVel = 0;
			}
		}
	},


	// This function gets called during every iteration of the scrolling animation loop
	scrollIntervalFunc: function() {
		var el = this.scrollEl;
		var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by

		// change the value of scrollEl's scroll
		if (this.scrollTopVel) {
			el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
		}
		if (this.scrollLeftVel) {
			el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
		}

		this.constrainScrollVel(); // since the scroll values changed, recompute the velocities

		// if scrolled all the way, which causes the vels to be zero, stop the animation loop
		if (!this.scrollTopVel && !this.scrollLeftVel) {
			this.endAutoScroll();
		}
	},


	// Kills any existing scrolling animation loop
	endAutoScroll: function() {
		if (this.scrollIntervalId) {
			clearInterval(this.scrollIntervalId);
			this.scrollIntervalId = null;

			this.handleScrollEnd();
		}
	},


	// Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
	handleDebouncedScroll: function() {
		// recompute all coordinates, but *only* if this is *not* part of our scrolling animation
		if (!this.scrollIntervalId) {
			this.handleScrollEnd();
		}
	},


	// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
	handleScrollEnd: function() {
	}

});
;;

/* Tracks mouse movements over a component and raises events about which hit the mouse is over.
------------------------------------------------------------------------------------------------------------------------
options:
- subjectEl
- subjectCenter
*/

var HitDragListener = DragListener.extend({

	component: null, // converts coordinates to hits
		// methods: hitsNeeded, hitsNotNeeded, queryHit

	origHit: null, // the hit the mouse was over when listening started
	hit: null, // the hit the mouse is over
	coordAdjust: null, // delta that will be added to the mouse coordinates when computing collisions


	constructor: function(component, options) {
		DragListener.call(this, options); // call the super-constructor

		this.component = component;
	},


	// Called when drag listening starts (but a real drag has not necessarily began).
	// ev might be undefined if dragging was started manually.
	handleInteractionStart: function(ev) {
		var subjectEl = this.subjectEl;
		var subjectRect;
		var origPoint;
		var point;

		this.component.hitsNeeded();
		this.computeScrollBounds(); // for autoscroll

		if (ev) {
			origPoint = { left: getEvX(ev), top: getEvY(ev) };
			point = origPoint;

			// constrain the point to bounds of the element being dragged
			if (subjectEl) {
				subjectRect = getOuterRect(subjectEl); // used for centering as well
				point = constrainPoint(point, subjectRect);
			}

			this.origHit = this.queryHit(point.left, point.top);

			// treat the center of the subject as the collision point?
			if (subjectEl && this.options.subjectCenter) {

				// only consider the area the subject overlaps the hit. best for large subjects.
				// TODO: skip this if hit didn't supply left/right/top/bottom
				if (this.origHit) {
					subjectRect = intersectRects(this.origHit, subjectRect) ||
						subjectRect; // in case there is no intersection
				}

				point = getRectCenter(subjectRect);
			}

			this.coordAdjust = diffPoints(point, origPoint); // point - origPoint
		}
		else {
			this.origHit = null;
			this.coordAdjust = null;
		}

		// call the super-method. do it after origHit has been computed
		DragListener.prototype.handleInteractionStart.apply(this, arguments);
	},


	// Called when the actual drag has started
	handleDragStart: function(ev) {
		var hit;

		DragListener.prototype.handleDragStart.apply(this, arguments); // call the super-method

		// might be different from this.origHit if the min-distance is large
		hit = this.queryHit(getEvX(ev), getEvY(ev));

		// report the initial hit the mouse is over
		// especially important if no min-distance and drag starts immediately
		if (hit) {
			this.handleHitOver(hit);
		}
	},


	// Called when the drag moves
	handleDrag: function(dx, dy, ev) {
		var hit;

		DragListener.prototype.handleDrag.apply(this, arguments); // call the super-method

		hit = this.queryHit(getEvX(ev), getEvY(ev));

		if (!isHitsEqual(hit, this.hit)) { // a different hit than before?
			if (this.hit) {
				this.handleHitOut();
			}
			if (hit) {
				this.handleHitOver(hit);
			}
		}
	},


	// Called when dragging has been stopped
	handleDragEnd: function() {
		this.handleHitDone();
		DragListener.prototype.handleDragEnd.apply(this, arguments); // call the super-method
	},


	// Called when a the mouse has just moved over a new hit
	handleHitOver: function(hit) {
		var isOrig = isHitsEqual(hit, this.origHit);

		this.hit = hit;

		this.trigger('hitOver', this.hit, isOrig, this.origHit);
	},


	// Called when the mouse has just moved out of a hit
	handleHitOut: function() {
		if (this.hit) {
			this.trigger('hitOut', this.hit);
			this.handleHitDone();
			this.hit = null;
		}
	},


	// Called after a hitOut. Also called before a dragStop
	handleHitDone: function() {
		if (this.hit) {
			this.trigger('hitDone', this.hit);
		}
	},


	// Called when the interaction ends, whether there was a real drag or not
	handleInteractionEnd: function() {
		DragListener.prototype.handleInteractionEnd.apply(this, arguments); // call the super-method

		this.origHit = null;
		this.hit = null;

		this.component.hitsNotNeeded();
	},


	// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
	handleScrollEnd: function() {
		DragListener.prototype.handleScrollEnd.apply(this, arguments); // call the super-method

		// hits' absolute positions will be in new places after a user's scroll.
		// HACK for recomputing.
		if (this.isDragging) {
			this.component.releaseHits();
			this.component.prepareHits();
		}
	},


	// Gets the hit underneath the coordinates for the given mouse event
	queryHit: function(left, top) {

		if (this.coordAdjust) {
			left += this.coordAdjust.left;
			top += this.coordAdjust.top;
		}

		return this.component.queryHit(left, top);
	}

});


// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.
// Two null values will be considered equal, as two "out of the component" states are the same.
function isHitsEqual(hit0, hit1) {

	if (!hit0 && !hit1) {
		return true;
	}

	if (hit0 && hit1) {
		return hit0.component === hit1.component &&
			isHitPropsWithin(hit0, hit1) &&
			isHitPropsWithin(hit1, hit0); // ensures all props are identical
	}

	return false;
}


// Returns true if all of subHit's non-standard properties are within superHit
function isHitPropsWithin(subHit, superHit) {
	for (var propName in subHit) {
		if (!/^(component|left|right|top|bottom)$/.test(propName)) {
			if (subHit[propName] !== superHit[propName]) {
				return false;
			}
		}
	}
	return true;
}

;;

/*
Listens to document and window-level user-interaction events, like touch events and mouse events,
and fires these events as-is to whoever is observing a GlobalEmitter.
Best when used as a singleton via GlobalEmitter.get()

Normalizes mouse/touch events. For examples:
- ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click
- compensates for various buggy scenarios where a touchend does not fire
*/

FC.touchMouseIgnoreWait = 500;

var GlobalEmitter = Class.extend(ListenerMixin, EmitterMixin, {

	isTouching: false,
	mouseIgnoreDepth: 0,
	handleScrollProxy: null,


	bind: function() {
		var _this = this;

		this.listenTo($(document), {
			touchstart: this.handleTouchStart,
			touchcancel: this.handleTouchCancel,
			touchend: this.handleTouchEnd,
			mousedown: this.handleMouseDown,
			mousemove: this.handleMouseMove,
			mouseup: this.handleMouseUp,
			click: this.handleClick,
			selectstart: this.handleSelectStart,
			contextmenu: this.handleContextMenu
		});

		// because we need to call preventDefault
		// because https://www.chromestatus.com/features/5093566007214080
		// TODO: investigate performance because this is a global handler
		window.addEventListener(
			'touchmove',
			this.handleTouchMoveProxy = function(ev) {
				_this.handleTouchMove($.Event(ev));
			},
			{ passive: false } // allows preventDefault()
		);

		// attach a handler to get called when ANY scroll action happens on the page.
		// this was impossible to do with normal on/off because 'scroll' doesn't bubble.
		// http://stackoverflow.com/a/32954565/96342
		window.addEventListener(
			'scroll',
			this.handleScrollProxy = function(ev) {
				_this.handleScroll($.Event(ev));
			},
			true // useCapture
		);
	},

	unbind: function() {
		this.stopListeningTo($(document));

		window.removeEventListener(
			'touchmove',
			this.handleTouchMoveProxy
		);

		window.removeEventListener(
			'scroll',
			this.handleScrollProxy,
			true // useCapture
		);
	},


	// Touch Handlers
	// -----------------------------------------------------------------------------------------------------------------

	handleTouchStart: function(ev) {

		// if a previous touch interaction never ended with a touchend, then implicitly end it,
		// but since a new touch interaction is about to begin, don't start the mouse ignore period.
		this.stopTouch(ev, true); // skipMouseIgnore=true

		this.isTouching = true;
		this.trigger('touchstart', ev);
	},

	handleTouchMove: function(ev) {
		if (this.isTouching) {
			this.trigger('touchmove', ev);
		}
	},

	handleTouchCancel: function(ev) {
		if (this.isTouching) {
			this.trigger('touchcancel', ev);

			// Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.
			// If touchend fires later, it won't have any effect b/c isTouching will be false.
			this.stopTouch(ev);
		}
	},

	handleTouchEnd: function(ev) {
		this.stopTouch(ev);
	},


	// Mouse Handlers
	// -----------------------------------------------------------------------------------------------------------------

	handleMouseDown: function(ev) {
		if (!this.shouldIgnoreMouse()) {
			this.trigger('mousedown', ev);
		}
	},

	handleMouseMove: function(ev) {
		if (!this.shouldIgnoreMouse()) {
			this.trigger('mousemove', ev);
		}
	},

	handleMouseUp: function(ev) {
		if (!this.shouldIgnoreMouse()) {
			this.trigger('mouseup', ev);
		}
	},

	handleClick: function(ev) {
		if (!this.shouldIgnoreMouse()) {
			this.trigger('click', ev);
		}
	},


	// Misc Handlers
	// -----------------------------------------------------------------------------------------------------------------

	handleSelectStart: function(ev) {
		this.trigger('selectstart', ev);
	},

	handleContextMenu: function(ev) {
		this.trigger('contextmenu', ev);
	},

	handleScroll: function(ev) {
		this.trigger('scroll', ev);
	},


	// Utils
	// -----------------------------------------------------------------------------------------------------------------

	stopTouch: function(ev, skipMouseIgnore) {
		if (this.isTouching) {
			this.isTouching = false;
			this.trigger('touchend', ev);

			if (!skipMouseIgnore) {
				this.startTouchMouseIgnore();
			}
		}
	},

	startTouchMouseIgnore: function() {
		var _this = this;
		var wait = FC.touchMouseIgnoreWait;

		if (wait) {
			this.mouseIgnoreDepth++;
			setTimeout(function() {
				_this.mouseIgnoreDepth--;
			}, wait);
		}
	},

	shouldIgnoreMouse: function() {
		return this.isTouching || Boolean(this.mouseIgnoreDepth);
	}

});


// Singleton
// ---------------------------------------------------------------------------------------------------------------------

(function() {
	var globalEmitter = null;
	var neededCount = 0;


	// gets the singleton
	GlobalEmitter.get = function() {

		if (!globalEmitter) {
			globalEmitter = new GlobalEmitter();
			globalEmitter.bind();
		}

		return globalEmitter;
	};


	// called when an object knows it will need a GlobalEmitter in the near future.
	GlobalEmitter.needed = function() {
		GlobalEmitter.get(); // ensures globalEmitter
		neededCount++;
	};


	// called when the object that originally called needed() doesn't need a GlobalEmitter anymore.
	GlobalEmitter.unneeded = function() {
		neededCount--;

		if (!neededCount) { // nobody else needs it
			globalEmitter.unbind();
			globalEmitter = null;
		}
	};

})();

;;

/* Creates a clone of an element and lets it track the mouse as it moves
----------------------------------------------------------------------------------------------------------------------*/

var MouseFollower = Class.extend(ListenerMixin, {

	options: null,

	sourceEl: null, // the element that will be cloned and made to look like it is dragging
	el: null, // the clone of `sourceEl` that will track the mouse
	parentEl: null, // the element that `el` (the clone) will be attached to

	// the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl
	top0: null,
	left0: null,

	// the absolute coordinates of the initiating touch/mouse action
	y0: null,
	x0: null,

	// the number of pixels the mouse has moved from its initial position
	topDelta: null,
	leftDelta: null,

	isFollowing: false,
	isHidden: false,
	isAnimating: false, // doing the revert animation?

	constructor: function(sourceEl, options) {
		this.options = options = options || {};
		this.sourceEl = sourceEl;
		this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent
	},


	// Causes the element to start following the mouse
	start: function(ev) {
		if (!this.isFollowing) {
			this.isFollowing = true;

			this.y0 = getEvY(ev);
			this.x0 = getEvX(ev);
			this.topDelta = 0;
			this.leftDelta = 0;

			if (!this.isHidden) {
				this.updatePosition();
			}

			if (getEvIsTouch(ev)) {
				this.listenTo($(document), 'touchmove', this.handleMove);
			}
			else {
				this.listenTo($(document), 'mousemove', this.handleMove);
			}
		}
	},


	// Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
	// `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
	stop: function(shouldRevert, callback) {
		var _this = this;
		var revertDuration = this.options.revertDuration;

		function complete() { // might be called by .animate(), which might change `this` context
			_this.isAnimating = false;
			_this.removeElement();

			_this.top0 = _this.left0 = null; // reset state for future updatePosition calls

			if (callback) {
				callback();
			}
		}

		if (this.isFollowing && !this.isAnimating) { // disallow more than one stop animation at a time
			this.isFollowing = false;

			this.stopListeningTo($(document));

			if (shouldRevert && revertDuration && !this.isHidden) { // do a revert animation?
				this.isAnimating = true;
				this.el.animate({
					top: this.top0,
					left: this.left0
				}, {
					duration: revertDuration,
					complete: complete
				});
			}
			else {
				complete();
			}
		}
	},


	// Gets the tracking element. Create it if necessary
	getEl: function() {
		var el = this.el;

		if (!el) {
			el = this.el = this.sourceEl.clone()
				.addClass(this.options.additionalClass || '')
				.css({
					position: 'absolute',
					visibility: '', // in case original element was hidden (commonly through hideEvents())
					display: this.isHidden ? 'none' : '', // for when initially hidden
					margin: 0,
					right: 'auto', // erase and set width instead
					bottom: 'auto', // erase and set height instead
					width: this.sourceEl.width(), // explicit height in case there was a 'right' value
					height: this.sourceEl.height(), // explicit width in case there was a 'bottom' value
					opacity: this.options.opacity || '',
					zIndex: this.options.zIndex
				});

			// we don't want long taps or any mouse interaction causing selection/menus.
			// would use preventSelection(), but that prevents selectstart, causing problems.
			el.addClass('fc-unselectable');

			el.appendTo(this.parentEl);
		}

		return el;
	},


	// Removes the tracking element if it has already been created
	removeElement: function() {
		if (this.el) {
			this.el.remove();
			this.el = null;
		}
	},


	// Update the CSS position of the tracking element
	updatePosition: function() {
		var sourceOffset;
		var origin;

		this.getEl(); // ensure this.el

		// make sure origin info was computed
		if (this.top0 === null) {
			sourceOffset = this.sourceEl.offset();
			origin = this.el.offsetParent().offset();
			this.top0 = sourceOffset.top - origin.top;
			this.left0 = sourceOffset.left - origin.left;
		}

		this.el.css({
			top: this.top0 + this.topDelta,
			left: this.left0 + this.leftDelta
		});
	},


	// Gets called when the user moves the mouse
	handleMove: function(ev) {
		this.topDelta = getEvY(ev) - this.y0;
		this.leftDelta = getEvX(ev) - this.x0;

		if (!this.isHidden) {
			this.updatePosition();
		}
	},


	// Temporarily makes the tracking element invisible. Can be called before following starts
	hide: function() {
		if (!this.isHidden) {
			this.isHidden = true;
			if (this.el) {
				this.el.hide();
			}
		}
	},


	// Show the tracking element after it has been temporarily hidden
	show: function() {
		if (this.isHidden) {
			this.isHidden = false;
			this.updatePosition();
			this.getEl().show();
		}
	}

});

;;

/* An abstract class comprised of a "grid" of areas that each represent a specific datetime
----------------------------------------------------------------------------------------------------------------------*/

var Grid = FC.Grid = Class.extend(ListenerMixin, {

	// self-config, overridable by subclasses
	hasDayInteractions: true, // can user click/select ranges of time?

	view: null, // a View object
	isRTL: null, // shortcut to the view's isRTL option

	start: null,
	end: null,

	el: null, // the containing element
	elsByFill: null, // a hash of jQuery element sets used for rendering each fill. Keyed by fill name.

	// derived from options
	eventTimeFormat: null,
	displayEventTime: null,
	displayEventEnd: null,

	minResizeDuration: null, // TODO: hack. set by subclasses. minumum event resize duration

	// if defined, holds the unit identified (ex: "year" or "month") that determines the level of granularity
	// of the date areas. if not defined, assumes to be day and time granularity.
	// TODO: port isTimeScale into same system?
	largeUnit: null,

	dayClickListener: null,
	daySelectListener: null,
	segDragListener: null,
	segResizeListener: null,
	externalDragListener: null,


	constructor: function(view) {
		this.view = view;
		this.isRTL = view.opt('isRTL');
		this.elsByFill = {};

		this.dayClickListener = this.buildDayClickListener();
		this.daySelectListener = this.buildDaySelectListener();
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Generates the format string used for event time text, if not explicitly defined by 'timeFormat'
	computeEventTimeFormat: function() {
		return this.view.opt('smallTimeFormat');
	},


	// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventTime'.
	// Only applies to non-all-day events.
	computeDisplayEventTime: function() {
		return true;
	},


	// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventEnd'
	computeDisplayEventEnd: function() {
		return true;
	},


	/* Dates
	------------------------------------------------------------------------------------------------------------------*/


	// Tells the grid about what period of time to display.
	// Any date-related internal data should be generated.
	setRange: function(range) {
		this.start = range.start.clone();
		this.end = range.end.clone();

		this.rangeUpdated();
		this.processRangeOptions();
	},


	// Called when internal variables that rely on the range should be updated
	rangeUpdated: function() {
	},


	// Updates values that rely on options and also relate to range
	processRangeOptions: function() {
		var view = this.view;
		var displayEventTime;
		var displayEventEnd;

		this.eventTimeFormat =
			view.opt('eventTimeFormat') ||
			view.opt('timeFormat') || // deprecated
			this.computeEventTimeFormat();

		displayEventTime = view.opt('displayEventTime');
		if (displayEventTime == null) {
			displayEventTime = this.computeDisplayEventTime(); // might be based off of range
		}

		displayEventEnd = view.opt('displayEventEnd');
		if (displayEventEnd == null) {
			displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
		}

		this.displayEventTime = displayEventTime;
		this.displayEventEnd = displayEventEnd;
	},


	// Converts a span (has unzoned start/end and any other grid-specific location information)
	// into an array of segments (pieces of events whose format is decided by the grid).
	spanToSegs: function(span) {
		// subclasses must implement
	},


	// Diffs the two dates, returning a duration, based on granularity of the grid
	// TODO: port isTimeScale into this system?
	diffDates: function(a, b) {
		if (this.largeUnit) {
			return diffByUnit(a, b, this.largeUnit);
		}
		else {
			return diffDayTime(a, b);
		}
	},


	/* Hit Area
	------------------------------------------------------------------------------------------------------------------*/

	hitsNeededDepth: 0, // necessary because multiple callers might need the same hits

	hitsNeeded: function() {
		if (!(this.hitsNeededDepth++)) {
			this.prepareHits();
		}
	},

	hitsNotNeeded: function() {
		if (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {
			this.releaseHits();
		}
	},


	// Called before one or more queryHit calls might happen. Should prepare any cached coordinates for queryHit
	prepareHits: function() {
	},


	// Called when queryHit calls have subsided. Good place to clear any coordinate caches.
	releaseHits: function() {
	},


	// Given coordinates from the topleft of the document, return data about the date-related area underneath.
	// Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).
	// Must have a `grid` property, a reference to this current grid. TODO: avoid this
	// The returned object will be processed by getHitSpan and getHitEl.
	queryHit: function(leftOffset, topOffset) {
	},


	// like getHitSpan, but returns null if the resulting span's range is invalid
	getSafeHitSpan: function(hit) {
		var hitSpan = this.getHitSpan(hit);

		if (!isRangeWithinRange(hitSpan, this.view.activeRange)) {
			return null;
		}

		return hitSpan;
	},


	// Given position-level information about a date-related area within the grid,
	// should return an object with at least a start/end date. Can provide other information as well.
	getHitSpan: function(hit) {
	},


	// Given position-level information about a date-related area within the grid,
	// should return a jQuery element that best represents it. passed to dayClick callback.
	getHitEl: function(hit) {
	},


	/* Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Sets the container element that the grid should render inside of.
	// Does other DOM-related initializations.
	setElement: function(el) {
		this.el = el;

		if (this.hasDayInteractions) {
			preventSelection(el);

			this.bindDayHandler('touchstart', this.dayTouchStart);
			this.bindDayHandler('mousedown', this.dayMousedown);
		}

		// attach event-element-related handlers. in Grid.events
		// same garbage collection note as above.
		this.bindSegHandlers();

		this.bindGlobalHandlers();
	},


	bindDayHandler: function(name, handler) {
		var _this = this;

		// attach a handler to the grid's root element.
		// jQuery will take care of unregistering them when removeElement gets called.
		this.el.on(name, function(ev) {
			if (
				!$(ev.target).is(
					_this.segSelector + ',' + // directly on an event element
					_this.segSelector + ' *,' + // within an event element
					'.fc-more,' + // a "more.." link
					'a[data-goto]' // a clickable nav link
				)
			) {
				return handler.call(_this, ev);
			}
		});
	},


	// Removes the grid's container element from the DOM. Undoes any other DOM-related attachments.
	// DOES NOT remove any content beforehand (doesn't clear events or call unrenderDates), unlike View
	removeElement: function() {
		this.unbindGlobalHandlers();
		this.clearDragListeners();

		this.el.remove();

		// NOTE: we don't null-out this.el for the same reasons we don't do it within View::removeElement
	},


	// Renders the basic structure of grid view before any content is rendered
	renderSkeleton: function() {
		// subclasses should implement
	},


	// Renders the grid's date-related content (like areas that represent days/times).
	// Assumes setRange has already been called and the skeleton has already been rendered.
	renderDates: function() {
		// subclasses should implement
	},


	// Unrenders the grid's date-related content
	unrenderDates: function() {
		// subclasses should implement
	},


	/* Handlers
	------------------------------------------------------------------------------------------------------------------*/


	// Binds DOM handlers to elements that reside outside the grid, such as the document
	bindGlobalHandlers: function() {
		this.listenTo($(document), {
			dragstart: this.externalDragStart, // jqui
			sortstart: this.externalDragStart // jqui
		});
	},


	// Unbinds DOM handlers from elements that reside outside the grid
	unbindGlobalHandlers: function() {
		this.stopListeningTo($(document));
	},


	// Process a mousedown on an element that represents a day. For day clicking and selecting.
	dayMousedown: function(ev) {
		var view = this.view;

		// HACK
		// This will still work even though bindDayHandler doesn't use GlobalEmitter.
		if (GlobalEmitter.get().shouldIgnoreMouse()) {
			return;
		}

		this.dayClickListener.startInteraction(ev);

		if (view.opt('selectable')) {
			this.daySelectListener.startInteraction(ev, {
				distance: view.opt('selectMinDistance')
			});
		}
	},


	dayTouchStart: function(ev) {
		var view = this.view;
		var selectLongPressDelay;

		// On iOS (and Android?) when a new selection is initiated overtop another selection,
		// the touchend never fires because the elements gets removed mid-touch-interaction (my theory).
		// HACK: simply don't allow this to happen.
		// ALSO: prevent selection when an *event* is already raised.
		if (view.isSelected || view.selectedEvent) {
			return;
		}

		selectLongPressDelay = view.opt('selectLongPressDelay');
		if (selectLongPressDelay == null) {
			selectLongPressDelay = view.opt('longPressDelay'); // fallback
		}

		this.dayClickListener.startInteraction(ev);

		if (view.opt('selectable')) {
			this.daySelectListener.startInteraction(ev, {
				delay: selectLongPressDelay
			});
		}
	},


	// Creates a listener that tracks the user's drag across day elements, for day clicking.
	buildDayClickListener: function() {
		var _this = this;
		var view = this.view;
		var dayClickHit; // null if invalid dayClick

		var dragListener = new HitDragListener(this, {
			scroll: view.opt('dragScroll'),
			interactionStart: function() {
				dayClickHit = dragListener.origHit;
			},
			hitOver: function(hit, isOrig, origHit) {
				// if user dragged to another cell at any point, it can no longer be a dayClick
				if (!isOrig) {
					dayClickHit = null;
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				dayClickHit = null;
			},
			interactionEnd: function(ev, isCancelled) {
				var hitSpan;

				if (!isCancelled && dayClickHit) {
					hitSpan = _this.getSafeHitSpan(dayClickHit);

					if (hitSpan) {
						view.triggerDayClick(hitSpan, _this.getHitEl(dayClickHit), ev);
					}
				}
			}
		});

		// because dayClickListener won't be called with any time delay, "dragging" will begin immediately,
		// which will kill any touchmoving/scrolling. Prevent this.
		dragListener.shouldCancelTouchScroll = false;

		dragListener.scrollAlwaysKills = true;

		return dragListener;
	},


	// Creates a listener that tracks the user's drag across day elements, for day selecting.
	buildDaySelectListener: function() {
		var _this = this;
		var view = this.view;
		var selectionSpan; // null if invalid selection

		var dragListener = new HitDragListener(this, {
			scroll: view.opt('dragScroll'),
			interactionStart: function() {
				selectionSpan = null;
			},
			dragStart: function() {
				view.unselect(); // since we could be rendering a new selection, we want to clear any old one
			},
			hitOver: function(hit, isOrig, origHit) {
				var origHitSpan;
				var hitSpan;

				if (origHit) { // click needs to have started on a hit

					origHitSpan = _this.getSafeHitSpan(origHit);
					hitSpan = _this.getSafeHitSpan(hit);

					if (origHitSpan && hitSpan) {
						selectionSpan = _this.computeSelection(origHitSpan, hitSpan);
					}
					else {
						selectionSpan = null;
					}

					if (selectionSpan) {
						_this.renderSelection(selectionSpan);
					}
					else if (selectionSpan === false) {
						disableCursor();
					}
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				selectionSpan = null;
				_this.unrenderSelection();
			},
			hitDone: function() { // called after a hitOut OR before a dragEnd
				enableCursor();
			},
			interactionEnd: function(ev, isCancelled) {
				if (!isCancelled && selectionSpan) {
					// the selection will already have been rendered. just report it
					view.reportSelection(selectionSpan, ev);
				}
			}
		});

		return dragListener;
	},


	// Kills all in-progress dragging.
	// Useful for when public API methods that result in re-rendering are invoked during a drag.
	// Also useful for when touch devices misbehave and don't fire their touchend.
	clearDragListeners: function() {
		this.dayClickListener.endInteraction();
		this.daySelectListener.endInteraction();

		if (this.segDragListener) {
			this.segDragListener.endInteraction(); // will clear this.segDragListener
		}
		if (this.segResizeListener) {
			this.segResizeListener.endInteraction(); // will clear this.segResizeListener
		}
		if (this.externalDragListener) {
			this.externalDragListener.endInteraction(); // will clear this.externalDragListener
		}
	},


	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: should probably move this to Grid.events, like we did event dragging / resizing


	// Renders a mock event at the given event location, which contains zoned start/end properties.
	// Returns all mock event elements.
	renderEventLocationHelper: function(eventLocation, sourceSeg) {
		var fakeEvent = this.fabricateHelperEvent(eventLocation, sourceSeg);

		return this.renderHelper(fakeEvent, sourceSeg); // do the actual rendering
	},


	// Builds a fake event given zoned event date properties and a segment is should be inspired from.
	// The range's end can be null, in which case the mock event that is rendered will have a null end time.
	// `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.
	fabricateHelperEvent: function(eventLocation, sourceSeg) {
		var fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {}; // mask the original event object if possible

		fakeEvent.start = eventLocation.start.clone();
		fakeEvent.end = eventLocation.end ? eventLocation.end.clone() : null;
		fakeEvent.allDay = null; // force it to be freshly computed by normalizeEventDates
		this.view.calendar.normalizeEventDates(fakeEvent);

		// this extra className will be useful for differentiating real events from mock events in CSS
		fakeEvent.className = (fakeEvent.className || []).concat('fc-helper');

		// if something external is being dragged in, don't render a resizer
		if (!sourceSeg) {
			fakeEvent.editable = false;
		}

		return fakeEvent;
	},


	// Renders a mock event. Given zoned event date properties.
	// Must return all mock event elements.
	renderHelper: function(eventLocation, sourceSeg) {
		// subclasses must implement
	},


	// Unrenders a mock event
	unrenderHelper: function() {
		// subclasses must implement
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.
	// Given a span (unzoned start/end and other misc data)
	renderSelection: function(span) {
		this.renderHighlight(span);
	},


	// Unrenders any visual indications of a selection. Will unrender a highlight by default.
	unrenderSelection: function() {
		this.unrenderHighlight();
	},


	// Given the first and last date-spans of a selection, returns another date-span object.
	// Subclasses can override and provide additional data in the span object. Will be passed to renderSelection().
	// Will return false if the selection is invalid and this should be indicated to the user.
	// Will return null/undefined if a selection invalid but no error should be reported.
	computeSelection: function(span0, span1) {
		var span = this.computeSelectionSpan(span0, span1);

		if (span && !this.view.calendar.isSelectionSpanAllowed(span)) {
			return false;
		}

		return span;
	},


	// Given two spans, must return the combination of the two.
	// TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.
	computeSelectionSpan: function(span0, span1) {
		var dates = [ span0.start, span0.end, span1.start, span1.end ];

		dates.sort(compareNumbers); // sorts chronologically. works with Moments

		return { start: dates[0].clone(), end: dates[3].clone() };
	},


	/* Highlight
	------------------------------------------------------------------------------------------------------------------*/


	// Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)
	renderHighlight: function(span) {
		this.renderFill('highlight', this.spanToSegs(span));
	},


	// Unrenders the emphasis on a date range
	unrenderHighlight: function() {
		this.unrenderFill('highlight');
	},


	// Generates an array of classNames for rendering the highlight. Used by the fill system.
	highlightSegClasses: function() {
		return [ 'fc-highlight' ];
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessHours: function() {
	},


	unrenderBusinessHours: function() {
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	getNowIndicatorUnit: function() {
	},


	renderNowIndicator: function(date) {
	},


	unrenderNowIndicator: function() {
	},


	/* Fill System (highlight, background events, business hours)
	--------------------------------------------------------------------------------------------------------------------
	TODO: remove this system. like we did in TimeGrid
	*/


	// Renders a set of rectangles over the given segments of time.
	// MUST RETURN a subset of segs, the segs that were actually rendered.
	// Responsible for populating this.elsByFill. TODO: better API for expressing this requirement
	renderFill: function(type, segs) {
		// subclasses must implement
	},


	// Unrenders a specific type of fill that is currently rendered on the grid
	unrenderFill: function(type) {
		var el = this.elsByFill[type];

		if (el) {
			el.remove();
			delete this.elsByFill[type];
		}
	},


	// Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
	// Only returns segments that successfully rendered.
	// To be harnessed by renderFill (implemented by subclasses).
	// Analagous to renderFgSegEls.
	renderFillSegEls: function(type, segs) {
		var _this = this;
		var segElMethod = this[type + 'SegEl'];
		var html = '';
		var renderedSegs = [];
		var i;

		if (segs.length) {

			// build a large concatenation of segment HTML
			for (i = 0; i < segs.length; i++) {
				html += this.fillSegHtml(type, segs[i]);
			}

			// Grab individual elements from the combined HTML string. Use each as the default rendering.
			// Then, compute the 'el' for each segment.
			$(html).each(function(i, node) {
				var seg = segs[i];
				var el = $(node);

				// allow custom filter methods per-type
				if (segElMethod) {
					el = segElMethod.call(_this, seg, el);
				}

				if (el) { // custom filters did not cancel the render
					el = $(el); // allow custom filter to return raw DOM node

					// correct element type? (would be bad if a non-TD were inserted into a table for example)
					if (el.is(_this.fillSegTag)) {
						seg.el = el;
						renderedSegs.push(seg);
					}
				}
			});
		}

		return renderedSegs;
	},


	fillSegTag: 'div', // subclasses can override


	// Builds the HTML needed for one fill segment. Generic enough to work with different types.
	fillSegHtml: function(type, seg) {

		// custom hooks per-type
		var classesMethod = this[type + 'SegClasses'];
		var cssMethod = this[type + 'SegCss'];

		var classes = classesMethod ? classesMethod.call(this, seg) : [];
		var css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});

		return '<' + this.fillSegTag +
			(classes.length ? ' class="' + classes.join(' ') + '"' : '') +
			(css ? ' style="' + css + '"' : '') +
			' />';
	},



	/* Generic rendering utilities for subclasses
	------------------------------------------------------------------------------------------------------------------*/


	// Computes HTML classNames for a single-day element
	getDayClasses: function(date, noThemeHighlight) {
		var view = this.view;
		var classes = [];
		var today;

		if (!isDateWithinRange(date, view.activeRange)) {
			classes.push('fc-disabled-day'); // TODO: jQuery UI theme?
		}
		else {
			classes.push('fc-' + dayIDs[date.day()]);

			if (
				view.currentRangeAs('months') == 1 && // TODO: somehow get into MonthView
				date.month() != view.currentRange.start.month()
			) {
				classes.push('fc-other-month');
			}

			today = view.calendar.getNow();

			if (date.isSame(today, 'day')) {
				classes.push('fc-today');

				if (noThemeHighlight !== true) {
					classes.push(view.highlightStateClass);
				}
			}
			else if (date < today) {
				classes.push('fc-past');
			}
			else {
				classes.push('fc-future');
			}
		}

		return classes;
	}

});

;;

/* Event-rendering and event-interaction methods for the abstract Grid class
----------------------------------------------------------------------------------------------------------------------

Data Types:
	event - { title, id, start, (end), whatever }
	location - { start, (end), allDay }
	rawEventRange - { start, end }
	eventRange - { start, end, isStart, isEnd }
	eventSpan - { start, end, isStart, isEnd, whatever }
	eventSeg - { event, whatever }
	seg - { whatever }
*/

Grid.mixin({

	// self-config, overridable by subclasses
	segSelector: '.fc-event-container > *', // what constitutes an event element?

	mousedOverSeg: null, // the segment object the user's mouse is over. null if over nothing
	isDraggingSeg: false, // is a segment being dragged? boolean
	isResizingSeg: false, // is a segment being resized? boolean
	isDraggingExternal: false, // jqui-dragging an external element? boolean
	segs: null, // the *event* segments currently rendered in the grid. TODO: rename to `eventSegs`


	// Renders the given events onto the grid
	renderEvents: function(events) {
		var bgEvents = [];
		var fgEvents = [];
		var i;

		for (i = 0; i < events.length; i++) {
			(isBgEvent(events[i]) ? bgEvents : fgEvents).push(events[i]);
		}

		this.segs = [].concat( // record all segs
			this.renderBgEvents(bgEvents),
			this.renderFgEvents(fgEvents)
		);
	},


	renderBgEvents: function(events) {
		var segs = this.eventsToSegs(events);

		// renderBgSegs might return a subset of segs, segs that were actually rendered
		return this.renderBgSegs(segs) || segs;
	},


	renderFgEvents: function(events) {
		var segs = this.eventsToSegs(events);

		// renderFgSegs might return a subset of segs, segs that were actually rendered
		return this.renderFgSegs(segs) || segs;
	},


	// Unrenders all events currently rendered on the grid
	unrenderEvents: function() {
		this.handleSegMouseout(); // trigger an eventMouseout if user's mouse is over an event
		this.clearDragListeners();

		this.unrenderFgSegs();
		this.unrenderBgSegs();

		this.segs = null;
	},


	// Retrieves all rendered segment objects currently rendered on the grid
	getEventSegs: function() {
		return this.segs || [];
	},


	/* Foreground Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Renders foreground event segments onto the grid. May return a subset of segs that were rendered.
	renderFgSegs: function(segs) {
		// subclasses must implement
	},


	// Unrenders all currently rendered foreground segments
	unrenderFgSegs: function() {
		// subclasses must implement
	},


	// Renders and assigns an `el` property for each foreground event segment.
	// Only returns segments that successfully rendered.
	// A utility that subclasses may use.
	renderFgSegEls: function(segs, disableResizing) {
		var view = this.view;
		var html = '';
		var renderedSegs = [];
		var i;

		if (segs.length) { // don't build an empty html string

			// build a large concatenation of event segment HTML
			for (i = 0; i < segs.length; i++) {
				html += this.fgSegHtml(segs[i], disableResizing);
			}

			// Grab individual elements from the combined HTML string. Use each as the default rendering.
			// Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
			$(html).each(function(i, node) {
				var seg = segs[i];
				var el = view.resolveEventEl(seg.event, $(node));

				if (el) {
					el.data('fc-seg', seg); // used by handlers
					seg.el = el;
					renderedSegs.push(seg);
				}
			});
		}

		return renderedSegs;
	},


	// Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
	fgSegHtml: function(seg, disableResizing) {
		// subclasses should implement
	},


	/* Background Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Renders the given background event segments onto the grid.
	// Returns a subset of the segs that were actually rendered.
	renderBgSegs: function(segs) {
		return this.renderFill('bgEvent', segs);
	},


	// Unrenders all the currently rendered background event segments
	unrenderBgSegs: function() {
		this.unrenderFill('bgEvent');
	},


	// Renders a background event element, given the default rendering. Called by the fill system.
	bgEventSegEl: function(seg, el) {
		return this.view.resolveEventEl(seg.event, el); // will filter through eventRender
	},


	// Generates an array of classNames to be used for the default rendering of a background event.
	// Called by fillSegHtml.
	bgEventSegClasses: function(seg) {
		var event = seg.event;
		var source = event.source || {};

		return [ 'fc-bgevent' ].concat(
			event.className,
			source.className || []
		);
	},


	// Generates a semicolon-separated CSS string to be used for the default rendering of a background event.
	// Called by fillSegHtml.
	bgEventSegCss: function(seg) {
		return {
			'background-color': this.getSegSkinCss(seg)['background-color']
		};
	},


	// Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.
	// Called by fillSegHtml.
	businessHoursSegClasses: function(seg) {
		return [ 'fc-nonbusiness', 'fc-bgevent' ];
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	// Compute business hour segs for the grid's current date range.
	// Caller must ask if whole-day business hours are needed.
	// If no `businessHours` configuration value is specified, assumes the calendar default.
	buildBusinessHourSegs: function(wholeDay, businessHours) {
		return this.eventsToSegs(
			this.buildBusinessHourEvents(wholeDay, businessHours)
		);
	},


	// Compute business hour *events* for the grid's current date range.
	// Caller must ask if whole-day business hours are needed.
	// If no `businessHours` configuration value is specified, assumes the calendar default.
	buildBusinessHourEvents: function(wholeDay, businessHours) {
		var calendar = this.view.calendar;
		var events;

		if (businessHours == null) {
			// fallback
			// access from calendawr. don't access from view. doesn't update with dynamic options.
			businessHours = calendar.opt('businessHours');
		}

		events = calendar.computeBusinessHourEvents(wholeDay, businessHours);

		// HACK. Eventually refactor business hours "events" system.
		// If no events are given, but businessHours is activated, this means the entire visible range should be
		// marked as *not* business-hours, via inverse-background rendering.
		if (!events.length && businessHours) {
			events = [
				$.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, {
					start: this.view.activeRange.end, // guaranteed out-of-range
					end: this.view.activeRange.end,   // "
					dow: null
				})
			];
		}

		return events;
	},


	/* Handlers
	------------------------------------------------------------------------------------------------------------------*/


	// Attaches event-element-related handlers for *all* rendered event segments of the view.
	bindSegHandlers: function() {
		this.bindSegHandlersToEl(this.el);
	},


	// Attaches event-element-related handlers to an arbitrary container element. leverages bubbling.
	bindSegHandlersToEl: function(el) {
		this.bindSegHandlerToEl(el, 'touchstart', this.handleSegTouchStart);
		this.bindSegHandlerToEl(el, 'mouseenter', this.handleSegMouseover);
		this.bindSegHandlerToEl(el, 'mouseleave', this.handleSegMouseout);
		this.bindSegHandlerToEl(el, 'mousedown', this.handleSegMousedown);
		this.bindSegHandlerToEl(el, 'click', this.handleSegClick);
	},


	// Executes a handler for any a user-interaction on a segment.
	// Handler gets called with (seg, ev), and with the `this` context of the Grid
	bindSegHandlerToEl: function(el, name, handler) {
		var _this = this;

		el.on(name, this.segSelector, function(ev) {
			var seg = $(this).data('fc-seg'); // grab segment data. put there by View::renderEvents

			// only call the handlers if there is not a drag/resize in progress
			if (seg && !_this.isDraggingSeg && !_this.isResizingSeg) {
				return handler.call(_this, seg, ev); // context will be the Grid
			}
		});
	},


	handleSegClick: function(seg, ev) {
		var res = this.view.publiclyTrigger('eventClick', seg.el[0], seg.event, ev); // can return `false` to cancel
		if (res === false) {
			ev.preventDefault();
		}
	},


	// Updates internal state and triggers handlers for when an event element is moused over
	handleSegMouseover: function(seg, ev) {
		if (
			!GlobalEmitter.get().shouldIgnoreMouse() &&
			!this.mousedOverSeg
		) {
			this.mousedOverSeg = seg;
			if (this.view.isEventResizable(seg.event)) {
				seg.el.addClass('fc-allow-mouse-resize');
			}
			this.view.publiclyTrigger('eventMouseover', seg.el[0], seg.event, ev);
		}
	},


	// Updates internal state and triggers handlers for when an event element is moused out.
	// Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
	handleSegMouseout: function(seg, ev) {
		ev = ev || {}; // if given no args, make a mock mouse event

		if (this.mousedOverSeg) {
			seg = seg || this.mousedOverSeg; // if given no args, use the currently moused-over segment
			this.mousedOverSeg = null;
			if (this.view.isEventResizable(seg.event)) {
				seg.el.removeClass('fc-allow-mouse-resize');
			}
			this.view.publiclyTrigger('eventMouseout', seg.el[0], seg.event, ev);
		}
	},


	handleSegMousedown: function(seg, ev) {
		var isResizing = this.startSegResize(seg, ev, { distance: 5 });

		if (!isResizing && this.view.isEventDraggable(seg.event)) {
			this.buildSegDragListener(seg)
				.startInteraction(ev, {
					distance: 5
				});
		}
	},


	handleSegTouchStart: function(seg, ev) {
		var view = this.view;
		var event = seg.event;
		var isSelected = view.isEventSelected(event);
		var isDraggable = view.isEventDraggable(event);
		var isResizable = view.isEventResizable(event);
		var isResizing = false;
		var dragListener;
		var eventLongPressDelay;

		if (isSelected && isResizable) {
			// only allow resizing of the event is selected
			isResizing = this.startSegResize(seg, ev);
		}

		if (!isResizing && (isDraggable || isResizable)) { // allowed to be selected?

			eventLongPressDelay = view.opt('eventLongPressDelay');
			if (eventLongPressDelay == null) {
				eventLongPressDelay = view.opt('longPressDelay'); // fallback
			}

			dragListener = isDraggable ?
				this.buildSegDragListener(seg) :
				this.buildSegSelectListener(seg); // seg isn't draggable, but still needs to be selected

			dragListener.startInteraction(ev, { // won't start if already started
				delay: isSelected ? 0 : eventLongPressDelay // do delay if not already selected
			});
		}
	},


	// returns boolean whether resizing actually started or not.
	// assumes the seg allows resizing.
	// `dragOptions` are optional.
	startSegResize: function(seg, ev, dragOptions) {
		if ($(ev.target).is('.fc-resizer')) {
			this.buildSegResizeListener(seg, $(ev.target).is('.fc-start-resizer'))
				.startInteraction(ev, dragOptions);
			return true;
		}
		return false;
	},



	/* Event Dragging
	------------------------------------------------------------------------------------------------------------------*/


	// Builds a listener that will track user-dragging on an event segment.
	// Generic enough to work with any type of Grid.
	// Has side effect of setting/unsetting `segDragListener`
	buildSegDragListener: function(seg) {
		var _this = this;
		var view = this.view;
		var el = seg.el;
		var event = seg.event;
		var isDragging;
		var mouseFollower; // A clone of the original element that will move with the mouse
		var dropLocation; // zoned event date properties

		if (this.segDragListener) {
			return this.segDragListener;
		}

		// Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents
		// of the view.
		var dragListener = this.segDragListener = new HitDragListener(view, {
			scroll: view.opt('dragScroll'),
			subjectEl: el,
			subjectCenter: true,
			interactionStart: function(ev) {
				seg.component = _this; // for renderDrag
				isDragging = false;
				mouseFollower = new MouseFollower(seg.el, {
					additionalClass: 'fc-dragging',
					parentEl: view.el,
					opacity: dragListener.isTouch ? null : view.opt('dragOpacity'),
					revertDuration: view.opt('dragRevertDuration'),
					zIndex: 2 // one above the .fc-view
				});
				mouseFollower.hide(); // don't show until we know this is a real drag
				mouseFollower.start(ev);
			},
			dragStart: function(ev) {
				if (dragListener.isTouch && !view.isEventSelected(event)) {
					// if not previously selected, will fire after a delay. then, select the event
					view.selectEvent(event);
				}
				isDragging = true;
				_this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
				_this.segDragStart(seg, ev);
				view.hideEvent(event); // hide all event segments. our mouseFollower will take over
			},
			hitOver: function(hit, isOrig, origHit) {
				var isAllowed = true;
				var origHitSpan;
				var hitSpan;
				var dragHelperEls;

				// starting hit could be forced (DayGrid.limit)
				if (seg.hit) {
					origHit = seg.hit;
				}

				// hit might not belong to this grid, so query origin grid
				origHitSpan = origHit.component.getSafeHitSpan(origHit);
				hitSpan = hit.component.getSafeHitSpan(hit);

				if (origHitSpan && hitSpan) {
					dropLocation = _this.computeEventDrop(origHitSpan, hitSpan, event);
					isAllowed = dropLocation && _this.isEventLocationAllowed(dropLocation, event);
				}
				else {
					isAllowed = false;
				}

				if (!isAllowed) {
					dropLocation = null;
					disableCursor();
				}

				// if a valid drop location, have the subclass render a visual indication
				if (dropLocation && (dragHelperEls = view.renderDrag(dropLocation, seg))) {

					dragHelperEls.addClass('fc-dragging');
					if (!dragListener.isTouch) {
						_this.applyDragOpacity(dragHelperEls);
					}

					mouseFollower.hide(); // if the subclass is already using a mock event "helper", hide our own
				}
				else {
					mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)
				}

				if (isOrig) {
					dropLocation = null; // needs to have moved hits to be a valid drop
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				view.unrenderDrag(); // unrender whatever was done in renderDrag
				mouseFollower.show(); // show in case we are moving out of all hits
				dropLocation = null;
			},
			hitDone: function() { // Called after a hitOut OR before a dragEnd
				enableCursor();
			},
			interactionEnd: function(ev) {
				delete seg.component; // prevent side effects

				// do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
				mouseFollower.stop(!dropLocation, function() {
					if (isDragging) {
						view.unrenderDrag();
						_this.segDragStop(seg, ev);
					}

					if (dropLocation) {
						// no need to re-show original, will rerender all anyways. esp important if eventRenderWait
						view.reportSegDrop(seg, dropLocation, _this.largeUnit, el, ev);
					}
					else {
						view.showEvent(event);
					}
				});
				_this.segDragListener = null;
			}
		});

		return dragListener;
	},


	// seg isn't draggable, but let's use a generic DragListener
	// simply for the delay, so it can be selected.
	// Has side effect of setting/unsetting `segDragListener`
	buildSegSelectListener: function(seg) {
		var _this = this;
		var view = this.view;
		var event = seg.event;

		if (this.segDragListener) {
			return this.segDragListener;
		}

		var dragListener = this.segDragListener = new DragListener({
			dragStart: function(ev) {
				if (dragListener.isTouch && !view.isEventSelected(event)) {
					// if not previously selected, will fire after a delay. then, select the event
					view.selectEvent(event);
				}
			},
			interactionEnd: function(ev) {
				_this.segDragListener = null;
			}
		});

		return dragListener;
	},


	// Called before event segment dragging starts
	segDragStart: function(seg, ev) {
		this.isDraggingSeg = true;
		this.view.publiclyTrigger('eventDragStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Called after event segment dragging stops
	segDragStop: function(seg, ev) {
		this.isDraggingSeg = false;
		this.view.publiclyTrigger('eventDragStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Given the spans an event drag began, and the span event was dropped, calculates the new zoned start/end/allDay
	// values for the event. Subclasses may override and set additional properties to be used by renderDrag.
	// A falsy returned value indicates an invalid drop.
	// DOES NOT consider overlap/constraint.
	computeEventDrop: function(startSpan, endSpan, event) {
		var calendar = this.view.calendar;
		var dragStart = startSpan.start;
		var dragEnd = endSpan.start;
		var delta;
		var dropLocation; // zoned event date properties

		if (dragStart.hasTime() === dragEnd.hasTime()) {
			delta = this.diffDates(dragEnd, dragStart);

			// if an all-day event was in a timed area and it was dragged to a different time,
			// guarantee an end and adjust start/end to have times
			if (event.allDay && durationHasTime(delta)) {
				dropLocation = {
					start: event.start.clone(),
					end: calendar.getEventEnd(event), // will be an ambig day
					allDay: false // for normalizeEventTimes
				};
				calendar.normalizeEventTimes(dropLocation);
			}
			// othewise, work off existing values
			else {
				dropLocation = pluckEventDateProps(event);
			}

			dropLocation.start.add(delta);
			if (dropLocation.end) {
				dropLocation.end.add(delta);
			}
		}
		else {
			// if switching from day <-> timed, start should be reset to the dropped date, and the end cleared
			dropLocation = {
				start: dragEnd.clone(),
				end: null, // end should be cleared
				allDay: !dragEnd.hasTime()
			};
		}

		return dropLocation;
	},


	// Utility for apply dragOpacity to a jQuery set
	applyDragOpacity: function(els) {
		var opacity = this.view.opt('dragOpacity');

		if (opacity != null) {
			els.css('opacity', opacity);
		}
	},


	/* External Element Dragging
	------------------------------------------------------------------------------------------------------------------*/


	// Called when a jQuery UI drag is initiated anywhere in the DOM
	externalDragStart: function(ev, ui) {
		var view = this.view;
		var el;
		var accept;

		if (view.opt('droppable')) { // only listen if this setting is on
			el = $((ui ? ui.item : null) || ev.target);

			// Test that the dragged element passes the dropAccept selector or filter function.
			// FYI, the default is "*" (matches all)
			accept = view.opt('dropAccept');
			if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
				if (!this.isDraggingExternal) { // prevent double-listening if fired twice
					this.listenToExternalDrag(el, ev, ui);
				}
			}
		}
	},


	// Called when a jQuery UI drag starts and it needs to be monitored for dropping
	listenToExternalDrag: function(el, ev, ui) {
		var _this = this;
		var view = this.view;
		var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create
		var dropLocation; // a null value signals an unsuccessful drag

		// listener that tracks mouse movement over date-associated pixel regions
		var dragListener = _this.externalDragListener = new HitDragListener(this, {
			interactionStart: function() {
				_this.isDraggingExternal = true;
			},
			hitOver: function(hit) {
				var isAllowed = true;
				var hitSpan = hit.component.getSafeHitSpan(hit); // hit might not belong to this grid

				if (hitSpan) {
					dropLocation = _this.computeExternalDrop(hitSpan, meta);
					isAllowed = dropLocation && _this.isExternalLocationAllowed(dropLocation, meta.eventProps);
				}
				else {
					isAllowed = false;
				}

				if (!isAllowed) {
					dropLocation = null;
					disableCursor();
				}

				if (dropLocation) {
					_this.renderDrag(dropLocation); // called without a seg parameter
				}
			},
			hitOut: function() {
				dropLocation = null; // signal unsuccessful
			},
			hitDone: function() { // Called after a hitOut OR before a dragEnd
				enableCursor();
				_this.unrenderDrag();
			},
			interactionEnd: function(ev) {
				if (dropLocation) { // element was dropped on a valid hit
					view.reportExternalDrop(meta, dropLocation, el, ev, ui);
				}
				_this.isDraggingExternal = false;
				_this.externalDragListener = null;
			}
		});

		dragListener.startDrag(ev); // start listening immediately
	},


	// Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
	// returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.
	// Returning a null value signals an invalid drop hit.
	// DOES NOT consider overlap/constraint.
	computeExternalDrop: function(span, meta) {
		var calendar = this.view.calendar;
		var dropLocation = {
			start: calendar.applyTimezone(span.start), // simulate a zoned event start date
			end: null
		};

		// if dropped on an all-day span, and element's metadata specified a time, set it
		if (meta.startTime && !dropLocation.start.hasTime()) {
			dropLocation.start.time(meta.startTime);
		}

		if (meta.duration) {
			dropLocation.end = dropLocation.start.clone().add(meta.duration);
		}

		return dropLocation;
	},



	/* Drag Rendering (for both events and an external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event or external element being dragged.
	// `dropLocation` contains hypothetical start/end/allDay values the event would have if dropped. end can be null.
	// `seg` is the internal segment object that is being dragged. If dragging an external element, `seg` is null.
	// A truthy returned value indicates this method has rendered a helper element.
	// Must return elements used for any mock events.
	renderDrag: function(dropLocation, seg) {
		// subclasses must implement
	},


	// Unrenders a visual indication of an event or external element being dragged
	unrenderDrag: function() {
		// subclasses must implement
	},


	/* Resizing
	------------------------------------------------------------------------------------------------------------------*/


	// Creates a listener that tracks the user as they resize an event segment.
	// Generic enough to work with any type of Grid.
	buildSegResizeListener: function(seg, isStart) {
		var _this = this;
		var view = this.view;
		var calendar = view.calendar;
		var el = seg.el;
		var event = seg.event;
		var eventEnd = calendar.getEventEnd(event);
		var isDragging;
		var resizeLocation; // zoned event date properties. falsy if invalid resize

		// Tracks mouse movement over the *grid's* coordinate map
		var dragListener = this.segResizeListener = new HitDragListener(this, {
			scroll: view.opt('dragScroll'),
			subjectEl: el,
			interactionStart: function() {
				isDragging = false;
			},
			dragStart: function(ev) {
				isDragging = true;
				_this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
				_this.segResizeStart(seg, ev);
			},
			hitOver: function(hit, isOrig, origHit) {
				var isAllowed = true;
				var origHitSpan = _this.getSafeHitSpan(origHit);
				var hitSpan = _this.getSafeHitSpan(hit);

				if (origHitSpan && hitSpan) {
					resizeLocation = isStart ?
						_this.computeEventStartResize(origHitSpan, hitSpan, event) :
						_this.computeEventEndResize(origHitSpan, hitSpan, event);

					isAllowed = resizeLocation && _this.isEventLocationAllowed(resizeLocation, event);
				}
				else {
					isAllowed = false;
				}

				if (!isAllowed) {
					resizeLocation = null;
					disableCursor();
				}
				else {
					if (
						resizeLocation.start.isSame(event.start.clone().stripZone()) &&
						resizeLocation.end.isSame(eventEnd.clone().stripZone())
					) {
						// no change. (FYI, event dates might have zones)
						resizeLocation = null;
					}
				}

				if (resizeLocation) {
					view.hideEvent(event);
					_this.renderEventResize(resizeLocation, seg);
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				resizeLocation = null;
				view.showEvent(event); // for when out-of-bounds. show original
			},
			hitDone: function() { // resets the rendering to show the original event
				_this.unrenderEventResize();
				enableCursor();
			},
			interactionEnd: function(ev) {
				if (isDragging) {
					_this.segResizeStop(seg, ev);
				}

				if (resizeLocation) { // valid date to resize to?
					// no need to re-show original, will rerender all anyways. esp important if eventRenderWait
					view.reportSegResize(seg, resizeLocation, _this.largeUnit, el, ev);
				}
				else {
					view.showEvent(event);
				}
				_this.segResizeListener = null;
			}
		});

		return dragListener;
	},


	// Called before event segment resizing starts
	segResizeStart: function(seg, ev) {
		this.isResizingSeg = true;
		this.view.publiclyTrigger('eventResizeStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Called after event segment resizing stops
	segResizeStop: function(seg, ev) {
		this.isResizingSeg = false;
		this.view.publiclyTrigger('eventResizeStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Returns new date-information for an event segment being resized from its start
	computeEventStartResize: function(startSpan, endSpan, event) {
		return this.computeEventResize('start', startSpan, endSpan, event);
	},


	// Returns new date-information for an event segment being resized from its end
	computeEventEndResize: function(startSpan, endSpan, event) {
		return this.computeEventResize('end', startSpan, endSpan, event);
	},


	// Returns new zoned date information for an event segment being resized from its start OR end
	// `type` is either 'start' or 'end'.
	// DOES NOT consider overlap/constraint.
	computeEventResize: function(type, startSpan, endSpan, event) {
		var calendar = this.view.calendar;
		var delta = this.diffDates(endSpan[type], startSpan[type]);
		var resizeLocation; // zoned event date properties
		var defaultDuration;

		// build original values to work from, guaranteeing a start and end
		resizeLocation = {
			start: event.start.clone(),
			end: calendar.getEventEnd(event),
			allDay: event.allDay
		};

		// if an all-day event was in a timed area and was resized to a time, adjust start/end to have times
		if (resizeLocation.allDay && durationHasTime(delta)) {
			resizeLocation.allDay = false;
			calendar.normalizeEventTimes(resizeLocation);
		}

		resizeLocation[type].add(delta); // apply delta to start or end

		// if the event was compressed too small, find a new reasonable duration for it
		if (!resizeLocation.start.isBefore(resizeLocation.end)) {

			defaultDuration =
				this.minResizeDuration || // TODO: hack
				(event.allDay ?
					calendar.defaultAllDayEventDuration :
					calendar.defaultTimedEventDuration);

			if (type == 'start') { // resizing the start?
				resizeLocation.start = resizeLocation.end.clone().subtract(defaultDuration);
			}
			else { // resizing the end?
				resizeLocation.end = resizeLocation.start.clone().add(defaultDuration);
			}
		}

		return resizeLocation;
	},


	// Renders a visual indication of an event being resized.
	// `range` has the updated dates of the event. `seg` is the original segment object involved in the drag.
	// Must return elements used for any mock events.
	renderEventResize: function(range, seg) {
		// subclasses must implement
	},


	// Unrenders a visual indication of an event being resized.
	unrenderEventResize: function() {
		// subclasses must implement
	},


	/* Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Compute the text that should be displayed on an event's element.
	// `range` can be the Event object itself, or something range-like, with at least a `start`.
	// If event times are disabled, or the event has no time, will return a blank string.
	// If not specified, formatStr will default to the eventTimeFormat setting,
	// and displayEnd will default to the displayEventEnd setting.
	getEventTimeText: function(range, formatStr, displayEnd) {

		if (formatStr == null) {
			formatStr = this.eventTimeFormat;
		}

		if (displayEnd == null) {
			displayEnd = this.displayEventEnd;
		}

		if (this.displayEventTime && range.start.hasTime()) {
			if (displayEnd && range.end) {
				return this.view.formatRange(range, formatStr);
			}
			else {
				return range.start.format(formatStr);
			}
		}

		return '';
	},


	// Generic utility for generating the HTML classNames for an event segment's element
	getSegClasses: function(seg, isDraggable, isResizable) {
		var view = this.view;
		var classes = [
			'fc-event',
			seg.isStart ? 'fc-start' : 'fc-not-start',
			seg.isEnd ? 'fc-end' : 'fc-not-end'
		].concat(this.getSegCustomClasses(seg));

		if (isDraggable) {
			classes.push('fc-draggable');
		}
		if (isResizable) {
			classes.push('fc-resizable');
		}

		// event is currently selected? attach a className.
		if (view.isEventSelected(seg.event)) {
			classes.push('fc-selected');
		}

		return classes;
	},


	// List of classes that were defined by the caller of the API in some way
	getSegCustomClasses: function(seg) {
		var event = seg.event;

		return [].concat(
			event.className, // guaranteed to be an array
			event.source ? event.source.className : []
		);
	},


	// Utility for generating event skin-related CSS properties
	getSegSkinCss: function(seg) {
		return {
			'background-color': this.getSegBackgroundColor(seg),
			'border-color': this.getSegBorderColor(seg),
			color: this.getSegTextColor(seg)
		};
	},


	// Queries for caller-specified color, then falls back to default
	getSegBackgroundColor: function(seg) {
		return seg.event.backgroundColor ||
			seg.event.color ||
			this.getSegDefaultBackgroundColor(seg);
	},


	getSegDefaultBackgroundColor: function(seg) {
		var source = seg.event.source || {};

		return source.backgroundColor ||
			source.color ||
			this.view.opt('eventBackgroundColor') ||
			this.view.opt('eventColor');
	},


	// Queries for caller-specified color, then falls back to default
	getSegBorderColor: function(seg) {
		return seg.event.borderColor ||
			seg.event.color ||
			this.getSegDefaultBorderColor(seg);
	},


	getSegDefaultBorderColor: function(seg) {
		var source = seg.event.source || {};

		return source.borderColor ||
			source.color ||
			this.view.opt('eventBorderColor') ||
			this.view.opt('eventColor');
	},


	// Queries for caller-specified color, then falls back to default
	getSegTextColor: function(seg) {
		return seg.event.textColor ||
			this.getSegDefaultTextColor(seg);
	},


	getSegDefaultTextColor: function(seg) {
		var source = seg.event.source || {};

		return source.textColor ||
			this.view.opt('eventTextColor');
	},


	/* Event Location Validation
	------------------------------------------------------------------------------------------------------------------*/


	isEventLocationAllowed: function(eventLocation, event) {
		if (this.isEventLocationInRange(eventLocation)) {
			var calendar = this.view.calendar;
			var eventSpans = this.eventToSpans(eventLocation);
			var i;

			if (eventSpans.length) {
				for (i = 0; i < eventSpans.length; i++) {
					if (!calendar.isEventSpanAllowed(eventSpans[i], event)) {
						return false;
					}
				}

				return true;
			}
		}

		return false;
	},


	isExternalLocationAllowed: function(eventLocation, metaProps) { // FOR the external element
		if (this.isEventLocationInRange(eventLocation)) {
			var calendar = this.view.calendar;
			var eventSpans = this.eventToSpans(eventLocation);
			var i;

			if (eventSpans.length) {
				for (i = 0; i < eventSpans.length; i++) {
					if (!calendar.isExternalSpanAllowed(eventSpans[i], eventLocation, metaProps)) {
						return false;
					}
				}

				return true;
			}
		}

		return false;
	},


	isEventLocationInRange: function(eventLocation) {
		return isRangeWithinRange(
			this.eventToRawRange(eventLocation),
			this.view.validRange
		);
	},


	/* Converting events -> eventRange -> eventSpan -> eventSegs
	------------------------------------------------------------------------------------------------------------------*/


	// Generates an array of segments for the given single event
	// Can accept an event "location" as well (which only has start/end and no allDay)
	eventToSegs: function(event) {
		return this.eventsToSegs([ event ]);
	},


	// Generates spans (always unzoned) for the given event.
	// Does not do any inverting for inverse-background events.
	// Can accept an event "location" as well (which only has start/end and no allDay)
	eventToSpans: function(event) {
		var eventRange = this.eventToRange(event); // { start, end, isStart, isEnd }

		if (eventRange) {
			return this.eventRangeToSpans(eventRange, event);
		}
		else { // out of view's valid range
			return [];
		}
	},



	// Converts an array of event objects into an array of event segment objects.
	// A custom `segSliceFunc` may be given for arbitrarily slicing up events.
	// Doesn't guarantee an order for the resulting array.
	eventsToSegs: function(allEvents, segSliceFunc) {
		var _this = this;
		var eventsById = groupEventsById(allEvents);
		var segs = [];

		$.each(eventsById, function(id, events) {
			var visibleEvents = [];
			var eventRanges = [];
			var eventRange; // { start, end, isStart, isEnd }
			var i;

			for (i = 0; i < events.length; i++) {
				eventRange = _this.eventToRange(events[i]); // might be null if completely out of range

				if (eventRange) {
					eventRanges.push(eventRange);
					visibleEvents.push(events[i]);
				}
			}

			// inverse-background events (utilize only the first event in calculations)
			if (isInverseBgEvent(events[0])) {
				eventRanges = _this.invertRanges(eventRanges); // will lose isStart/isEnd

				for (i = 0; i < eventRanges.length; i++) {
					segs.push.apply(segs, // append to
						_this.eventRangeToSegs(eventRanges[i], events[0], segSliceFunc)
					);
				}
			}
			// normal event ranges
			else {
				for (i = 0; i < eventRanges.length; i++) {
					segs.push.apply(segs, // append to
						_this.eventRangeToSegs(eventRanges[i], visibleEvents[i], segSliceFunc)
					);
				}
			}
		});

		return segs;
	},


	// Generates the unzoned start/end dates an event appears to occupy
	// Can accept an event "location" as well (which only has start/end and no allDay)
	// returns { start, end, isStart, isEnd }
	// If the event is completely outside of the grid's valid range, will return undefined.
	eventToRange: function(event) {
		return this.refineRawEventRange(
			this.eventToRawRange(event)
		);
	},


	// Ensures the given range is within the view's activeRange and is correctly localized.
	// Always returns a result
	refineRawEventRange: function(rawRange) {
		var view = this.view;
		var calendar = view.calendar;
		var range = intersectRanges(rawRange, view.activeRange);

		if (range) { // otherwise, event doesn't have valid range

			// hack: dynamic locale change forgets to upate stored event localed
			calendar.localizeMoment(range.start);
			calendar.localizeMoment(range.end);

			return range;
		}
	},


	// not constrained to valid dates
	// not given localizeMoment hack
	eventToRawRange: function(event) {
		var calendar = this.view.calendar;
		var start = event.start.clone().stripZone();
		var end = (
				event.end ?
					event.end.clone() :
					// derive the end from the start and allDay. compute allDay if necessary
					calendar.getDefaultEventEnd(
						event.allDay != null ?
							event.allDay :
							!event.start.hasTime(),
						event.start
					)
			).stripZone();

		return { start: start, end: end };
	},


	// Given an event's range (unzoned start/end), and the event itself,
	// slice into segments (using the segSliceFunc function if specified)
	// eventRange - { start, end, isStart, isEnd }
	eventRangeToSegs: function(eventRange, event, segSliceFunc) {
		var eventSpans = this.eventRangeToSpans(eventRange, event);
		var segs = [];
		var i;

		for (i = 0; i < eventSpans.length; i++) {
			segs.push.apply(segs, // append to
				this.eventSpanToSegs(eventSpans[i], event, segSliceFunc)
			);
		}

		return segs;
	},


	// Given an event's unzoned date range, return an array of eventSpan objects.
	// eventSpan - { start, end, isStart, isEnd, otherthings... }
	// Subclasses can override.
	// Subclasses are obligated to forward eventRange.isStart/isEnd to the resulting spans.
	eventRangeToSpans: function(eventRange, event) {
		return [ $.extend({}, eventRange) ]; // copy into a single-item array
	},


	// Given an event's span (unzoned start/end and other misc data), and the event itself,
	// slices into segments and attaches event-derived properties to them.
	// eventSpan - { start, end, isStart, isEnd, otherthings... }
	eventSpanToSegs: function(eventSpan, event, segSliceFunc) {
		var segs = segSliceFunc ? segSliceFunc(eventSpan) : this.spanToSegs(eventSpan);
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];

			// the eventSpan's isStart/isEnd takes precedence over the seg's
			if (!eventSpan.isStart) {
				seg.isStart = false;
			}
			if (!eventSpan.isEnd) {
				seg.isEnd = false;
			}

			seg.event = event;
			seg.eventStartMS = +eventSpan.start; // TODO: not the best name after making spans unzoned
			seg.eventDurationMS = eventSpan.end - eventSpan.start;
		}

		return segs;
	},


	// Produces a new array of range objects that will cover all the time NOT covered by the given ranges.
	// SIDE EFFECT: will mutate the given array and will use its date references.
	invertRanges: function(ranges) {
		var view = this.view;
		var viewStart = view.activeRange.start.clone(); // need a copy
		var viewEnd = view.activeRange.end.clone(); // need a copy
		var inverseRanges = [];
		var start = viewStart; // the end of the previous range. the start of the new range
		var i, range;

		// ranges need to be in order. required for our date-walking algorithm
		ranges.sort(compareRanges);

		for (i = 0; i < ranges.length; i++) {
			range = ranges[i];

			// add the span of time before the event (if there is any)
			if (range.start > start) { // compare millisecond time (skip any ambig logic)
				inverseRanges.push({
					start: start,
					end: range.start
				});
			}

			if (range.end > start) {
				start = range.end;
			}
		}

		// add the span of time after the last event (if there is any)
		if (start < viewEnd) { // compare millisecond time (skip any ambig logic)
			inverseRanges.push({
				start: start,
				end: viewEnd
			});
		}

		return inverseRanges;
	},


	sortEventSegs: function(segs) {
		segs.sort(proxy(this, 'compareEventSegs'));
	},


	// A cmp function for determining which segments should take visual priority
	compareEventSegs: function(seg1, seg2) {
		return seg1.eventStartMS - seg2.eventStartMS || // earlier events go first
			seg2.eventDurationMS - seg1.eventDurationMS || // tie? longer events go first
			seg2.event.allDay - seg1.event.allDay || // tie? put all-day events first (booleans cast to 0/1)
			compareByFieldSpecs(seg1.event, seg2.event, this.view.eventOrderSpecs);
	}

});


/* Utilities
----------------------------------------------------------------------------------------------------------------------*/


function pluckEventDateProps(event) {
	return {
		start: event.start.clone(),
		end: event.end ? event.end.clone() : null,
		allDay: event.allDay // keep it the same
	};
}
FC.pluckEventDateProps = pluckEventDateProps;


function isBgEvent(event) { // returns true if background OR inverse-background
	var rendering = getEventRendering(event);
	return rendering === 'background' || rendering === 'inverse-background';
}
FC.isBgEvent = isBgEvent; // export


function isInverseBgEvent(event) {
	return getEventRendering(event) === 'inverse-background';
}


function getEventRendering(event) {
	return firstDefined((event.source || {}).rendering, event.rendering);
}


function groupEventsById(events) {
	var eventsById = {};
	var i, event;

	for (i = 0; i < events.length; i++) {
		event = events[i];
		(eventsById[event._id] || (eventsById[event._id] = [])).push(event);
	}

	return eventsById;
}


// A cmp function for determining which non-inverted "ranges" (see above) happen earlier
function compareRanges(range1, range2) {
	return range1.start - range2.start; // earlier ranges go first
}


/* External-Dragging-Element Data
----------------------------------------------------------------------------------------------------------------------*/

// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.
FC.dataAttrPrefix = '';

// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
function getDraggedElMeta(el) {
	var prefix = FC.dataAttrPrefix;
	var eventProps; // properties for creating the event, not related to date/time
	var startTime; // a Duration
	var duration;
	var stick;

	if (prefix) { prefix += '-'; }
	eventProps = el.data(prefix + 'event') || null;

	if (eventProps) {
		if (typeof eventProps === 'object') {
			eventProps = $.extend({}, eventProps); // make a copy
		}
		else { // something like 1 or true. still signal event creation
			eventProps = {};
		}

		// pluck special-cased date/time properties
		startTime = eventProps.start;
		if (startTime == null) { startTime = eventProps.time; } // accept 'time' as well
		duration = eventProps.duration;
		stick = eventProps.stick;
		delete eventProps.start;
		delete eventProps.time;
		delete eventProps.duration;
		delete eventProps.stick;
	}

	// fallback to standalone attribute values for each of the date/time properties
	if (startTime == null) { startTime = el.data(prefix + 'start'); }
	if (startTime == null) { startTime = el.data(prefix + 'time'); } // accept 'time' as well
	if (duration == null) { duration = el.data(prefix + 'duration'); }
	if (stick == null) { stick = el.data(prefix + 'stick'); }

	// massage into correct data types
	startTime = startTime != null ? moment.duration(startTime) : null;
	duration = duration != null ? moment.duration(duration) : null;
	stick = Boolean(stick);

	return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };
}


;;

/*
A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.
Prerequisite: the object being mixed into needs to be a *Grid*
*/
var DayTableMixin = FC.DayTableMixin = {

	breakOnWeeks: false, // should create a new row for each week?
	dayDates: null, // whole-day dates for each column. left to right
	dayIndices: null, // for each day from start, the offset
	daysPerRow: null,
	rowCnt: null,
	colCnt: null,
	colHeadFormat: null,


	// Populates internal variables used for date calculation and rendering
	updateDayTable: function() {
		var view = this.view;
		var date = this.start.clone();
		var dayIndex = -1;
		var dayIndices = [];
		var dayDates = [];
		var daysPerRow;
		var firstDay;
		var rowCnt;

		while (date.isBefore(this.end)) { // loop each day from start to end
			if (view.isHiddenDay(date)) {
				dayIndices.push(dayIndex + 0.5); // mark that it's between indices
			}
			else {
				dayIndex++;
				dayIndices.push(dayIndex);
				dayDates.push(date.clone());
			}
			date.add(1, 'days');
		}

		if (this.breakOnWeeks) {
			// count columns until the day-of-week repeats
			firstDay = dayDates[0].day();
			for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {
				if (dayDates[daysPerRow].day() == firstDay) {
					break;
				}
			}
			rowCnt = Math.ceil(dayDates.length / daysPerRow);
		}
		else {
			rowCnt = 1;
			daysPerRow = dayDates.length;
		}

		this.dayDates = dayDates;
		this.dayIndices = dayIndices;
		this.daysPerRow = daysPerRow;
		this.rowCnt = rowCnt;

		this.updateDayTableCols();
	},


	// Computes and assigned the colCnt property and updates any options that may be computed from it
	updateDayTableCols: function() {
		this.colCnt = this.computeColCnt();
		this.colHeadFormat = this.view.opt('columnFormat') || this.computeColHeadFormat();
	},


	// Determines how many columns there should be in the table
	computeColCnt: function() {
		return this.daysPerRow;
	},


	// Computes the ambiguously-timed moment for the given cell
	getCellDate: function(row, col) {
		return this.dayDates[
				this.getCellDayIndex(row, col)
			].clone();
	},


	// Computes the ambiguously-timed date range for the given cell
	getCellRange: function(row, col) {
		var start = this.getCellDate(row, col);
		var end = start.clone().add(1, 'days');

		return { start: start, end: end };
	},


	// Returns the number of day cells, chronologically, from the first of the grid (0-based)
	getCellDayIndex: function(row, col) {
		return row * this.daysPerRow + this.getColDayIndex(col);
	},


	// Returns the numner of day cells, chronologically, from the first cell in *any given row*
	getColDayIndex: function(col) {
		if (this.isRTL) {
			return this.colCnt - 1 - col;
		}
		else {
			return col;
		}
	},


	// Given a date, returns its chronolocial cell-index from the first cell of the grid.
	// If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
	// If before the first offset, returns a negative number.
	// If after the last offset, returns an offset past the last cell offset.
	// Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
	getDateDayIndex: function(date) {
		var dayIndices = this.dayIndices;
		var dayOffset = date.diff(this.start, 'days');

		if (dayOffset < 0) {
			return dayIndices[0] - 1;
		}
		else if (dayOffset >= dayIndices.length) {
			return dayIndices[dayIndices.length - 1] + 1;
		}
		else {
			return dayIndices[dayOffset];
		}
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Computes a default column header formatting string if `colFormat` is not explicitly defined
	computeColHeadFormat: function() {
		// if more than one week row, or if there are a lot of columns with not much space,
		// put just the day numbers will be in each cell
		if (this.rowCnt > 1 || this.colCnt > 10) {
			return 'ddd'; // "Sat"
		}
		// multiple days, so full single date string WON'T be in title text
		else if (this.colCnt > 1) {
			return this.view.opt('dayOfMonthFormat'); // "Sat 12/10"
		}
		// single day, so full single date string will probably be in title text
		else {
			return 'dddd'; // "Saturday"
		}
	},


	/* Slicing
	------------------------------------------------------------------------------------------------------------------*/


	// Slices up a date range into a segment for every week-row it intersects with
	sliceRangeByRow: function(range) {
		var daysPerRow = this.daysPerRow;
		var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
		var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
		var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
		var segs = [];
		var row;
		var rowFirst, rowLast; // inclusive day-index range for current row
		var segFirst, segLast; // inclusive day-index range for segment

		for (row = 0; row < this.rowCnt; row++) {
			rowFirst = row * daysPerRow;
			rowLast = rowFirst + daysPerRow - 1;

			// intersect segment's offset range with the row's
			segFirst = Math.max(rangeFirst, rowFirst);
			segLast = Math.min(rangeLast, rowLast);

			// deal with in-between indices
			segFirst = Math.ceil(segFirst); // in-between starts round to next cell
			segLast = Math.floor(segLast); // in-between ends round to prev cell

			if (segFirst <= segLast) { // was there any intersection with the current row?
				segs.push({
					row: row,

					// normalize to start of row
					firstRowDayIndex: segFirst - rowFirst,
					lastRowDayIndex: segLast - rowFirst,

					// must be matching integers to be the segment's start/end
					isStart: segFirst === rangeFirst,
					isEnd: segLast === rangeLast
				});
			}
		}

		return segs;
	},


	// Slices up a date range into a segment for every day-cell it intersects with.
	// TODO: make more DRY with sliceRangeByRow somehow.
	sliceRangeByDay: function(range) {
		var daysPerRow = this.daysPerRow;
		var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
		var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
		var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
		var segs = [];
		var row;
		var rowFirst, rowLast; // inclusive day-index range for current row
		var i;
		var segFirst, segLast; // inclusive day-index range for segment

		for (row = 0; row < this.rowCnt; row++) {
			rowFirst = row * daysPerRow;
			rowLast = rowFirst + daysPerRow - 1;

			for (i = rowFirst; i <= rowLast; i++) {

				// intersect segment's offset range with the row's
				segFirst = Math.max(rangeFirst, i);
				segLast = Math.min(rangeLast, i);

				// deal with in-between indices
				segFirst = Math.ceil(segFirst); // in-between starts round to next cell
				segLast = Math.floor(segLast); // in-between ends round to prev cell

				if (segFirst <= segLast) { // was there any intersection with the current row?
					segs.push({
						row: row,

						// normalize to start of row
						firstRowDayIndex: segFirst - rowFirst,
						lastRowDayIndex: segLast - rowFirst,

						// must be matching integers to be the segment's start/end
						isStart: segFirst === rangeFirst,
						isEnd: segLast === rangeLast
					});
				}
			}
		}

		return segs;
	},


	/* Header Rendering
	------------------------------------------------------------------------------------------------------------------*/


	renderHeadHtml: function() {
		var view = this.view;

		return '' +
			'<div class="fc-row ' + view.widgetHeaderClass + '">' +
				'<table>' +
					'<thead>' +
						this.renderHeadTrHtml() +
					'</thead>' +
				'</table>' +
			'</div>';
	},


	renderHeadIntroHtml: function() {
		return this.renderIntroHtml(); // fall back to generic
	},


	renderHeadTrHtml: function() {
		return '' +
			'<tr>' +
				(this.isRTL ? '' : this.renderHeadIntroHtml()) +
				this.renderHeadDateCellsHtml() +
				(this.isRTL ? this.renderHeadIntroHtml() : '') +
			'</tr>';
	},


	renderHeadDateCellsHtml: function() {
		var htmls = [];
		var col, date;

		for (col = 0; col < this.colCnt; col++) {
			date = this.getCellDate(0, col);
			htmls.push(this.renderHeadDateCellHtml(date));
		}

		return htmls.join('');
	},


	// TODO: when internalApiVersion, accept an object for HTML attributes
	// (colspan should be no different)
	renderHeadDateCellHtml: function(date, colspan, otherAttrs) {
		var view = this.view;
		var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.
		var classNames = [
			'fc-day-header',
			view.widgetHeaderClass
		];
		var innerHtml = htmlEscape(date.format(this.colHeadFormat));

		// if only one row of days, the classNames on the header can represent the specific days beneath
		if (this.rowCnt === 1) {
			classNames = classNames.concat(
				// includes the day-of-week class
				// noThemeHighlight=true (don't highlight the header)
				this.getDayClasses(date, true)
			);
		}
		else {
			classNames.push('fc-' + dayIDs[date.day()]); // only add the day-of-week class
		}

		return '' +
            '<th class="' + classNames.join(' ') + '"' +
				((isDateValid && this.rowCnt) === 1 ?
					' data-date="' + date.format('YYYY-MM-DD') + '"' :
					'') +
				(colspan > 1 ?
					' colspan="' + colspan + '"' :
					'') +
				(otherAttrs ?
					' ' + otherAttrs :
					'') +
				'>' +
				(isDateValid ?
					// don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)
					view.buildGotoAnchorHtml(
						{ date: date, forceOff: this.rowCnt > 1 || this.colCnt === 1 },
						innerHtml
					) :
					// if not valid, display text, but no link
					innerHtml
				) +
			'</th>';
	},


	/* Background Rendering
	------------------------------------------------------------------------------------------------------------------*/


	renderBgTrHtml: function(row) {
		return '' +
			'<tr>' +
				(this.isRTL ? '' : this.renderBgIntroHtml(row)) +
				this.renderBgCellsHtml(row) +
				(this.isRTL ? this.renderBgIntroHtml(row) : '') +
			'</tr>';
	},


	renderBgIntroHtml: function(row) {
		return this.renderIntroHtml(); // fall back to generic
	},


	renderBgCellsHtml: function(row) {
		var htmls = [];
		var col, date;

		for (col = 0; col < this.colCnt; col++) {
			date = this.getCellDate(row, col);
			htmls.push(this.renderBgCellHtml(date));
		}

		return htmls.join('');
	},


	renderBgCellHtml: function(date, otherAttrs) {
		var view = this.view;
		var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.
		var classes = this.getDayClasses(date);

		classes.unshift('fc-day', view.widgetContentClass);

		return '<td class="' + classes.join(' ') + '"' +
			(isDateValid ?
				' data-date="' + date.format('YYYY-MM-DD') + '"' : // if date has a time, won't format it
				'') +
			(otherAttrs ?
				' ' + otherAttrs :
				'') +
			'></td>';
	},


	/* Generic
	------------------------------------------------------------------------------------------------------------------*/


	// Generates the default HTML intro for any row. User classes should override
	renderIntroHtml: function() {
	},


	// TODO: a generic method for dealing with <tr>, RTL, intro
	// when increment internalApiVersion
	// wrapTr (scheduler)


	/* Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Applies the generic "intro" and "outro" HTML to the given cells.
	// Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
	bookendCells: function(trEl) {
		var introHtml = this.renderIntroHtml();

		if (introHtml) {
			if (this.isRTL) {
				trEl.append(introHtml);
			}
			else {
				trEl.prepend(introHtml);
			}
		}
	}

};

;;

/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
----------------------------------------------------------------------------------------------------------------------*/

var DayGrid = FC.DayGrid = Grid.extend(DayTableMixin, {

	numbersVisible: false, // should render a row for day/week numbers? set by outside view. TODO: make internal
	bottomCoordPadding: 0, // hack for extending the hit area for the last row of the coordinate grid

	rowEls: null, // set of fake row elements
	cellEls: null, // set of whole-day elements comprising the row's background
	helperEls: null, // set of cell skeleton elements for rendering the mock event "helper"

	rowCoordCache: null,
	colCoordCache: null,


	// Renders the rows and columns into the component's `this.el`, which should already be assigned.
	// isRigid determins whether the individual rows should ignore the contents and be a constant height.
	// Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
	renderDates: function(isRigid) {
		var view = this.view;
		var rowCnt = this.rowCnt;
		var colCnt = this.colCnt;
		var html = '';
		var row;
		var col;

		for (row = 0; row < rowCnt; row++) {
			html += this.renderDayRowHtml(row, isRigid);
		}
		this.el.html(html);

		this.rowEls = this.el.find('.fc-row');
		this.cellEls = this.el.find('.fc-day, .fc-disabled-day');

		this.rowCoordCache = new CoordCache({
			els: this.rowEls,
			isVertical: true
		});
		this.colCoordCache = new CoordCache({
			els: this.cellEls.slice(0, this.colCnt), // only the first row
			isHorizontal: true
		});

		// trigger dayRender with each cell's element
		for (row = 0; row < rowCnt; row++) {
			for (col = 0; col < colCnt; col++) {
				view.publiclyTrigger(
					'dayRender',
					null,
					this.getCellDate(row, col),
					this.getCellEl(row, col)
				);
			}
		}
	},


	unrenderDates: function() {
		this.removeSegPopover();
	},


	renderBusinessHours: function() {
		var segs = this.buildBusinessHourSegs(true); // wholeDay=true
		this.renderFill('businessHours', segs, 'bgevent');
	},


	unrenderBusinessHours: function() {
		this.unrenderFill('businessHours');
	},


	// Generates the HTML for a single row, which is a div that wraps a table.
	// `row` is the row number.
	renderDayRowHtml: function(row, isRigid) {
		var view = this.view;
		var classes = [ 'fc-row', 'fc-week', view.widgetContentClass ];

		if (isRigid) {
			classes.push('fc-rigid');
		}

		return '' +
			'<div class="' + classes.join(' ') + '">' +
				'<div class="fc-bg">' +
					'<table>' +
						this.renderBgTrHtml(row) +
					'</table>' +
				'</div>' +
				'<div class="fc-content-skeleton">' +
					'<table>' +
						(this.numbersVisible ?
							'<thead>' +
								this.renderNumberTrHtml(row) +
							'</thead>' :
							''
							) +
					'</table>' +
				'</div>' +
			'</div>';
	},


	/* Grid Number Rendering
	------------------------------------------------------------------------------------------------------------------*/


	renderNumberTrHtml: function(row) {
		return '' +
			'<tr>' +
				(this.isRTL ? '' : this.renderNumberIntroHtml(row)) +
				this.renderNumberCellsHtml(row) +
				(this.isRTL ? this.renderNumberIntroHtml(row) : '') +
			'</tr>';
	},


	renderNumberIntroHtml: function(row) {
		return this.renderIntroHtml();
	},


	renderNumberCellsHtml: function(row) {
		var htmls = [];
		var col, date;

		for (col = 0; col < this.colCnt; col++) {
			date = this.getCellDate(row, col);
			htmls.push(this.renderNumberCellHtml(date));
		}

		return htmls.join('');
	},


	// Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
	// The number row will only exist if either day numbers or week numbers are turned on.
	renderNumberCellHtml: function(date) {
		var view = this.view;
		var html = '';
		var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.
		var isDayNumberVisible = view.dayNumbersVisible && isDateValid;
		var classes;
		var weekCalcFirstDoW;

		if (!isDayNumberVisible && !view.cellWeekNumbersVisible) {
			// no numbers in day cell (week number must be along the side)
			return '<td/>'; //  will create an empty space above events :(
		}

		classes = this.getDayClasses(date);
		classes.unshift('fc-day-top');

		if (view.cellWeekNumbersVisible) {
			// To determine the day of week number change under ISO, we cannot
			// rely on moment.js methods such as firstDayOfWeek() or weekday(),
			// because they rely on the locale's dow (possibly overridden by
			// our firstDay option), which may not be Monday. We cannot change
			// dow, because that would affect the calendar start day as well.
			if (date._locale._fullCalendar_weekCalc === 'ISO') {
				weekCalcFirstDoW = 1;  // Monday by ISO 8601 definition
			}
			else {
				weekCalcFirstDoW = date._locale.firstDayOfWeek();
			}
		}

		html += '<td class="' + classes.join(' ') + '"' +
			(isDateValid ?
				' data-date="' + date.format() + '"' :
				''
				) +
			'>';

		if (view.cellWeekNumbersVisible && (date.day() == weekCalcFirstDoW)) {
			html += view.buildGotoAnchorHtml(
				{ date: date, type: 'week' },
				{ 'class': 'fc-week-number' },
				date.format('w') // inner HTML
			);
		}

		if (isDayNumberVisible) {
			html += view.buildGotoAnchorHtml(
				date,
				{ 'class': 'fc-day-number' },
				date.date() // inner HTML
			);
		}

		html += '</td>';

		return html;
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Computes a default event time formatting string if `timeFormat` is not explicitly defined
	computeEventTimeFormat: function() {
		return this.view.opt('extraSmallTimeFormat'); // like "6p" or "6:30p"
	},


	// Computes a default `displayEventEnd` value if one is not expliclty defined
	computeDisplayEventEnd: function() {
		return this.colCnt == 1; // we'll likely have space if there's only one day
	},


	/* Dates
	------------------------------------------------------------------------------------------------------------------*/


	rangeUpdated: function() {
		this.updateDayTable();
	},


	// Slices up the given span (unzoned start/end with other misc data) into an array of segments
	spanToSegs: function(span) {
		var segs = this.sliceRangeByRow(span);
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			if (this.isRTL) {
				seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;
				seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;
			}
			else {
				seg.leftCol = seg.firstRowDayIndex;
				seg.rightCol = seg.lastRowDayIndex;
			}
		}

		return segs;
	},


	/* Hit System
	------------------------------------------------------------------------------------------------------------------*/


	prepareHits: function() {
		this.colCoordCache.build();
		this.rowCoordCache.build();
		this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
	},


	releaseHits: function() {
		this.colCoordCache.clear();
		this.rowCoordCache.clear();
	},


	queryHit: function(leftOffset, topOffset) {
		if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {
			var col = this.colCoordCache.getHorizontalIndex(leftOffset);
			var row = this.rowCoordCache.getVerticalIndex(topOffset);

			if (row != null && col != null) {
				return this.getCellHit(row, col);
			}
		}
	},


	getHitSpan: function(hit) {
		return this.getCellRange(hit.row, hit.col);
	},


	getHitEl: function(hit) {
		return this.getCellEl(hit.row, hit.col);
	},


	/* Cell System
	------------------------------------------------------------------------------------------------------------------*/
	// FYI: the first column is the leftmost column, regardless of date


	getCellHit: function(row, col) {
		return {
			row: row,
			col: col,
			component: this, // needed unfortunately :(
			left: this.colCoordCache.getLeftOffset(col),
			right: this.colCoordCache.getRightOffset(col),
			top: this.rowCoordCache.getTopOffset(row),
			bottom: this.rowCoordCache.getBottomOffset(row)
		};
	},


	getCellEl: function(row, col) {
		return this.cellEls.eq(row * this.colCnt + col);
	},


	/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: move to DayGrid.event, similar to what we did with Grid's drag methods


	// Renders a visual indication of an event or external element being dragged.
	// `eventLocation` has zoned start and end (optional)
	renderDrag: function(eventLocation, seg) {
		var eventSpans = this.eventToSpans(eventLocation);
		var i;

		// always render a highlight underneath
		for (i = 0; i < eventSpans.length; i++) {
			this.renderHighlight(eventSpans[i]);
		}

		// if a segment from the same calendar but another component is being dragged, render a helper event
		if (seg && seg.component !== this) {
			return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
		}
	},


	// Unrenders any visual indication of a hovering event
	unrenderDrag: function() {
		this.unrenderHighlight();
		this.unrenderHelper();
	},


	/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event being resized
	renderEventResize: function(eventLocation, seg) {
		var eventSpans = this.eventToSpans(eventLocation);
		var i;

		for (i = 0; i < eventSpans.length; i++) {
			this.renderHighlight(eventSpans[i]);
		}

		return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
	},


	// Unrenders a visual indication of an event being resized
	unrenderEventResize: function() {
		this.unrenderHighlight();
		this.unrenderHelper();
	},


	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a mock "helper" event. `sourceSeg` is the associated internal segment object. It can be null.
	renderHelper: function(event, sourceSeg) {
		var helperNodes = [];
		var segs = this.eventToSegs(event);
		var rowStructs;

		segs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered
		rowStructs = this.renderSegRows(segs);

		// inject each new event skeleton into each associated row
		this.rowEls.each(function(row, rowNode) {
			var rowEl = $(rowNode); // the .fc-row
			var skeletonEl = $('<div class="fc-helper-skeleton"><table/></div>'); // will be absolutely positioned
			var skeletonTop;

			// If there is an original segment, match the top position. Otherwise, put it at the row's top level
			if (sourceSeg && sourceSeg.row === row) {
				skeletonTop = sourceSeg.el.position().top;
			}
			else {
				skeletonTop = rowEl.find('.fc-content-skeleton tbody').position().top;
			}

			skeletonEl.css('top', skeletonTop)
				.find('table')
					.append(rowStructs[row].tbodyEl);

			rowEl.append(skeletonEl);
			helperNodes.push(skeletonEl[0]);
		});

		return ( // must return the elements rendered
			this.helperEls = $(helperNodes) // array -> jQuery set
		);
	},


	// Unrenders any visual indication of a mock helper event
	unrenderHelper: function() {
		if (this.helperEls) {
			this.helperEls.remove();
			this.helperEls = null;
		}
	},


	/* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/


	fillSegTag: 'td', // override the default tag name


	// Renders a set of rectangles over the given segments of days.
	// Only returns segments that successfully rendered.
	renderFill: function(type, segs, className) {
		var nodes = [];
		var i, seg;
		var skeletonEl;

		segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			skeletonEl = this.renderFillRow(type, seg, className);
			this.rowEls.eq(seg.row).append(skeletonEl);
			nodes.push(skeletonEl[0]);
		}

		this.elsByFill[type] = $(nodes);

		return segs;
	},


	// Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
	renderFillRow: function(type, seg, className) {
		var colCnt = this.colCnt;
		var startCol = seg.leftCol;
		var endCol = seg.rightCol + 1;
		var skeletonEl;
		var trEl;

		className = className || type.toLowerCase();

		skeletonEl = $(
			'<div class="fc-' + className + '-skeleton">' +
				'<table><tr/></table>' +
			'</div>'
		);
		trEl = skeletonEl.find('tr');

		if (startCol > 0) {
			trEl.append('<td colspan="' + startCol + '"/>');
		}

		trEl.append(
			seg.el.attr('colspan', endCol - startCol)
		);

		if (endCol < colCnt) {
			trEl.append('<td colspan="' + (colCnt - endCol) + '"/>');
		}

		this.bookendCells(trEl);

		return skeletonEl;
	}

});

;;

/* Event-rendering methods for the DayGrid class
----------------------------------------------------------------------------------------------------------------------*/

DayGrid.mixin({

	rowStructs: null, // an array of objects, each holding information about a row's foreground event-rendering


	// Unrenders all events currently rendered on the grid
	unrenderEvents: function() {
		this.removeSegPopover(); // removes the "more.." events popover
		Grid.prototype.unrenderEvents.apply(this, arguments); // calls the super-method
	},


	// Retrieves all rendered segment objects currently rendered on the grid
	getEventSegs: function() {
		return Grid.prototype.getEventSegs.call(this) // get the segments from the super-method
			.concat(this.popoverSegs || []); // append the segments from the "more..." popover
	},


	// Renders the given background event segments onto the grid
	renderBgSegs: function(segs) {

		// don't render timed background events
		var allDaySegs = $.grep(segs, function(seg) {
			return seg.event.allDay;
		});

		return Grid.prototype.renderBgSegs.call(this, allDaySegs); // call the super-method
	},


	// Renders the given foreground event segments onto the grid
	renderFgSegs: function(segs) {
		var rowStructs;

		// render an `.el` on each seg
		// returns a subset of the segs. segs that were actually rendered
		segs = this.renderFgSegEls(segs);

		rowStructs = this.rowStructs = this.renderSegRows(segs);

		// append to each row's content skeleton
		this.rowEls.each(function(i, rowNode) {
			$(rowNode).find('.fc-content-skeleton > table').append(
				rowStructs[i].tbodyEl
			);
		});

		return segs; // return only the segs that were actually rendered
	},


	// Unrenders all currently rendered foreground event segments
	unrenderFgSegs: function() {
		var rowStructs = this.rowStructs || [];
		var rowStruct;

		while ((rowStruct = rowStructs.pop())) {
			rowStruct.tbodyEl.remove();
		}

		this.rowStructs = null;
	},


	// Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
	// Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
	// PRECONDITION: each segment shoud already have a rendered and assigned `.el`
	renderSegRows: function(segs) {
		var rowStructs = [];
		var segRows;
		var row;

		segRows = this.groupSegRows(segs); // group into nested arrays

		// iterate each row of segment groupings
		for (row = 0; row < segRows.length; row++) {
			rowStructs.push(
				this.renderSegRow(row, segRows[row])
			);
		}

		return rowStructs;
	},


	// Builds the HTML to be used for the default element for an individual segment
	fgSegHtml: function(seg, disableResizing) {
		var view = this.view;
		var event = seg.event;
		var isDraggable = view.isEventDraggable(event);
		var isResizableFromStart = !disableResizing && event.allDay &&
			seg.isStart && view.isEventResizableFromStart(event);
		var isResizableFromEnd = !disableResizing && event.allDay &&
			seg.isEnd && view.isEventResizableFromEnd(event);
		var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
		var skinCss = cssToStr(this.getSegSkinCss(seg));
		var timeHtml = '';
		var timeText;
		var titleHtml;

		classes.unshift('fc-day-grid-event', 'fc-h-event');

		// Only display a timed events time if it is the starting segment
		if (seg.isStart) {
			timeText = this.getEventTimeText(event);
			if (timeText) {
				timeHtml = '<span class="fc-time">' + htmlEscape(timeText) + '</span>';
			}
		}

		titleHtml =
			'<span class="fc-title">' +
				(htmlEscape(event.title || '') || '&nbsp;') + // we always want one line of height
			'</span>';
		
		return '<a class="' + classes.join(' ') + '"' +
				(event.url ?
					' href="' + htmlEscape(event.url) + '"' :
					''
					) +
				(skinCss ?
					' style="' + skinCss + '"' :
					''
					) +
			'>' +
				'<div class="fc-content">' +
					(this.isRTL ?
						titleHtml + ' ' + timeHtml : // put a natural space in between
						timeHtml + ' ' + titleHtml   //
						) +
				'</div>' +
				(isResizableFromStart ?
					'<div class="fc-resizer fc-start-resizer" />' :
					''
					) +
				(isResizableFromEnd ?
					'<div class="fc-resizer fc-end-resizer" />' :
					''
					) +
			'</a>';
	},


	// Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
	// the segments. Returns object with a bunch of internal data about how the render was calculated.
	// NOTE: modifies rowSegs
	renderSegRow: function(row, rowSegs) {
		var colCnt = this.colCnt;
		var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
		var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
		var tbody = $('<tbody/>');
		var segMatrix = []; // lookup for which segments are rendered into which level+col cells
		var cellMatrix = []; // lookup for all <td> elements of the level+col matrix
		var loneCellMatrix = []; // lookup for <td> elements that only take up a single column
		var i, levelSegs;
		var col;
		var tr;
		var j, seg;
		var td;

		// populates empty cells from the current column (`col`) to `endCol`
		function emptyCellsUntil(endCol) {
			while (col < endCol) {
				// try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
				td = (loneCellMatrix[i - 1] || [])[col];
				if (td) {
					td.attr(
						'rowspan',
						parseInt(td.attr('rowspan') || 1, 10) + 1
					);
				}
				else {
					td = $('<td/>');
					tr.append(td);
				}
				cellMatrix[i][col] = td;
				loneCellMatrix[i][col] = td;
				col++;
			}
		}

		for (i = 0; i < levelCnt; i++) { // iterate through all levels
			levelSegs = segLevels[i];
			col = 0;
			tr = $('<tr/>');

			segMatrix.push([]);
			cellMatrix.push([]);
			loneCellMatrix.push([]);

			// levelCnt might be 1 even though there are no actual levels. protect against this.
			// this single empty row is useful for styling.
			if (levelSegs) {
				for (j = 0; j < levelSegs.length; j++) { // iterate through segments in level
					seg = levelSegs[j];

					emptyCellsUntil(seg.leftCol);

					// create a container that occupies or more columns. append the event element.
					td = $('<td class="fc-event-container"/>').append(seg.el);
					if (seg.leftCol != seg.rightCol) {
						td.attr('colspan', seg.rightCol - seg.leftCol + 1);
					}
					else { // a single-column segment
						loneCellMatrix[i][col] = td;
					}

					while (col <= seg.rightCol) {
						cellMatrix[i][col] = td;
						segMatrix[i][col] = seg;
						col++;
					}

					tr.append(td);
				}
			}

			emptyCellsUntil(colCnt); // finish off the row
			this.bookendCells(tr);
			tbody.append(tr);
		}

		return { // a "rowStruct"
			row: row, // the row number
			tbodyEl: tbody,
			cellMatrix: cellMatrix,
			segMatrix: segMatrix,
			segLevels: segLevels,
			segs: rowSegs
		};
	},


	// Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
	// NOTE: modifies segs
	buildSegLevels: function(segs) {
		var levels = [];
		var i, seg;
		var j;

		// Give preference to elements with certain criteria, so they have
		// a chance to be closer to the top.
		this.sortEventSegs(segs);
		
		for (i = 0; i < segs.length; i++) {
			seg = segs[i];

			// loop through levels, starting with the topmost, until the segment doesn't collide with other segments
			for (j = 0; j < levels.length; j++) {
				if (!isDaySegCollision(seg, levels[j])) {
					break;
				}
			}
			// `j` now holds the desired subrow index
			seg.level = j;

			// create new level array if needed and append segment
			(levels[j] || (levels[j] = [])).push(seg);
		}

		// order segments left-to-right. very important if calendar is RTL
		for (j = 0; j < levels.length; j++) {
			levels[j].sort(compareDaySegCols);
		}

		return levels;
	},


	// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
	groupSegRows: function(segs) {
		var segRows = [];
		var i;

		for (i = 0; i < this.rowCnt; i++) {
			segRows.push([]);
		}

		for (i = 0; i < segs.length; i++) {
			segRows[segs[i].row].push(segs[i]);
		}

		return segRows;
	}

});


// Computes whether two segments' columns collide. They are assumed to be in the same row.
function isDaySegCollision(seg, otherSegs) {
	var i, otherSeg;

	for (i = 0; i < otherSegs.length; i++) {
		otherSeg = otherSegs[i];

		if (
			otherSeg.leftCol <= seg.rightCol &&
			otherSeg.rightCol >= seg.leftCol
		) {
			return true;
		}
	}

	return false;
}


// A cmp function for determining the leftmost event
function compareDaySegCols(a, b) {
	return a.leftCol - b.leftCol;
}

;;

/* Methods relate to limiting the number events for a given day on a DayGrid
----------------------------------------------------------------------------------------------------------------------*/
// NOTE: all the segs being passed around in here are foreground segs

DayGrid.mixin({

	segPopover: null, // the Popover that holds events that can't fit in a cell. null when not visible
	popoverSegs: null, // an array of segment objects that the segPopover holds. null when not visible


	removeSegPopover: function() {
		if (this.segPopover) {
			this.segPopover.hide(); // in handler, will call segPopover's removeElement
		}
	},


	// Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
	// `levelLimit` can be false (don't limit), a number, or true (should be computed).
	limitRows: function(levelLimit) {
		var rowStructs = this.rowStructs || [];
		var row; // row #
		var rowLevelLimit;

		for (row = 0; row < rowStructs.length; row++) {
			this.unlimitRow(row);

			if (!levelLimit) {
				rowLevelLimit = false;
			}
			else if (typeof levelLimit === 'number') {
				rowLevelLimit = levelLimit;
			}
			else {
				rowLevelLimit = this.computeRowLevelLimit(row);
			}

			if (rowLevelLimit !== false) {
				this.limitRow(row, rowLevelLimit);
			}
		}
	},


	// Computes the number of levels a row will accomodate without going outside its bounds.
	// Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
	// `row` is the row number.
	computeRowLevelLimit: function(row) {
		var rowEl = this.rowEls.eq(row); // the containing "fake" row div
		var rowHeight = rowEl.height(); // TODO: cache somehow?
		var trEls = this.rowStructs[row].tbodyEl.children();
		var i, trEl;
		var trHeight;

		function iterInnerHeights(i, childNode) {
			trHeight = Math.max(trHeight, $(childNode).outerHeight());
		}

		// Reveal one level <tr> at a time and stop when we find one out of bounds
		for (i = 0; i < trEls.length; i++) {
			trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)

			// with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,
			// so instead, find the tallest inner content element.
			trHeight = 0;
			trEl.find('> td > :first-child').each(iterInnerHeights);

			if (trEl.position().top + trHeight > rowHeight) {
				return i;
			}
		}

		return false; // should not limit at all
	},


	// Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
	// `row` is the row number.
	// `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
	limitRow: function(row, levelLimit) {
		var _this = this;
		var rowStruct = this.rowStructs[row];
		var moreNodes = []; // array of "more" <a> links and <td> DOM nodes
		var col = 0; // col #, left-to-right (not chronologically)
		var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
		var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row
		var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes
		var i, seg;
		var segsBelow; // array of segment objects below `seg` in the current `col`
		var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
		var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)
		var td, rowspan;
		var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell
		var j;
		var moreTd, moreWrap, moreLink;

		// Iterates through empty level cells and places "more" links inside if need be
		function emptyCellsUntil(endCol) { // goes from current `col` to `endCol`
			while (col < endCol) {
				segsBelow = _this.getCellSegs(row, col, levelLimit);
				if (segsBelow.length) {
					td = cellMatrix[levelLimit - 1][col];
					moreLink = _this.renderMoreLink(row, col, segsBelow);
					moreWrap = $('<div/>').append(moreLink);
					td.append(moreWrap);
					moreNodes.push(moreWrap[0]);
				}
				col++;
			}
		}

		if (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?
			levelSegs = rowStruct.segLevels[levelLimit - 1];
			cellMatrix = rowStruct.cellMatrix;

			limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit
				.addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array

			// iterate though segments in the last allowable level
			for (i = 0; i < levelSegs.length; i++) {
				seg = levelSegs[i];
				emptyCellsUntil(seg.leftCol); // process empty cells before the segment

				// determine *all* segments below `seg` that occupy the same columns
				colSegsBelow = [];
				totalSegsBelow = 0;
				while (col <= seg.rightCol) {
					segsBelow = this.getCellSegs(row, col, levelLimit);
					colSegsBelow.push(segsBelow);
					totalSegsBelow += segsBelow.length;
					col++;
				}

				if (totalSegsBelow) { // do we need to replace this segment with one or many "more" links?
					td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell
					rowspan = td.attr('rowspan') || 1;
					segMoreNodes = [];

					// make a replacement <td> for each column the segment occupies. will be one for each colspan
					for (j = 0; j < colSegsBelow.length; j++) {
						moreTd = $('<td class="fc-more-cell"/>').attr('rowspan', rowspan);
						segsBelow = colSegsBelow[j];
						moreLink = this.renderMoreLink(
							row,
							seg.leftCol + j,
							[ seg ].concat(segsBelow) // count seg as hidden too
						);
						moreWrap = $('<div/>').append(moreLink);
						moreTd.append(moreWrap);
						segMoreNodes.push(moreTd[0]);
						moreNodes.push(moreTd[0]);
					}

					td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements
					limitedNodes.push(td[0]);
				}
			}

			emptyCellsUntil(this.colCnt); // finish off the level
			rowStruct.moreEls = $(moreNodes); // for easy undoing later
			rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
		}
	},


	// Reveals all levels and removes all "more"-related elements for a grid's row.
	// `row` is a row number.
	unlimitRow: function(row) {
		var rowStruct = this.rowStructs[row];

		if (rowStruct.moreEls) {
			rowStruct.moreEls.remove();
			rowStruct.moreEls = null;
		}

		if (rowStruct.limitedEls) {
			rowStruct.limitedEls.removeClass('fc-limited');
			rowStruct.limitedEls = null;
		}
	},


	// Renders an <a> element that represents hidden event element for a cell.
	// Responsible for attaching click handler as well.
	renderMoreLink: function(row, col, hiddenSegs) {
		var _this = this;
		var view = this.view;

		return $('<a class="fc-more"/>')
			.text(
				this.getMoreLinkText(hiddenSegs.length)
			)
			.on('click', function(ev) {
				var clickOption = view.opt('eventLimitClick');
				var date = _this.getCellDate(row, col);
				var moreEl = $(this);
				var dayEl = _this.getCellEl(row, col);
				var allSegs = _this.getCellSegs(row, col);

				// rescope the segments to be within the cell's date
				var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
				var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);

				if (typeof clickOption === 'function') {
					// the returned value can be an atomic option
					clickOption = view.publiclyTrigger('eventLimitClick', null, {
						date: date,
						dayEl: dayEl,
						moreEl: moreEl,
						segs: reslicedAllSegs,
						hiddenSegs: reslicedHiddenSegs
					}, ev);
				}

				if (clickOption === 'popover') {
					_this.showSegPopover(row, col, moreEl, reslicedAllSegs);
				}
				else if (typeof clickOption === 'string') { // a view name
					view.calendar.zoomTo(date, clickOption);
				}
			});
	},


	// Reveals the popover that displays all events within a cell
	showSegPopover: function(row, col, moreLink, segs) {
		var _this = this;
		var view = this.view;
		var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>
		var topEl; // the element we want to match the top coordinate of
		var options;

		if (this.rowCnt == 1) {
			topEl = view.el; // will cause the popover to cover any sort of header
		}
		else {
			topEl = this.rowEls.eq(row); // will align with top of row
		}

		options = {
			className: 'fc-more-popover',
			content: this.renderSegPopoverContent(row, col, segs),
			parentEl: this.view.el, // attach to root of view. guarantees outside of scrollbars.
			top: topEl.offset().top,
			autoHide: true, // when the user clicks elsewhere, hide the popover
			viewportConstrain: view.opt('popoverViewportConstrain'),
			hide: function() {
				// kill everything when the popover is hidden
				// notify events to be removed
				if (_this.popoverSegs) {
					var seg;
					for (var i = 0; i < _this.popoverSegs.length; ++i) {
						seg = _this.popoverSegs[i];
						view.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);
					}
				}
				_this.segPopover.removeElement();
				_this.segPopover = null;
				_this.popoverSegs = null;
			}
		};

		// Determine horizontal coordinate.
		// We use the moreWrap instead of the <td> to avoid border confusion.
		if (this.isRTL) {
			options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
		}
		else {
			options.left = moreWrap.offset().left - 1; // -1 to be over cell border
		}

		this.segPopover = new Popover(options);
		this.segPopover.show();

		// the popover doesn't live within the grid's container element, and thus won't get the event
		// delegated-handlers for free. attach event-related handlers to the popover.
		this.bindSegHandlersToEl(this.segPopover.el);
	},


	// Builds the inner DOM contents of the segment popover
	renderSegPopoverContent: function(row, col, segs) {
		var view = this.view;
		var isTheme = view.opt('theme');
		var title = this.getCellDate(row, col).format(view.opt('dayPopoverFormat'));
		var content = $(
			'<div class="fc-header ' + view.widgetHeaderClass + '">' +
				'<span class="fc-close ' +
					(isTheme ? 'ui-icon ui-icon-closethick' : 'fc-icon fc-icon-x') +
				'"></span>' +
				'<span class="fc-title">' +
					htmlEscape(title) +
				'</span>' +
				'<div class="fc-clear"/>' +
			'</div>' +
			'<div class="fc-body ' + view.widgetContentClass + '">' +
				'<div class="fc-event-container"></div>' +
			'</div>'
		);
		var segContainer = content.find('.fc-event-container');
		var i;

		// render each seg's `el` and only return the visible segs
		segs = this.renderFgSegEls(segs, true); // disableResizing=true
		this.popoverSegs = segs;

		for (i = 0; i < segs.length; i++) {

			// because segments in the popover are not part of a grid coordinate system, provide a hint to any
			// grids that want to do drag-n-drop about which cell it came from
			this.hitsNeeded();
			segs[i].hit = this.getCellHit(row, col);
			this.hitsNotNeeded();

			segContainer.append(segs[i].el);
		}

		return content;
	},


	// Given the events within an array of segment objects, reslice them to be in a single day
	resliceDaySegs: function(segs, dayDate) {

		// build an array of the original events
		var events = $.map(segs, function(seg) {
			return seg.event;
		});

		var dayStart = dayDate.clone();
		var dayEnd = dayStart.clone().add(1, 'days');
		var dayRange = { start: dayStart, end: dayEnd };

		// slice the events with a custom slicing function
		segs = this.eventsToSegs(
			events,
			function(range) {
				var seg = intersectRanges(range, dayRange); // undefind if no intersection
				return seg ? [ seg ] : []; // must return an array of segments
			}
		);

		// force an order because eventsToSegs doesn't guarantee one
		this.sortEventSegs(segs);

		return segs;
	},


	// Generates the text that should be inside a "more" link, given the number of events it represents
	getMoreLinkText: function(num) {
		var opt = this.view.opt('eventLimitText');

		if (typeof opt === 'function') {
			return opt(num);
		}
		else {
			return '+' + num + ' ' + opt;
		}
	},


	// Returns segments within a given cell.
	// If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
	getCellSegs: function(row, col, startLevel) {
		var segMatrix = this.rowStructs[row].segMatrix;
		var level = startLevel || 0;
		var segs = [];
		var seg;

		while (level < segMatrix.length) {
			seg = segMatrix[level][col];
			if (seg) {
				segs.push(seg);
			}
			level++;
		}

		return segs;
	}

});

;;

/* A component that renders one or more columns of vertical time slots
----------------------------------------------------------------------------------------------------------------------*/
// We mixin DayTable, even though there is only a single row of days

var TimeGrid = FC.TimeGrid = Grid.extend(DayTableMixin, {

	slotDuration: null, // duration of a "slot", a distinct time segment on given day, visualized by lines
	snapDuration: null, // granularity of time for dragging and selecting
	snapsPerSlot: null,
	labelFormat: null, // formatting string for times running along vertical axis
	labelInterval: null, // duration of how often a label should be displayed for a slot

	colEls: null, // cells elements in the day-row background
	slatContainerEl: null, // div that wraps all the slat rows
	slatEls: null, // elements running horizontally across all columns
	nowIndicatorEls: null,

	colCoordCache: null,
	slatCoordCache: null,


	constructor: function() {
		Grid.apply(this, arguments); // call the super-constructor

		this.processOptions();
	},


	// Renders the time grid into `this.el`, which should already be assigned.
	// Relies on the view's colCnt. In the future, this component should probably be self-sufficient.
	renderDates: function() {
		this.el.html(this.renderHtml());
		this.colEls = this.el.find('.fc-day, .fc-disabled-day');
		this.slatContainerEl = this.el.find('.fc-slats');
		this.slatEls = this.slatContainerEl.find('tr');

		this.colCoordCache = new CoordCache({
			els: this.colEls,
			isHorizontal: true
		});
		this.slatCoordCache = new CoordCache({
			els: this.slatEls,
			isVertical: true
		});

		this.renderContentSkeleton();
	},


	// Renders the basic HTML skeleton for the grid
	renderHtml: function() {
		return '' +
			'<div class="fc-bg">' +
				'<table>' +
					this.renderBgTrHtml(0) + // row=0
				'</table>' +
			'</div>' +
			'<div class="fc-slats">' +
				'<table>' +
					this.renderSlatRowHtml() +
				'</table>' +
			'</div>';
	},


	// Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
	renderSlatRowHtml: function() {
		var view = this.view;
		var isRTL = this.isRTL;
		var html = '';
		var slotTime = moment.duration(+this.view.minTime); // wish there was .clone() for durations
		var slotDate; // will be on the view's first day, but we only care about its time
		var isLabeled;
		var axisHtml;

		// Calculate the time for each slot
		while (slotTime < this.view.maxTime) {
			slotDate = this.start.clone().time(slotTime);
			isLabeled = isInt(divideDurationByDuration(slotTime, this.labelInterval));

			axisHtml =
				'<td class="fc-axis fc-time ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' +
					(isLabeled ?
						'<span>' + // for matchCellWidths
							htmlEscape(slotDate.format(this.labelFormat)) +
						'</span>' :
						''
						) +
				'</td>';

			html +=
				'<tr data-time="' + slotDate.format('HH:mm:ss') + '"' +
					(isLabeled ? '' : ' class="fc-minor"') +
					'>' +
					(!isRTL ? axisHtml : '') +
					'<td class="' + view.widgetContentClass + '"/>' +
					(isRTL ? axisHtml : '') +
				"</tr>";

			slotTime.add(this.slotDuration);
		}

		return html;
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Parses various options into properties of this object
	processOptions: function() {
		var view = this.view;
		var slotDuration = view.opt('slotDuration');
		var snapDuration = view.opt('snapDuration');
		var input;

		slotDuration = moment.duration(slotDuration);
		snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;

		this.slotDuration = slotDuration;
		this.snapDuration = snapDuration;
		this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?

		this.minResizeDuration = snapDuration; // hack

		// might be an array value (for TimelineView).
		// if so, getting the most granular entry (the last one probably).
		input = view.opt('slotLabelFormat');
		if ($.isArray(input)) {
			input = input[input.length - 1];
		}

		this.labelFormat =
			input ||
			view.opt('smallTimeFormat'); // the computed default

		input = view.opt('slotLabelInterval');
		this.labelInterval = input ?
			moment.duration(input) :
			this.computeLabelInterval(slotDuration);
	},


	// Computes an automatic value for slotLabelInterval
	computeLabelInterval: function(slotDuration) {
		var i;
		var labelInterval;
		var slotsPerLabel;

		// find the smallest stock label interval that results in more than one slots-per-label
		for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
			labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
			slotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);
			if (isInt(slotsPerLabel) && slotsPerLabel > 1) {
				return labelInterval;
			}
		}

		return moment.duration(slotDuration); // fall back. clone
	},


	// Computes a default event time formatting string if `timeFormat` is not explicitly defined
	computeEventTimeFormat: function() {
		return this.view.opt('noMeridiemTimeFormat'); // like "6:30" (no AM/PM)
	},


	// Computes a default `displayEventEnd` value if one is not expliclty defined
	computeDisplayEventEnd: function() {
		return true;
	},


	/* Hit System
	------------------------------------------------------------------------------------------------------------------*/


	prepareHits: function() {
		this.colCoordCache.build();
		this.slatCoordCache.build();
	},


	releaseHits: function() {
		this.colCoordCache.clear();
		// NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop
	},


	queryHit: function(leftOffset, topOffset) {
		var snapsPerSlot = this.snapsPerSlot;
		var colCoordCache = this.colCoordCache;
		var slatCoordCache = this.slatCoordCache;

		if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {
			var colIndex = colCoordCache.getHorizontalIndex(leftOffset);
			var slatIndex = slatCoordCache.getVerticalIndex(topOffset);

			if (colIndex != null && slatIndex != null) {
				var slatTop = slatCoordCache.getTopOffset(slatIndex);
				var slatHeight = slatCoordCache.getHeight(slatIndex);
				var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1
				var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
				var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
				var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;
				var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;

				return {
					col: colIndex,
					snap: snapIndex,
					component: this, // needed unfortunately :(
					left: colCoordCache.getLeftOffset(colIndex),
					right: colCoordCache.getRightOffset(colIndex),
					top: snapTop,
					bottom: snapBottom
				};
			}
		}
	},


	getHitSpan: function(hit) {
		var start = this.getCellDate(0, hit.col); // row=0
		var time = this.computeSnapTime(hit.snap); // pass in the snap-index
		var end;

		start.time(time);
		end = start.clone().add(this.snapDuration);

		return { start: start, end: end };
	},


	getHitEl: function(hit) {
		return this.colEls.eq(hit.col);
	},


	/* Dates
	------------------------------------------------------------------------------------------------------------------*/


	rangeUpdated: function() {
		this.updateDayTable();
	},


	// Given a row number of the grid, representing a "snap", returns a time (Duration) from its start-of-day
	computeSnapTime: function(snapIndex) {
		return moment.duration(this.view.minTime + this.snapDuration * snapIndex);
	},


	// Slices up the given span (unzoned start/end with other misc data) into an array of segments
	spanToSegs: function(span) {
		var segs = this.sliceRangeByTimes(span);
		var i;

		for (i = 0; i < segs.length; i++) {
			if (this.isRTL) {
				segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;
			}
			else {
				segs[i].col = segs[i].dayIndex;
			}
		}

		return segs;
	},


	sliceRangeByTimes: function(range) {
		var segs = [];
		var seg;
		var dayIndex;
		var dayDate;
		var dayRange;

		for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {
			dayDate = this.dayDates[dayIndex].clone().time(0); // TODO: better API for this?
			dayRange = {
				start: dayDate.clone().add(this.view.minTime), // don't use .time() because it sux with negatives
				end: dayDate.clone().add(this.view.maxTime)
			};
			seg = intersectRanges(range, dayRange); // both will be ambig timezone
			if (seg) {
				seg.dayIndex = dayIndex;
				segs.push(seg);
			}
		}

		return segs;
	},


	/* Coordinates
	------------------------------------------------------------------------------------------------------------------*/


	updateSize: function(isResize) { // NOT a standard Grid method
		this.slatCoordCache.build();

		if (isResize) {
			this.updateSegVerticals(
				[].concat(this.fgSegs || [], this.bgSegs || [], this.businessSegs || [])
			);
		}
	},


	getTotalSlatHeight: function() {
		return this.slatContainerEl.outerHeight();
	},


	// Computes the top coordinate, relative to the bounds of the grid, of the given date.
	// A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
	computeDateTop: function(date, startOfDayDate) {
		return this.computeTimeTop(
			moment.duration(
				date - startOfDayDate.clone().stripTime()
			)
		);
	},


	// Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
	computeTimeTop: function(time) {
		var len = this.slatEls.length;
		var slatCoverage = (time - this.view.minTime) / this.slotDuration; // floating-point value of # of slots covered
		var slatIndex;
		var slatRemainder;

		// compute a floating-point number for how many slats should be progressed through.
		// from 0 to number of slats (inclusive)
		// constrained because minTime/maxTime might be customized.
		slatCoverage = Math.max(0, slatCoverage);
		slatCoverage = Math.min(len, slatCoverage);

		// an integer index of the furthest whole slat
		// from 0 to number slats (*exclusive*, so len-1)
		slatIndex = Math.floor(slatCoverage);
		slatIndex = Math.min(slatIndex, len - 1);

		// how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
		// could be 1.0 if slatCoverage is covering *all* the slots
		slatRemainder = slatCoverage - slatIndex;

		return this.slatCoordCache.getTopPosition(slatIndex) +
			this.slatCoordCache.getHeight(slatIndex) * slatRemainder;
	},



	/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event being dragged over the specified date(s).
	// A returned value of `true` signals that a mock "helper" event has been rendered.
	renderDrag: function(eventLocation, seg) {
		var eventSpans;
		var i;

		if (seg) { // if there is event information for this drag, render a helper event

			// returns mock event elements
			// signal that a helper has been rendered
			return this.renderEventLocationHelper(eventLocation, seg);
		}
		else { // otherwise, just render a highlight
			eventSpans = this.eventToSpans(eventLocation);

			for (i = 0; i < eventSpans.length; i++) {
				this.renderHighlight(eventSpans[i]);
			}
		}
	},


	// Unrenders any visual indication of an event being dragged
	unrenderDrag: function() {
		this.unrenderHelper();
		this.unrenderHighlight();
	},


	/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event being resized
	renderEventResize: function(eventLocation, seg) {
		return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
	},


	// Unrenders any visual indication of an event being resized
	unrenderEventResize: function() {
		this.unrenderHelper();
	},


	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a mock "helper" event. `sourceSeg` is the original segment object and might be null (an external drag)
	renderHelper: function(event, sourceSeg) {
		return this.renderHelperSegs(this.eventToSegs(event), sourceSeg); // returns mock event elements
	},


	// Unrenders any mock helper event
	unrenderHelper: function() {
		this.unrenderHelperSegs();
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessHours: function() {
		this.renderBusinessSegs(
			this.buildBusinessHourSegs()
		);
	},


	unrenderBusinessHours: function() {
		this.unrenderBusinessSegs();
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	getNowIndicatorUnit: function() {
		return 'minute'; // will refresh on the minute
	},


	renderNowIndicator: function(date) {
		// seg system might be overkill, but it handles scenario where line needs to be rendered
		//  more than once because of columns with the same date (resources columns for example)
		var segs = this.spanToSegs({ start: date, end: date });
		var top = this.computeDateTop(date, date);
		var nodes = [];
		var i;

		// render lines within the columns
		for (i = 0; i < segs.length; i++) {
			nodes.push($('<div class="fc-now-indicator fc-now-indicator-line"></div>')
				.css('top', top)
				.appendTo(this.colContainerEls.eq(segs[i].col))[0]);
		}

		// render an arrow over the axis
		if (segs.length > 0) { // is the current time in view?
			nodes.push($('<div class="fc-now-indicator fc-now-indicator-arrow"></div>')
				.css('top', top)
				.appendTo(this.el.find('.fc-content-skeleton'))[0]);
		}

		this.nowIndicatorEls = $(nodes);
	},


	unrenderNowIndicator: function() {
		if (this.nowIndicatorEls) {
			this.nowIndicatorEls.remove();
			this.nowIndicatorEls = null;
		}
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
	renderSelection: function(span) {
		if (this.view.opt('selectHelper')) { // this setting signals that a mock helper event should be rendered

			// normally acceps an eventLocation, span has a start/end, which is good enough
			this.renderEventLocationHelper(span);
		}
		else {
			this.renderHighlight(span);
		}
	},


	// Unrenders any visual indication of a selection
	unrenderSelection: function() {
		this.unrenderHelper();
		this.unrenderHighlight();
	},


	/* Highlight
	------------------------------------------------------------------------------------------------------------------*/


	renderHighlight: function(span) {
		this.renderHighlightSegs(this.spanToSegs(span));
	},


	unrenderHighlight: function() {
		this.unrenderHighlightSegs();
	}

});

;;

/* Methods for rendering SEGMENTS, pieces of content that live on the view
 ( this file is no longer just for events )
----------------------------------------------------------------------------------------------------------------------*/

TimeGrid.mixin({

	colContainerEls: null, // containers for each column

	// inner-containers for each column where different types of segs live
	fgContainerEls: null,
	bgContainerEls: null,
	helperContainerEls: null,
	highlightContainerEls: null,
	businessContainerEls: null,

	// arrays of different types of displayed segments
	fgSegs: null,
	bgSegs: null,
	helperSegs: null,
	highlightSegs: null,
	businessSegs: null,


	// Renders the DOM that the view's content will live in
	renderContentSkeleton: function() {
		var cellHtml = '';
		var i;
		var skeletonEl;

		for (i = 0; i < this.colCnt; i++) {
			cellHtml +=
				'<td>' +
					'<div class="fc-content-col">' +
						'<div class="fc-event-container fc-helper-container"></div>' +
						'<div class="fc-event-container"></div>' +
						'<div class="fc-highlight-container"></div>' +
						'<div class="fc-bgevent-container"></div>' +
						'<div class="fc-business-container"></div>' +
					'</div>' +
				'</td>';
		}

		skeletonEl = $(
			'<div class="fc-content-skeleton">' +
				'<table>' +
					'<tr>' + cellHtml + '</tr>' +
				'</table>' +
			'</div>'
		);

		this.colContainerEls = skeletonEl.find('.fc-content-col');
		this.helperContainerEls = skeletonEl.find('.fc-helper-container');
		this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');
		this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');
		this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');
		this.businessContainerEls = skeletonEl.find('.fc-business-container');

		this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level
		this.el.append(skeletonEl);
	},


	/* Foreground Events
	------------------------------------------------------------------------------------------------------------------*/


	renderFgSegs: function(segs) {
		segs = this.renderFgSegsIntoContainers(segs, this.fgContainerEls);
		this.fgSegs = segs;
		return segs; // needed for Grid::renderEvents
	},


	unrenderFgSegs: function() {
		this.unrenderNamedSegs('fgSegs');
	},


	/* Foreground Helper Events
	------------------------------------------------------------------------------------------------------------------*/


	renderHelperSegs: function(segs, sourceSeg) {
		var helperEls = [];
		var i, seg;
		var sourceEl;

		segs = this.renderFgSegsIntoContainers(segs, this.helperContainerEls);

		// Try to make the segment that is in the same row as sourceSeg look the same
		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			if (sourceSeg && sourceSeg.col === seg.col) {
				sourceEl = sourceSeg.el;
				seg.el.css({
					left: sourceEl.css('left'),
					right: sourceEl.css('right'),
					'margin-left': sourceEl.css('margin-left'),
					'margin-right': sourceEl.css('margin-right')
				});
			}
			helperEls.push(seg.el[0]);
		}

		this.helperSegs = segs;

		return $(helperEls); // must return rendered helpers
	},


	unrenderHelperSegs: function() {
		this.unrenderNamedSegs('helperSegs');
	},


	/* Background Events
	------------------------------------------------------------------------------------------------------------------*/


	renderBgSegs: function(segs) {
		segs = this.renderFillSegEls('bgEvent', segs); // TODO: old fill system
		this.updateSegVerticals(segs);
		this.attachSegsByCol(this.groupSegsByCol(segs), this.bgContainerEls);
		this.bgSegs = segs;
		return segs; // needed for Grid::renderEvents
	},


	unrenderBgSegs: function() {
		this.unrenderNamedSegs('bgSegs');
	},


	/* Highlight
	------------------------------------------------------------------------------------------------------------------*/


	renderHighlightSegs: function(segs) {
		segs = this.renderFillSegEls('highlight', segs); // TODO: old fill system
		this.updateSegVerticals(segs);
		this.attachSegsByCol(this.groupSegsByCol(segs), this.highlightContainerEls);
		this.highlightSegs = segs;
	},


	unrenderHighlightSegs: function() {
		this.unrenderNamedSegs('highlightSegs');
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessSegs: function(segs) {
		segs = this.renderFillSegEls('businessHours', segs); // TODO: old fill system
		this.updateSegVerticals(segs);
		this.attachSegsByCol(this.groupSegsByCol(segs), this.businessContainerEls);
		this.businessSegs = segs;
	},


	unrenderBusinessSegs: function() {
		this.unrenderNamedSegs('businessSegs');
	},


	/* Seg Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
	groupSegsByCol: function(segs) {
		var segsByCol = [];
		var i;

		for (i = 0; i < this.colCnt; i++) {
			segsByCol.push([]);
		}

		for (i = 0; i < segs.length; i++) {
			segsByCol[segs[i].col].push(segs[i]);
		}

		return segsByCol;
	},


	// Given segments grouped by column, insert the segments' elements into a parallel array of container
	// elements, each living within a column.
	attachSegsByCol: function(segsByCol, containerEls) {
		var col;
		var segs;
		var i;

		for (col = 0; col < this.colCnt; col++) { // iterate each column grouping
			segs = segsByCol[col];

			for (i = 0; i < segs.length; i++) {
				containerEls.eq(col).append(segs[i].el);
			}
		}
	},


	// Given the name of a property of `this` object, assumed to be an array of segments,
	// loops through each segment and removes from DOM. Will null-out the property afterwards.
	unrenderNamedSegs: function(propName) {
		var segs = this[propName];
		var i;

		if (segs) {
			for (i = 0; i < segs.length; i++) {
				segs[i].el.remove();
			}
			this[propName] = null;
		}
	},



	/* Foreground Event Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Given an array of foreground segments, render a DOM element for each, computes position,
	// and attaches to the column inner-container elements.
	renderFgSegsIntoContainers: function(segs, containerEls) {
		var segsByCol;
		var col;

		segs = this.renderFgSegEls(segs); // will call fgSegHtml
		segsByCol = this.groupSegsByCol(segs);

		for (col = 0; col < this.colCnt; col++) {
			this.updateFgSegCoords(segsByCol[col]);
		}

		this.attachSegsByCol(segsByCol, containerEls);

		return segs;
	},


	// Renders the HTML for a single event segment's default rendering
	fgSegHtml: function(seg, disableResizing) {
		var view = this.view;
		var event = seg.event;
		var isDraggable = view.isEventDraggable(event);
		var isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);
		var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);
		var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
		var skinCss = cssToStr(this.getSegSkinCss(seg));
		var timeText;
		var fullTimeText; // more verbose time text. for the print stylesheet
		var startTimeText; // just the start time text

		classes.unshift('fc-time-grid-event', 'fc-v-event');

		if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day...
			// Don't display time text on segments that run entirely through a day.
			// That would appear as midnight-midnight and would look dumb.
			// Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
			if (seg.isStart || seg.isEnd) {
				timeText = this.getEventTimeText(seg);
				fullTimeText = this.getEventTimeText(seg, 'LT');
				startTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false
			}
		} else {
			// Display the normal time text for the *event's* times
			timeText = this.getEventTimeText(event);
			fullTimeText = this.getEventTimeText(event, 'LT');
			startTimeText = this.getEventTimeText(event, null, false); // displayEnd=false
		}

		return '<a class="' + classes.join(' ') + '"' +
			(event.url ?
				' href="' + htmlEscape(event.url) + '"' :
				''
				) +
			(skinCss ?
				' style="' + skinCss + '"' :
				''
				) +
			'>' +
				'<div class="fc-content">' +
					(timeText ?
						'<div class="fc-time"' +
						' data-start="' + htmlEscape(startTimeText) + '"' +
						' data-full="' + htmlEscape(fullTimeText) + '"' +
						'>' +
							'<span>' + htmlEscape(timeText) + '</span>' +
						'</div>' :
						''
						) +
					(event.title ?
						'<div class="fc-title">' +
							htmlEscape(event.title) +
						'</div>' :
						''
						) +
				'</div>' +
				'<div class="fc-bg"/>' +
				/* TODO: write CSS for this
				(isResizableFromStart ?
					'<div class="fc-resizer fc-start-resizer" />' :
					''
					) +
				*/
				(isResizableFromEnd ?
					'<div class="fc-resizer fc-end-resizer" />' :
					''
					) +
			'</a>';
	},


	/* Seg Position Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Refreshes the CSS top/bottom coordinates for each segment element.
	// Works when called after initial render, after a window resize/zoom for example.
	updateSegVerticals: function(segs) {
		this.computeSegVerticals(segs);
		this.assignSegVerticals(segs);
	},


	// For each segment in an array, computes and assigns its top and bottom properties
	computeSegVerticals: function(segs) {
		var i, seg;
		var dayDate;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			dayDate = this.dayDates[seg.dayIndex];

			seg.top = this.computeDateTop(seg.start, dayDate);
			seg.bottom = this.computeDateTop(seg.end, dayDate);
		}
	},


	// Given segments that already have their top/bottom properties computed, applies those values to
	// the segments' elements.
	assignSegVerticals: function(segs) {
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			seg.el.css(this.generateSegVerticalCss(seg));
		}
	},


	// Generates an object with CSS properties for the top/bottom coordinates of a segment element
	generateSegVerticalCss: function(seg) {
		return {
			top: seg.top,
			bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
		};
	},


	/* Foreground Event Positioning Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Given segments that are assumed to all live in the *same column*,
	// compute their verical/horizontal coordinates and assign to their elements.
	updateFgSegCoords: function(segs) {
		this.computeSegVerticals(segs); // horizontals relies on this
		this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array
		this.assignSegVerticals(segs);
		this.assignFgSegHorizontals(segs);
	},


	// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
	// NOTE: Also reorders the given array by date!
	computeFgSegHorizontals: function(segs) {
		var levels;
		var level0;
		var i;

		this.sortEventSegs(segs); // order by certain criteria
		levels = buildSlotSegLevels(segs);
		computeForwardSlotSegs(levels);

		if ((level0 = levels[0])) {

			for (i = 0; i < level0.length; i++) {
				computeSlotSegPressures(level0[i]);
			}

			for (i = 0; i < level0.length; i++) {
				this.computeFgSegForwardBack(level0[i], 0, 0);
			}
		}
	},


	// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
	// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
	// seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
	//
	// The segment might be part of a "series", which means consecutive segments with the same pressure
	// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
	// segments behind this one in the current series, and `seriesBackwardCoord` is the starting
	// coordinate of the first segment in the series.
	computeFgSegForwardBack: function(seg, seriesBackwardPressure, seriesBackwardCoord) {
		var forwardSegs = seg.forwardSegs;
		var i;

		if (seg.forwardCoord === undefined) { // not already computed

			if (!forwardSegs.length) {

				// if there are no forward segments, this segment should butt up against the edge
				seg.forwardCoord = 1;
			}
			else {

				// sort highest pressure first
				this.sortForwardSegs(forwardSegs);

				// this segment's forwardCoord will be calculated from the backwardCoord of the
				// highest-pressure forward segment.
				this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
				seg.forwardCoord = forwardSegs[0].backwardCoord;
			}

			// calculate the backwardCoord from the forwardCoord. consider the series
			seg.backwardCoord = seg.forwardCoord -
				(seg.forwardCoord - seriesBackwardCoord) / // available width for series
				(seriesBackwardPressure + 1); // # of segments in the series

			// use this segment's coordinates to computed the coordinates of the less-pressurized
			// forward segments
			for (i=0; i<forwardSegs.length; i++) {
				this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
			}
		}
	},


	sortForwardSegs: function(forwardSegs) {
		forwardSegs.sort(proxy(this, 'compareForwardSegs'));
	},


	// A cmp function for determining which forward segment to rely on more when computing coordinates.
	compareForwardSegs: function(seg1, seg2) {
		// put higher-pressure first
		return seg2.forwardPressure - seg1.forwardPressure ||
			// put segments that are closer to initial edge first (and favor ones with no coords yet)
			(seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
			// do normal sorting...
			this.compareEventSegs(seg1, seg2);
	},


	// Given foreground event segments that have already had their position coordinates computed,
	// assigns position-related CSS values to their elements.
	assignFgSegHorizontals: function(segs) {
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			seg.el.css(this.generateFgSegHorizontalCss(seg));

			// if the height is short, add a className for alternate styling
			if (seg.bottom - seg.top < 30) {
				seg.el.addClass('fc-short');
			}
		}
	},


	// Generates an object with CSS properties/values that should be applied to an event segment element.
	// Contains important positioning-related properties that should be applied to any event element, customized or not.
	generateFgSegHorizontalCss: function(seg) {
		var shouldOverlap = this.view.opt('slotEventOverlap');
		var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
		var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
		var props = this.generateSegVerticalCss(seg); // get top/bottom first
		var left; // amount of space from left edge, a fraction of the total width
		var right; // amount of space from right edge, a fraction of the total width

		if (shouldOverlap) {
			// double the width, but don't go beyond the maximum forward coordinate (1.0)
			forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
		}

		if (this.isRTL) {
			left = 1 - forwardCoord;
			right = backwardCoord;
		}
		else {
			left = backwardCoord;
			right = 1 - forwardCoord;
		}

		props.zIndex = seg.level + 1; // convert from 0-base to 1-based
		props.left = left * 100 + '%';
		props.right = right * 100 + '%';

		if (shouldOverlap && seg.forwardPressure) {
			// add padding to the edge so that forward stacked events don't cover the resizer's icon
			props[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
		}

		return props;
	}

});


// Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
function buildSlotSegLevels(segs) {
	var levels = [];
	var i, seg;
	var j;

	for (i=0; i<segs.length; i++) {
		seg = segs[i];

		// go through all the levels and stop on the first level where there are no collisions
		for (j=0; j<levels.length; j++) {
			if (!computeSlotSegCollisions(seg, levels[j]).length) {
				break;
			}
		}

		seg.level = j;

		(levels[j] || (levels[j] = [])).push(seg);
	}

	return levels;
}


// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function computeForwardSlotSegs(levels) {
	var i, level;
	var j, seg;
	var k;

	for (i=0; i<levels.length; i++) {
		level = levels[i];

		for (j=0; j<level.length; j++) {
			seg = level[j];

			seg.forwardSegs = [];
			for (k=i+1; k<levels.length; k++) {
				computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
			}
		}
	}
}


// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function computeSlotSegPressures(seg) {
	var forwardSegs = seg.forwardSegs;
	var forwardPressure = 0;
	var i, forwardSeg;

	if (seg.forwardPressure === undefined) { // not already computed

		for (i=0; i<forwardSegs.length; i++) {
			forwardSeg = forwardSegs[i];

			// figure out the child's maximum forward path
			computeSlotSegPressures(forwardSeg);

			// either use the existing maximum, or use the child's forward pressure
			// plus one (for the forwardSeg itself)
			forwardPressure = Math.max(
				forwardPressure,
				1 + forwardSeg.forwardPressure
			);
		}

		seg.forwardPressure = forwardPressure;
	}
}


// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function computeSlotSegCollisions(seg, otherSegs, results) {
	results = results || [];

	for (var i=0; i<otherSegs.length; i++) {
		if (isSlotSegCollision(seg, otherSegs[i])) {
			results.push(otherSegs[i]);
		}
	}

	return results;
}


// Do these segments occupy the same vertical space?
function isSlotSegCollision(seg1, seg2) {
	return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
}

;;

/* An abstract class from which other views inherit from
----------------------------------------------------------------------------------------------------------------------*/

var View = FC.View = Model.extend({

	type: null, // subclass' view name (string)
	name: null, // deprecated. use `type` instead
	title: null, // the text that will be displayed in the header's title

	calendar: null, // owner Calendar object
	viewSpec: null,
	options: null, // hash containing all options. already merged with view-specific-options
	el: null, // the view's containing element. set by Calendar

	renderQueue: null,
	batchRenderDepth: 0,
	isDatesRendered: false,
	isEventsRendered: false,
	isBaseRendered: false, // related to viewRender/viewDestroy triggers

	queuedScroll: null,

	isRTL: false,
	isSelected: false, // boolean whether a range of time is user-selected or not
	selectedEvent: null,

	eventOrderSpecs: null, // criteria for ordering events when they have same date/time

	// classNames styled by jqui themes
	widgetHeaderClass: null,
	widgetContentClass: null,
	highlightStateClass: null,

	// for date utils, computed from options
	nextDayThreshold: null,
	isHiddenDayHash: null,

	// now indicator
	isNowIndicatorRendered: null,
	initialNowDate: null, // result first getNow call
	initialNowQueriedMs: null, // ms time the getNow was called
	nowIndicatorTimeoutID: null, // for refresh timing of now indicator
	nowIndicatorIntervalID: null, // "


	constructor: function(calendar, viewSpec) {
		Model.prototype.constructor.call(this);

		this.calendar = calendar;
		this.viewSpec = viewSpec;

		// shortcuts
		this.type = viewSpec.type;
		this.options = viewSpec.options;

		// .name is deprecated
		this.name = this.type;

		this.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));
		this.initThemingProps();
		this.initHiddenDays();
		this.isRTL = this.opt('isRTL');

		this.eventOrderSpecs = parseFieldSpecs(this.opt('eventOrder'));

		this.renderQueue = this.buildRenderQueue();
		this.initAutoBatchRender();

		this.initialize();
	},


	buildRenderQueue: function() {
		var _this = this;
		var renderQueue = new RenderQueue({
			event: this.opt('eventRenderWait')
		});

		renderQueue.on('start', function() {
			_this.freezeHeight();
			_this.addScroll(_this.queryScroll());
		});

		renderQueue.on('stop', function() {
			_this.thawHeight();
			_this.popScroll();
		});

		return renderQueue;
	},


	initAutoBatchRender: function() {
		var _this = this;

		this.on('before:change', function() {
			_this.startBatchRender();
		});

		this.on('change', function() {
			_this.stopBatchRender();
		});
	},


	startBatchRender: function() {
		if (!(this.batchRenderDepth++)) {
			this.renderQueue.pause();
		}
	},


	stopBatchRender: function() {
		if (!(--this.batchRenderDepth)) {
			this.renderQueue.resume();
		}
	},


	// A good place for subclasses to initialize member variables
	initialize: function() {
		// subclasses can implement
	},


	// Retrieves an option with the given name
	opt: function(name) {
		return this.options[name];
	},


	// Triggers handlers that are view-related. Modifies args before passing to calendar.
	publiclyTrigger: function(name, thisObj) { // arguments beyond thisObj are passed along
		var calendar = this.calendar;

		return calendar.publiclyTrigger.apply(
			calendar,
			[name, thisObj || this].concat(
				Array.prototype.slice.call(arguments, 2), // arguments beyond thisObj
				[ this ] // always make the last argument a reference to the view. TODO: deprecate
			)
		);
	},


	/* Title and Date Formatting
	------------------------------------------------------------------------------------------------------------------*/


	// Sets the view's title property to the most updated computed value
	updateTitle: function() {
		this.title = this.computeTitle();
		this.calendar.setToolbarsTitle(this.title);
	},


	// Computes what the title at the top of the calendar should be for this view
	computeTitle: function() {
		var range;

		// for views that span a large unit of time, show the proper interval, ignoring stray days before and after
		if (/^(year|month)$/.test(this.currentRangeUnit)) {
			range = this.currentRange;
		}
		else { // for day units or smaller, use the actual day range
			range = this.activeRange;
		}

		return this.formatRange(
			{
				// in case currentRange has a time, make sure timezone is correct
				start: this.calendar.applyTimezone(range.start),
				end: this.calendar.applyTimezone(range.end)
			},
			this.opt('titleFormat') || this.computeTitleFormat(),
			this.opt('titleRangeSeparator')
		);
	},


	// Generates the format string that should be used to generate the title for the current date range.
	// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
	computeTitleFormat: function() {
		if (this.currentRangeUnit == 'year') {
			return 'YYYY';
		}
		else if (this.currentRangeUnit == 'month') {
			return this.opt('monthYearFormat'); // like "September 2014"
		}
		else if (this.currentRangeAs('days') > 1) {
			return 'll'; // multi-day range. shorter, like "Sep 9 - 10 2014"
		}
		else {
			return 'LL'; // one day. longer, like "September 9 2014"
		}
	},


	// Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
	// Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
	// The timezones of the dates within `range` will be respected.
	formatRange: function(range, formatStr, separator) {
		var end = range.end;

		if (!end.hasTime()) { // all-day?
			end = end.clone().subtract(1); // convert to inclusive. last ms of previous day
		}

		return formatRange(range.start, end, formatStr, separator, this.opt('isRTL'));
	},


	getAllDayHtml: function() {
		return this.opt('allDayHtml') || htmlEscape(this.opt('allDayText'));
	},


	/* Navigation
	------------------------------------------------------------------------------------------------------------------*/


	// Generates HTML for an anchor to another view into the calendar.
	// Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.
	// `gotoOptions` can either be a moment input, or an object with the form:
	// { date, type, forceOff }
	// `type` is a view-type like "day" or "week". default value is "day".
	// `attrs` and `innerHtml` are use to generate the rest of the HTML tag.
	buildGotoAnchorHtml: function(gotoOptions, attrs, innerHtml) {
		var date, type, forceOff;
		var finalOptions;

		if ($.isPlainObject(gotoOptions)) {
			date = gotoOptions.date;
			type = gotoOptions.type;
			forceOff = gotoOptions.forceOff;
		}
		else {
			date = gotoOptions; // a single moment input
		}
		date = FC.moment(date); // if a string, parse it

		finalOptions = { // for serialization into the link
			date: date.format('YYYY-MM-DD'),
			type: type || 'day'
		};

		if (typeof attrs === 'string') {
			innerHtml = attrs;
			attrs = null;
		}

		attrs = attrs ? ' ' + attrsToStr(attrs) : ''; // will have a leading space
		innerHtml = innerHtml || '';

		if (!forceOff && this.opt('navLinks')) {
			return '<a' + attrs +
				' data-goto="' + htmlEscape(JSON.stringify(finalOptions)) + '">' +
				innerHtml +
				'</a>';
		}
		else {
			return '<span' + attrs + '>' +
				innerHtml +
				'</span>';
		}
	},


	// Rendering Non-date-related Content
	// -----------------------------------------------------------------------------------------------------------------


	// Sets the container element that the view should render inside of, does global DOM-related initializations,
	// and renders all the non-date-related content inside.
	setElement: function(el) {
		this.el = el;
		this.bindGlobalHandlers();
		this.bindBaseRenderHandlers();
		this.renderSkeleton();
	},


	// Removes the view's container element from the DOM, clearing any content beforehand.
	// Undoes any other DOM-related attachments.
	removeElement: function() {
		this.unsetDate();
		this.unrenderSkeleton();

		this.unbindGlobalHandlers();
		this.unbindBaseRenderHandlers();

		this.el.remove();
		// NOTE: don't null-out this.el in case the View was destroyed within an API callback.
		// We don't null-out the View's other jQuery element references upon destroy,
		//  so we shouldn't kill this.el either.
	},


	// Renders the basic structure of the view before any content is rendered
	renderSkeleton: function() {
		// subclasses should implement
	},


	// Unrenders the basic structure of the view
	unrenderSkeleton: function() {
		// subclasses should implement
	},


	// Date Setting/Unsetting
	// -----------------------------------------------------------------------------------------------------------------


	setDate: function(date) {
		var currentDateProfile = this.get('dateProfile');
		var newDateProfile = this.buildDateProfile(date, null, true); // forceToValid=true

		if (
			!currentDateProfile ||
			!isRangesEqual(currentDateProfile.activeRange, newDateProfile.activeRange)
		) {
			this.set('dateProfile', newDateProfile);
		}

		return newDateProfile.date;
	},


	unsetDate: function() {
		this.unset('dateProfile');
	},


	// Date Rendering
	// -----------------------------------------------------------------------------------------------------------------


	requestDateRender: function(dateProfile) {
		var _this = this;

		this.renderQueue.queue(function() {
			_this.executeDateRender(dateProfile);
		}, 'date', 'init');
	},


	requestDateUnrender: function() {
		var _this = this;

		this.renderQueue.queue(function() {
			_this.executeDateUnrender();
		}, 'date', 'destroy');
	},


	// Event Data
	// -----------------------------------------------------------------------------------------------------------------


	fetchInitialEvents: function(dateProfile) {
		return this.calendar.requestEvents(
			dateProfile.activeRange.start,
			dateProfile.activeRange.end
		);
	},


	bindEventChanges: function() {
		this.listenTo(this.calendar, 'eventsReset', this.resetEvents);
	},


	unbindEventChanges: function() {
		this.stopListeningTo(this.calendar, 'eventsReset');
	},


	setEvents: function(events) {
		this.set('currentEvents', events);
		this.set('hasEvents', true);
	},


	unsetEvents: function() {
		this.unset('currentEvents');
		this.unset('hasEvents');
	},


	resetEvents: function(events) {
		this.startBatchRender();
		this.unsetEvents();
		this.setEvents(events);
		this.stopBatchRender();
	},


	// Event Rendering
	// -----------------------------------------------------------------------------------------------------------------


	requestEventsRender: function(events) {
		var _this = this;

		this.renderQueue.queue(function() {
			_this.executeEventsRender(events);
		}, 'event', 'init');
	},


	requestEventsUnrender: function() {
		var _this = this;

		this.renderQueue.queue(function() {
			_this.executeEventsUnrender();
		}, 'event', 'destroy');
	},


	// Date High-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	// if dateProfile not specified, uses current
	executeDateRender: function(dateProfile, skipScroll) {

		this.setDateProfileForRendering(dateProfile);
		this.updateTitle();
		this.calendar.updateToolbarButtons();

		if (this.render) {
			this.render(); // TODO: deprecate
		}

		this.renderDates();
		this.updateSize();
		this.renderBusinessHours(); // might need coordinates, so should go after updateSize()
		this.startNowIndicator();

		if (!skipScroll) {
			this.addScroll(this.computeInitialDateScroll());
		}

		this.isDatesRendered = true;
		this.trigger('datesRendered');
	},


	executeDateUnrender: function() {

		this.unselect();
		this.stopNowIndicator();

		this.trigger('before:datesUnrendered');

		this.unrenderBusinessHours();
		this.unrenderDates();

		if (this.destroy) {
			this.destroy(); // TODO: deprecate
		}

		this.isDatesRendered = false;
	},


	// Date Low-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	// date-cell content only
	renderDates: function() {
		// subclasses should implement
	},


	// date-cell content only
	unrenderDates: function() {
		// subclasses should override
	},


	// Determing when the "meat" of the view is rendered (aka the base)
	// -----------------------------------------------------------------------------------------------------------------


	bindBaseRenderHandlers: function() {
		var _this = this;

		this.on('datesRendered.baseHandler', function() {
			_this.onBaseRender();
		});

		this.on('before:datesUnrendered.baseHandler', function() {
			_this.onBeforeBaseUnrender();
		});
	},


	unbindBaseRenderHandlers: function() {
		this.off('.baseHandler');
	},


	onBaseRender: function() {
		this.applyScreenState();
		this.publiclyTrigger('viewRender', this, this, this.el);
	},


	onBeforeBaseUnrender: function() {
		this.applyScreenState();
		this.publiclyTrigger('viewDestroy', this, this, this.el);
	},


	// Misc view rendering utils
	// -----------------------------------------------------------------------------------------------------------------


	// Binds DOM handlers to elements that reside outside the view container, such as the document
	bindGlobalHandlers: function() {
		this.listenTo(GlobalEmitter.get(), {
			touchstart: this.processUnselect,
			mousedown: this.handleDocumentMousedown
		});
	},


	// Unbinds DOM handlers from elements that reside outside the view container
	unbindGlobalHandlers: function() {
		this.stopListeningTo(GlobalEmitter.get());
	},


	// Initializes internal variables related to theming
	initThemingProps: function() {
		var tm = this.opt('theme') ? 'ui' : 'fc';

		this.widgetHeaderClass = tm + '-widget-header';
		this.widgetContentClass = tm + '-widget-content';
		this.highlightStateClass = tm + '-state-highlight';
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	// Renders business-hours onto the view. Assumes updateSize has already been called.
	renderBusinessHours: function() {
		// subclasses should implement
	},


	// Unrenders previously-rendered business-hours
	unrenderBusinessHours: function() {
		// subclasses should implement
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	// Immediately render the current time indicator and begins re-rendering it at an interval,
	// which is defined by this.getNowIndicatorUnit().
	// TODO: somehow do this for the current whole day's background too
	startNowIndicator: function() {
		var _this = this;
		var unit;
		var update;
		var delay; // ms wait value

		if (this.opt('nowIndicator')) {
			unit = this.getNowIndicatorUnit();
			if (unit) {
				update = proxy(this, 'updateNowIndicator'); // bind to `this`

				this.initialNowDate = this.calendar.getNow();
				this.initialNowQueriedMs = +new Date();
				this.renderNowIndicator(this.initialNowDate);
				this.isNowIndicatorRendered = true;

				// wait until the beginning of the next interval
				delay = this.initialNowDate.clone().startOf(unit).add(1, unit) - this.initialNowDate;
				this.nowIndicatorTimeoutID = setTimeout(function() {
					_this.nowIndicatorTimeoutID = null;
					update();
					delay = +moment.duration(1, unit);
					delay = Math.max(100, delay); // prevent too frequent
					_this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval
				}, delay);
			}
		}
	},


	// rerenders the now indicator, computing the new current time from the amount of time that has passed
	// since the initial getNow call.
	updateNowIndicator: function() {
		if (this.isNowIndicatorRendered) {
			this.unrenderNowIndicator();
			this.renderNowIndicator(
				this.initialNowDate.clone().add(new Date() - this.initialNowQueriedMs) // add ms
			);
		}
	},


	// Immediately unrenders the view's current time indicator and stops any re-rendering timers.
	// Won't cause side effects if indicator isn't rendered.
	stopNowIndicator: function() {
		if (this.isNowIndicatorRendered) {

			if (this.nowIndicatorTimeoutID) {
				clearTimeout(this.nowIndicatorTimeoutID);
				this.nowIndicatorTimeoutID = null;
			}
			if (this.nowIndicatorIntervalID) {
				clearTimeout(this.nowIndicatorIntervalID);
				this.nowIndicatorIntervalID = null;
			}

			this.unrenderNowIndicator();
			this.isNowIndicatorRendered = false;
		}
	},


	// Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator
	// should be refreshed. If something falsy is returned, no time indicator is rendered at all.
	getNowIndicatorUnit: function() {
		// subclasses should implement
	},


	// Renders a current time indicator at the given datetime
	renderNowIndicator: function(date) {
		// subclasses should implement
	},


	// Undoes the rendering actions from renderNowIndicator
	unrenderNowIndicator: function() {
		// subclasses should implement
	},


	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


	// Refreshes anything dependant upon sizing of the container element of the grid
	updateSize: function(isResize) {
		var scroll;

		if (isResize) {
			scroll = this.queryScroll();
		}

		this.updateHeight(isResize);
		this.updateWidth(isResize);
		this.updateNowIndicator();

		if (isResize) {
			this.applyScroll(scroll);
		}
	},


	// Refreshes the horizontal dimensions of the calendar
	updateWidth: function(isResize) {
		// subclasses should implement
	},


	// Refreshes the vertical dimensions of the calendar
	updateHeight: function(isResize) {
		var calendar = this.calendar; // we poll the calendar for height information

		this.setHeight(
			calendar.getSuggestedViewHeight(),
			calendar.isHeightAuto()
		);
	},


	// Updates the vertical dimensions of the calendar to the specified height.
	// if `isAuto` is set to true, height becomes merely a suggestion and the view should use its "natural" height.
	setHeight: function(height, isAuto) {
		// subclasses should implement
	},


	/* Scroller
	------------------------------------------------------------------------------------------------------------------*/


	addForcedScroll: function(scroll) {
		this.addScroll(
			$.extend(scroll, { isForced: true })
		);
	},


	addScroll: function(scroll) {
		var queuedScroll = this.queuedScroll || (this.queuedScroll = {});

		if (!queuedScroll.isForced) {
			$.extend(queuedScroll, scroll);
		}
	},


	popScroll: function() {
		this.applyQueuedScroll();
		this.queuedScroll = null;
	},


	applyQueuedScroll: function() {
		if (this.queuedScroll) {
			this.applyScroll(this.queuedScroll);
		}
	},


	queryScroll: function() {
		var scroll = {};

		if (this.isDatesRendered) {
			$.extend(scroll, this.queryDateScroll());
		}

		return scroll;
	},


	applyScroll: function(scroll) {
		if (this.isDatesRendered) {
			this.applyDateScroll(scroll);
		}
	},


	computeInitialDateScroll: function() {
		return {}; // subclasses must implement
	},


	queryDateScroll: function() {
		return {}; // subclasses must implement
	},


	applyDateScroll: function(scroll) {
		; // subclasses must implement
	},


	/* Height Freezing
	------------------------------------------------------------------------------------------------------------------*/


	freezeHeight: function() {
		this.calendar.freezeContentHeight();
	},


	thawHeight: function() {
		this.calendar.thawContentHeight();
	},


	// Event High-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	executeEventsRender: function(events) {
		this.renderEvents(events);
		this.isEventsRendered = true;

		this.onEventsRender();
	},


	executeEventsUnrender: function() {
		this.onBeforeEventsUnrender();

		if (this.destroyEvents) {
			this.destroyEvents(); // TODO: deprecate
		}

		this.unrenderEvents();
		this.isEventsRendered = false;
	},


	// Event Rendering Triggers
	// -----------------------------------------------------------------------------------------------------------------


	// Signals that all events have been rendered
	onEventsRender: function() {
		this.applyScreenState();

		this.renderedEventSegEach(function(seg) {
			this.publiclyTrigger('eventAfterRender', seg.event, seg.event, seg.el);
		});
		this.publiclyTrigger('eventAfterAllRender');
	},


	// Signals that all event elements are about to be removed
	onBeforeEventsUnrender: function() {
		this.applyScreenState();

		this.renderedEventSegEach(function(seg) {
			this.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);
		});
	},


	applyScreenState: function() {
		this.thawHeight();
		this.freezeHeight();
		this.applyQueuedScroll();
	},


	// Event Low-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	// Renders the events onto the view.
	renderEvents: function(events) {
		// subclasses should implement
	},


	// Removes event elements from the view.
	unrenderEvents: function() {
		// subclasses should implement
	},


	// Event Rendering Utils
	// -----------------------------------------------------------------------------------------------------------------


	// Given an event and the default element used for rendering, returns the element that should actually be used.
	// Basically runs events and elements through the eventRender hook.
	resolveEventEl: function(event, el) {
		var custom = this.publiclyTrigger('eventRender', event, event, el);

		if (custom === false) { // means don't render at all
			el = null;
		}
		else if (custom && custom !== true) {
			el = $(custom);
		}

		return el;
	},


	// Hides all rendered event segments linked to the given event
	showEvent: function(event) {
		this.renderedEventSegEach(function(seg) {
			seg.el.css('visibility', '');
		}, event);
	},


	// Shows all rendered event segments linked to the given event
	hideEvent: function(event) {
		this.renderedEventSegEach(function(seg) {
			seg.el.css('visibility', 'hidden');
		}, event);
	},


	// Iterates through event segments that have been rendered (have an el). Goes through all by default.
	// If the optional `event` argument is specified, only iterates through segments linked to that event.
	// The `this` value of the callback function will be the view.
	renderedEventSegEach: function(func, event) {
		var segs = this.getEventSegs();
		var i;

		for (i = 0; i < segs.length; i++) {
			if (!event || segs[i].event._id === event._id) {
				if (segs[i].el) {
					func.call(this, segs[i]);
				}
			}
		}
	},


	// Retrieves all the rendered segment objects for the view
	getEventSegs: function() {
		// subclasses must implement
		return [];
	},


	/* Event Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/


	// Computes if the given event is allowed to be dragged by the user
	isEventDraggable: function(event) {
		return this.isEventStartEditable(event);
	},


	isEventStartEditable: function(event) {
		return firstDefined(
			event.startEditable,
			(event.source || {}).startEditable,
			this.opt('eventStartEditable'),
			this.isEventGenerallyEditable(event)
		);
	},


	isEventGenerallyEditable: function(event) {
		return firstDefined(
			event.editable,
			(event.source || {}).editable,
			this.opt('editable')
		);
	},


	// Must be called when an event in the view is dropped onto new location.
	// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
	reportSegDrop: function(seg, dropLocation, largeUnit, el, ev) {
		var calendar = this.calendar;
		var mutateResult = calendar.mutateSeg(seg, dropLocation, largeUnit);
		var undoFunc = function() {
			mutateResult.undo();
			calendar.reportEventChange();
		};

		this.triggerEventDrop(seg.event, mutateResult.dateDelta, undoFunc, el, ev);
		calendar.reportEventChange(); // will rerender events
	},


	// Triggers event-drop handlers that have subscribed via the API
	triggerEventDrop: function(event, dateDelta, undoFunc, el, ev) {
		this.publiclyTrigger('eventDrop', el[0], event, dateDelta, undoFunc, ev, {}); // {} = jqui dummy
	},


	/* External Element Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/


	// Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
	// `meta` is the parsed data that has been embedded into the dragging event.
	// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
	reportExternalDrop: function(meta, dropLocation, el, ev, ui) {
		var eventProps = meta.eventProps;
		var eventInput;
		var event;

		// Try to build an event object and render it. TODO: decouple the two
		if (eventProps) {
			eventInput = $.extend({}, eventProps, dropLocation);
			event = this.calendar.renderEvent(eventInput, meta.stick)[0]; // renderEvent returns an array
		}

		this.triggerExternalDrop(event, dropLocation, el, ev, ui);
	},


	// Triggers external-drop handlers that have subscribed via the API
	triggerExternalDrop: function(event, dropLocation, el, ev, ui) {

		// trigger 'drop' regardless of whether element represents an event
		this.publiclyTrigger('drop', el[0], dropLocation.start, ev, ui);

		if (event) {
			this.publiclyTrigger('eventReceive', null, event); // signal an external event landed
		}
	},


	/* Drag-n-Drop Rendering (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a event or external-element drag over the given drop zone.
	// If an external-element, seg will be `null`.
	// Must return elements used for any mock events.
	renderDrag: function(dropLocation, seg) {
		// subclasses must implement
	},


	// Unrenders a visual indication of an event or external-element being dragged.
	unrenderDrag: function() {
		// subclasses must implement
	},


	/* Event Resizing
	------------------------------------------------------------------------------------------------------------------*/


	// Computes if the given event is allowed to be resized from its starting edge
	isEventResizableFromStart: function(event) {
		return this.opt('eventResizableFromStart') && this.isEventResizable(event);
	},


	// Computes if the given event is allowed to be resized from its ending edge
	isEventResizableFromEnd: function(event) {
		return this.isEventResizable(event);
	},


	// Computes if the given event is allowed to be resized by the user at all
	isEventResizable: function(event) {
		var source = event.source || {};

		return firstDefined(
			event.durationEditable,
			source.durationEditable,
			this.opt('eventDurationEditable'),
			event.editable,
			source.editable,
			this.opt('editable')
		);
	},


	// Must be called when an event in the view has been resized to a new length
	reportSegResize: function(seg, resizeLocation, largeUnit, el, ev) {
		var calendar = this.calendar;
		var mutateResult = calendar.mutateSeg(seg, resizeLocation, largeUnit);
		var undoFunc = function() {
			mutateResult.undo();
			calendar.reportEventChange();
		};

		this.triggerEventResize(seg.event, mutateResult.durationDelta, undoFunc, el, ev);
		calendar.reportEventChange(); // will rerender events
	},


	// Triggers event-resize handlers that have subscribed via the API
	triggerEventResize: function(event, durationDelta, undoFunc, el, ev) {
		this.publiclyTrigger('eventResize', el[0], event, durationDelta, undoFunc, ev, {}); // {} = jqui dummy
	},


	/* Selection (time range)
	------------------------------------------------------------------------------------------------------------------*/


	// Selects a date span on the view. `start` and `end` are both Moments.
	// `ev` is the native mouse event that begin the interaction.
	select: function(span, ev) {
		this.unselect(ev);
		this.renderSelection(span);
		this.reportSelection(span, ev);
	},


	// Renders a visual indication of the selection
	renderSelection: function(span) {
		// subclasses should implement
	},


	// Called when a new selection is made. Updates internal state and triggers handlers.
	reportSelection: function(span, ev) {
		this.isSelected = true;
		this.triggerSelect(span, ev);
	},


	// Triggers handlers to 'select'
	triggerSelect: function(span, ev) {
		this.publiclyTrigger(
			'select',
			null,
			this.calendar.applyTimezone(span.start), // convert to calendar's tz for external API
			this.calendar.applyTimezone(span.end), // "
			ev
		);
	},


	// Undoes a selection. updates in the internal state and triggers handlers.
	// `ev` is the native mouse event that began the interaction.
	unselect: function(ev) {
		if (this.isSelected) {
			this.isSelected = false;
			if (this.destroySelection) {
				this.destroySelection(); // TODO: deprecate
			}
			this.unrenderSelection();
			this.publiclyTrigger('unselect', null, ev);
		}
	},


	// Unrenders a visual indication of selection
	unrenderSelection: function() {
		// subclasses should implement
	},


	/* Event Selection
	------------------------------------------------------------------------------------------------------------------*/


	selectEvent: function(event) {
		if (!this.selectedEvent || this.selectedEvent !== event) {
			this.unselectEvent();
			this.renderedEventSegEach(function(seg) {
				seg.el.addClass('fc-selected');
			}, event);
			this.selectedEvent = event;
		}
	},


	unselectEvent: function() {
		if (this.selectedEvent) {
			this.renderedEventSegEach(function(seg) {
				seg.el.removeClass('fc-selected');
			}, this.selectedEvent);
			this.selectedEvent = null;
		}
	},


	isEventSelected: function(event) {
		// event references might change on refetchEvents(), while selectedEvent doesn't,
		// so compare IDs
		return this.selectedEvent && this.selectedEvent._id === event._id;
	},


	/* Mouse / Touch Unselecting (time range & event unselection)
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: move consistently to down/start or up/end?
	// TODO: don't kill previous selection if touch scrolling


	handleDocumentMousedown: function(ev) {
		if (isPrimaryMouseButton(ev)) {
			this.processUnselect(ev);
		}
	},


	processUnselect: function(ev) {
		this.processRangeUnselect(ev);
		this.processEventUnselect(ev);
	},


	processRangeUnselect: function(ev) {
		var ignore;

		// is there a time-range selection?
		if (this.isSelected && this.opt('unselectAuto')) {
			// only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element
			ignore = this.opt('unselectCancel');
			if (!ignore || !$(ev.target).closest(ignore).length) {
				this.unselect(ev);
			}
		}
	},


	processEventUnselect: function(ev) {
		if (this.selectedEvent) {
			if (!$(ev.target).closest('.fc-selected').length) {
				this.unselectEvent();
			}
		}
	},


	/* Day Click
	------------------------------------------------------------------------------------------------------------------*/


	// Triggers handlers to 'dayClick'
	// Span has start/end of the clicked area. Only the start is useful.
	triggerDayClick: function(span, dayEl, ev) {
		this.publiclyTrigger(
			'dayClick',
			dayEl,
			this.calendar.applyTimezone(span.start), // convert to calendar's timezone for external API
			ev
		);
	},


	/* Date Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Returns the date range of the full days the given range visually appears to occupy.
	// Returns a new range object.
	computeDayRange: function(range) {
		var startDay = range.start.clone().stripTime(); // the beginning of the day the range starts
		var end = range.end;
		var endDay = null;
		var endTimeMS;

		if (end) {
			endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends
			endTimeMS = +end.time(); // # of milliseconds into `endDay`

			// If the end time is actually inclusively part of the next day and is equal to or
			// beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
			// Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
			if (endTimeMS && endTimeMS >= this.nextDayThreshold) {
				endDay.add(1, 'days');
			}
		}

		// If no end was specified, or if it is within `startDay` but not past nextDayThreshold,
		// assign the default duration of one day.
		if (!end || endDay <= startDay) {
			endDay = startDay.clone().add(1, 'days');
		}

		return { start: startDay, end: endDay };
	},


	// Does the given event visually appear to occupy more than one day?
	isMultiDayEvent: function(event) {
		var range = this.computeDayRange(event); // event is range-ish

		return range.end.diff(range.start, 'days') > 1;
	}

});


View.watch('displayingDates', [ 'dateProfile' ], function(deps) {
	this.requestDateRender(deps.dateProfile);
}, function() {
	this.requestDateUnrender();
});


View.watch('initialEvents', [ 'dateProfile' ], function(deps) {
	return this.fetchInitialEvents(deps.dateProfile);
});


View.watch('bindingEvents', [ 'initialEvents' ], function(deps) {
	this.setEvents(deps.initialEvents);
	this.bindEventChanges();
}, function() {
	this.unbindEventChanges();
	this.unsetEvents();
});


View.watch('displayingEvents', [ 'displayingDates', 'hasEvents' ], function() {
	this.requestEventsRender(this.get('currentEvents')); // if there were event mutations after initialEvents
}, function() {
	this.requestEventsUnrender();
});

;;

View.mixin({

	// range the view is formally responsible for.
	// for example, a month view might have 1st-31st, excluding padded dates
	currentRange: null,
	currentRangeUnit: null, // name of largest unit being displayed, like "month" or "week"

	// date range with a rendered skeleton
	// includes not-active days that need some sort of DOM
	renderRange: null,

	// dates that display events and accept drag-n-drop
	activeRange: null,

	// constraint for where prev/next operations can go and where events can be dragged/resized to.
	// an object with optional start and end properties.
	validRange: null,

	// how far the current date will move for a prev/next operation
	dateIncrement: null,

	minTime: null, // Duration object that denotes the first visible time of any given day
	maxTime: null, // Duration object that denotes the exclusive visible end time of any given day
	usesMinMaxTime: false, // whether minTime/maxTime will affect the activeRange. Views must opt-in.

	// DEPRECATED
	start: null, // use activeRange.start
	end: null, // use activeRange.end
	intervalStart: null, // use currentRange.start
	intervalEnd: null, // use currentRange.end


	/* Date Range Computation
	------------------------------------------------------------------------------------------------------------------*/


	setDateProfileForRendering: function(dateProfile) {
		this.currentRange = dateProfile.currentRange;
		this.currentRangeUnit = dateProfile.currentRangeUnit;
		this.renderRange = dateProfile.renderRange;
		this.activeRange = dateProfile.activeRange;
		this.validRange = dateProfile.validRange;
		this.dateIncrement = dateProfile.dateIncrement;
		this.minTime = dateProfile.minTime;
		this.maxTime = dateProfile.maxTime;

		// DEPRECATED, but we need to keep it updated
		this.start = dateProfile.activeRange.start;
		this.end = dateProfile.activeRange.end;
		this.intervalStart = dateProfile.currentRange.start;
		this.intervalEnd = dateProfile.currentRange.end;
	},


	// Builds a structure with info about what the dates/ranges will be for the "prev" view.
	buildPrevDateProfile: function(date) {
		var prevDate = date.clone().startOf(this.currentRangeUnit).subtract(this.dateIncrement);

		return this.buildDateProfile(prevDate, -1);
	},


	// Builds a structure with info about what the dates/ranges will be for the "next" view.
	buildNextDateProfile: function(date) {
		var nextDate = date.clone().startOf(this.currentRangeUnit).add(this.dateIncrement);

		return this.buildDateProfile(nextDate, 1);
	},


	// Builds a structure holding dates/ranges for rendering around the given date.
	// Optional direction param indicates whether the date is being incremented/decremented
	// from its previous value. decremented = -1, incremented = 1 (default).
	buildDateProfile: function(date, direction, forceToValid) {
		var validRange = this.buildValidRange();
		var minTime = null;
		var maxTime = null;
		var currentInfo;
		var renderRange;
		var activeRange;
		var isValid;

		if (forceToValid) {
			date = constrainDate(date, validRange);
		}

		currentInfo = this.buildCurrentRangeInfo(date, direction);
		renderRange = this.buildRenderRange(currentInfo.range, currentInfo.unit);
		activeRange = cloneRange(renderRange);

		if (!this.opt('showNonCurrentDates')) {
			activeRange = constrainRange(activeRange, currentInfo.range);
		}

		minTime = moment.duration(this.opt('minTime'));
		maxTime = moment.duration(this.opt('maxTime'));
		this.adjustActiveRange(activeRange, minTime, maxTime);

		activeRange = constrainRange(activeRange, validRange);
		date = constrainDate(date, activeRange);

		// it's invalid if the originally requested date is not contained,
		// or if the range is completely outside of the valid range.
		isValid = doRangesIntersect(currentInfo.range, validRange);

		return {
			validRange: validRange,
			currentRange: currentInfo.range,
			currentRangeUnit: currentInfo.unit,
			activeRange: activeRange,
			renderRange: renderRange,
			minTime: minTime,
			maxTime: maxTime,
			isValid: isValid,
			date: date,
			dateIncrement: this.buildDateIncrement(currentInfo.duration)
				// pass a fallback (might be null) ^
		};
	},


	// Builds an object with optional start/end properties.
	// Indicates the minimum/maximum dates to display.
	buildValidRange: function() {
		return this.getRangeOption('validRange', this.calendar.getNow()) || {};
	},


	// Builds a structure with info about the "current" range, the range that is
	// highlighted as being the current month for example.
	// See buildDateProfile for a description of `direction`.
	// Guaranteed to have `range` and `unit` properties. `duration` is optional.
	buildCurrentRangeInfo: function(date, direction) {
		var duration = null;
		var unit = null;
		var range = null;
		var dayCount;

		if (this.viewSpec.duration) {
			duration = this.viewSpec.duration;
			unit = this.viewSpec.durationUnit;
			range = this.buildRangeFromDuration(date, direction, duration, unit);
		}
		else if ((dayCount = this.opt('dayCount'))) {
			unit = 'day';
			range = this.buildRangeFromDayCount(date, direction, dayCount);
		}
		else if ((range = this.buildCustomVisibleRange(date))) {
			unit = computeGreatestUnit(range.start, range.end);
		}
		else {
			duration = this.getFallbackDuration();
			unit = computeGreatestUnit(duration);
			range = this.buildRangeFromDuration(date, direction, duration, unit);
		}

		this.normalizeCurrentRange(range, unit); // modifies in-place

		return { duration: duration, unit: unit, range: range };
	},


	getFallbackDuration: function() {
		return moment.duration({ days: 1 });
	},


	// If the range has day units or larger, remove times. Otherwise, ensure times.
	normalizeCurrentRange: function(range, unit) {

		if (/^(year|month|week|day)$/.test(unit)) { // whole-days?
			range.start.stripTime();
			range.end.stripTime();
		}
		else { // needs to have a time?
			if (!range.start.hasTime()) {
				range.start.time(0); // give 00:00 time
			}
			if (!range.end.hasTime()) {
				range.end.time(0); // give 00:00 time
			}
		}
	},


	// Mutates the given activeRange to have time values (un-ambiguate)
	// if the minTime or maxTime causes the range to expand.
	// TODO: eventually activeRange should *always* have times.
	adjustActiveRange: function(range, minTime, maxTime) {
		var hasSpecialTimes = false;

		if (this.usesMinMaxTime) {

			if (minTime < 0) {
				range.start.time(0).add(minTime);
				hasSpecialTimes = true;
			}

			if (maxTime > 24 * 60 * 60 * 1000) { // beyond 24 hours?
				range.end.time(maxTime - (24 * 60 * 60 * 1000));
				hasSpecialTimes = true;
			}

			if (hasSpecialTimes) {
				if (!range.start.hasTime()) {
					range.start.time(0);
				}
				if (!range.end.hasTime()) {
					range.end.time(0);
				}
			}
		}
	},


	// Builds the "current" range when it is specified as an explicit duration.
	// `unit` is the already-computed computeGreatestUnit value of duration.
	buildRangeFromDuration: function(date, direction, duration, unit) {
		var alignment = this.opt('dateAlignment');
		var start = date.clone();
		var end;
		var dateIncrementInput;
		var dateIncrementDuration;

		// if the view displays a single day or smaller
		if (duration.as('days') <= 1) {
			if (this.isHiddenDay(start)) {
				start = this.skipHiddenDays(start, direction);
				start.startOf('day');
			}
		}

		// compute what the alignment should be
		if (!alignment) {
			dateIncrementInput = this.opt('dateIncrement');

			if (dateIncrementInput) {
				dateIncrementDuration = moment.duration(dateIncrementInput);

				// use the smaller of the two units
				if (dateIncrementDuration < duration) {
					alignment = computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);
				}
				else {
					alignment = unit;
				}
			}
			else {
				alignment = unit;
			}
		}

		start.startOf(alignment);
		end = start.clone().add(duration);

		return { start: start, end: end };
	},


	// Builds the "current" range when a dayCount is specified.
	buildRangeFromDayCount: function(date, direction, dayCount) {
		var customAlignment = this.opt('dateAlignment');
		var runningCount = 0;
		var start = date.clone();
		var end;

		if (customAlignment) {
			start.startOf(customAlignment);
		}

		start.startOf('day');
		start = this.skipHiddenDays(start, direction);

		end = start.clone();
		do {
			end.add(1, 'day');
			if (!this.isHiddenDay(end)) {
				runningCount++;
			}
		} while (runningCount < dayCount);

		return { start: start, end: end };
	},


	// Builds a normalized range object for the "visible" range,
	// which is a way to define the currentRange and activeRange at the same time.
	buildCustomVisibleRange: function(date) {
		var visibleRange = this.getRangeOption(
			'visibleRange',
			this.calendar.moment(date) // correct zone. also generates new obj that avoids mutations
		);

		if (visibleRange && (!visibleRange.start || !visibleRange.end)) {
			return null;
		}

		return visibleRange;
	},


	// Computes the range that will represent the element/cells for *rendering*,
	// but which may have voided days/times.
	buildRenderRange: function(currentRange, currentRangeUnit) {
		// cut off days in the currentRange that are hidden
		return this.trimHiddenDays(currentRange);
	},


	// Compute the duration value that should be added/substracted to the current date
	// when a prev/next operation happens.
	buildDateIncrement: function(fallback) {
		var dateIncrementInput = this.opt('dateIncrement');
		var customAlignment;

		if (dateIncrementInput) {
			return moment.duration(dateIncrementInput);
		}
		else if ((customAlignment = this.opt('dateAlignment'))) {
			return moment.duration(1, customAlignment);
		}
		else if (fallback) {
			return fallback;
		}
		else {
			return moment.duration({ days: 1 });
		}
	},


	// Remove days from the beginning and end of the range that are computed as hidden.
	trimHiddenDays: function(inputRange) {
		return {
			start: this.skipHiddenDays(inputRange.start),
			end: this.skipHiddenDays(inputRange.end, -1, true) // exclusively move backwards
		};
	},


	// Compute the number of the give units in the "current" range.
	// Will return a floating-point number. Won't round.
	currentRangeAs: function(unit) {
		var currentRange = this.currentRange;
		return currentRange.end.diff(currentRange.start, unit, true);
	},


	// Arguments after name will be forwarded to a hypothetical function value
	// WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.
	// Always clone your objects if you fear mutation.
	getRangeOption: function(name) {
		var val = this.opt(name);

		if (typeof val === 'function') {
			val = val.apply(
				null,
				Array.prototype.slice.call(arguments, 1)
			);
		}

		if (val) {
			return this.calendar.parseRange(val);
		}
	},


	/* Hidden Days
	------------------------------------------------------------------------------------------------------------------*/


	// Initializes internal variables related to calculating hidden days-of-week
	initHiddenDays: function() {
		var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden
		var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
		var dayCnt = 0;
		var i;

		if (this.opt('weekends') === false) {
			hiddenDays.push(0, 6); // 0=sunday, 6=saturday
		}

		for (i = 0; i < 7; i++) {
			if (
				!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)
			) {
				dayCnt++;
			}
		}

		if (!dayCnt) {
			throw 'invalid hiddenDays'; // all days were hidden? bad.
		}

		this.isHiddenDayHash = isHiddenDayHash;
	},


	// Is the current day hidden?
	// `day` is a day-of-week index (0-6), or a Moment
	isHiddenDay: function(day) {
		if (moment.isMoment(day)) {
			day = day.day();
		}
		return this.isHiddenDayHash[day];
	},


	// Incrementing the current day until it is no longer a hidden day, returning a copy.
	// DOES NOT CONSIDER validRange!
	// If the initial value of `date` is not a hidden day, don't do anything.
	// Pass `isExclusive` as `true` if you are dealing with an end date.
	// `inc` defaults to `1` (increment one day forward each time)
	skipHiddenDays: function(date, inc, isExclusive) {
		var out = date.clone();
		inc = inc || 1;
		while (
			this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]
		) {
			out.add(inc, 'days');
		}
		return out;
	}

});

;;

/*
Embodies a div that has potential scrollbars
*/
var Scroller = FC.Scroller = Class.extend({

	el: null, // the guaranteed outer element
	scrollEl: null, // the element with the scrollbars
	overflowX: null,
	overflowY: null,


	constructor: function(options) {
		options = options || {};
		this.overflowX = options.overflowX || options.overflow || 'auto';
		this.overflowY = options.overflowY || options.overflow || 'auto';
	},


	render: function() {
		this.el = this.renderEl();
		this.applyOverflow();
	},


	renderEl: function() {
		return (this.scrollEl = $('<div class="fc-scroller"></div>'));
	},


	// sets to natural height, unlocks overflow
	clear: function() {
		this.setHeight('auto');
		this.applyOverflow();
	},


	destroy: function() {
		this.el.remove();
	},


	// Overflow
	// -----------------------------------------------------------------------------------------------------------------


	applyOverflow: function() {
		this.scrollEl.css({
			'overflow-x': this.overflowX,
			'overflow-y': this.overflowY
		});
	},


	// Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.
	// Useful for preserving scrollbar widths regardless of future resizes.
	// Can pass in scrollbarWidths for optimization.
	lockOverflow: function(scrollbarWidths) {
		var overflowX = this.overflowX;
		var overflowY = this.overflowY;

		scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();

		if (overflowX === 'auto') {
			overflowX = (
					scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?
					// OR scrolling pane with massless scrollbars?
					this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth
						// subtract 1 because of IE off-by-one issue
				) ? 'scroll' : 'hidden';
		}

		if (overflowY === 'auto') {
			overflowY = (
					scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?
					// OR scrolling pane with massless scrollbars?
					this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight
						// subtract 1 because of IE off-by-one issue
				) ? 'scroll' : 'hidden';
		}

		this.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });
	},


	// Getters / Setters
	// -----------------------------------------------------------------------------------------------------------------


	setHeight: function(height) {
		this.scrollEl.height(height);
	},


	getScrollTop: function() {
		return this.scrollEl.scrollTop();
	},


	setScrollTop: function(top) {
		this.scrollEl.scrollTop(top);
	},


	getClientWidth: function() {
		return this.scrollEl[0].clientWidth;
	},


	getClientHeight: function() {
		return this.scrollEl[0].clientHeight;
	},


	getScrollbarWidths: function() {
		return getScrollbarWidths(this.scrollEl);
	}

});

;;
function Iterator(items) {
    this.items = items || [];
}


/* Calls a method on every item passing the arguments through */
Iterator.prototype.proxyCall = function(methodName) {
    var args = Array.prototype.slice.call(arguments, 1);
    var results = [];

    this.items.forEach(function(item) {
        results.push(item[methodName].apply(item, args));
    });

    return results;
};

;;

/* Toolbar with buttons and title
----------------------------------------------------------------------------------------------------------------------*/

function Toolbar(calendar, toolbarOptions) {
	var t = this;

	// exports
	t.setToolbarOptions = setToolbarOptions;
	t.render = render;
	t.removeElement = removeElement;
	t.updateTitle = updateTitle;
	t.activateButton = activateButton;
	t.deactivateButton = deactivateButton;
	t.disableButton = disableButton;
	t.enableButton = enableButton;
	t.getViewsWithButtons = getViewsWithButtons;
	t.el = null; // mirrors local `el`

	// locals
	var el;
	var viewsWithButtons = [];
	var tm;

	// method to update toolbar-specific options, not calendar-wide options
	function setToolbarOptions(newToolbarOptions) {
		toolbarOptions = newToolbarOptions;
	}

	// can be called repeatedly and will rerender
	function render() {
		var sections = toolbarOptions.layout;

		tm = calendar.opt('theme') ? 'ui' : 'fc';

		if (sections) {
			if (!el) {
				el = this.el = $("<div class='fc-toolbar "+ toolbarOptions.extraClasses + "'/>");
			}
			else {
				el.empty();
			}
			el.append(renderSection('left'))
				.append(renderSection('right'))
				.append(renderSection('center'))
				.append('<div class="fc-clear"/>');
		}
		else {
			removeElement();
		}
	}


	function removeElement() {
		if (el) {
			el.remove();
			el = t.el = null;
		}
	}


	function renderSection(position) {
		var sectionEl = $('<div class="fc-' + position + '"/>');
		var buttonStr = toolbarOptions.layout[position];
		var calendarCustomButtons = calendar.opt('customButtons') || {};
		var calendarButtonText = calendar.opt('buttonText') || {};

		if (buttonStr) {
			$.each(buttonStr.split(' '), function(i) {
				var groupChildren = $();
				var isOnlyButtons = true;
				var groupEl;

				$.each(this.split(','), function(j, buttonName) {
					var customButtonProps;
					var viewSpec;
					var buttonClick;
					var overrideText; // text explicitly set by calendar's constructor options. overcomes icons
					var defaultText;
					var themeIcon;
					var normalIcon;
					var innerHtml;
					var classes;
					var button; // the element

					if (buttonName == 'title') {
						groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height
						isOnlyButtons = false;
					}
					else {
						if ((customButtonProps = calendarCustomButtons[buttonName])) {
							buttonClick = function(ev) {
								if (customButtonProps.click) {
									customButtonProps.click.call(button[0], ev);
								}
							};
							overrideText = ''; // icons will override text
							defaultText = customButtonProps.text;
						}
						else if ((viewSpec = calendar.getViewSpec(buttonName))) {
							buttonClick = function() {
								calendar.changeView(buttonName);
							};
							viewsWithButtons.push(buttonName);
							overrideText = viewSpec.buttonTextOverride;
							defaultText = viewSpec.buttonTextDefault;
						}
						else if (calendar[buttonName]) { // a calendar method
							buttonClick = function() {
								calendar[buttonName]();
							};
							overrideText = (calendar.overrides.buttonText || {})[buttonName];
							defaultText = calendarButtonText[buttonName]; // everything else is considered default
						}

						if (buttonClick) {

							themeIcon =
								customButtonProps ?
									customButtonProps.themeIcon :
									calendar.opt('themeButtonIcons')[buttonName];

							normalIcon =
								customButtonProps ?
									customButtonProps.icon :
									calendar.opt('buttonIcons')[buttonName];

							if (overrideText) {
								innerHtml = htmlEscape(overrideText);
							}
							else if (themeIcon && calendar.opt('theme')) {
								innerHtml = "<span class='ui-icon ui-icon-" + themeIcon + "'></span>";
							}
							else if (normalIcon && !calendar.opt('theme')) {
								innerHtml = "<span class='fc-icon fc-icon-" + normalIcon + "'></span>";
							}
							else {
								innerHtml = htmlEscape(defaultText);
							}

							classes = [
								'fc-' + buttonName + '-button',
								tm + '-button',
								tm + '-state-default'
							];

							button = $( // type="button" so that it doesn't submit a form
								'<button type="button" class="' + classes.join(' ') + '">' +
									innerHtml +
								'</button>'
								)
								.click(function(ev) {
									// don't process clicks for disabled buttons
									if (!button.hasClass(tm + '-state-disabled')) {

										buttonClick(ev);

										// after the click action, if the button becomes the "active" tab, or disabled,
										// it should never have a hover class, so remove it now.
										if (
											button.hasClass(tm + '-state-active') ||
											button.hasClass(tm + '-state-disabled')
										) {
											button.removeClass(tm + '-state-hover');
										}
									}
								})
								.mousedown(function() {
									// the *down* effect (mouse pressed in).
									// only on buttons that are not the "active" tab, or disabled
									button
										.not('.' + tm + '-state-active')
										.not('.' + tm + '-state-disabled')
										.addClass(tm + '-state-down');
								})
								.mouseup(function() {
									// undo the *down* effect
									button.removeClass(tm + '-state-down');
								})
								.hover(
									function() {
										// the *hover* effect.
										// only on buttons that are not the "active" tab, or disabled
										button
											.not('.' + tm + '-state-active')
											.not('.' + tm + '-state-disabled')
											.addClass(tm + '-state-hover');
									},
									function() {
										// undo the *hover* effect
										button
											.removeClass(tm + '-state-hover')
											.removeClass(tm + '-state-down'); // if mouseleave happens before mouseup
									}
								);

							groupChildren = groupChildren.add(button);
						}
					}
				});

				if (isOnlyButtons) {
					groupChildren
						.first().addClass(tm + '-corner-left').end()
						.last().addClass(tm + '-corner-right').end();
				}

				if (groupChildren.length > 1) {
					groupEl = $('<div/>');
					if (isOnlyButtons) {
						groupEl.addClass('fc-button-group');
					}
					groupEl.append(groupChildren);
					sectionEl.append(groupEl);
				}
				else {
					sectionEl.append(groupChildren); // 1 or 0 children
				}
			});
		}

		return sectionEl;
	}


	function updateTitle(text) {
		if (el) {
			el.find('h2').text(text);
		}
	}


	function activateButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.addClass(tm + '-state-active');
		}
	}


	function deactivateButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.removeClass(tm + '-state-active');
		}
	}


	function disableButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.prop('disabled', true)
				.addClass(tm + '-state-disabled');
		}
	}


	function enableButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.prop('disabled', false)
				.removeClass(tm + '-state-disabled');
		}
	}


	function getViewsWithButtons() {
		return viewsWithButtons;
	}

}

;;

var Calendar = FC.Calendar = Class.extend(EmitterMixin, {

	view: null, // current View object
	viewsByType: null, // holds all instantiated view instances, current or not
	currentDate: null, // unzoned moment. private (public API should use getDate instead)
	loadingLevel: 0, // number of simultaneous loading tasks


	constructor: function(el, overrides) {

		// declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.
		// unneeded() is called in destroy.
		GlobalEmitter.needed();

		this.el = el;
		this.viewsByType = {};
		this.viewSpecCache = {};

		this.initOptionsInternals(overrides);
		this.initMomentInternals(); // needs to happen after options hash initialized
		this.initCurrentDate();

		EventManager.call(this); // needs options immediately
		this.initialize();
	},


	// Subclasses can override this for initialization logic after the constructor has been called
	initialize: function() {
	},


	// Public API
	// -----------------------------------------------------------------------------------------------------------------


	getCalendar: function() {
		return this;
	},


	getView: function() {
		return this.view;
	},


	publiclyTrigger: function(name, thisObj) {
		var args = Array.prototype.slice.call(arguments, 2);
		var optHandler = this.opt(name);

		thisObj = thisObj || this.el[0];
		this.triggerWith(name, thisObj, args); // Emitter's method

		if (optHandler) {
			return optHandler.apply(thisObj, args);
		}
	},


	// View
	// -----------------------------------------------------------------------------------------------------------------


	// Given a view name for a custom view or a standard view, creates a ready-to-go View object
	instantiateView: function(viewType) {
		var spec = this.getViewSpec(viewType);

		return new spec['class'](this, spec);
	},


	// Returns a boolean about whether the view is okay to instantiate at some point
	isValidViewType: function(viewType) {
		return Boolean(this.getViewSpec(viewType));
	},


	changeView: function(viewName, dateOrRange) {

		if (dateOrRange) {

			if (dateOrRange.start && dateOrRange.end) { // a range
				this.recordOptionOverrides({ // will not rerender
					visibleRange: dateOrRange
				});
			}
			else { // a date
				this.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate
			}
		}

		this.renderView(viewName);
	},


	// Forces navigation to a view for the given date.
	// `viewType` can be a specific view name or a generic one like "week" or "day".
	zoomTo: function(newDate, viewType) {
		var spec;

		viewType = viewType || 'day'; // day is default zoom
		spec = this.getViewSpec(viewType) || this.getUnitViewSpec(viewType);

		this.currentDate = newDate.clone();
		this.renderView(spec ? spec.type : null);
	},


	// Current Date
	// -----------------------------------------------------------------------------------------------------------------


	initCurrentDate: function() {
		var defaultDateInput = this.opt('defaultDate');

		// compute the initial ambig-timezone date
		if (defaultDateInput != null) {
			this.currentDate = this.moment(defaultDateInput).stripZone();
		}
		else {
			this.currentDate = this.getNow(); // getNow already returns unzoned
		}
	},


	prev: function() {
		var prevInfo = this.view.buildPrevDateProfile(this.currentDate);

		if (prevInfo.isValid) {
			this.currentDate = prevInfo.date;
			this.renderView();
		}
	},


	next: function() {
		var nextInfo = this.view.buildNextDateProfile(this.currentDate);

		if (nextInfo.isValid) {
			this.currentDate = nextInfo.date;
			this.renderView();
		}
	},


	prevYear: function() {
		this.currentDate.add(-1, 'years');
		this.renderView();
	},


	nextYear: function() {
		this.currentDate.add(1, 'years');
		this.renderView();
	},


	today: function() {
		this.currentDate = this.getNow(); // should deny like prev/next?
		this.renderView();
	},


	gotoDate: function(zonedDateInput) {
		this.currentDate = this.moment(zonedDateInput).stripZone();
		this.renderView();
	},


	incrementDate: function(delta) {
		this.currentDate.add(moment.duration(delta));
		this.renderView();
	},


	// for external API
	getDate: function() {
		return this.applyTimezone(this.currentDate); // infuse the calendar's timezone
	},


	// Loading Triggering
	// -----------------------------------------------------------------------------------------------------------------


	// Should be called when any type of async data fetching begins
	pushLoading: function() {
		if (!(this.loadingLevel++)) {
			this.publiclyTrigger('loading', null, true, this.view);
		}
	},


	// Should be called when any type of async data fetching completes
	popLoading: function() {
		if (!(--this.loadingLevel)) {
			this.publiclyTrigger('loading', null, false, this.view);
		}
	},


	// Selection
	// -----------------------------------------------------------------------------------------------------------------


	// this public method receives start/end dates in any format, with any timezone
	select: function(zonedStartInput, zonedEndInput) {
		this.view.select(
			this.buildSelectSpan.apply(this, arguments)
		);
	},


	unselect: function() { // safe to be called before renderView
		if (this.view) {
			this.view.unselect();
		}
	},


	// Given arguments to the select method in the API, returns a span (unzoned start/end and other info)
	buildSelectSpan: function(zonedStartInput, zonedEndInput) {
		var start = this.moment(zonedStartInput).stripZone();
		var end;

		if (zonedEndInput) {
			end = this.moment(zonedEndInput).stripZone();
		}
		else if (start.hasTime()) {
			end = start.clone().add(this.defaultTimedEventDuration);
		}
		else {
			end = start.clone().add(this.defaultAllDayEventDuration);
		}

		return { start: start, end: end };
	},


	// Misc
	// -----------------------------------------------------------------------------------------------------------------


	// will return `null` if invalid range
	parseRange: function(rangeInput) {
		var start = null;
		var end = null;

		if (rangeInput.start) {
			start = this.moment(rangeInput.start).stripZone();
		}

		if (rangeInput.end) {
			end = this.moment(rangeInput.end).stripZone();
		}

		if (!start && !end) {
			return null;
		}

		if (start && end && end.isBefore(start)) {
			return null;
		}

		return { start: start, end: end };
	},


	rerenderEvents: function() { // API method. destroys old events if previously rendered.
		if (this.elementVisible()) {
			this.reportEventChange(); // will re-trasmit events to the view, causing a rerender
		}
	}

});

;;
/*
Options binding/triggering system.
*/
Calendar.mixin({

	dirDefaults: null, // option defaults related to LTR or RTL
	localeDefaults: null, // option defaults related to current locale
	overrides: null, // option overrides given to the fullCalendar constructor
	dynamicOverrides: null, // options set with dynamic setter method. higher precedence than view overrides.
	optionsModel: null, // all defaults combined with overrides


	initOptionsInternals: function(overrides) {
		this.overrides = $.extend({}, overrides); // make a copy
		this.dynamicOverrides = {};
		this.optionsModel = new Model();

		this.populateOptionsHash();
	},


	// public getter/setter
	option: function(name, value) {
		var newOptionHash;

		if (typeof name === 'string') {
			if (value === undefined) { // getter
				return this.optionsModel.get(name);
			}
			else { // setter for individual option
				newOptionHash = {};
				newOptionHash[name] = value;
				this.setOptions(newOptionHash);
			}
		}
		else if (typeof name === 'object') { // compound setter with object input
			this.setOptions(name);
		}
	},


	// private getter
	opt: function(name) {
		return this.optionsModel.get(name);
	},


	setOptions: function(newOptionHash) {
		var optionCnt = 0;
		var optionName;

		this.recordOptionOverrides(newOptionHash);

		for (optionName in newOptionHash) {
			optionCnt++;
		}

		// special-case handling of single option change.
		// if only one option change, `optionName` will be its name.
		if (optionCnt === 1) {
			if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {
				this.updateSize(true); // true = allow recalculation of height
				return;
			}
			else if (optionName === 'defaultDate') {
				return; // can't change date this way. use gotoDate instead
			}
			else if (optionName === 'businessHours') {
				if (this.view) {
					this.view.unrenderBusinessHours();
					this.view.renderBusinessHours();
				}
				return;
			}
			else if (optionName === 'timezone') {
				this.rezoneArrayEventSources();
				this.refetchEvents();
				return;
			}
		}

		// catch-all. rerender the header and footer and rebuild/rerender the current view
		this.renderHeader();
		this.renderFooter();

		// even non-current views will be affected by this option change. do before rerender
		// TODO: detangle
		this.viewsByType = {};

		this.reinitView();
	},


	// Computes the flattened options hash for the calendar and assigns to `this.options`.
	// Assumes this.overrides and this.dynamicOverrides have already been initialized.
	populateOptionsHash: function() {
		var locale, localeDefaults;
		var isRTL, dirDefaults;
		var rawOptions;

		locale = firstDefined( // explicit locale option given?
			this.dynamicOverrides.locale,
			this.overrides.locale
		);
		localeDefaults = localeOptionHash[locale];
		if (!localeDefaults) { // explicit locale option not given or invalid?
			locale = Calendar.defaults.locale;
			localeDefaults = localeOptionHash[locale] || {};
		}

		isRTL = firstDefined( // based on options computed so far, is direction RTL?
			this.dynamicOverrides.isRTL,
			this.overrides.isRTL,
			localeDefaults.isRTL,
			Calendar.defaults.isRTL
		);
		dirDefaults = isRTL ? Calendar.rtlDefaults : {};

		this.dirDefaults = dirDefaults;
		this.localeDefaults = localeDefaults;

		rawOptions = mergeOptions([ // merge defaults and overrides. lowest to highest precedence
			Calendar.defaults, // global defaults
			dirDefaults,
			localeDefaults,
			this.overrides,
			this.dynamicOverrides
		]);
		populateInstanceComputableOptions(rawOptions); // fill in gaps with computed options

		this.optionsModel.reset(rawOptions);
	},


	// stores the new options internally, but does not rerender anything.
	recordOptionOverrides: function(newOptionHash) {
		var optionName;

		for (optionName in newOptionHash) {
			this.dynamicOverrides[optionName] = newOptionHash[optionName];
		}

		this.viewSpecCache = {}; // the dynamic override invalidates the options in this cache, so just clear it
		this.populateOptionsHash(); // this.options needs to be recomputed after the dynamic override
	}

});

;;

Calendar.mixin({

	defaultAllDayEventDuration: null,
	defaultTimedEventDuration: null,
	localeData: null,


	initMomentInternals: function() {
		var _this = this;

		this.defaultAllDayEventDuration = moment.duration(this.opt('defaultAllDayEventDuration'));
		this.defaultTimedEventDuration = moment.duration(this.opt('defaultTimedEventDuration'));

		// Called immediately, and when any of the options change.
		// Happens before any internal objects rebuild or rerender, because this is very core.
		this.optionsModel.watch('buildingMomentLocale', [
			'?locale', '?monthNames', '?monthNamesShort', '?dayNames', '?dayNamesShort',
			'?firstDay', '?weekNumberCalculation'
		], function(opts) {
			var weekNumberCalculation = opts.weekNumberCalculation;
			var firstDay = opts.firstDay;
			var _week;

			// normalize
			if (weekNumberCalculation === 'iso') {
				weekNumberCalculation = 'ISO'; // normalize
			}

			var localeData = createObject( // make a cheap copy
				getMomentLocaleData(opts.locale) // will fall back to en
			);

			if (opts.monthNames) {
				localeData._months = opts.monthNames;
			}
			if (opts.monthNamesShort) {
				localeData._monthsShort = opts.monthNamesShort;
			}
			if (opts.dayNames) {
				localeData._weekdays = opts.dayNames;
			}
			if (opts.dayNamesShort) {
				localeData._weekdaysShort = opts.dayNamesShort;
			}

			if (firstDay == null && weekNumberCalculation === 'ISO') {
				firstDay = 1;
			}
			if (firstDay != null) {
				_week = createObject(localeData._week); // _week: { dow: # }
				_week.dow = firstDay;
				localeData._week = _week;
			}

			if ( // whitelist certain kinds of input
				weekNumberCalculation === 'ISO' ||
				weekNumberCalculation === 'local' ||
				typeof weekNumberCalculation === 'function'
			) {
				localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it
			}

			_this.localeData = localeData;

			// If the internal current date object already exists, move to new locale.
			// We do NOT need to do this technique for event dates, because this happens when converting to "segments".
			if (_this.currentDate) {
				_this.localizeMoment(_this.currentDate); // sets to localeData
			}
		});
	},


	// Builds a moment using the settings of the current calendar: timezone and locale.
	// Accepts anything the vanilla moment() constructor accepts.
	moment: function() {
		var mom;

		if (this.opt('timezone') === 'local') {
			mom = FC.moment.apply(null, arguments);

			// Force the moment to be local, because FC.moment doesn't guarantee it.
			if (mom.hasTime()) { // don't give ambiguously-timed moments a local zone
				mom.local();
			}
		}
		else if (this.opt('timezone') === 'UTC') {
			mom = FC.moment.utc.apply(null, arguments); // process as UTC
		}
		else {
			mom = FC.moment.parseZone.apply(null, arguments); // let the input decide the zone
		}

		this.localizeMoment(mom); // TODO

		return mom;
	},


	// Updates the given moment's locale settings to the current calendar locale settings.
	localizeMoment: function(mom) {
		mom._locale = this.localeData;
	},


	// Returns a boolean about whether or not the calendar knows how to calculate
	// the timezone offset of arbitrary dates in the current timezone.
	getIsAmbigTimezone: function() {
		return this.opt('timezone') !== 'local' && this.opt('timezone') !== 'UTC';
	},


	// Returns a copy of the given date in the current timezone. Has no effect on dates without times.
	applyTimezone: function(date) {
		if (!date.hasTime()) {
			return date.clone();
		}

		var zonedDate = this.moment(date.toArray());
		var timeAdjust = date.time() - zonedDate.time();
		var adjustedZonedDate;

		// Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)
		if (timeAdjust) { // is the time result different than expected?
			adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds
			if (date.time() - adjustedZonedDate.time() === 0) { // does it match perfectly now?
				zonedDate = adjustedZonedDate;
			}
		}

		return zonedDate;
	},


	// Returns a moment for the current date, as defined by the client's computer or from the `now` option.
	// Will return an moment with an ambiguous timezone.
	getNow: function() {
		var now = this.opt('now');
		if (typeof now === 'function') {
			now = now();
		}
		return this.moment(now).stripZone();
	},


	// Produces a human-readable string for the given duration.
	// Side-effect: changes the locale of the given duration.
	humanizeDuration: function(duration) {
		return duration.locale(this.opt('locale')).humanize();
	},



	// Event-Specific Date Utilities. TODO: move
	// -----------------------------------------------------------------------------------------------------------------


	// Get an event's normalized end date. If not present, calculate it from the defaults.
	getEventEnd: function(event) {
		if (event.end) {
			return event.end.clone();
		}
		else {
			return this.getDefaultEventEnd(event.allDay, event.start);
		}
	},


	// Given an event's allDay status and start date, return what its fallback end date should be.
	// TODO: rename to computeDefaultEventEnd
	getDefaultEventEnd: function(allDay, zonedStart) {
		var end = zonedStart.clone();

		if (allDay) {
			end.stripTime().add(this.defaultAllDayEventDuration);
		}
		else {
			end.add(this.defaultTimedEventDuration);
		}

		if (this.getIsAmbigTimezone()) {
			end.stripZone(); // we don't know what the tzo should be
		}

		return end;
	}

});

;;

Calendar.mixin({

	viewSpecCache: null, // cache of view definitions (initialized in Calendar.js)


	// Gets information about how to create a view. Will use a cache.
	getViewSpec: function(viewType) {
		var cache = this.viewSpecCache;

		return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
	},


	// Given a duration singular unit, like "week" or "day", finds a matching view spec.
	// Preference is given to views that have corresponding buttons.
	getUnitViewSpec: function(unit) {
		var viewTypes;
		var i;
		var spec;

		if ($.inArray(unit, unitsDesc) != -1) {

			// put views that have buttons first. there will be duplicates, but oh well
			viewTypes = this.header.getViewsWithButtons(); // TODO: include footer as well?
			$.each(FC.views, function(viewType) { // all views
				viewTypes.push(viewType);
			});

			for (i = 0; i < viewTypes.length; i++) {
				spec = this.getViewSpec(viewTypes[i]);
				if (spec) {
					if (spec.singleUnit == unit) {
						return spec;
					}
				}
			}
		}
	},


	// Builds an object with information on how to create a given view
	buildViewSpec: function(requestedViewType) {
		var viewOverrides = this.overrides.views || {};
		var specChain = []; // for the view. lowest to highest priority
		var defaultsChain = []; // for the view. lowest to highest priority
		var overridesChain = []; // for the view. lowest to highest priority
		var viewType = requestedViewType;
		var spec; // for the view
		var overrides; // for the view
		var durationInput;
		var duration;
		var unit;

		// iterate from the specific view definition to a more general one until we hit an actual View class
		while (viewType) {
			spec = fcViews[viewType];
			overrides = viewOverrides[viewType];
			viewType = null; // clear. might repopulate for another iteration

			if (typeof spec === 'function') { // TODO: deprecate
				spec = { 'class': spec };
			}

			if (spec) {
				specChain.unshift(spec);
				defaultsChain.unshift(spec.defaults || {});
				durationInput = durationInput || spec.duration;
				viewType = viewType || spec.type;
			}

			if (overrides) {
				overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level
				durationInput = durationInput || overrides.duration;
				viewType = viewType || overrides.type;
			}
		}

		spec = mergeProps(specChain);
		spec.type = requestedViewType;
		if (!spec['class']) {
			return false;
		}

		// fall back to top-level `duration` option
		durationInput = durationInput ||
			this.dynamicOverrides.duration ||
			this.overrides.duration;

		if (durationInput) {
			duration = moment.duration(durationInput);

			if (duration.valueOf()) { // valid?

				unit = computeDurationGreatestUnit(duration, durationInput);

				spec.duration = duration;
				spec.durationUnit = unit;

				// view is a single-unit duration, like "week" or "day"
				// incorporate options for this. lowest priority
				if (duration.as(unit) === 1) {
					spec.singleUnit = unit;
					overridesChain.unshift(viewOverrides[unit] || {});
				}
			}
		}

		spec.defaults = mergeOptions(defaultsChain);
		spec.overrides = mergeOptions(overridesChain);

		this.buildViewSpecOptions(spec);
		this.buildViewSpecButtonText(spec, requestedViewType);

		return spec;
	},


	// Builds and assigns a view spec's options object from its already-assigned defaults and overrides
	buildViewSpecOptions: function(spec) {
		spec.options = mergeOptions([ // lowest to highest priority
			Calendar.defaults, // global defaults
			spec.defaults, // view's defaults (from ViewSubclass.defaults)
			this.dirDefaults,
			this.localeDefaults, // locale and dir take precedence over view's defaults!
			this.overrides, // calendar's overrides (options given to constructor)
			spec.overrides, // view's overrides (view-specific options)
			this.dynamicOverrides // dynamically set via setter. highest precedence
		]);
		populateInstanceComputableOptions(spec.options);
	},


	// Computes and assigns a view spec's buttonText-related options
	buildViewSpecButtonText: function(spec, requestedViewType) {

		// given an options object with a possible `buttonText` hash, lookup the buttonText for the
		// requested view, falling back to a generic unit entry like "week" or "day"
		function queryButtonText(options) {
			var buttonText = options.buttonText || {};
			return buttonText[requestedViewType] ||
				// view can decide to look up a certain key
				(spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||
				// a key like "month"
				(spec.singleUnit ? buttonText[spec.singleUnit] : null);
		}

		// highest to lowest priority
		spec.buttonTextOverride =
			queryButtonText(this.dynamicOverrides) ||
			queryButtonText(this.overrides) || // constructor-specified buttonText lookup hash takes precedence
			spec.overrides.buttonText; // `buttonText` for view-specific options is a string

		// highest to lowest priority. mirrors buildViewSpecOptions
		spec.buttonTextDefault =
			queryButtonText(this.localeDefaults) ||
			queryButtonText(this.dirDefaults) ||
			spec.defaults.buttonText || // a single string. from ViewSubclass.defaults
			queryButtonText(Calendar.defaults) ||
			(spec.duration ? this.humanizeDuration(spec.duration) : null) || // like "3 days"
			requestedViewType; // fall back to given view name
	}

});

;;

Calendar.mixin({

	el: null,
	contentEl: null,
	suggestedViewHeight: null,
	windowResizeProxy: null,
	ignoreWindowResize: 0,


	render: function() {
		if (!this.contentEl) {
			this.initialRender();
		}
		else if (this.elementVisible()) {
			// mainly for the public API
			this.calcSize();
			this.renderView();
		}
	},


	initialRender: function() {
		var _this = this;
		var el = this.el;

		el.addClass('fc');

		// event delegation for nav links
		el.on('click.fc', 'a[data-goto]', function(ev) {
			var anchorEl = $(this);
			var gotoOptions = anchorEl.data('goto'); // will automatically parse JSON
			var date = _this.moment(gotoOptions.date);
			var viewType = gotoOptions.type;

			// property like "navLinkDayClick". might be a string or a function
			var customAction = _this.view.opt('navLink' + capitaliseFirstLetter(viewType) + 'Click');

			if (typeof customAction === 'function') {
				customAction(date, ev);
			}
			else {
				if (typeof customAction === 'string') {
					viewType = customAction;
				}
				_this.zoomTo(date, viewType);
			}
		});

		// called immediately, and upon option change
		this.optionsModel.watch('applyingThemeClasses', [ '?theme' ], function(opts) {
			el.toggleClass('ui-widget', opts.theme);
			el.toggleClass('fc-unthemed', !opts.theme);
		});

		// called immediately, and upon option change.
		// HACK: locale often affects isRTL, so we explicitly listen to that too.
		this.optionsModel.watch('applyingDirClasses', [ '?isRTL', '?locale' ], function(opts) {
			el.toggleClass('fc-ltr', !opts.isRTL);
			el.toggleClass('fc-rtl', opts.isRTL);
		});

		this.contentEl = $("<div class='fc-view-container'/>").prependTo(el);

		this.initToolbars();
		this.renderHeader();
		this.renderFooter();
		this.renderView(this.opt('defaultView'));

		if (this.opt('handleWindowResize')) {
			$(window).resize(
				this.windowResizeProxy = debounce( // prevents rapid calls
					this.windowResize.bind(this),
					this.opt('windowResizeDelay')
				)
			);
		}
	},


	destroy: function() {

		if (this.view) {
			this.view.removeElement();

			// NOTE: don't null-out this.view in case API methods are called after destroy.
			// It is still the "current" view, just not rendered.
		}

		this.toolbarsManager.proxyCall('removeElement');
		this.contentEl.remove();
		this.el.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');

		this.el.off('.fc'); // unbind nav link handlers

		if (this.windowResizeProxy) {
			$(window).unbind('resize', this.windowResizeProxy);
			this.windowResizeProxy = null;
		}

		GlobalEmitter.unneeded();
	},


	elementVisible: function() {
		return this.el.is(':visible');
	},



	// View Rendering
	// -----------------------------------------------------------------------------------


	// Renders a view because of a date change, view-type change, or for the first time.
	// If not given a viewType, keep the current view but render different dates.
	// Accepts an optional scroll state to restore to.
	renderView: function(viewType, forcedScroll) {

		this.ignoreWindowResize++;

		var needsClearView = this.view && viewType && this.view.type !== viewType;

		// if viewType is changing, remove the old view's rendering
		if (needsClearView) {
			this.freezeContentHeight(); // prevent a scroll jump when view element is removed
			this.clearView();
		}

		// if viewType changed, or the view was never created, create a fresh view
		if (!this.view && viewType) {
			this.view =
				this.viewsByType[viewType] ||
				(this.viewsByType[viewType] = this.instantiateView(viewType));

			this.view.setElement(
				$("<div class='fc-view fc-" + viewType + "-view' />").appendTo(this.contentEl)
			);
			this.toolbarsManager.proxyCall('activateButton', viewType);
		}

		if (this.view) {

			if (forcedScroll) {
				this.view.addForcedScroll(forcedScroll);
			}

			if (this.elementVisible()) {
				this.currentDate = this.view.setDate(this.currentDate);
			}
		}

		if (needsClearView) {
			this.thawContentHeight();
		}

		this.ignoreWindowResize--;
	},


	// Unrenders the current view and reflects this change in the Header.
	// Unregsiters the `view`, but does not remove from viewByType hash.
	clearView: function() {
		this.toolbarsManager.proxyCall('deactivateButton', this.view.type);
		this.view.removeElement();
		this.view = null;
	},


	// Destroys the view, including the view object. Then, re-instantiates it and renders it.
	// Maintains the same scroll state.
	// TODO: maintain any other user-manipulated state.
	reinitView: function() {
		this.ignoreWindowResize++;
		this.freezeContentHeight();

		var viewType = this.view.type;
		var scrollState = this.view.queryScroll();
		this.clearView();
		this.calcSize();
		this.renderView(viewType, scrollState);

		this.thawContentHeight();
		this.ignoreWindowResize--;
	},


	// Resizing
	// -----------------------------------------------------------------------------------


	getSuggestedViewHeight: function() {
		if (this.suggestedViewHeight === null) {
			this.calcSize();
		}
		return this.suggestedViewHeight;
	},


	isHeightAuto: function() {
		return this.opt('contentHeight') === 'auto' || this.opt('height') === 'auto';
	},


	updateSize: function(shouldRecalc) {
		if (this.elementVisible()) {

			if (shouldRecalc) {
				this._calcSize();
			}

			this.ignoreWindowResize++;
			this.view.updateSize(true); // isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()
			this.ignoreWindowResize--;

			return true; // signal success
		}
	},


	calcSize: function() {
		if (this.elementVisible()) {
			this._calcSize();
		}
	},


	_calcSize: function() { // assumes elementVisible
		var contentHeightInput = this.opt('contentHeight');
		var heightInput = this.opt('height');

		if (typeof contentHeightInput === 'number') { // exists and not 'auto'
			this.suggestedViewHeight = contentHeightInput;
		}
		else if (typeof contentHeightInput === 'function') { // exists and is a function
			this.suggestedViewHeight = contentHeightInput();
		}
		else if (typeof heightInput === 'number') { // exists and not 'auto'
			this.suggestedViewHeight = heightInput - this.queryToolbarsHeight();
		}
		else if (typeof heightInput === 'function') { // exists and is a function
			this.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();
		}
		else if (heightInput === 'parent') { // set to height of parent element
			this.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();
		}
		else {
			this.suggestedViewHeight = Math.round(
				this.contentEl.width() /
				Math.max(this.opt('aspectRatio'), .5)
			);
		}
	},


	windowResize: function(ev) {
		if (
			!this.ignoreWindowResize &&
			ev.target === window && // so we don't process jqui "resize" events that have bubbled up
			this.view.renderRange // view has already been rendered
		) {
			if (this.updateSize(true)) {
				this.view.publiclyTrigger('windowResize', this.el[0]);
			}
		}
	},


	/* Height "Freezing"
	-----------------------------------------------------------------------------*/


	freezeContentHeight: function() {
		this.contentEl.css({
			width: '100%',
			height: this.contentEl.height(),
			overflow: 'hidden'
		});
	},


	thawContentHeight: function() {
		this.contentEl.css({
			width: '',
			height: '',
			overflow: ''
		});
	}

});

;;

Calendar.mixin({

	header: null,
	footer: null,
	toolbarsManager: null,


	initToolbars: function() {
		this.header = new Toolbar(this, this.computeHeaderOptions());
		this.footer = new Toolbar(this, this.computeFooterOptions());
		this.toolbarsManager = new Iterator([ this.header, this.footer ]);
	},


	computeHeaderOptions: function() {
		return {
			extraClasses: 'fc-header-toolbar',
			layout: this.opt('header')
		};
	},


	computeFooterOptions: function() {
		return {
			extraClasses: 'fc-footer-toolbar',
			layout: this.opt('footer')
		};
	},


	// can be called repeatedly and Header will rerender
	renderHeader: function() {
		var header = this.header;

		header.setToolbarOptions(this.computeHeaderOptions());
		header.render();

		if (header.el) {
			this.el.prepend(header.el);
		}
	},


	// can be called repeatedly and Footer will rerender
	renderFooter: function() {
		var footer = this.footer;

		footer.setToolbarOptions(this.computeFooterOptions());
		footer.render();

		if (footer.el) {
			this.el.append(footer.el);
		}
	},


	setToolbarsTitle: function(title) {
		this.toolbarsManager.proxyCall('updateTitle', title);
	},


	updateToolbarButtons: function() {
		var now = this.getNow();
		var view = this.view;
		var todayInfo = view.buildDateProfile(now);
		var prevInfo = view.buildPrevDateProfile(this.currentDate);
		var nextInfo = view.buildNextDateProfile(this.currentDate);

		this.toolbarsManager.proxyCall(
			(todayInfo.isValid && !isDateWithinRange(now, view.currentRange)) ?
				'enableButton' :
				'disableButton',
			'today'
		);

		this.toolbarsManager.proxyCall(
			prevInfo.isValid ?
				'enableButton' :
				'disableButton',
			'prev'
		);

		this.toolbarsManager.proxyCall(
			nextInfo.isValid ?
				'enableButton' :
				'disableButton',
			'next'
		);
	},


	queryToolbarsHeight: function() {
		return this.toolbarsManager.items.reduce(function(accumulator, toolbar) {
			var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin
			return accumulator + toolbarHeight;
		}, 0);
	}

});

;;

Calendar.defaults = {

	titleRangeSeparator: ' \u2013 ', // en dash
	monthYearFormat: 'MMMM YYYY', // required for en. other locales rely on datepicker computable option

	defaultTimedEventDuration: '02:00:00',
	defaultAllDayEventDuration: { days: 1 },
	forceEventDuration: false,
	nextDayThreshold: '09:00:00', // 9am

	// display
	defaultView: 'month',
	aspectRatio: 1.35,
	header: {
		left: 'title',
		center: '',
		right: 'today prev,next'
	},
	weekends: true,
	weekNumbers: false,

	weekNumberTitle: 'W',
	weekNumberCalculation: 'local',
	
	//editable: false,

	//nowIndicator: false,

	scrollTime: '06:00:00',
	minTime: '00:00:00',
	maxTime: '24:00:00',
	showNonCurrentDates: true,
	
	// event ajax
	lazyFetching: true,
	startParam: 'start',
	endParam: 'end',
	timezoneParam: 'timezone',

	timezone: false,

	//allDayDefault: undefined,

	// locale
	isRTL: false,
	buttonText: {
		prev: "prev",
		next: "next",
		prevYear: "prev year",
		nextYear: "next year",
		year: 'year', // TODO: locale files need to specify this
		today: 'today',
		month: 'month',
		week: 'week',
		day: 'day'
	},

	buttonIcons: {
		prev: 'left-single-arrow',
		next: 'right-single-arrow',
		prevYear: 'left-double-arrow',
		nextYear: 'right-double-arrow'
	},

	allDayText: 'all-day',
	
	// jquery-ui theming
	theme: false,
	themeButtonIcons: {
		prev: 'circle-triangle-w',
		next: 'circle-triangle-e',
		prevYear: 'seek-prev',
		nextYear: 'seek-next'
	},

	//eventResizableFromStart: false,
	dragOpacity: .75,
	dragRevertDuration: 500,
	dragScroll: true,
	
	//selectable: false,
	unselectAuto: true,
	//selectMinDistance: 0,
	
	dropAccept: '*',

	eventOrder: 'title',
	//eventRenderWait: null,

	eventLimit: false,
	eventLimitText: 'more',
	eventLimitClick: 'popover',
	dayPopoverFormat: 'LL',
	
	handleWindowResize: true,
	windowResizeDelay: 100, // milliseconds before an updateSize happens

	longPressDelay: 1000
	
};


Calendar.englishDefaults = { // used by locale.js
	dayPopoverFormat: 'dddd, MMMM D'
};


Calendar.rtlDefaults = { // right-to-left defaults
	header: { // TODO: smarter solution (first/center/last ?)
		left: 'next,prev today',
		center: '',
		right: 'title'
	},
	buttonIcons: {
		prev: 'right-single-arrow',
		next: 'left-single-arrow',
		prevYear: 'right-double-arrow',
		nextYear: 'left-double-arrow'
	},
	themeButtonIcons: {
		prev: 'circle-triangle-e',
		next: 'circle-triangle-w',
		nextYear: 'seek-prev',
		prevYear: 'seek-next'
	}
};

;;

var localeOptionHash = FC.locales = {}; // initialize and expose


// TODO: document the structure and ordering of a FullCalendar locale file


// Initialize jQuery UI datepicker translations while using some of the translations
// Will set this as the default locales for datepicker.
FC.datepickerLocale = function(localeCode, dpLocaleCode, dpOptions) {

	// get the FullCalendar internal option hash for this locale. create if necessary
	var fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});

	// transfer some simple options from datepicker to fc
	fcOptions.isRTL = dpOptions.isRTL;
	fcOptions.weekNumberTitle = dpOptions.weekHeader;

	// compute some more complex options from datepicker
	$.each(dpComputableOptions, function(name, func) {
		fcOptions[name] = func(dpOptions);
	});

	// is jQuery UI Datepicker is on the page?
	if ($.datepicker) {

		// Register the locale data.
		// FullCalendar and MomentJS use locale codes like "pt-br" but Datepicker
		// does it like "pt-BR" or if it doesn't have the locale, maybe just "pt".
		// Make an alias so the locale can be referenced either way.
		$.datepicker.regional[dpLocaleCode] =
			$.datepicker.regional[localeCode] = // alias
				dpOptions;

		// Alias 'en' to the default locale data. Do this every time.
		$.datepicker.regional.en = $.datepicker.regional[''];

		// Set as Datepicker's global defaults.
		$.datepicker.setDefaults(dpOptions);
	}
};


// Sets FullCalendar-specific translations. Will set the locales as the global default.
FC.locale = function(localeCode, newFcOptions) {
	var fcOptions;
	var momOptions;

	// get the FullCalendar internal option hash for this locale. create if necessary
	fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});

	// provided new options for this locales? merge them in
	if (newFcOptions) {
		fcOptions = localeOptionHash[localeCode] = mergeOptions([ fcOptions, newFcOptions ]);
	}

	// compute locale options that weren't defined.
	// always do this. newFcOptions can be undefined when initializing from i18n file,
	// so no way to tell if this is an initialization or a default-setting.
	momOptions = getMomentLocaleData(localeCode); // will fall back to en
	$.each(momComputableOptions, function(name, func) {
		if (fcOptions[name] == null) {
			fcOptions[name] = func(momOptions, fcOptions);
		}
	});

	// set it as the default locale for FullCalendar
	Calendar.defaults.locale = localeCode;
};


// NOTE: can't guarantee any of these computations will run because not every locale has datepicker
// configs, so make sure there are English fallbacks for these in the defaults file.
var dpComputableOptions = {

	buttonText: function(dpOptions) {
		return {
			// the translations sometimes wrongly contain HTML entities
			prev: stripHtmlEntities(dpOptions.prevText),
			next: stripHtmlEntities(dpOptions.nextText),
			today: stripHtmlEntities(dpOptions.currentText)
		};
	},

	// Produces format strings like "MMMM YYYY" -> "September 2014"
	monthYearFormat: function(dpOptions) {
		return dpOptions.showMonthAfterYear ?
			'YYYY[' + dpOptions.yearSuffix + '] MMMM' :
			'MMMM YYYY[' + dpOptions.yearSuffix + ']';
	}

};

var momComputableOptions = {

	// Produces format strings like "ddd M/D" -> "Fri 9/15"
	dayOfMonthFormat: function(momOptions, fcOptions) {
		var format = momOptions.longDateFormat('l'); // for the format like "M/D/YYYY"

		// strip the year off the edge, as well as other misc non-whitespace chars
		format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, '');

		if (fcOptions.isRTL) {
			format += ' ddd'; // for RTL, add day-of-week to end
		}
		else {
			format = 'ddd ' + format; // for LTR, add day-of-week to beginning
		}
		return format;
	},

	// Produces format strings like "h:mma" -> "6:00pm"
	mediumTimeFormat: function(momOptions) { // can't be called `timeFormat` because collides with option
		return momOptions.longDateFormat('LT')
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},

	// Produces format strings like "h(:mm)a" -> "6pm" / "6:30pm"
	smallTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '(:mm)')
			.replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},

	// Produces format strings like "h(:mm)t" -> "6p" / "6:30p"
	extraSmallTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '(:mm)')
			.replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
			.replace(/\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
	},

	// Produces format strings like "ha" / "H" -> "6pm" / "18"
	hourFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '')
			.replace(/(\Wmm)$/, '') // like above, but for foreign locales
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},

	// Produces format strings like "h:mm" -> "6:30" (with no AM/PM)
	noMeridiemTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(/\s*a$/i, ''); // remove trailing AM/PM
	}

};


// options that should be computed off live calendar options (considers override options)
// TODO: best place for this? related to locale?
// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it
var instanceComputableOptions = {

	// Produces format strings for results like "Mo 16"
	smallDayDateFormat: function(options) {
		return options.isRTL ?
			'D dd' :
			'dd D';
	},

	// Produces format strings for results like "Wk 5"
	weekFormat: function(options) {
		return options.isRTL ?
			'w[ ' + options.weekNumberTitle + ']' :
			'[' + options.weekNumberTitle + ' ]w';
	},

	// Produces format strings for results like "Wk5"
	smallWeekFormat: function(options) {
		return options.isRTL ?
			'w[' + options.weekNumberTitle + ']' :
			'[' + options.weekNumberTitle + ']w';
	}

};

// TODO: make these computable properties in optionsModel
function populateInstanceComputableOptions(options) {
	$.each(instanceComputableOptions, function(name, func) {
		if (options[name] == null) {
			options[name] = func(options);
		}
	});
}


// Returns moment's internal locale data. If doesn't exist, returns English.
function getMomentLocaleData(localeCode) {
	return moment.localeData(localeCode) || moment.localeData('en');
}


// Initialize English by forcing computation of moment-derived options.
// Also, sets it as the default.
FC.locale('en', Calendar.englishDefaults);

;;

FC.sourceNormalizers = [];
FC.sourceFetchers = [];

var ajaxDefaults = {
	dataType: 'json',
	cache: false
};

var eventGUID = 1;


function EventManager() { // assumed to be a calendar
	var t = this;


	// exports
	t.requestEvents = requestEvents;
	t.reportEventChange = reportEventChange;
	t.isFetchNeeded = isFetchNeeded;
	t.fetchEvents = fetchEvents;
	t.fetchEventSources = fetchEventSources;
	t.refetchEvents = refetchEvents;
	t.refetchEventSources = refetchEventSources;
	t.getEventSources = getEventSources;
	t.getEventSourceById = getEventSourceById;
	t.addEventSource = addEventSource;
	t.removeEventSource = removeEventSource;
	t.removeEventSources = removeEventSources;
	t.updateEvent = updateEvent;
	t.updateEvents = updateEvents;
	t.renderEvent = renderEvent;
	t.renderEvents = renderEvents;
	t.removeEvents = removeEvents;
	t.clientEvents = clientEvents;
	t.mutateEvent = mutateEvent;
	t.normalizeEventDates = normalizeEventDates;
	t.normalizeEventTimes = normalizeEventTimes;


	// locals
	var stickySource = { events: [] };
	var sources = [ stickySource ];
	var rangeStart, rangeEnd;
	var pendingSourceCnt = 0; // outstanding fetch requests, max one per source
	var cache = []; // holds events that have already been expanded
	var prunedCache; // like cache, but only events that intersect with rangeStart/rangeEnd


	$.each(
		(t.opt('events') ? [ t.opt('events') ] : []).concat(t.opt('eventSources') || []),
		function(i, sourceInput) {
			var source = buildEventSource(sourceInput);
			if (source) {
				sources.push(source);
			}
		}
	);



	function requestEvents(start, end) {
		if (!t.opt('lazyFetching') || isFetchNeeded(start, end)) {
			return fetchEvents(start, end);
		}
		else {
			return Promise.resolve(prunedCache);
		}
	}


	function reportEventChange() {
		prunedCache = filterEventsWithinRange(cache);
		t.trigger('eventsReset', prunedCache);
	}


	function filterEventsWithinRange(events) {
		var filteredEvents = [];
		var i, event;

		for (i = 0; i < events.length; i++) {
			event = events[i];

			if (
				event.start.clone().stripZone() < rangeEnd &&
				t.getEventEnd(event).stripZone() > rangeStart
			) {
				filteredEvents.push(event);
			}
		}

		return filteredEvents;
	}


	t.getEventCache = function() {
		return cache;
	};



	/* Fetching
	-----------------------------------------------------------------------------*/


	// start and end are assumed to be unzoned
	function isFetchNeeded(start, end) {
		return !rangeStart || // nothing has been fetched yet?
			start < rangeStart || end > rangeEnd; // is part of the new range outside of the old range?
	}


	function fetchEvents(start, end) {
		rangeStart = start;
		rangeEnd = end;
		return refetchEvents();
	}


	// poorly named. fetches all sources with current `rangeStart` and `rangeEnd`.
	function refetchEvents() {
		return fetchEventSources(sources, 'reset');
	}


	// poorly named. fetches a subset of event sources.
	function refetchEventSources(matchInputs) {
		return fetchEventSources(getEventSourcesByMatchArray(matchInputs));
	}


	// expects an array of event source objects (the originals, not copies)
	// `specialFetchType` is an optimization parameter that affects purging of the event cache.
	function fetchEventSources(specificSources, specialFetchType) {
		var i, source;

		if (specialFetchType === 'reset') {
			cache = [];
		}
		else if (specialFetchType !== 'add') {
			cache = excludeEventsBySources(cache, specificSources);
		}

		for (i = 0; i < specificSources.length; i++) {
			source = specificSources[i];

			// already-pending sources have already been accounted for in pendingSourceCnt
			if (source._status !== 'pending') {
				pendingSourceCnt++;
			}

			source._fetchId = (source._fetchId || 0) + 1;
			source._status = 'pending';
		}

		for (i = 0; i < specificSources.length; i++) {
			source = specificSources[i];
			tryFetchEventSource(source, source._fetchId);
		}

		if (pendingSourceCnt) {
			return Promise.construct(function(resolve) {
				t.one('eventsReceived', resolve); // will send prunedCache
			});
		}
		else { // executed all synchronously, or no sources at all
			return Promise.resolve(prunedCache);
		}
	}


	// fetches an event source and processes its result ONLY if it is still the current fetch.
	// caller is responsible for incrementing pendingSourceCnt first.
	function tryFetchEventSource(source, fetchId) {
		_fetchEventSource(source, function(eventInputs) {
			var isArraySource = $.isArray(source.events);
			var i, eventInput;
			var abstractEvent;

			if (
				// is this the source's most recent fetch?
				// if not, rely on an upcoming fetch of this source to decrement pendingSourceCnt
				fetchId === source._fetchId &&
				// event source no longer valid?
				source._status !== 'rejected'
			) {
				source._status = 'resolved';

				if (eventInputs) {
					for (i = 0; i < eventInputs.length; i++) {
						eventInput = eventInputs[i];

						if (isArraySource) { // array sources have already been convert to Event Objects
							abstractEvent = eventInput;
						}
						else {
							abstractEvent = buildEventFromInput(eventInput, source);
						}

						if (abstractEvent) { // not false (an invalid event)
							cache.push.apply( // append
								cache,
								expandEvent(abstractEvent) // add individual expanded events to the cache
							);
						}
					}
				}

				decrementPendingSourceCnt();
			}
		});
	}


	function rejectEventSource(source) {
		var wasPending = source._status === 'pending';

		source._status = 'rejected';

		if (wasPending) {
			decrementPendingSourceCnt();
		}
	}


	function decrementPendingSourceCnt() {
		pendingSourceCnt--;
		if (!pendingSourceCnt) {
			reportEventChange(cache); // updates prunedCache
			t.trigger('eventsReceived', prunedCache);
		}
	}


	function _fetchEventSource(source, callback) {
		var i;
		var fetchers = FC.sourceFetchers;
		var res;

		for (i=0; i<fetchers.length; i++) {
			res = fetchers[i].call(
				t, // this, the Calendar object
				source,
				rangeStart.clone(),
				rangeEnd.clone(),
				t.opt('timezone'),
				callback
			);

			if (res === true) {
				// the fetcher is in charge. made its own async request
				return;
			}
			else if (typeof res == 'object') {
				// the fetcher returned a new source. process it
				_fetchEventSource(res, callback);
				return;
			}
		}

		var events = source.events;
		if (events) {
			if ($.isFunction(events)) {
				t.pushLoading();
				events.call(
					t, // this, the Calendar object
					rangeStart.clone(),
					rangeEnd.clone(),
					t.opt('timezone'),
					function(events) {
						callback(events);
						t.popLoading();
					}
				);
			}
			else if ($.isArray(events)) {
				callback(events);
			}
			else {
				callback();
			}
		}else{
			var url = source.url;
			if (url) {
				var success = source.success;
				var error = source.error;
				var complete = source.complete;

				// retrieve any outbound GET/POST $.ajax data from the options
				var customData;
				if ($.isFunction(source.data)) {
					// supplied as a function that returns a key/value object
					customData = source.data();
				}
				else {
					// supplied as a straight key/value object
					customData = source.data;
				}

				// use a copy of the custom data so we can modify the parameters
				// and not affect the passed-in object.
				var data = $.extend({}, customData || {});

				var startParam = firstDefined(source.startParam, t.opt('startParam'));
				var endParam = firstDefined(source.endParam, t.opt('endParam'));
				var timezoneParam = firstDefined(source.timezoneParam, t.opt('timezoneParam'));

				if (startParam) {
					data[startParam] = rangeStart.format();
				}
				if (endParam) {
					data[endParam] = rangeEnd.format();
				}
				if (t.opt('timezone') && t.opt('timezone') != 'local') {
					data[timezoneParam] = t.opt('timezone');
				}

				t.pushLoading();
				$.ajax($.extend({}, ajaxDefaults, source, {
					data: data,
					success: function(events) {
						events = events || [];
						var res = applyAll(success, this, arguments);
						if ($.isArray(res)) {
							events = res;
						}
						callback(events);
					},
					error: function() {
						applyAll(error, this, arguments);
						callback();
					},
					complete: function() {
						applyAll(complete, this, arguments);
						t.popLoading();
					}
				}));
			}else{
				callback();
			}
		}
	}



	/* Sources
	-----------------------------------------------------------------------------*/


	function addEventSource(sourceInput) {
		var source = buildEventSource(sourceInput);
		if (source) {
			sources.push(source);
			fetchEventSources([ source ], 'add'); // will eventually call reportEventChange
		}
	}


	function buildEventSource(sourceInput) { // will return undefined if invalid source
		var normalizers = FC.sourceNormalizers;
		var source;
		var i;

		if ($.isFunction(sourceInput) || $.isArray(sourceInput)) {
			source = { events: sourceInput };
		}
		else if (typeof sourceInput === 'string') {
			source = { url: sourceInput };
		}
		else if (typeof sourceInput === 'object') {
			source = $.extend({}, sourceInput); // shallow copy
		}

		if (source) {

			// TODO: repeat code, same code for event classNames
			if (source.className) {
				if (typeof source.className === 'string') {
					source.className = source.className.split(/\s+/);
				}
				// otherwise, assumed to be an array
			}
			else {
				source.className = [];
			}

			// for array sources, we convert to standard Event Objects up front
			if ($.isArray(source.events)) {
				source.origArray = source.events; // for removeEventSource
				source.events = $.map(source.events, function(eventInput) {
					return buildEventFromInput(eventInput, source);
				});
			}

			for (i=0; i<normalizers.length; i++) {
				normalizers[i].call(t, source);
			}

			return source;
		}
	}


	function removeEventSource(matchInput) {
		removeSpecificEventSources(
			getEventSourcesByMatch(matchInput)
		);
	}


	// if called with no arguments, removes all.
	function removeEventSources(matchInputs) {
		if (matchInputs == null) {
			removeSpecificEventSources(sources, true); // isAll=true
		}
		else {
			removeSpecificEventSources(
				getEventSourcesByMatchArray(matchInputs)
			);
		}
	}


	function removeSpecificEventSources(targetSources, isAll) {
		var i;

		// cancel pending requests
		for (i = 0; i < targetSources.length; i++) {
			rejectEventSource(targetSources[i]);
		}

		if (isAll) { // an optimization
			sources = [];
			cache = [];
		}
		else {
			// remove from persisted source list
			sources = $.grep(sources, function(source) {
				for (i = 0; i < targetSources.length; i++) {
					if (source === targetSources[i]) {
						return false; // exclude
					}
				}
				return true; // include
			});

			cache = excludeEventsBySources(cache, targetSources);
		}

		reportEventChange();
	}


	function getEventSources() {
		return sources.slice(1); // returns a shallow copy of sources with stickySource removed
	}


	function getEventSourceById(id) {
		return $.grep(sources, function(source) {
			return source.id && source.id === id;
		})[0];
	}


	// like getEventSourcesByMatch, but accepts multple match criteria (like multiple IDs)
	function getEventSourcesByMatchArray(matchInputs) {

		// coerce into an array
		if (!matchInputs) {
			matchInputs = [];
		}
		else if (!$.isArray(matchInputs)) {
			matchInputs = [ matchInputs ];
		}

		var matchingSources = [];
		var i;

		// resolve raw inputs to real event source objects
		for (i = 0; i < matchInputs.length; i++) {
			matchingSources.push.apply( // append
				matchingSources,
				getEventSourcesByMatch(matchInputs[i])
			);
		}

		return matchingSources;
	}


	// matchInput can either by a real event source object, an ID, or the function/URL for the source.
	// returns an array of matching source objects.
	function getEventSourcesByMatch(matchInput) {
		var i, source;

		// given an proper event source object
		for (i = 0; i < sources.length; i++) {
			source = sources[i];
			if (source === matchInput) {
				return [ source ];
			}
		}

		// an ID match
		source = getEventSourceById(matchInput);
		if (source) {
			return [ source ];
		}

		return $.grep(sources, function(source) {
			return isSourcesEquivalent(matchInput, source);
		});
	}


	function isSourcesEquivalent(source1, source2) {
		return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
	}


	function getSourcePrimitive(source) {
		return (
			(typeof source === 'object') ? // a normalized event source?
				(source.origArray || source.googleCalendarId || source.url || source.events) : // get the primitive
				null
		) ||
		source; // the given argument *is* the primitive
	}


	// util
	// returns a filtered array without events that are part of any of the given sources
	function excludeEventsBySources(specificEvents, specificSources) {
		return $.grep(specificEvents, function(event) {
			for (var i = 0; i < specificSources.length; i++) {
				if (event.source === specificSources[i]) {
					return false; // exclude
				}
			}
			return true; // keep
		});
	}



	/* Manipulation
	-----------------------------------------------------------------------------*/


	// Only ever called from the externally-facing API
	function updateEvent(event) {
		updateEvents([ event ]);
	}


	// Only ever called from the externally-facing API
	function updateEvents(events) {
		var i, event;

		for (i = 0; i < events.length; i++) {
			event = events[i];

			// massage start/end values, even if date string values
			event.start = t.moment(event.start);
			if (event.end) {
				event.end = t.moment(event.end);
			}
			else {
				event.end = null;
			}

			mutateEvent(event, getMiscEventProps(event)); // will handle start/end/allDay normalization
		}

		reportEventChange(); // reports event modifications (so we can redraw)
	}


	// Returns a hash of misc event properties that should be copied over to related events.
	function getMiscEventProps(event) {
		var props = {};

		$.each(event, function(name, val) {
			if (isMiscEventPropName(name)) {
				if (val !== undefined && isAtomic(val)) { // a defined non-object
					props[name] = val;
				}
			}
		});

		return props;
	}

	// non-date-related, non-id-related, non-secret
	function isMiscEventPropName(name) {
		return !/^_|^(id|allDay|start|end)$/.test(name);
	}


	// returns the expanded events that were created
	function renderEvent(eventInput, stick) {
		return renderEvents([ eventInput ], stick);
	}


	// returns the expanded events that were created
	function renderEvents(eventInputs, stick) {
		var renderedEvents = [];
		var renderableEvents;
		var abstractEvent;
		var i, j, event;

		for (i = 0; i < eventInputs.length; i++) {
			abstractEvent = buildEventFromInput(eventInputs[i]);

			if (abstractEvent) { // not false (a valid input)
				renderableEvents = expandEvent(abstractEvent);

				for (j = 0; j < renderableEvents.length; j++) {
					event = renderableEvents[j];

					if (!event.source) {
						if (stick) {
							stickySource.events.push(event);
							event.source = stickySource;
						}
						cache.push(event);
					}
				}

				renderedEvents = renderedEvents.concat(renderableEvents);
			}
		}

		if (renderedEvents.length) { // any new events rendered?
			reportEventChange();
		}

		return renderedEvents;
	}


	function removeEvents(filter) {
		var eventID;
		var i;

		if (filter == null) { // null or undefined. remove all events
			filter = function() { return true; }; // will always match
		}
		else if (!$.isFunction(filter)) { // an event ID
			eventID = filter + '';
			filter = function(event) {
				return event._id == eventID;
			};
		}

		// Purge event(s) from our local cache
		cache = $.grep(cache, filter, true); // inverse=true

		// Remove events from array sources.
		// This works because they have been converted to official Event Objects up front.
		// (and as a result, event._id has been calculated).
		for (i=0; i<sources.length; i++) {
			if ($.isArray(sources[i].events)) {
				sources[i].events = $.grep(sources[i].events, filter, true);
			}
		}

		reportEventChange();
	}


	function clientEvents(filter) {
		if ($.isFunction(filter)) {
			return $.grep(cache, filter);
		}
		else if (filter != null) { // not null, not undefined. an event ID
			filter += '';
			return $.grep(cache, function(e) {
				return e._id == filter;
			});
		}
		return cache; // else, return all
	}


	// Makes sure all array event sources have their internal event objects
	// converted over to the Calendar's current timezone.
	t.rezoneArrayEventSources = function() {
		var i;
		var events;
		var j;

		for (i = 0; i < sources.length; i++) {
			events = sources[i].events;
			if ($.isArray(events)) {

				for (j = 0; j < events.length; j++) {
					rezoneEventDates(events[j]);
				}
			}
		}
	};

	function rezoneEventDates(event) {
		event.start = t.moment(event.start);
		if (event.end) {
			event.end = t.moment(event.end);
		}
		backupEventDates(event);
	}


	/* Event Normalization
	-----------------------------------------------------------------------------*/


	// Given a raw object with key/value properties, returns an "abstract" Event object.
	// An "abstract" event is an event that, if recurring, will not have been expanded yet.
	// Will return `false` when input is invalid.
	// `source` is optional
	function buildEventFromInput(input, source) {
		var calendarEventDataTransform = t.opt('eventDataTransform');
		var out = {};
		var start, end;
		var allDay;

		if (calendarEventDataTransform) {
			input = calendarEventDataTransform(input);
		}
		if (source && source.eventDataTransform) {
			input = source.eventDataTransform(input);
		}

		// Copy all properties over to the resulting object.
		// The special-case properties will be copied over afterwards.
		$.extend(out, input);

		if (source) {
			out.source = source;
		}

		out._id = input._id || (input.id === undefined ? '_fc' + eventGUID++ : input.id + '');

		if (input.className) {
			if (typeof input.className == 'string') {
				out.className = input.className.split(/\s+/);
			}
			else { // assumed to be an array
				out.className = input.className;
			}
		}
		else {
			out.className = [];
		}

		start = input.start || input.date; // "date" is an alias for "start"
		end = input.end;

		// parse as a time (Duration) if applicable
		if (isTimeString(start)) {
			start = moment.duration(start);
		}
		if (isTimeString(end)) {
			end = moment.duration(end);
		}

		if (input.dow || moment.isDuration(start) || moment.isDuration(end)) {

			// the event is "abstract" (recurring) so don't calculate exact start/end dates just yet
			out.start = start ? moment.duration(start) : null; // will be a Duration or null
			out.end = end ? moment.duration(end) : null; // will be a Duration or null
			out._recurring = true; // our internal marker
		}
		else {

			if (start) {
				start = t.moment(start);
				if (!start.isValid()) {
					return false;
				}
			}

			if (end) {
				end = t.moment(end);
				if (!end.isValid()) {
					end = null; // let defaults take over
				}
			}

			allDay = input.allDay;
			if (allDay === undefined) { // still undefined? fallback to default
				allDay = firstDefined(
					source ? source.allDayDefault : undefined,
					t.opt('allDayDefault')
				);
				// still undefined? normalizeEventDates will calculate it
			}

			assignDatesToEvent(start, end, allDay, out);
		}

		t.normalizeEvent(out); // hook for external use. a prototype method

		return out;
	}
	t.buildEventFromInput = buildEventFromInput;


	// Normalizes and assigns the given dates to the given partially-formed event object.
	// NOTE: mutates the given start/end moments. does not make a copy.
	function assignDatesToEvent(start, end, allDay, event) {
		event.start = start;
		event.end = end;
		event.allDay = allDay;
		normalizeEventDates(event);
		backupEventDates(event);
	}


	// Ensures proper values for allDay/start/end. Accepts an Event object, or a plain object with event-ish properties.
	// NOTE: Will modify the given object.
	function normalizeEventDates(eventProps) {

		normalizeEventTimes(eventProps);

		if (eventProps.end && !eventProps.end.isAfter(eventProps.start)) {
			eventProps.end = null;
		}

		if (!eventProps.end) {
			if (t.opt('forceEventDuration')) {
				eventProps.end = t.getDefaultEventEnd(eventProps.allDay, eventProps.start);
			}
			else {
				eventProps.end = null;
			}
		}
	}


	// Ensures the allDay property exists and the timeliness of the start/end dates are consistent
	function normalizeEventTimes(eventProps) {
		if (eventProps.allDay == null) {
			eventProps.allDay = !(eventProps.start.hasTime() || (eventProps.end && eventProps.end.hasTime()));
		}

		if (eventProps.allDay) {
			eventProps.start.stripTime();
			if (eventProps.end) {
				// TODO: consider nextDayThreshold here? If so, will require a lot of testing and adjustment
				eventProps.end.stripTime();
			}
		}
		else {
			if (!eventProps.start.hasTime()) {
				eventProps.start = t.applyTimezone(eventProps.start.time(0)); // will assign a 00:00 time
			}
			if (eventProps.end && !eventProps.end.hasTime()) {
				eventProps.end = t.applyTimezone(eventProps.end.time(0)); // will assign a 00:00 time
			}
		}
	}


	// If the given event is a recurring event, break it down into an array of individual instances.
	// If not a recurring event, return an array with the single original event.
	// If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.
	// HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).
	function expandEvent(abstractEvent, _rangeStart, _rangeEnd) {
		var events = [];
		var dowHash;
		var dow;
		var i;
		var date;
		var startTime, endTime;
		var start, end;
		var event;

		_rangeStart = _rangeStart || rangeStart;
		_rangeEnd = _rangeEnd || rangeEnd;

		if (abstractEvent) {
			if (abstractEvent._recurring) {

				// make a boolean hash as to whether the event occurs on each day-of-week
				if ((dow = abstractEvent.dow)) {
					dowHash = {};
					for (i = 0; i < dow.length; i++) {
						dowHash[dow[i]] = true;
					}
				}

				// iterate through every day in the current range
				date = _rangeStart.clone().stripTime(); // holds the date of the current day
				while (date.isBefore(_rangeEnd)) {

					if (!dowHash || dowHash[date.day()]) { // if everyday, or this particular day-of-week

						startTime = abstractEvent.start; // the stored start and end properties are times (Durations)
						endTime = abstractEvent.end; // "
						start = date.clone();
						end = null;

						if (startTime) {
							start = start.time(startTime);
						}
						if (endTime) {
							end = date.clone().time(endTime);
						}

						event = $.extend({}, abstractEvent); // make a copy of the original
						assignDatesToEvent(
							start, end,
							!startTime && !endTime, // allDay?
							event
						);
						events.push(event);
					}

					date.add(1, 'days');
				}
			}
			else {
				events.push(abstractEvent); // return the original event. will be a one-item array
			}
		}

		return events;
	}
	t.expandEvent = expandEvent;



	/* Event Modification Math
	-----------------------------------------------------------------------------------------*/


	// Modifies an event and all related events by applying the given properties.
	// Special date-diffing logic is used for manipulation of dates.
	// If `props` does not contain start/end dates, the updated values are assumed to be the event's current start/end.
	// All date comparisons are done against the event's pristine _start and _end dates.
	// Returns an object with delta information and a function to undo all operations.
	// For making computations in a granularity greater than day/time, specify largeUnit.
	// NOTE: The given `newProps` might be mutated for normalization purposes.
	function mutateEvent(event, newProps, largeUnit) {
		var miscProps = {};
		var oldProps;
		var clearEnd;
		var startDelta;
		var endDelta;
		var durationDelta;
		var undoFunc;

		// diffs the dates in the appropriate way, returning a duration
		function diffDates(date1, date0) { // date1 - date0
			if (largeUnit) {
				return diffByUnit(date1, date0, largeUnit);
			}
			else if (newProps.allDay) {
				return diffDay(date1, date0);
			}
			else {
				return diffDayTime(date1, date0);
			}
		}

		newProps = newProps || {};

		// normalize new date-related properties
		if (!newProps.start) {
			newProps.start = event.start.clone();
		}
		if (newProps.end === undefined) {
			newProps.end = event.end ? event.end.clone() : null;
		}
		if (newProps.allDay == null) { // is null or undefined?
			newProps.allDay = event.allDay;
		}
		normalizeEventDates(newProps);

		// create normalized versions of the original props to compare against
		// need a real end value, for diffing
		oldProps = {
			start: event._start.clone(),
			end: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),
			allDay: newProps.allDay // normalize the dates in the same regard as the new properties
		};
		normalizeEventDates(oldProps);

		// need to clear the end date if explicitly changed to null
		clearEnd = event._end !== null && newProps.end === null;

		// compute the delta for moving the start date
		startDelta = diffDates(newProps.start, oldProps.start);

		// compute the delta for moving the end date
		if (newProps.end) {
			endDelta = diffDates(newProps.end, oldProps.end);
			durationDelta = endDelta.subtract(startDelta);
		}
		else {
			durationDelta = null;
		}

		// gather all non-date-related properties
		$.each(newProps, function(name, val) {
			if (isMiscEventPropName(name)) {
				if (val !== undefined) {
					miscProps[name] = val;
				}
			}
		});

		// apply the operations to the event and all related events
		undoFunc = mutateEvents(
			clientEvents(event._id), // get events with this ID
			clearEnd,
			newProps.allDay,
			startDelta,
			durationDelta,
			miscProps
		);

		return {
			dateDelta: startDelta,
			durationDelta: durationDelta,
			undo: undoFunc
		};
	}


	// Modifies an array of events in the following ways (operations are in order):
	// - clear the event's `end`
	// - convert the event to allDay
	// - add `dateDelta` to the start and end
	// - add `durationDelta` to the event's duration
	// - assign `miscProps` to the event
	//
	// Returns a function that can be called to undo all the operations.
	//
	// TODO: don't use so many closures. possible memory issues when lots of events with same ID.
	//
	function mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {
		var isAmbigTimezone = t.getIsAmbigTimezone();
		var undoFunctions = [];

		// normalize zero-length deltas to be null
		if (dateDelta && !dateDelta.valueOf()) { dateDelta = null; }
		if (durationDelta && !durationDelta.valueOf()) { durationDelta = null; }

		$.each(events, function(i, event) {
			var oldProps;
			var newProps;

			// build an object holding all the old values, both date-related and misc.
			// for the undo function.
			oldProps = {
				start: event.start.clone(),
				end: event.end ? event.end.clone() : null,
				allDay: event.allDay
			};
			$.each(miscProps, function(name) {
				oldProps[name] = event[name];
			});

			// new date-related properties. work off the original date snapshot.
			// ok to use references because they will be thrown away when backupEventDates is called.
			newProps = {
				start: event._start,
				end: event._end,
				allDay: allDay // normalize the dates in the same regard as the new properties
			};
			normalizeEventDates(newProps); // massages start/end/allDay

			// strip or ensure the end date
			if (clearEnd) {
				newProps.end = null;
			}
			else if (durationDelta && !newProps.end) { // the duration translation requires an end date
				newProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);
			}

			if (dateDelta) {
				newProps.start.add(dateDelta);
				if (newProps.end) {
					newProps.end.add(dateDelta);
				}
			}

			if (durationDelta) {
				newProps.end.add(durationDelta); // end already ensured above
			}

			// if the dates have changed, and we know it is impossible to recompute the
			// timezone offsets, strip the zone.
			if (
				isAmbigTimezone &&
				!newProps.allDay &&
				(dateDelta || durationDelta)
			) {
				newProps.start.stripZone();
				if (newProps.end) {
					newProps.end.stripZone();
				}
			}

			$.extend(event, miscProps, newProps); // copy over misc props, then date-related props
			backupEventDates(event); // regenerate internal _start/_end/_allDay

			undoFunctions.push(function() {
				$.extend(event, oldProps);
				backupEventDates(event); // regenerate internal _start/_end/_allDay
			});
		});

		return function() {
			for (var i = 0; i < undoFunctions.length; i++) {
				undoFunctions[i]();
			}
		};
	}

}


// returns an undo function
Calendar.prototype.mutateSeg = function(seg, newProps) {
	return this.mutateEvent(seg.event, newProps);
};


// hook for external libs to manipulate event properties upon creation.
// should manipulate the event in-place.
Calendar.prototype.normalizeEvent = function(event) {
};


// Does the given span (start, end, and other location information)
// fully contain the other?
Calendar.prototype.spanContainsSpan = function(outerSpan, innerSpan) {
	var eventStart = outerSpan.start.clone().stripZone();
	var eventEnd = this.getEventEnd(outerSpan).stripZone();

	return innerSpan.start >= eventStart && innerSpan.end <= eventEnd;
};


// Returns a list of events that the given event should be compared against when being considered for a move to
// the specified span. Attached to the Calendar's prototype because EventManager is a mixin for a Calendar.
Calendar.prototype.getPeerEvents = function(span, event) {
	var cache = this.getEventCache();
	var peerEvents = [];
	var i, otherEvent;

	for (i = 0; i < cache.length; i++) {
		otherEvent = cache[i];
		if (
			!event ||
			event._id !== otherEvent._id // don't compare the event to itself or other related [repeating] events
		) {
			peerEvents.push(otherEvent);
		}
	}

	return peerEvents;
};


// updates the "backup" properties, which are preserved in order to compute diffs later on.
function backupEventDates(event) {
	event._allDay = event.allDay;
	event._start = event.start.clone();
	event._end = event.end ? event.end.clone() : null;
}


/* Overlapping / Constraining
-----------------------------------------------------------------------------------------*/


// Determines if the given event can be relocated to the given span (unzoned start/end with other misc data)
Calendar.prototype.isEventSpanAllowed = function(span, event) {
	var source = event.source || {};
	var eventAllowFunc = this.opt('eventAllow');

	var constraint = firstDefined(
		event.constraint,
		source.constraint,
		this.opt('eventConstraint')
	);

	var overlap = firstDefined(
		event.overlap,
		source.overlap,
		this.opt('eventOverlap')
	);

	return this.isSpanAllowed(span, constraint, overlap, event) &&
		(!eventAllowFunc || eventAllowFunc(span, event) !== false);
};


// Determines if an external event can be relocated to the given span (unzoned start/end with other misc data)
Calendar.prototype.isExternalSpanAllowed = function(eventSpan, eventLocation, eventProps) {
	var eventInput;
	var event;

	// note: very similar logic is in View's reportExternalDrop
	if (eventProps) {
		eventInput = $.extend({}, eventProps, eventLocation);
		event = this.expandEvent(
			this.buildEventFromInput(eventInput)
		)[0];
	}

	if (event) {
		return this.isEventSpanAllowed(eventSpan, event);
	}
	else { // treat it as a selection

		return this.isSelectionSpanAllowed(eventSpan);
	}
};


// Determines the given span (unzoned start/end with other misc data) can be selected.
Calendar.prototype.isSelectionSpanAllowed = function(span) {
	var selectAllowFunc = this.opt('selectAllow');

	return this.isSpanAllowed(span, this.opt('selectConstraint'), this.opt('selectOverlap')) &&
		(!selectAllowFunc || selectAllowFunc(span) !== false);
};


// Returns true if the given span (caused by an event drop/resize or a selection) is allowed to exist
// according to the constraint/overlap settings.
// `event` is not required if checking a selection.
Calendar.prototype.isSpanAllowed = function(span, constraint, overlap, event) {
	var constraintEvents;
	var anyContainment;
	var peerEvents;
	var i, peerEvent;
	var peerOverlap;

	// the range must be fully contained by at least one of produced constraint events
	if (constraint != null) {

		// not treated as an event! intermediate data structure
		// TODO: use ranges in the future
		constraintEvents = this.constraintToEvents(constraint);
		if (constraintEvents) { // not invalid

			anyContainment = false;
			for (i = 0; i < constraintEvents.length; i++) {
				if (this.spanContainsSpan(constraintEvents[i], span)) {
					anyContainment = true;
					break;
				}
			}

			if (!anyContainment) {
				return false;
			}
		}
	}

	peerEvents = this.getPeerEvents(span, event);

	for (i = 0; i < peerEvents.length; i++)  {
		peerEvent = peerEvents[i];

		// there needs to be an actual intersection before disallowing anything
		if (this.eventIntersectsRange(peerEvent, span)) {

			// evaluate overlap for the given range and short-circuit if necessary
			if (overlap === false) {
				return false;
			}
			// if the event's overlap is a test function, pass the peer event in question as the first param
			else if (typeof overlap === 'function' && !overlap(peerEvent, event)) {
				return false;
			}

			// if we are computing if the given range is allowable for an event, consider the other event's
			// EventObject-specific or Source-specific `overlap` property
			if (event) {
				peerOverlap = firstDefined(
					peerEvent.overlap,
					(peerEvent.source || {}).overlap
					// we already considered the global `eventOverlap`
				);
				if (peerOverlap === false) {
					return false;
				}
				// if the peer event's overlap is a test function, pass the subject event as the first param
				if (typeof peerOverlap === 'function' && !peerOverlap(event, peerEvent)) {
					return false;
				}
			}
		}
	}

	return true;
};


// Given an event input from the API, produces an array of event objects. Possible event inputs:
// 'businessHours'
// An event ID (number or string)
// An object with specific start/end dates or a recurring event (like what businessHours accepts)
Calendar.prototype.constraintToEvents = function(constraintInput) {

	if (constraintInput === 'businessHours') {
		return this.getCurrentBusinessHourEvents();
	}

	if (typeof constraintInput === 'object') {
		if (constraintInput.start != null) { // needs to be event-like input
			return this.expandEvent(this.buildEventFromInput(constraintInput));
		}
		else {
			return null; // invalid
		}
	}

	return this.clientEvents(constraintInput); // probably an ID
};


// Does the event's date range intersect with the given range?
// start/end already assumed to have stripped zones :(
Calendar.prototype.eventIntersectsRange = function(event, range) {
	var eventStart = event.start.clone().stripZone();
	var eventEnd = this.getEventEnd(event).stripZone();

	return range.start < eventEnd && range.end > eventStart;
};


/* Business Hours
-----------------------------------------------------------------------------------------*/

var BUSINESS_HOUR_EVENT_DEFAULTS = {
	id: '_fcBusinessHours', // will relate events from different calls to expandEvent
	start: '09:00',
	end: '17:00',
	dow: [ 1, 2, 3, 4, 5 ], // monday - friday
	rendering: 'inverse-background'
	// classNames are defined in businessHoursSegClasses
};

// Return events objects for business hours within the current view.
// Abuse of our event system :(
Calendar.prototype.getCurrentBusinessHourEvents = function(wholeDay) {
	return this.computeBusinessHourEvents(wholeDay, this.opt('businessHours'));
};

// Given a raw input value from options, return events objects for business hours within the current view.
Calendar.prototype.computeBusinessHourEvents = function(wholeDay, input) {
	if (input === true) {
		return this.expandBusinessHourEvents(wholeDay, [ {} ]);
	}
	else if ($.isPlainObject(input)) {
		return this.expandBusinessHourEvents(wholeDay, [ input ]);
	}
	else if ($.isArray(input)) {
		return this.expandBusinessHourEvents(wholeDay, input, true);
	}
	else {
		return [];
	}
};

// inputs expected to be an array of objects.
// if ignoreNoDow is true, will ignore entries that don't specify a day-of-week (dow) key.
Calendar.prototype.expandBusinessHourEvents = function(wholeDay, inputs, ignoreNoDow) {
	var view = this.getView();
	var events = [];
	var i, input;

	for (i = 0; i < inputs.length; i++) {
		input = inputs[i];

		if (ignoreNoDow && !input.dow) {
			continue;
		}

		// give defaults. will make a copy
		input = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, input);

		// if a whole-day series is requested, clear the start/end times
		if (wholeDay) {
			input.start = null;
			input.end = null;
		}

		events.push.apply(events, // append
			this.expandEvent(
				this.buildEventFromInput(input),
				view.activeRange.start,
				view.activeRange.end
			)
		);
	}

	return events;
};

;;

/* An abstract class for the "basic" views, as well as month view. Renders one or more rows of day cells.
----------------------------------------------------------------------------------------------------------------------*/
// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.

var BasicView = FC.BasicView = View.extend({

	scroller: null,

	dayGridClass: DayGrid, // class the dayGrid will be instantiated from (overridable by subclasses)
	dayGrid: null, // the main subcomponent that does most of the heavy lifting

	dayNumbersVisible: false, // display day numbers on each day cell?
	colWeekNumbersVisible: false, // display week numbers along the side?
	cellWeekNumbersVisible: false, // display week numbers in day cell?

	weekNumberWidth: null, // width of all the week-number cells running down the side

	headContainerEl: null, // div that hold's the dayGrid's rendered date header
	headRowEl: null, // the fake row element of the day-of-week header


	initialize: function() {
		this.dayGrid = this.instantiateDayGrid();

		this.scroller = new Scroller({
			overflowX: 'hidden',
			overflowY: 'auto'
		});
	},


	// Generates the DayGrid object this view needs. Draws from this.dayGridClass
	instantiateDayGrid: function() {
		// generate a subclass on the fly with BasicView-specific behavior
		// TODO: cache this subclass
		var subclass = this.dayGridClass.extend(basicDayGridMethods);

		return new subclass(this);
	},


	// Computes the date range that will be rendered.
	buildRenderRange: function(currentRange, currentRangeUnit) {
		var renderRange = View.prototype.buildRenderRange.apply(this, arguments);

		// year and month views should be aligned with weeks. this is already done for week
		if (/^(year|month)$/.test(currentRangeUnit)) {
			renderRange.start.startOf('week');

			// make end-of-week if not already
			if (renderRange.end.weekday()) {
				renderRange.end.add(1, 'week').startOf('week'); // exclusively move backwards
			}
		}

		return this.trimHiddenDays(renderRange);
	},


	// Renders the view into `this.el`, which should already be assigned
	renderDates: function() {

		this.dayGrid.breakOnWeeks = /year|month|week/.test(this.currentRangeUnit); // do before Grid::setRange
		this.dayGrid.setRange(this.renderRange);

		this.dayNumbersVisible = this.dayGrid.rowCnt > 1; // TODO: make grid responsible
		if (this.opt('weekNumbers')) {
			if (this.opt('weekNumbersWithinDays')) {
				this.cellWeekNumbersVisible = true;
				this.colWeekNumbersVisible = false;
			}
			else {
				this.cellWeekNumbersVisible = false;
				this.colWeekNumbersVisible = true;
			};
		}
		this.dayGrid.numbersVisible = this.dayNumbersVisible ||
			this.cellWeekNumbersVisible || this.colWeekNumbersVisible;

		this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());
		this.renderHead();

		this.scroller.render();
		var dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');
		var dayGridEl = $('<div class="fc-day-grid" />').appendTo(dayGridContainerEl);
		this.el.find('.fc-body > tr > td').append(dayGridContainerEl);

		this.dayGrid.setElement(dayGridEl);
		this.dayGrid.renderDates(this.hasRigidRows());
	},


	// render the day-of-week headers
	renderHead: function() {
		this.headContainerEl =
			this.el.find('.fc-head-container')
				.html(this.dayGrid.renderHeadHtml());
		this.headRowEl = this.headContainerEl.find('.fc-row');
	},


	// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
	// always completely kill the dayGrid's rendering.
	unrenderDates: function() {
		this.dayGrid.unrenderDates();
		this.dayGrid.removeElement();
		this.scroller.destroy();
	},


	renderBusinessHours: function() {
		this.dayGrid.renderBusinessHours();
	},


	unrenderBusinessHours: function() {
		this.dayGrid.unrenderBusinessHours();
	},


	// Builds the HTML skeleton for the view.
	// The day-grid component will render inside of a container defined by this HTML.
	renderSkeletonHtml: function() {
		return '' +
			'<table>' +
				'<thead class="fc-head">' +
					'<tr>' +
						'<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' +
					'</tr>' +
				'</thead>' +
				'<tbody class="fc-body">' +
					'<tr>' +
						'<td class="' + this.widgetContentClass + '"></td>' +
					'</tr>' +
				'</tbody>' +
			'</table>';
	},


	// Generates an HTML attribute string for setting the width of the week number column, if it is known
	weekNumberStyleAttr: function() {
		if (this.weekNumberWidth !== null) {
			return 'style="width:' + this.weekNumberWidth + 'px"';
		}
		return '';
	},


	// Determines whether each row should have a constant height
	hasRigidRows: function() {
		var eventLimit = this.opt('eventLimit');
		return eventLimit && typeof eventLimit !== 'number';
	},


	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


	// Refreshes the horizontal dimensions of the view
	updateWidth: function() {
		if (this.colWeekNumbersVisible) {
			// Make sure all week number cells running down the side have the same width.
			// Record the width for cells created later.
			this.weekNumberWidth = matchCellWidths(
				this.el.find('.fc-week-number')
			);
		}
	},


	// Adjusts the vertical dimensions of the view to the specified values
	setHeight: function(totalHeight, isAuto) {
		var eventLimit = this.opt('eventLimit');
		var scrollerHeight;
		var scrollbarWidths;

		// reset all heights to be natural
		this.scroller.clear();
		uncompensateScroll(this.headRowEl);

		this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

		// is the event limit a constant level number?
		if (eventLimit && typeof eventLimit === 'number') {
			this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
		}

		// distribute the height to the rows
		// (totalHeight is a "recommended" value if isAuto)
		scrollerHeight = this.computeScrollerHeight(totalHeight);
		this.setGridHeight(scrollerHeight, isAuto);

		// is the event limit dynamically calculated?
		if (eventLimit && typeof eventLimit !== 'number') {
			this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
		}

		if (!isAuto) { // should we force dimensions of the scroll container?

			this.scroller.setHeight(scrollerHeight);
			scrollbarWidths = this.scroller.getScrollbarWidths();

			if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?

				compensateScroll(this.headRowEl, scrollbarWidths);

				// doing the scrollbar compensation might have created text overflow which created more height. redo
				scrollerHeight = this.computeScrollerHeight(totalHeight);
				this.scroller.setHeight(scrollerHeight);
			}

			// guarantees the same scrollbar widths
			this.scroller.lockOverflow(scrollbarWidths);
		}
	},


	// given a desired total height of the view, returns what the height of the scroller should be
	computeScrollerHeight: function(totalHeight) {
		return totalHeight -
			subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
	},


	// Sets the height of just the DayGrid component in this view
	setGridHeight: function(height, isAuto) {
		if (isAuto) {
			undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
		}
		else {
			distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
		}
	},


	/* Scroll
	------------------------------------------------------------------------------------------------------------------*/


	computeInitialDateScroll: function() {
		return { top: 0 };
	},


	queryDateScroll: function() {
		return { top: this.scroller.getScrollTop() };
	},


	applyDateScroll: function(scroll) {
		if (scroll.top !== undefined) {
			this.scroller.setScrollTop(scroll.top);
		}
	},


	/* Hit Areas
	------------------------------------------------------------------------------------------------------------------*/
	// forward all hit-related method calls to dayGrid


	hitsNeeded: function() {
		this.dayGrid.hitsNeeded();
	},


	hitsNotNeeded: function() {
		this.dayGrid.hitsNotNeeded();
	},


	prepareHits: function() {
		this.dayGrid.prepareHits();
	},


	releaseHits: function() {
		this.dayGrid.releaseHits();
	},


	queryHit: function(left, top) {
		return this.dayGrid.queryHit(left, top);
	},


	getHitSpan: function(hit) {
		return this.dayGrid.getHitSpan(hit);
	},


	getHitEl: function(hit) {
		return this.dayGrid.getHitEl(hit);
	},


	/* Events
	------------------------------------------------------------------------------------------------------------------*/


	// Renders the given events onto the view and populates the segments array
	renderEvents: function(events) {
		this.dayGrid.renderEvents(events);

		this.updateHeight(); // must compensate for events that overflow the row
	},


	// Retrieves all segment objects that are rendered in the view
	getEventSegs: function() {
		return this.dayGrid.getEventSegs();
	},


	// Unrenders all event elements and clears internal segment data
	unrenderEvents: function() {
		this.dayGrid.unrenderEvents();

		// we DON'T need to call updateHeight() because
		// a renderEvents() call always happens after this, which will eventually call updateHeight()
	},


	/* Dragging (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// A returned value of `true` signals that a mock "helper" event has been rendered.
	renderDrag: function(dropLocation, seg) {
		return this.dayGrid.renderDrag(dropLocation, seg);
	},


	unrenderDrag: function() {
		this.dayGrid.unrenderDrag();
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection
	renderSelection: function(span) {
		this.dayGrid.renderSelection(span);
	},


	// Unrenders a visual indications of a selection
	unrenderSelection: function() {
		this.dayGrid.unrenderSelection();
	}

});


// Methods that will customize the rendering behavior of the BasicView's dayGrid
var basicDayGridMethods = {


	// Generates the HTML that will go before the day-of week header cells
	renderHeadIntroHtml: function() {
		var view = this.view;

		if (view.colWeekNumbersVisible) {
			return '' +
				'<th class="fc-week-number ' + view.widgetHeaderClass + '" ' + view.weekNumberStyleAttr() + '>' +
					'<span>' + // needed for matchCellWidths
						htmlEscape(view.opt('weekNumberTitle')) +
					'</span>' +
				'</th>';
		}

		return '';
	},


	// Generates the HTML that will go before content-skeleton cells that display the day/week numbers
	renderNumberIntroHtml: function(row) {
		var view = this.view;
		var weekStart = this.getCellDate(row, 0);

		if (view.colWeekNumbersVisible) {
			return '' +
				'<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '>' +
					view.buildGotoAnchorHtml( // aside from link, important for matchCellWidths
						{ date: weekStart, type: 'week', forceOff: this.colCnt === 1 },
						weekStart.format('w') // inner HTML
					) +
				'</td>';
		}

		return '';
	},


	// Generates the HTML that goes before the day bg cells for each day-row
	renderBgIntroHtml: function() {
		var view = this.view;

		if (view.colWeekNumbersVisible) {
			return '<td class="fc-week-number ' + view.widgetContentClass + '" ' +
				view.weekNumberStyleAttr() + '></td>';
		}

		return '';
	},


	// Generates the HTML that goes before every other type of row generated by DayGrid.
	// Affects helper-skeleton and highlight-skeleton rows.
	renderIntroHtml: function() {
		var view = this.view;

		if (view.colWeekNumbersVisible) {
			return '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '></td>';
		}

		return '';
	}

};

;;

/* A month view with day cells running in rows (one-per-week) and columns
----------------------------------------------------------------------------------------------------------------------*/

var MonthView = FC.MonthView = BasicView.extend({


	// Computes the date range that will be rendered.
	buildRenderRange: function() {
		var renderRange = BasicView.prototype.buildRenderRange.apply(this, arguments);
		var rowCnt;

		// ensure 6 weeks
		if (this.isFixedWeeks()) {
			rowCnt = Math.ceil( // could be partial weeks due to hiddenDays
				renderRange.end.diff(renderRange.start, 'weeks', true) // dontRound=true
			);
			renderRange.end.add(6 - rowCnt, 'weeks');
		}

		return renderRange;
	},


	// Overrides the default BasicView behavior to have special multi-week auto-height logic
	setGridHeight: function(height, isAuto) {

		// if auto, make the height of each row the height that it would be if there were 6 weeks
		if (isAuto) {
			height *= this.rowCnt / 6;
		}

		distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
	},


	isFixedWeeks: function() {
		return this.opt('fixedWeekCount');
	}

});

;;

fcViews.basic = {
	'class': BasicView
};

fcViews.basicDay = {
	type: 'basic',
	duration: { days: 1 }
};

fcViews.basicWeek = {
	type: 'basic',
	duration: { weeks: 1 }
};

fcViews.month = {
	'class': MonthView,
	duration: { months: 1 }, // important for prev/next
	defaults: {
		fixedWeekCount: true
	}
};
;;

/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
----------------------------------------------------------------------------------------------------------------------*/
// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.

var AgendaView = FC.AgendaView = View.extend({

	scroller: null,

	timeGridClass: TimeGrid, // class used to instantiate the timeGrid. subclasses can override
	timeGrid: null, // the main time-grid subcomponent of this view

	dayGridClass: DayGrid, // class used to instantiate the dayGrid. subclasses can override
	dayGrid: null, // the "all-day" subcomponent. if all-day is turned off, this will be null

	axisWidth: null, // the width of the time axis running down the side

	headContainerEl: null, // div that hold's the timeGrid's rendered date header
	noScrollRowEls: null, // set of fake row elements that must compensate when scroller has scrollbars

	// when the time-grid isn't tall enough to occupy the given height, we render an <hr> underneath
	bottomRuleEl: null,

	// indicates that minTime/maxTime affects rendering
	usesMinMaxTime: true,


	initialize: function() {
		this.timeGrid = this.instantiateTimeGrid();

		if (this.opt('allDaySlot')) { // should we display the "all-day" area?
			this.dayGrid = this.instantiateDayGrid(); // the all-day subcomponent of this view
		}

		this.scroller = new Scroller({
			overflowX: 'hidden',
			overflowY: 'auto'
		});
	},


	// Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass
	instantiateTimeGrid: function() {
		var subclass = this.timeGridClass.extend(agendaTimeGridMethods);

		return new subclass(this);
	},


	// Instantiates the DayGrid object this view might need. Draws from this.dayGridClass
	instantiateDayGrid: function() {
		var subclass = this.dayGridClass.extend(agendaDayGridMethods);

		return new subclass(this);
	},


	/* Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Renders the view into `this.el`, which has already been assigned
	renderDates: function() {

		this.timeGrid.setRange(this.renderRange);

		if (this.dayGrid) {
			this.dayGrid.setRange(this.renderRange);
		}

		this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());
		this.renderHead();

		this.scroller.render();
		var timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');
		var timeGridEl = $('<div class="fc-time-grid" />').appendTo(timeGridWrapEl);
		this.el.find('.fc-body > tr > td').append(timeGridWrapEl);

		this.timeGrid.setElement(timeGridEl);
		this.timeGrid.renderDates();

		// the <hr> that sometimes displays under the time-grid
		this.bottomRuleEl = $('<hr class="fc-divider ' + this.widgetHeaderClass + '"/>')
			.appendTo(this.timeGrid.el); // inject it into the time-grid

		if (this.dayGrid) {
			this.dayGrid.setElement(this.el.find('.fc-day-grid'));
			this.dayGrid.renderDates();

			// have the day-grid extend it's coordinate area over the <hr> dividing the two grids
			this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();
		}

		this.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)'); // fake rows not within the scroller
	},


	// render the day-of-week headers
	renderHead: function() {
		this.headContainerEl =
			this.el.find('.fc-head-container')
				.html(this.timeGrid.renderHeadHtml());
	},


	// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
	// always completely kill each grid's rendering.
	unrenderDates: function() {
		this.timeGrid.unrenderDates();
		this.timeGrid.removeElement();

		if (this.dayGrid) {
			this.dayGrid.unrenderDates();
			this.dayGrid.removeElement();
		}

		this.scroller.destroy();
	},


	// Builds the HTML skeleton for the view.
	// The day-grid and time-grid components will render inside containers defined by this HTML.
	renderSkeletonHtml: function() {
		return '' +
			'<table>' +
				'<thead class="fc-head">' +
					'<tr>' +
						'<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' +
					'</tr>' +
				'</thead>' +
				'<tbody class="fc-body">' +
					'<tr>' +
						'<td class="' + this.widgetContentClass + '">' +
							(this.dayGrid ?
								'<div class="fc-day-grid"/>' +
								'<hr class="fc-divider ' + this.widgetHeaderClass + '"/>' :
								''
								) +
						'</td>' +
					'</tr>' +
				'</tbody>' +
			'</table>';
	},


	// Generates an HTML attribute string for setting the width of the axis, if it is known
	axisStyleAttr: function() {
		if (this.axisWidth !== null) {
			 return 'style="width:' + this.axisWidth + 'px"';
		}
		return '';
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessHours: function() {
		this.timeGrid.renderBusinessHours();

		if (this.dayGrid) {
			this.dayGrid.renderBusinessHours();
		}
	},


	unrenderBusinessHours: function() {
		this.timeGrid.unrenderBusinessHours();

		if (this.dayGrid) {
			this.dayGrid.unrenderBusinessHours();
		}
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	getNowIndicatorUnit: function() {
		return this.timeGrid.getNowIndicatorUnit();
	},


	renderNowIndicator: function(date) {
		this.timeGrid.renderNowIndicator(date);
	},


	unrenderNowIndicator: function() {
		this.timeGrid.unrenderNowIndicator();
	},


	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


	updateSize: function(isResize) {
		this.timeGrid.updateSize(isResize);

		View.prototype.updateSize.call(this, isResize); // call the super-method
	},


	// Refreshes the horizontal dimensions of the view
	updateWidth: function() {
		// make all axis cells line up, and record the width so newly created axis cells will have it
		this.axisWidth = matchCellWidths(this.el.find('.fc-axis'));
	},


	// Adjusts the vertical dimensions of the view to the specified values
	setHeight: function(totalHeight, isAuto) {
		var eventLimit;
		var scrollerHeight;
		var scrollbarWidths;

		// reset all dimensions back to the original state
		this.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary
		this.scroller.clear(); // sets height to 'auto' and clears overflow
		uncompensateScroll(this.noScrollRowEls);

		// limit number of events in the all-day area
		if (this.dayGrid) {
			this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

			eventLimit = this.opt('eventLimit');
			if (eventLimit && typeof eventLimit !== 'number') {
				eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
			}
			if (eventLimit) {
				this.dayGrid.limitRows(eventLimit);
			}
		}

		if (!isAuto) { // should we force dimensions of the scroll container?

			scrollerHeight = this.computeScrollerHeight(totalHeight);
			this.scroller.setHeight(scrollerHeight);
			scrollbarWidths = this.scroller.getScrollbarWidths();

			if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?

				// make the all-day and header rows lines up
				compensateScroll(this.noScrollRowEls, scrollbarWidths);

				// the scrollbar compensation might have changed text flow, which might affect height, so recalculate
				// and reapply the desired height to the scroller.
				scrollerHeight = this.computeScrollerHeight(totalHeight);
				this.scroller.setHeight(scrollerHeight);
			}

			// guarantees the same scrollbar widths
			this.scroller.lockOverflow(scrollbarWidths);

			// if there's any space below the slats, show the horizontal rule.
			// this won't cause any new overflow, because lockOverflow already called.
			if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {
				this.bottomRuleEl.show();
			}
		}
	},


	// given a desired total height of the view, returns what the height of the scroller should be
	computeScrollerHeight: function(totalHeight) {
		return totalHeight -
			subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
	},


	/* Scroll
	------------------------------------------------------------------------------------------------------------------*/


	// Computes the initial pre-configured scroll state prior to allowing the user to change it
	computeInitialDateScroll: function() {
		var scrollTime = moment.duration(this.opt('scrollTime'));
		var top = this.timeGrid.computeTimeTop(scrollTime);

		// zoom can give weird floating-point values. rather scroll a little bit further
		top = Math.ceil(top);

		if (top) {
			top++; // to overcome top border that slots beyond the first have. looks better
		}

		return { top: top };
	},


	queryDateScroll: function() {
		return { top: this.scroller.getScrollTop() };
	},


	applyDateScroll: function(scroll) {
		if (scroll.top !== undefined) {
			this.scroller.setScrollTop(scroll.top);
		}
	},


	/* Hit Areas
	------------------------------------------------------------------------------------------------------------------*/
	// forward all hit-related method calls to the grids (dayGrid might not be defined)


	hitsNeeded: function() {
		this.timeGrid.hitsNeeded();
		if (this.dayGrid) {
			this.dayGrid.hitsNeeded();
		}
	},


	hitsNotNeeded: function() {
		this.timeGrid.hitsNotNeeded();
		if (this.dayGrid) {
			this.dayGrid.hitsNotNeeded();
		}
	},


	prepareHits: function() {
		this.timeGrid.prepareHits();
		if (this.dayGrid) {
			this.dayGrid.prepareHits();
		}
	},


	releaseHits: function() {
		this.timeGrid.releaseHits();
		if (this.dayGrid) {
			this.dayGrid.releaseHits();
		}
	},


	queryHit: function(left, top) {
		var hit = this.timeGrid.queryHit(left, top);

		if (!hit && this.dayGrid) {
			hit = this.dayGrid.queryHit(left, top);
		}

		return hit;
	},


	getHitSpan: function(hit) {
		// TODO: hit.component is set as a hack to identify where the hit came from
		return hit.component.getHitSpan(hit);
	},


	getHitEl: function(hit) {
		// TODO: hit.component is set as a hack to identify where the hit came from
		return hit.component.getHitEl(hit);
	},


	/* Events
	------------------------------------------------------------------------------------------------------------------*/


	// Renders events onto the view and populates the View's segment array
	renderEvents: function(events) {
		var dayEvents = [];
		var timedEvents = [];
		var daySegs = [];
		var timedSegs;
		var i;

		// separate the events into all-day and timed
		for (i = 0; i < events.length; i++) {
			if (events[i].allDay) {
				dayEvents.push(events[i]);
			}
			else {
				timedEvents.push(events[i]);
			}
		}

		// render the events in the subcomponents
		timedSegs = this.timeGrid.renderEvents(timedEvents);
		if (this.dayGrid) {
			daySegs = this.dayGrid.renderEvents(dayEvents);
		}

		// the all-day area is flexible and might have a lot of events, so shift the height
		this.updateHeight();
	},


	// Retrieves all segment objects that are rendered in the view
	getEventSegs: function() {
		return this.timeGrid.getEventSegs().concat(
			this.dayGrid ? this.dayGrid.getEventSegs() : []
		);
	},


	// Unrenders all event elements and clears internal segment data
	unrenderEvents: function() {

		// unrender the events in the subcomponents
		this.timeGrid.unrenderEvents();
		if (this.dayGrid) {
			this.dayGrid.unrenderEvents();
		}

		// we DON'T need to call updateHeight() because
		// a renderEvents() call always happens after this, which will eventually call updateHeight()
	},


	/* Dragging (for events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// A returned value of `true` signals that a mock "helper" event has been rendered.
	renderDrag: function(dropLocation, seg) {
		if (dropLocation.start.hasTime()) {
			return this.timeGrid.renderDrag(dropLocation, seg);
		}
		else if (this.dayGrid) {
			return this.dayGrid.renderDrag(dropLocation, seg);
		}
	},


	unrenderDrag: function() {
		this.timeGrid.unrenderDrag();
		if (this.dayGrid) {
			this.dayGrid.unrenderDrag();
		}
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection
	renderSelection: function(span) {
		if (span.start.hasTime() || span.end.hasTime()) {
			this.timeGrid.renderSelection(span);
		}
		else if (this.dayGrid) {
			this.dayGrid.renderSelection(span);
		}
	},


	// Unrenders a visual indications of a selection
	unrenderSelection: function() {
		this.timeGrid.unrenderSelection();
		if (this.dayGrid) {
			this.dayGrid.unrenderSelection();
		}
	}

});


// Methods that will customize the rendering behavior of the AgendaView's timeGrid
// TODO: move into TimeGrid
var agendaTimeGridMethods = {


	// Generates the HTML that will go before the day-of week header cells
	renderHeadIntroHtml: function() {
		var view = this.view;
		var weekText;

		if (view.opt('weekNumbers')) {
			weekText = this.start.format(view.opt('smallWeekFormat'));

			return '' +
				'<th class="fc-axis fc-week-number ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '>' +
					view.buildGotoAnchorHtml( // aside from link, important for matchCellWidths
						{ date: this.start, type: 'week', forceOff: this.colCnt > 1 },
						htmlEscape(weekText) // inner HTML
					) +
				'</th>';
		}
		else {
			return '<th class="fc-axis ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '></th>';
		}
	},


	// Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
	renderBgIntroHtml: function() {
		var view = this.view;

		return '<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '></td>';
	},


	// Generates the HTML that goes before all other types of cells.
	// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
	renderIntroHtml: function() {
		var view = this.view;

		return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
	}

};


// Methods that will customize the rendering behavior of the AgendaView's dayGrid
var agendaDayGridMethods = {


	// Generates the HTML that goes before the all-day cells
	renderBgIntroHtml: function() {
		var view = this.view;

		return '' +
			'<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' +
				'<span>' + // needed for matchCellWidths
					view.getAllDayHtml() +
				'</span>' +
			'</td>';
	},


	// Generates the HTML that goes before all other types of cells.
	// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
	renderIntroHtml: function() {
		var view = this.view;

		return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
	}

};

;;

var AGENDA_ALL_DAY_EVENT_LIMIT = 5;

// potential nice values for the slot-duration and interval-duration
// from largest to smallest
var AGENDA_STOCK_SUB_DURATIONS = [
	{ hours: 1 },
	{ minutes: 30 },
	{ minutes: 15 },
	{ seconds: 30 },
	{ seconds: 15 }
];

fcViews.agenda = {
	'class': AgendaView,
	defaults: {
		allDaySlot: true,
		slotDuration: '00:30:00',
		slotEventOverlap: true // a bad name. confused with overlap/constraint system
	}
};

fcViews.agendaDay = {
	type: 'agenda',
	duration: { days: 1 }
};

fcViews.agendaWeek = {
	type: 'agenda',
	duration: { weeks: 1 }
};
;;

/*
Responsible for the scroller, and forwarding event-related actions into the "grid"
*/
var ListView = View.extend({

	grid: null,
	scroller: null,

	initialize: function() {
		this.grid = new ListViewGrid(this);
		this.scroller = new Scroller({
			overflowX: 'hidden',
			overflowY: 'auto'
		});
	},

	renderSkeleton: function() {
		this.el.addClass(
			'fc-list-view ' +
			this.widgetContentClass
		);

		this.scroller.render();
		this.scroller.el.appendTo(this.el);

		this.grid.setElement(this.scroller.scrollEl);
	},

	unrenderSkeleton: function() {
		this.scroller.destroy(); // will remove the Grid too
	},

	setHeight: function(totalHeight, isAuto) {
		this.scroller.setHeight(this.computeScrollerHeight(totalHeight));
	},

	computeScrollerHeight: function(totalHeight) {
		return totalHeight -
			subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
	},

	renderDates: function() {
		this.grid.setRange(this.renderRange); // needs to process range-related options
	},

	renderEvents: function(events) {
		this.grid.renderEvents(events);
	},

	unrenderEvents: function() {
		this.grid.unrenderEvents();
	},

	isEventResizable: function(event) {
		return false;
	},

	isEventDraggable: function(event) {
		return false;
	}

});

/*
Responsible for event rendering and user-interaction.
Its "el" is the inner-content of the above view's scroller.
*/
var ListViewGrid = Grid.extend({

	segSelector: '.fc-list-item', // which elements accept event actions
	hasDayInteractions: false, // no day selection or day clicking

	// slices by day
	spanToSegs: function(span) {
		var view = this.view;
		var dayStart = view.renderRange.start.clone().time(0); // timed, so segs get times!
		var dayIndex = 0;
		var seg;
		var segs = [];

		while (dayStart < view.renderRange.end) {

			seg = intersectRanges(span, {
				start: dayStart,
				end: dayStart.clone().add(1, 'day')
			});

			if (seg) {
				seg.dayIndex = dayIndex;
				segs.push(seg);
			}

			dayStart.add(1, 'day');
			dayIndex++;

			// detect when span won't go fully into the next day,
			// and mutate the latest seg to the be the end.
			if (
				seg && !seg.isEnd && span.end.hasTime() &&
				span.end < dayStart.clone().add(this.view.nextDayThreshold)
			) {
				seg.end = span.end.clone();
				seg.isEnd = true;
				break;
			}
		}

		return segs;
	},

	// like "4:00am"
	computeEventTimeFormat: function() {
		return this.view.opt('mediumTimeFormat');
	},

	// for events with a url, the whole <tr> should be clickable,
	// but it's impossible to wrap with an <a> tag. simulate this.
	handleSegClick: function(seg, ev) {
		var url;

		Grid.prototype.handleSegClick.apply(this, arguments); // super. might prevent the default action

		// not clicking on or within an <a> with an href
		if (!$(ev.target).closest('a[href]').length) {
			url = seg.event.url;
			if (url && !ev.isDefaultPrevented()) { // jsEvent not cancelled in handler
				window.location.href = url; // simulate link click
			}
		}
	},

	// returns list of foreground segs that were actually rendered
	renderFgSegs: function(segs) {
		segs = this.renderFgSegEls(segs); // might filter away hidden events

		if (!segs.length) {
			this.renderEmptyMessage();
		}
		else {
			this.renderSegList(segs);
		}

		return segs;
	},

	renderEmptyMessage: function() {
		this.el.html(
			'<div class="fc-list-empty-wrap2">' + // TODO: try less wraps
			'<div class="fc-list-empty-wrap1">' +
			'<div class="fc-list-empty">' +
				htmlEscape(this.view.opt('noEventsMessage')) +
			'</div>' +
			'</div>' +
			'</div>'
		);
	},

	// render the event segments in the view
	renderSegList: function(allSegs) {
		var segsByDay = this.groupSegsByDay(allSegs); // sparse array
		var dayIndex;
		var daySegs;
		var i;
		var tableEl = $('<table class="fc-list-table"><tbody/></table>');
		var tbodyEl = tableEl.find('tbody');

		for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {
			daySegs = segsByDay[dayIndex];
			if (daySegs) { // sparse array, so might be undefined

				// append a day header
				tbodyEl.append(this.dayHeaderHtml(
					this.view.renderRange.start.clone().add(dayIndex, 'days')
				));

				this.sortEventSegs(daySegs);

				for (i = 0; i < daySegs.length; i++) {
					tbodyEl.append(daySegs[i].el); // append event row
				}
			}
		}

		this.el.empty().append(tableEl);
	},

	// Returns a sparse array of arrays, segs grouped by their dayIndex
	groupSegsByDay: function(segs) {
		var segsByDay = []; // sparse array
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			(segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))
				.push(seg);
		}

		return segsByDay;
	},

	// generates the HTML for the day headers that live amongst the event rows
	dayHeaderHtml: function(dayDate) {
		var view = this.view;
		var mainFormat = view.opt('listDayFormat');
		var altFormat = view.opt('listDayAltFormat');

		return '<tr class="fc-list-heading" data-date="' + dayDate.format('YYYY-MM-DD') + '">' +
			'<td class="' + view.widgetHeaderClass + '" colspan="3">' +
				(mainFormat ?
					view.buildGotoAnchorHtml(
						dayDate,
						{ 'class': 'fc-list-heading-main' },
						htmlEscape(dayDate.format(mainFormat)) // inner HTML
					) :
					'') +
				(altFormat ?
					view.buildGotoAnchorHtml(
						dayDate,
						{ 'class': 'fc-list-heading-alt' },
						htmlEscape(dayDate.format(altFormat)) // inner HTML
					) :
					'') +
			'</td>' +
		'</tr>';
	},

	// generates the HTML for a single event row
	fgSegHtml: function(seg) {
		var view = this.view;
		var classes = [ 'fc-list-item' ].concat(this.getSegCustomClasses(seg));
		var bgColor = this.getSegBackgroundColor(seg);
		var event = seg.event;
		var url = event.url;
		var timeHtml;

		if (event.allDay) {
			timeHtml = view.getAllDayHtml();
		}
		else if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day
			if (seg.isStart || seg.isEnd) { // outer segment that probably lasts part of the day
				timeHtml = htmlEscape(this.getEventTimeText(seg));
			}
			else { // inner segment that lasts the whole day
				timeHtml = view.getAllDayHtml();
			}
		}
		else {
			// Display the normal time text for the *event's* times
			timeHtml = htmlEscape(this.getEventTimeText(event));
		}

		if (url) {
			classes.push('fc-has-url');
		}

		return '<tr class="' + classes.join(' ') + '">' +
			(this.displayEventTime ?
				'<td class="fc-list-item-time ' + view.widgetContentClass + '">' +
					(timeHtml || '') +
				'</td>' :
				'') +
			'<td class="fc-list-item-marker ' + view.widgetContentClass + '">' +
				'<span class="fc-event-dot"' +
				(bgColor ?
					' style="background-color:' + bgColor + '"' :
					'') +
				'></span>' +
			'</td>' +
			'<td class="fc-list-item-title ' + view.widgetContentClass + '">' +
				'<a' + (url ? ' href="' + htmlEscape(url) + '"' : '') + '>' +
					htmlEscape(seg.event.title || '') +
				'</a>' +
			'</td>' +
		'</tr>';
	}

});

;;

fcViews.list = {
	'class': ListView,
	buttonTextKey: 'list', // what to lookup in locale files
	defaults: {
		buttonText: 'list', // text to display for English
		listDayFormat: 'LL', // like "January 1, 2016"
		noEventsMessage: 'No events to display'
	}
};

fcViews.listDay = {
	type: 'list',
	duration: { days: 1 },
	defaults: {
		listDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header
	}
};

fcViews.listWeek = {
	type: 'list',
	duration: { weeks: 1 },
	defaults: {
		listDayFormat: 'dddd', // day-of-week is more important
		listDayAltFormat: 'LL'
	}
};

fcViews.listMonth = {
	type: 'list',
	duration: { month: 1 },
	defaults: {
		listDayAltFormat: 'dddd' // day-of-week is nice-to-have
	}
};

fcViews.listYear = {
	type: 'list',
	duration: { year: 1 },
	defaults: {
		listDayAltFormat: 'dddd' // day-of-week is nice-to-have
	}
};

;;

return FC; // export for Node/CommonJS
});

/***/ }),

/***/ 590:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(78);
module.exports = __webpack_require__(351);


/***/ })

},[590]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9hZi5qcz8zZjMyIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2FyLWR6LmpzP2NhODkiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvYXIta3cuanM/MzNiNSIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9hci1seS5qcz80MGNlIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2FyLW1hLmpzP2I4YjciLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvYXItc2EuanM/MjE0ZCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9hci10bi5qcz80ZWU0Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2FyLmpzP2M4OGQiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvYmcuanM/OTdhZiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9jYS5qcz9kY2VjIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2NzLmpzP2EwOWMiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZGEuanM/ZmQyOCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9kZS1hdC5qcz83ODNkIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2RlLWNoLmpzPzExMzIiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZGUuanM/YzgxMyIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9lbC5qcz9jMGU3Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2VuLWF1LmpzP2E5ZTUiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZW4tY2EuanM/YWU1MCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9lbi1nYi5qcz8xNWUzIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2VuLWllLmpzP2ZiZTMiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZW4tbnouanM/NDczYiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9lcy1kby5qcz9jN2YwIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2VzLmpzPzk4ZDMiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZXQuanM/M2Q2NiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9ldS5qcz84OTcwIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2ZhLmpzPzBjZDciLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZmkuanM/N2IyZiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9mci1jYS5qcz83MzkzIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2ZyLWNoLmpzPzJkZDciLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZnIuanM/NjdkZiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9nbC5qcz81NmUzIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2hlLmpzPzJiYmYiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvaGkuanM/YzkwYiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9oci5qcz8zMTg5Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2h1LmpzP2YwMGMiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvaWQuanM/YWFjNSIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9pcy5qcz80NGQyIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2l0LmpzPzE2NTUiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvamEuanM/YzNkNyIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9ray5qcz9hY2E4Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2tvLmpzPzA4ZDUiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbGIuanM/MGQyZiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9sdC5qcz9iN2YxIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2x2LmpzPzhkY2UiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbWsuanM/YjI0OCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9tcy1teS5qcz9hYzU5Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL21zLmpzP2E4MWMiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbmIuanM/ZmQ5NiIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9ubC1iZS5qcz8zOTFiIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL25sLmpzP2FmOWUiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbm4uanM/OWMwZCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9wbC5qcz8xY2U5Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3B0LWJyLmpzPzlmOGYiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvcHQuanM/ZjQ1OCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9yby5qcz80NjMxIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3J1LmpzPzZjN2MiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvc2suanM/MjZkOCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9zbC5qcz9mYjJhIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3NyLWN5cmwuanM/OGU4MCIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9zci5qcz9kODgwIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3N2LmpzPzkxMGQiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvdGguanM/NDgyNyIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS90ci5qcz83NzM1Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3VrLmpzPzA0MmEiLCJ3ZWJwYWNrOi8vLy4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvdmkuanM/ODdkOSIsIndlYnBhY2s6Ly8vLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS96aC1jbi5qcz9hZGQ5Iiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3poLXR3LmpzPzA1ZTciLCJ3ZWJwYWNrOi8vLyBeXFwuXFwvLiokPzM0YWEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbGVuZGFyL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9jYWxlbmRhci9jb252ZXJ0VG9GQy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FsZW5kYXIvZGlzcGxheUV2ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvdGVtcGxhdGVzLmpzIiwid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvZnVsbGNhbGVuZGFyLmpzIl0sIm5hbWVzIjpbInF1ZXJ5UmVnRXhwIiwiYmVnaW4iLCJtb21lbnRMYW5nIiwiY2FsZW5kYXJPcHRpb25zIiwiZWRpdGFibGUiLCJoZWFkZXIiLCJsZWZ0IiwiY2VudGVyIiwicmlnaHQiLCJsYW5nIiwiZXZlbnRzIiwic3RhcnQiLCJlbmQiLCJ0aW1lem9uZSIsImNhbGxiYWNrIiwic29ja2V0IiwiZW1pdCIsInN0YXJ0RGF0ZSIsInZhbHVlT2YiLCJlbmREYXRlIiwiZXJyIiwibWVzc2FnZSIsImFwcCIsImFsZXJ0RXJyb3IiLCJldmVudENsaWNrIiwiZSIsIm9yaWdpbmFsIiwicGlkIiwiaWQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImV4dGVybmFsIiwicmVwZWF0cyIsImFqYXhpZnkiLCJ1cGRhdGVIaXN0b3J5IiwiZGF5Iiwic2hvdWxkSGFuZGxlIiwibGlzdGVuIiwic3RhdGUiLCJkYXRhIiwicHJldiIsInN0YXJ0c1dpdGgiLCJjdXJyZW50IiwidXJsIiwiaW5pdCIsIiRjYWxlbmRhciIsIiQiLCJmdWxsQ2FsZW5kYXIiLCJidG4iLCJvbiIsInRvZ2dsZUNsYXNzIiwiZGV0YWNoIiwiYXBwZW5kVG8iLCJmaW5kIiwiJGRpc3BsYXkiLCJtb2RhbCIsIm1hdGNoZXMiLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwibWF0Y2giLCJwYXJzZUludCIsImVsIiwiZ2V0RXZlbnRDYWNoZSIsIngiLCJldmVudCIsImhpc3RvcnkiLCJyZXBsYWNlU3RhdGUiLCJSRUxBVElWRV9QQVRIIiwid2luZG93IiwiY2FsZW5kYXJFdmVudERhdGEiLCJkb2N1bWVudCIsInJlYWR5IiwiX193ZWJwYWNrX3B1YmxpY19wYXRoX18iLCJjb25maWciLCJ1c2VyTGFuZyIsImRlZmF1bHRMYW5nIiwidG9Mb3dlckNhc2UiLCJyZXBsYWNlIiwicmVxdWlyZSIsInNwbGl0IiwiZXIiLCJFcnJvciIsIm1hcHBlciIsIm5ld0V2ZW50IiwidGl0bGUiLCJuYW1lIiwiYWxsRGF5IiwiYWxsZGF5IiwiY2xhc3NOYW1lIiwiY2lkIiwicmVzcG9uc2VzIiwidXNlciIsInVpZCIsInRvcGljRGVsZXRlZCIsImNvbnZlcnRUb0ZDIiwibWFwIiwiZGlzcGxheUV2ZW50IiwiY2IiLCJjb250ZW50IiwiZGl2IiwiJGdvVG9Qb3N0IiwiJGdvVG9VcmwiLCJlbXB0eSIsImFwcGVuZCIsImhpZGUiLCJzaG93IiwiYXR0ciIsInRyaWdnZXIiLCJwYXJzZWQiLCJtYWtlTGlzdEVsZW1lbnQiLCJuIiwibGkiLCJldmVudFRlbXBsYXRlIiwiaXNFbWFpbCIsInJlc3BvbnNlIiwicmVzcG9uc2VzVGVtcGxhdGUiLCJhY3RpdmUiLCJubyIsIm1heWJlIiwieWVzIiwiaHRtbCIsInNvdXJjZSIsImRlc2NyaXB0aW9uIiwicmVtaW5kZXJzIiwibGVuZ3RoIiwic29ydCIsImEiLCJiIiwiam9pbiIsImtleSIsImV2ZXJ5IiwiZGF5c09mV2VlayIsImRheXMiLCJlbmREYXRlVGV4dCIsIk51bWJlciIsImlzRmluaXRlIiwibWFuZGF0b3J5Il0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxDQUFDLGlFOzs7Ozs7O0FDYkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsQ0FBQyxpRTs7Ozs7OztBQ2JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLENBQUMsaUU7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Qjs7Ozs7Ozs7OztBQ3RKQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBLElBQU1BLGNBQWMscUNBQXBCOztBQUVBLElBQU1DLFFBQVEs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QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFtQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVDQUF1QztBQUM3QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FB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Q0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGLHNCQUFzQjtBQUN0QjtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFF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QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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Q0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLHFFQUFxRTs7QUFFckU7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSSxpQkFBaUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0UsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5Qzs7QUFFQTs7QUFFQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FB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QUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FB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QTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDZEQUE2RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0EsZ0NBQWdDO0FBQ2hDLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztB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O0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQywrREFBK0Q7QUFDL0QsS0FBSztBQUNMO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0EsWUFBWTtBQUNaLEVBQUU7OztBQUdGO0FBQ0EsWUFBWTtBQUNaLEVBQUU7OztBQUdGO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSw2RUFBNkUsRUFBRSxNQUFNO0FBQ3JGLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsZ0VBQWdFO0FBQ2hFOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQixFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsbUZBQW1GLEVBQUUsTUFBTTtBQUMzRixFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEMsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVixFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLHFEQUFxRDtBQUNyRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7O0FBRTFDLFVBQVU7QUFDVixFQUFFOzs7QUFHRjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVO0FBQ1YsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsVUFBVTtBQUNWLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBOztBQUVBLDhDQUE4QztBQUM5QyxnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxTQUFTO0FBQ1QsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1YsRUFBRTs7O0FBR0YsNkJBQTZCO0FBQzdCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3Qjs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLHlEQUF5RDtBQUN6RCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7OztBQUlGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQsd0NBQXdDO0FBQ3hDO0FBQ0EsSUFBSTs7QUFFSixjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUI7QUFDQSxXQUFXO0FBQ1gsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkIsb0NBQW9DO0FBQ3BDLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUEsZUFBZTtBQUNmO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRix3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFtQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUEsNEVBQTRFO0FBQzVFOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUEsZ0JBQWdCOztBQUVoQjtBQUNBOztBQUVBLHVEQUF1RDs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQSxVQUFVO0FBQ1YsRUFBRTs7O0FBR0Y7QUFDQSxVQUFVO0FBQ1YsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDZEQUE2RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQ7QUFDekQsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQiw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9FQUFvRTtBQUNwRSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pELEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBOztBQUVBLHVEQUF1RDs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsVUFBVTtBQUNWLEVBQUU7OztBQUdGO0FBQ0EsVUFBVTtBQUNWLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7OztBQUdBO0FBQ0E7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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0NBQWtDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8saUNBQWlDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVO0FBQ1YsQ0FBQyxFIiwiZmlsZSI6ImNhbGVuZGFyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vYWYuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2FmLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9hci1kei5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvYXItZHouanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2FyLWt3LmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9hci1rdy5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vYXItbHkuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2FyLWx5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9hci1tYS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvYXItbWEuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2FyLXNhLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9hci1zYS5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vYXItdG4uanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2FyLXRuLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9hci5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvYXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2JnLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9iZy5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vY2EuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2NhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9jcy5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvY3MuanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2RhLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9kYS5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZGUtYXQuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2RlLWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9kZS1jaC5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZGUtY2guanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2RlLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZWwuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2VsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9lbi1hdS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZW4tYXUuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2VuLWNhLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9lbi1jYS5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZW4tZ2IuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2VuLWdiLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9lbi1pZS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZW4taWUuanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2VuLW56LmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9lbi1uei5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZXMtZG8uanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2VzLWRvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9lcy5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2V0LmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9ldC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZXUuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2V1LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9mYS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZmEuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2ZpLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9maS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZnItY2EuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2ZyLWNhLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9mci1jaC5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZnItY2guanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2ZyLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9mci5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vZ2wuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2dsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9oZS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvaGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2hpLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9oaS5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vaHIuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2hyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9odS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvaHUuanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2lkLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9pZC5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vaXMuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2lzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9pdC5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvaXQuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2phLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9qYS5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4va2suanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2trLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9rby5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUva28uanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL2xiLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9sYi5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vbHQuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2x0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9sdi5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbHYuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL21rLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9tay5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vbXMtbXkuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL21zLW15LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9tcy5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbXMuanNcbi8vIG1vZHVsZSBpZCA9IDE2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL25iLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9uYi5qc1xuLy8gbW9kdWxlIGlkID0gMTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vbmwtYmUuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL25sLWJlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9ubC5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvbmwuanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL25uLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9ubi5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vcGwuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3BsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9wdC1ici5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvcHQtYnIuanNcbi8vIG1vZHVsZSBpZCA9IDE3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL3B0LmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9wdC5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vcm8uanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3JvLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9ydS5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvcnUuanNcbi8vIG1vZHVsZSBpZCA9IDE3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL3NrLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9zay5qc1xuLy8gbW9kdWxlIGlkID0gMTc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vc2wuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3NsLmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9zci1jeXJsLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9zci1jeXJsLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi9zci5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvc3IuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL3N2LmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9zdi5qc1xuLy8gbW9kdWxlIGlkID0gMTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vdGguanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3RoLmpzXG4vLyBtb2R1bGUgaWQgPSAxODRcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi90ci5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvdHIuanNcbi8vIG1vZHVsZSBpZCA9IDE4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL3VrLmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS91ay5qc1xuLy8gbW9kdWxlIGlkID0gMTg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIGNicyA9IFtdLCBcblx0ZGF0YTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcblx0aWYoY2JzKSBjYnMucHVzaChjYik7XG5cdGVsc2UgY2IoZGF0YSk7XG59XG5yZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24ocmVxdWlyZSkge1xuXHRkYXRhID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vcmVtb3ZlQU1ELmpzIS4vdmkuanNcIik7XG5cdHZhciBjYWxsYmFja3MgPSBjYnM7XG5cdGNicyA9IG51bGw7XG5cdGZvcih2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2FsbGJhY2tzW2ldKGRhdGEpO1xuXHR9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVuZGxlLWxvYWRlciEuL34vZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3ZpLmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAxODMiLCJ2YXIgY2JzID0gW10sIFxuXHRkYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuXHRpZihjYnMpIGNicy5wdXNoKGNiKTtcblx0ZWxzZSBjYihkYXRhKTtcbn1cbnJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbihyZXF1aXJlKSB7XG5cdGRhdGEgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9yZW1vdmVBTUQuanMhLi96aC1jbi5qc1wiKTtcblx0dmFyIGNhbGxiYWNrcyA9IGNicztcblx0Y2JzID0gbnVsbDtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRjYWxsYmFja3NbaV0oZGF0YSk7XG5cdH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idW5kbGUtbG9hZGVyIS4vfi9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvemgtY24uanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyIsInZhciBjYnMgPSBbXSwgXG5cdGRhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNiKSB7XG5cdGlmKGNicykgY2JzLnB1c2goY2IpO1xuXHRlbHNlIGNiKGRhdGEpO1xufVxucmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uKHJlcXVpcmUpIHtcblx0ZGF0YSA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL3JlbW92ZUFNRC5qcyEuL3poLXR3LmpzXCIpO1xuXHR2YXIgY2FsbGJhY2tzID0gY2JzO1xuXHRjYnMgPSBudWxsO1xuXHRmb3IodmFyIGkgPSAwLCBsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGNhbGxiYWNrc1tpXShkYXRhKTtcblx0fVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1bmRsZS1sb2FkZXIhLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS96aC10dy5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwidmFyIG1hcCA9IHtcblx0XCIuL2FmXCI6IDEyMyxcblx0XCIuL2FmLmpzXCI6IDEyMyxcblx0XCIuL2FyXCI6IDEzMCxcblx0XCIuL2FyLWR6XCI6IDEyNCxcblx0XCIuL2FyLWR6LmpzXCI6IDEyNCxcblx0XCIuL2FyLWt3XCI6IDEyNSxcblx0XCIuL2FyLWt3LmpzXCI6IDEyNSxcblx0XCIuL2FyLWx5XCI6IDEyNixcblx0XCIuL2FyLWx5LmpzXCI6IDEyNixcblx0XCIuL2FyLW1hXCI6IDEyNyxcblx0XCIuL2FyLW1hLmpzXCI6IDEyNyxcblx0XCIuL2FyLXNhXCI6IDEyOCxcblx0XCIuL2FyLXNhLmpzXCI6IDEyOCxcblx0XCIuL2FyLXRuXCI6IDEyOSxcblx0XCIuL2FyLXRuLmpzXCI6IDEyOSxcblx0XCIuL2FyLmpzXCI6IDEzMCxcblx0XCIuL2JnXCI6IDEzMSxcblx0XCIuL2JnLmpzXCI6IDEzMSxcblx0XCIuL2NhXCI6IDEzMixcblx0XCIuL2NhLmpzXCI6IDEzMixcblx0XCIuL2NzXCI6IDEzMyxcblx0XCIuL2NzLmpzXCI6IDEzMyxcblx0XCIuL2RhXCI6IDEzNCxcblx0XCIuL2RhLmpzXCI6IDEzNCxcblx0XCIuL2RlXCI6IDEzNyxcblx0XCIuL2RlLWF0XCI6IDEzNSxcblx0XCIuL2RlLWF0LmpzXCI6IDEzNSxcblx0XCIuL2RlLWNoXCI6IDEzNixcblx0XCIuL2RlLWNoLmpzXCI6IDEzNixcblx0XCIuL2RlLmpzXCI6IDEzNyxcblx0XCIuL2VsXCI6IDEzOCxcblx0XCIuL2VsLmpzXCI6IDEzOCxcblx0XCIuL2VuLWF1XCI6IDEzOSxcblx0XCIuL2VuLWF1LmpzXCI6IDEzOSxcblx0XCIuL2VuLWNhXCI6IDE0MCxcblx0XCIuL2VuLWNhLmpzXCI6IDE0MCxcblx0XCIuL2VuLWdiXCI6IDE0MSxcblx0XCIuL2VuLWdiLmpzXCI6IDE0MSxcblx0XCIuL2VuLWllXCI6IDE0Mixcblx0XCIuL2VuLWllLmpzXCI6IDE0Mixcblx0XCIuL2VuLW56XCI6IDE0Myxcblx0XCIuL2VuLW56LmpzXCI6IDE0Myxcblx0XCIuL2VzXCI6IDE0NSxcblx0XCIuL2VzLWRvXCI6IDE0NCxcblx0XCIuL2VzLWRvLmpzXCI6IDE0NCxcblx0XCIuL2VzLmpzXCI6IDE0NSxcblx0XCIuL2V0XCI6IDE0Nixcblx0XCIuL2V0LmpzXCI6IDE0Nixcblx0XCIuL2V1XCI6IDE0Nyxcblx0XCIuL2V1LmpzXCI6IDE0Nyxcblx0XCIuL2ZhXCI6IDE0OCxcblx0XCIuL2ZhLmpzXCI6IDE0OCxcblx0XCIuL2ZpXCI6IDE0OSxcblx0XCIuL2ZpLmpzXCI6IDE0OSxcblx0XCIuL2ZyXCI6IDE1Mixcblx0XCIuL2ZyLWNhXCI6IDE1MCxcblx0XCIuL2ZyLWNhLmpzXCI6IDE1MCxcblx0XCIuL2ZyLWNoXCI6IDE1MSxcblx0XCIuL2ZyLWNoLmpzXCI6IDE1MSxcblx0XCIuL2ZyLmpzXCI6IDE1Mixcblx0XCIuL2dsXCI6IDE1Myxcblx0XCIuL2dsLmpzXCI6IDE1Myxcblx0XCIuL2hlXCI6IDE1NCxcblx0XCIuL2hlLmpzXCI6IDE1NCxcblx0XCIuL2hpXCI6IDE1NSxcblx0XCIuL2hpLmpzXCI6IDE1NSxcblx0XCIuL2hyXCI6IDE1Nixcblx0XCIuL2hyLmpzXCI6IDE1Nixcblx0XCIuL2h1XCI6IDE1Nyxcblx0XCIuL2h1LmpzXCI6IDE1Nyxcblx0XCIuL2lkXCI6IDE1OCxcblx0XCIuL2lkLmpzXCI6IDE1OCxcblx0XCIuL2lzXCI6IDE1OSxcblx0XCIuL2lzLmpzXCI6IDE1OSxcblx0XCIuL2l0XCI6IDE2MCxcblx0XCIuL2l0LmpzXCI6IDE2MCxcblx0XCIuL2phXCI6IDE2MSxcblx0XCIuL2phLmpzXCI6IDE2MSxcblx0XCIuL2trXCI6IDE2Mixcblx0XCIuL2trLmpzXCI6IDE2Mixcblx0XCIuL2tvXCI6IDE2Myxcblx0XCIuL2tvLmpzXCI6IDE2Myxcblx0XCIuL2xiXCI6IDE2NCxcblx0XCIuL2xiLmpzXCI6IDE2NCxcblx0XCIuL2x0XCI6IDE2NSxcblx0XCIuL2x0LmpzXCI6IDE2NSxcblx0XCIuL2x2XCI6IDE2Nixcblx0XCIuL2x2LmpzXCI6IDE2Nixcblx0XCIuL21rXCI6IDE2Nyxcblx0XCIuL21rLmpzXCI6IDE2Nyxcblx0XCIuL21zXCI6IDE2OSxcblx0XCIuL21zLW15XCI6IDE2OCxcblx0XCIuL21zLW15LmpzXCI6IDE2OCxcblx0XCIuL21zLmpzXCI6IDE2OSxcblx0XCIuL25iXCI6IDE3MCxcblx0XCIuL25iLmpzXCI6IDE3MCxcblx0XCIuL25sXCI6IDE3Mixcblx0XCIuL25sLWJlXCI6IDE3MSxcblx0XCIuL25sLWJlLmpzXCI6IDE3MSxcblx0XCIuL25sLmpzXCI6IDE3Mixcblx0XCIuL25uXCI6IDE3Myxcblx0XCIuL25uLmpzXCI6IDE3Myxcblx0XCIuL3BsXCI6IDE3NCxcblx0XCIuL3BsLmpzXCI6IDE3NCxcblx0XCIuL3B0XCI6IDE3Nixcblx0XCIuL3B0LWJyXCI6IDE3NSxcblx0XCIuL3B0LWJyLmpzXCI6IDE3NSxcblx0XCIuL3B0LmpzXCI6IDE3Nixcblx0XCIuL3JvXCI6IDE3Nyxcblx0XCIuL3JvLmpzXCI6IDE3Nyxcblx0XCIuL3J1XCI6IDE3OCxcblx0XCIuL3J1LmpzXCI6IDE3OCxcblx0XCIuL3NrXCI6IDE3OSxcblx0XCIuL3NrLmpzXCI6IDE3OSxcblx0XCIuL3NsXCI6IDE4MCxcblx0XCIuL3NsLmpzXCI6IDE4MCxcblx0XCIuL3NyXCI6IDE4Mixcblx0XCIuL3NyLWN5cmxcIjogMTgxLFxuXHRcIi4vc3ItY3lybC5qc1wiOiAxODEsXG5cdFwiLi9zci5qc1wiOiAxODIsXG5cdFwiLi9zdlwiOiAxODMsXG5cdFwiLi9zdi5qc1wiOiAxODMsXG5cdFwiLi90aFwiOiAxODQsXG5cdFwiLi90aC5qc1wiOiAxODQsXG5cdFwiLi90clwiOiAxODUsXG5cdFwiLi90ci5qc1wiOiAxODUsXG5cdFwiLi91a1wiOiAxODYsXG5cdFwiLi91ay5qc1wiOiAxODYsXG5cdFwiLi92aVwiOiAxODcsXG5cdFwiLi92aS5qc1wiOiAxODcsXG5cdFwiLi96aC1jblwiOiAxODgsXG5cdFwiLi96aC1jbi5qc1wiOiAxODgsXG5cdFwiLi96aC10d1wiOiAxODksXG5cdFwiLi96aC10dy5qc1wiOiAxODlcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18od2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkpO1xufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0dmFyIGlkID0gbWFwW3JlcV07XG5cdGlmKCEoaWQgKyAxKSkgLy8gY2hlY2sgZm9yIG51bWJlciBvciBzdHJpbmdcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKTtcblx0cmV0dXJuIGlkO1xufTtcbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSAzMDU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZSAuL34vYnVuZGxlLWxvYWRlciEgXlxcLlxcLy4qJFxuLy8gbW9kdWxlIGlkID0gMzA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMTgzIiwiaW1wb3J0ICdmdWxsY2FsZW5kYXInO1xuaW1wb3J0IGNvbnZlcnRUb0ZDIGZyb20gJy4vY29udmVydFRvRkMnO1xuaW1wb3J0IGRpc3BsYXlFdmVudCBmcm9tICcuL2Rpc3BsYXlFdmVudCc7XG5pbXBvcnQgbG9jYXRpb25IaXN0b3J5IGZyb20gJy4uL2NsaWVudC9sb2NhdGlvbkhpc3RvcnknO1xuaW1wb3J0IHsgc2V0dXBEVFAgfSBmcm9tICcuLi9jbGllbnQvcmVzcG9uc2VzJztcblxuY29uc3QgcXVlcnlSZWdFeHAgPSAvY2FsZW5kYXJcXC8/KD86XFwvKmV2ZW50XFwvKyhbMC05XSspKT8vO1xuXG5jb25zdCBiZWdpbiA9IChtb21lbnRMYW5nKSA9PiB7XG4gIGNvbnN0IGNhbGVuZGFyT3B0aW9ucyA9IHtcbiAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgaGVhZGVyOiB7XG4gICAgICBsZWZ0OiAncHJldixuZXh0IHRvZGF5JyxcbiAgICAgIGNlbnRlcjogJ3RpdGxlJyxcbiAgICAgIHJpZ2h0OiAnbW9udGgsYWdlbmRhV2VlayxhZ2VuZGFEYXknLFxuICAgIH0sXG4gICAgbGFuZzogbW9tZW50TGFuZyxcbiAgICBldmVudHM6IChzdGFydCwgZW5kLCB0aW1lem9uZSwgY2FsbGJhY2spID0+IHtcbiAgICAgIHNvY2tldC5lbWl0KCdwbHVnaW5zLmNhbGVuZGFyLmdldEV2ZW50c0J5RGF0ZScsIHtcbiAgICAgICAgc3RhcnREYXRlOiBzdGFydC52YWx1ZU9mKCksXG4gICAgICAgIGVuZERhdGU6IGVuZC52YWx1ZU9mKCksXG4gICAgICB9LCAoZXJyLCBldmVudHMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgICAgICAgYXBwLmFsZXJ0RXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soY29udmVydFRvRkMoZXZlbnRzKSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGV2ZW50Q2xpY2s6ICh7IG9yaWdpbmFsLCBpZDogcGlkIH0sIGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBkaXNwbGF5RXZlbnQob3JpZ2luYWwpO1xuICAgICAgaWYgKG9yaWdpbmFsLmV4dGVybmFsKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcmlnaW5hbC5yZXBlYXRzKSB7XG4gICAgICAgICAgYWpheGlmeS51cGRhdGVIaXN0b3J5KGBjYWxlbmRhci9ldmVudC8ke3BpZH0vJHtvcmlnaW5hbC5kYXl9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWpheGlmeS51cGRhdGVIaXN0b3J5KGBjYWxlbmRhci9ldmVudC8ke3BpZH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdGltZXpvbmU6ICdsb2NhbCcsXG4gIH07XG5cbiAgbGV0IHNob3VsZEhhbmRsZSA9IGZhbHNlO1xuXG4gIGxvY2F0aW9uSGlzdG9yeS5saXN0ZW4oKHN0YXRlLCBkYXRhKSA9PiB7XG4gICAgaWYgKHN0YXRlLnByZXYuc3RhcnRzV2l0aCgnY2FsZW5kYXInKSAmJiBzdGF0ZS5jdXJyZW50LnN0YXJ0c1dpdGgoJ2NhbGVuZGFyJykpIHtcbiAgICAgIGRhdGEudXJsID0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgc2hvdWxkSGFuZGxlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkSGFuZGxlID0gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgIGNvbnN0ICRjYWxlbmRhciA9ICQoJyNjYWxlbmRhcicpO1xuXG4gICAgaWYgKCRjYWxlbmRhciAmJiAhc2hvdWxkSGFuZGxlKSB7XG4gICAgICAkY2FsZW5kYXIuZnVsbENhbGVuZGFyKGNhbGVuZGFyT3B0aW9ucyk7XG4gICAgICBjb25zdCBidG4gPSAkKCcjcGx1Z2luLWNhbGVuZGFyLWNhbC1vbmx5LXllcycpO1xuICAgICAgYnRuXG4gICAgICAgIC5vbignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAkY2FsZW5kYXIudG9nZ2xlQ2xhc3MoJ3BsdWdpbi1jYWxlbmRhci1jYWwtb25seS15ZXMnKTtcbiAgICAgICAgICBidG4udG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICB9KVxuICAgICAgICAuZGV0YWNoKClcbiAgICAgICAgLmFwcGVuZFRvKCRjYWxlbmRhci5maW5kKCcuZmMtdG9vbGJhciAuZmMtcmlnaHQnKSk7XG4gICAgfVxuXG4gICAgY29uc3QgJGRpc3BsYXkgPSAkKCcjcGx1Z2luLWNhbGVuZGFyLWNhbC1ldmVudC1kaXNwbGF5Jyk7XG4gICAgaWYgKCRkaXNwbGF5KSB7XG4gICAgICAkZGlzcGxheS5vbignY2xpY2snLCAnLmRpc21pc3MnLCAoKSA9PiB7XG4gICAgICAgICRkaXNwbGF5Lm1vZGFsKCdoaWRlJyk7XG4gICAgICAgIGFqYXhpZnkudXBkYXRlSGlzdG9yeSgnY2FsZW5kYXInKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoZXMgPSBsb2NhdGlvbi5wYXRobmFtZS5tYXRjaChxdWVyeVJlZ0V4cCk7XG4gICAgY29uc3QgcGlkID0gbWF0Y2hlcyAmJiBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgaWYgKHBpZCkge1xuICAgICAgY29uc3QgZWwgPSAkY2FsZW5kYXJcbiAgICAgICAgLmRhdGEoJ2Z1bGxDYWxlbmRhcicpXG4gICAgICAgIC5nZXRFdmVudENhY2hlKClcbiAgICAgICAgLmZpbmQoeCA9PiB4LmlkID09PSBwaWQpO1xuXG4gICAgICBpZiAoc2hvdWxkSGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZWwgJiYgZWwub3JpZ2luYWw7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgIGRpc3BsYXlFdmVudChldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCBgJHtSRUxBVElWRV9QQVRIfS9jYWxlbmRhcmApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXR1cERUUCgkZGlzcGxheS5maW5kKCdbZGF0YS1kYXldJyksIHdpbmRvdy5jYWxlbmRhckV2ZW50RGF0YS5kYXkpO1xuICAgICAgfVxuICAgICAgJGNhbGVuZGFyLmZ1bGxDYWxlbmRhcignZ290b0RhdGUnLCBlbCA/IGVsLnN0YXJ0IDogKFxuICAgICAgICB3aW5kb3cuY2FsZW5kYXJFdmVudERhdGEuZGF5IHx8IHdpbmRvdy5jYWxlbmRhckV2ZW50RGF0YS5zdGFydERhdGVcbiAgICAgICkpO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkSGFuZGxlKSB7XG4gICAgICAkZGlzcGxheS5tb2RhbCgnaGlkZScpO1xuICAgIH1cbiAgfTtcblxuICAkKGRvY3VtZW50KS5yZWFkeShpbml0KTtcbiAgJCh3aW5kb3cpLm9uKCdhY3Rpb246YWpheGlmeS5lbmQnLCBpbml0KTtcbn07XG5cbl9fd2VicGFja19wdWJsaWNfcGF0aF9fID0gYCR7UkVMQVRJVkVfUEFUSH0vcGx1Z2lucy9ub2RlYmItcGx1Z2luLWNhbGVuZGFyL2J1bmRsZXMvYDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5jb25zdCBsYW5nID0gY29uZmlnLnVzZXJMYW5nIHx8IGNvbmZpZy5kZWZhdWx0TGFuZztcbmNvbnN0IG1vbWVudExhbmcgPSBsYW5nLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXy9nLCAnLScpO1xuXG50cnkge1xuICBpZiAobW9tZW50TGFuZyA9PT0gJ2VuLXVzJykge1xuICAgIGJlZ2luKCdlbi11cycpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVpcmUoYGJ1bmRsZS1sb2FkZXIhZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlLyR7bW9tZW50TGFuZ31gKSgoKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGJlZ2luKG1vbWVudExhbmcpO1xuICAgIH0pO1xuICB9XG59IGNhdGNoIChlKSB7XG4gIHRyeSB7XG4gICAgcmVxdWlyZShgYnVuZGxlLWxvYWRlciFmdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvJHttb21lbnRMYW5nLnNwbGl0KCctJylbMF19YCkoKCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBiZWdpbihtb21lbnRMYW5nKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBiZWdpbignZW4tdXMnKTtcbiAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90IGxvYWQgbG9jYWxlIGRhdGEgKCR7bW9tZW50TGFuZ30pIGZvciBmdWxsY2FsZW5kYXJgKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NhbGVuZGFyL2luZGV4LmpzIiwiY29uc3QgbWFwcGVyID0gZXZlbnQgPT4ge1xuICBjb25zdCBuZXdFdmVudCA9IHtcbiAgICBpZDogZXZlbnQucGlkLFxuICAgIHRpdGxlOiBldmVudC5uYW1lLFxuICAgIGFsbERheTogZXZlbnQuYWxsZGF5LFxuICAgIHN0YXJ0OiBldmVudC5zdGFydERhdGUsXG4gICAgZW5kOiBldmVudC5lbmREYXRlICsgMSxcbiAgICBjbGFzc05hbWU6IFtdLFxuICAgIG9yaWdpbmFsOiBldmVudCxcbiAgfTtcblxuICBpZiAoZXZlbnQuZXh0ZXJuYWwpIHtcbiAgICBuZXdFdmVudC5jbGFzc05hbWUgPSBbJ3BsdWdpbi1jYWxlbmRhci1jYWwtZXZlbnQtZXh0ZXJuYWwnXTtcbiAgfSBlbHNlIHtcbiAgICBuZXdFdmVudC5jbGFzc05hbWUgPSBbXG4gICAgICBgcGx1Z2luLWNhbGVuZGFyLWNhbC1ldmVudC1jYXRlZ29yeS0ke2V2ZW50LmNpZH1gLFxuICAgICAgYHBsdWdpbi1jYWxlbmRhci1jYWwtZXZlbnQtcmVzcG9uc2UtJHtldmVudC5yZXNwb25zZXNbYXBwLnVzZXIudWlkXSB8fCAnbm8nfWAsXG4gICAgICBldmVudC50b3BpY0RlbGV0ZWQgPyAncGx1Z2luLWNhbGVuZGFyLWNhbC1ldmVudC10b3BpYy1kZWxldGVkJyA6ICcnLFxuICAgIF07XG4gIH1cblxuICByZXR1cm4gbmV3RXZlbnQ7XG59O1xuXG5jb25zdCBjb252ZXJ0VG9GQyA9IGV2ZW50cyA9PiBldmVudHMubWFwKG1hcHBlcik7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnZlcnRUb0ZDO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NhbGVuZGFyL2NvbnZlcnRUb0ZDLmpzIiwiaW1wb3J0IHsgZXZlbnRUZW1wbGF0ZSB9IGZyb20gJy4uL2xpYi90ZW1wbGF0ZXMnO1xuaW1wb3J0IHsgc2V0dXBQb3N0IH0gZnJvbSAnLi4vY2xpZW50L3Jlc3BvbnNlcyc7XG5cbmNvbnN0IGRpc3BsYXlFdmVudCA9IChldmVudCwgY2IpID0+IHtcbiAgY29uc3QgY29udGVudCA9IGV2ZW50VGVtcGxhdGUoeyBldmVudCwgdWlkOiBhcHAudXNlci51aWQgfSk7XG4gIGNvbnN0IHBpZCA9IGV2ZW50LnBpZDtcblxuICBjb25zdCBkaXYgPSAkKGNvbnRlbnQpO1xuICBjb25zdCAkZGlzcGxheSA9ICQoJyNwbHVnaW4tY2FsZW5kYXItY2FsLWV2ZW50LWRpc3BsYXknKTtcbiAgY29uc3QgJGdvVG9Qb3N0ID0gJGRpc3BsYXkuZmluZCgnLm1vZGFsLWZvb3RlciBhLmJ0bi1wcmltYXJ5LmdvdG9wb3N0Jyk7XG4gIGNvbnN0ICRnb1RvVXJsID0gJGRpc3BsYXkuZmluZCgnLm1vZGFsLWZvb3RlciBhLmJ0bi1wcmltYXJ5LmdvdG91cmwnKTtcbiAgJGRpc3BsYXlcbiAgICAubW9kYWwoJ2hpZGUnKVxuICAgIC5maW5kKCcubW9kYWwtYm9keSAucG9zdHMnKVxuICAgIC5lbXB0eSgpXG4gICAgLmFwcGVuZChkaXYpO1xuICBpZiAoZXZlbnQuZXh0ZXJuYWwpIHtcbiAgICAkZ29Ub1Bvc3QuaGlkZSgpO1xuXG4gICAgaWYgKGV2ZW50LnVybCkge1xuICAgICAgJGdvVG9VcmxcbiAgICAgICAgLnNob3coKVxuICAgICAgICAuYXR0cignaHJlZicsIGV2ZW50LnVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRnb1RvVXJsLmhpZGUoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgJGdvVG9VcmwuaGlkZSgpO1xuICAgICRnb1RvUG9zdFxuICAgICAgLnNob3coKVxuICAgICAgLmF0dHIoJ2hyZWYnLCBgJHtSRUxBVElWRV9QQVRIfS9wb3N0LyR7cGlkfWApO1xuICB9XG4gICRkaXNwbGF5XG4gICAgLmZpbmQoJy5tb2RhbC1ib2R5JylcbiAgICAuYXR0cignZGF0YS1waWQnLCBwaWQpO1xuICBpZiAoIWV2ZW50LmV4dGVybmFsICYmIGV2ZW50LnJlcGVhdHMpIHtcbiAgICAkZGlzcGxheS5maW5kKCdbZGF0YS1kYXldJykuYXR0cignZGF0YS1kYXknLCBldmVudC5kYXkpO1xuICB9XG4gICRkaXNwbGF5XG4gICAgLm1vZGFsKCdzaG93Jyk7XG5cbiAgc2V0dXBQb3N0KHsgcGlkIH0sICgpID0+IHtcbiAgICAkKHdpbmRvdykudHJpZ2dlcignYWN0aW9uOmNhbGVuZGFyLmV2ZW50LmRpc3BsYXknLCB7IHBpZCwgZGF5OiBldmVudC5kYXksIG1vZGFsOiAkZGlzcGxheSB9KTtcblxuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiKHsgY29udGVudCwgcGFyc2VkOiBldmVudCB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZGlzcGxheUV2ZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NhbGVuZGFyL2Rpc3BsYXlFdmVudC5qcyIsImNvbnN0IG1ha2VMaXN0RWxlbWVudCA9IChuKSA9PiB7XG4gIGNvbnN0IGxpID0gYDxsaSBkYXRhLXZhbHVlPVwiJHtufVwiPltbbW9tZW50OnRpbWUtZHVyYXRpb24sICR7bn1dXTwvbGk+YDtcbiAgcmV0dXJuIGxpO1xufTtcblxuY29uc3QgZXZlbnRUZW1wbGF0ZSA9ICh7IGV2ZW50LCBpc0VtYWlsLCB1aWQgfSkgPT4ge1xuICBjb25zdCB7IHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgYWxsZGF5IH0gPSBldmVudDtcblxuICBsZXQgcmVzcG9uc2UgPSAnbm8nO1xuICBpZiAodWlkICYmIGV2ZW50LnJlc3BvbnNlcyAmJiBldmVudC5yZXNwb25zZXNbdWlkXSkge1xuICAgIHJlc3BvbnNlID0gZXZlbnQucmVzcG9uc2VzW3VpZF07XG4gIH1cbiAgY29uc3QgcmVzcG9uc2VzVGVtcGxhdGUgPSAoKSA9PiBgXG48ZGl2IGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLWV2ZW50LXJlc3BvbnNlc1wiIGRhdGEtZGF5PVwiJHtldmVudC5kYXkgfHwgJyd9XCI+XG4gIDxpIGNsYXNzPVwiZmEgZmEtcmVwbHlcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gIDxkaXYgY2xhc3M9XCJjb2wteHMtMTIgY29sLXNtLTZcIj5cbiAgICAke2V2ZW50LnJlcGVhdHMgPyBgXG4gICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIHBsdWdpbi1jYWxlbmRhci1ldmVudC1yZXNwb25zZXMtZGF5XCI+XG4gICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiB0aXRsZT1cIltbY2FsZW5kYXI6c2VsZWN0X2RheV1dXCIgdHlwZT1cInRleHRcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIj5cbiAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1jYWxlbmRhci1jaGVjay1vXCI+PC9pPlxuICAgICAgPC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIGAgOiAnJ31cbiAgICAke3VpZCA9PT0gMCA/ICcnIDogYFxuICAgIDxkaXYgY2xhc3M9XCJwbHVnaW4tY2FsZW5kYXItZXZlbnQtcmVzcG9uc2VzLXVzZXIgYnRuLWdyb3VwXCI+XG4gICAgICAkeygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHtcbiAgICAgICAgICBubzogJycsXG4gICAgICAgICAgbWF5YmU6ICcnLFxuICAgICAgICAgIHllczogJycsXG4gICAgICAgICAgW3Jlc3BvbnNlXTogJ2FjdGl2ZScsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGBcbiAgICAgIDxidXR0b24gZGF0YS12YWx1ZT1cIm5vXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tZGFuZ2VyICR7YWN0aXZlLm5vfVwiPlxuICAgICAgICBbW2NhbGVuZGFyOnJlc3BvbnNlX25vXV1cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBkYXRhLXZhbHVlPVwibWF5YmVcIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1kZWZhdWx0ICR7YWN0aXZlLm1heWJlfVwiPlxuICAgICAgICBbW2NhbGVuZGFyOnJlc3BvbnNlX21heWJlXV1cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBkYXRhLXZhbHVlPVwieWVzXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tc3VjY2VzcyAke2FjdGl2ZS55ZXN9XCI+XG4gICAgICAgIFtbY2FsZW5kYXI6cmVzcG9uc2VfeWVzXV1cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgICBgO1xuICAgICAgfSkoKX1cbiAgICA8L2Rpdj5cbiAgICBgfVxuICAgIDxkaXYgY2xhc3M9XCJwYW5lbC1ncm91cCBwbHVnaW4tY2FsZW5kYXItZXZlbnQtcmVzcG9uc2VzLWxpc3RzXCIgZGF0YS1sb2FkZWQ9XCJmYWxzZVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInBhbmVsIHBhbmVsLWRlZmF1bHQgY2xvc2VkXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYW5lbC1oZWFkaW5nXCI+XG4gICAgICAgICAgPGEgcm9sZT1cImJ1dHRvblwiIGRhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIiBocmVmPVwiI1wiXG4gICAgICAgICAgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1pbmZvXCIgYXJpYS1leHBhbmRlZD1cInRydWVcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtY2hldnJvbi1kb3duIHB1bGwtcmlnaHRcIj48L2k+XG4gICAgICAgICAgICBbW2NhbGVuZGFyOnJlc3BvbnNlX3llc11dXG4gICAgICAgICAgPC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhbmVsLWNvbGxhcHNlXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInBhbmVsLWJvZHlcIj5cbiAgICAgICAgICAgIDx1bCBjbGFzcz1cInBsdWdpbi1jYWxlbmRhci1ldmVudC1yZXNwb25zZXMtbGlzdC15ZXNcIj5cbiAgICAgICAgICAgICAgPCEtLSB5ZXMgcmVzcG9uc2VzIGdvIGhlcmUgLS0+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInBhbmVsIHBhbmVsLWRlZmF1bHQgY2xvc2VkXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYW5lbC1oZWFkaW5nXCI+XG4gICAgICAgICAgPGEgcm9sZT1cImJ1dHRvblwiIGRhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIiBocmVmPVwiI1wiXG4gICAgICAgICAgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1saW5rXCIgYXJpYS1leHBhbmRlZD1cInRydWVcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtY2hldnJvbi1kb3duIHB1bGwtcmlnaHRcIj48L2k+XG4gICAgICAgICAgICBbW2NhbGVuZGFyOnJlc3BvbnNlX21heWJlXV1cbiAgICAgICAgICA8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicGFuZWwtY29sbGFwc2VcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFuZWwtYm9keVwiPlxuICAgICAgICAgICAgPHVsIGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLWV2ZW50LXJlc3BvbnNlcy1saXN0LW1heWJlXCI+XG4gICAgICAgICAgICAgIDwhLS0gbWF5YmUgcmVzcG9uc2VzIGdvIGhlcmUgLS0+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInBhbmVsIHBhbmVsLWRlZmF1bHQgY2xvc2VkXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYW5lbC1oZWFkaW5nXCI+XG4gICAgICAgICAgPGEgcm9sZT1cImJ1dHRvblwiIGRhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIiBocmVmPVwiI1wiXG4gICAgICAgICAgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi13YXJuaW5nXCIgYXJpYS1leHBhbmRlZD1cInRydWVcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtY2hldnJvbi1kb3duIHB1bGwtcmlnaHRcIj48L2k+XG4gICAgICAgICAgICBbW2NhbGVuZGFyOnJlc3BvbnNlX25vXV1cbiAgICAgICAgICA8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicGFuZWwtY29sbGFwc2VcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFuZWwtYm9keVwiPlxuICAgICAgICAgICAgPHVsIGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLWV2ZW50LXJlc3BvbnNlcy1saXN0LW5vXCI+XG4gICAgICAgICAgICAgIDwhLS0gbm8gcmVzcG9uc2VzIGdvIGhlcmUgLS0+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PmA7XG4gIGxldCByZXNwb25zZXMgPSBpc0VtYWlsID8gYFxuICA8ZGl2IGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLWV2ZW50LXJlc3BvbnNlc1wiPlxuICAgIDxpIGNsYXNzPVwiZmEgZmEtcmVwbHlcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgW1tjYWxlbmRhcjp5b3VfcmVzcG9uZGVkLCBbW2NhbGVuZGFyOnJlc3BvbnNlXyR7cmVzcG9uc2V9XV1dXVxuICA8L2Rpdj5cbiAgYCA6IHJlc3BvbnNlc1RlbXBsYXRlKCk7XG5cbiAgaWYgKGV2ZW50LmV4dGVybmFsKSB7XG4gICAgcmVzcG9uc2VzID0gJyc7XG4gIH1cblxuICBjb25zdCBodG1sID0gYFxuPGRpdiBjbGFzcz1cInBsdWdpbi1jYWxlbmRhci1ldmVudCBwYW5lbCBwYW5lbC1zdWNjZXNzXCIgZGF0YS10cmFuc2xhdGVkPVwiZmFsc2VcIj5cbiAgPGRpdiBjbGFzcz1cInBsdWdpbi1jYWxlbmRhci1ldmVudC1uYW1lIHBhbmVsLWhlYWRpbmdcIj5cbiAgICAke2V2ZW50Lm5hbWV9XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwicGFuZWwtYm9keVwiPlxuICAgIDxkaXYgY2xhc3M9XCJwbHVnaW4tY2FsZW5kYXItZXZlbnQtZGF0ZVwiPlxuICAgICAgPGkgY2xhc3M9XCJmYSBmYS1jbG9jay1vXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgPGFcbiAgICAgICAgdGl0bGU9XCJbW21vbWVudDp0aW1lLWRhdGUtdmlldywgdXRjLCAke3N0YXJ0RGF0ZX0sICR7ZW5kRGF0ZX0sICR7YWxsZGF5fV1dIFVUQ1wiXG4gICAgICAgIGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLXRpbWUtZGF0ZS12aWV3XCJcbiAgICAgID5bW21vbWVudDp0aW1lLWRhdGUtdmlldywgbG9jYWwsICR7c3RhcnREYXRlfSwgJHtlbmREYXRlfSwgJHthbGxkYXl9XV08L2E+XG4gICAgPC9kaXY+XG4gICAgJHtldmVudC5leHRlcm5hbCA/IGBcbiAgICA8ZGl2IGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLWV2ZW50LWxvY2F0aW9uXCI+XG4gICAgICA8aSBjbGFzcz1cImZhIGZhLWxvY2F0aW9uLWFycm93XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgPHNwYW4+RXh0ZXJuYWw6ICR7ZXZlbnQuc291cmNlfTxzcGFuPlxuICAgIDwvZGl2PlxuICAgIGAgOiAnJ31cbiAgICAke2V2ZW50LmxvY2F0aW9uID8gYFxuICAgIDxkaXYgY2xhc3M9XCJwbHVnaW4tY2FsZW5kYXItZXZlbnQtbG9jYXRpb25cIj5cbiAgICAgIDxpIGNsYXNzPVwiZmEgZmEtbG9jYXRpb24tYXJyb3dcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgICA8c3Bhbj4ke2V2ZW50LmxvY2F0aW9ufTxzcGFuPlxuICAgIDwvZGl2PlxuICAgIGAgOiAnJ31cbiAgICAke2V2ZW50LmRlc2NyaXB0aW9uID8gYFxuICAgIDxkaXYgY2xhc3M9XCJwbHVnaW4tY2FsZW5kYXItZXZlbnQtZGVzY3JpcHRpb25cIj5cbiAgICAgIDxpIGNsYXNzPVwiZmEgZmEtaW5mby1jaXJjbGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgICA8ZGl2PiR7ZXZlbnQuZGVzY3JpcHRpb259PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYCA6ICcnfVxuICAgICR7IWV2ZW50LmV4dGVybmFsICYmIGV2ZW50LnJlbWluZGVycy5sZW5ndGggPyBgXG4gICAgPGRpdiBjbGFzcz1cInBsdWdpbi1jYWxlbmRhci1ldmVudC1yZW1pbmRlcnNcIj5cbiAgICAgIDxpIGNsYXNzPVwiZmEgZmEtYmVsbFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cbiAgICAgIDx1bD5cbiAgICAgICAgJHtldmVudC5yZW1pbmRlcnNcbiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICAgICAgLm1hcChtYWtlTGlzdEVsZW1lbnQpLmpvaW4oJ1xcbicpfVxuICAgICAgPC91bD5cbiAgICA8L2Rpdj5cbiAgICBgIDogJyd9XG4gICAgJHsoKCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnJlcGVhdHMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gWydkYXknLCAnd2VlaycsICdtb250aCcsICd5ZWFyJ10uZmluZCh4ID0+IGV2ZW50LnJlcGVhdHMuZXZlcnlbeF0pO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLWV2ZW50LXJlcGVhdHNcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtcmVwZWF0XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgICAgICAgPHNwYW4+W1tjYWxlbmRhcjpldmVyeV8ke2tleX1dXTwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5yZXBlYXRzLmV2ZXJ5LmRheXNPZldlZWspIHtcbiAgICAgICAgICBjb25zdCBkYXlzID0gZXZlbnQucmVwZWF0cy5ldmVyeS5kYXlzT2ZXZWVrXG4gICAgICAgICAgICAubWFwKGRheSA9PiBgW1ttb21lbnQ6bG9jYWxlLWRhdGEsIF93ZWVrZGF5c1Nob3J0LCAke2RheX1dXWApXG4gICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICBjb25zdCBlbmREYXRlVGV4dCA9IGBbW21vbWVudDp0aW1lLWRhdGUtdmlldywgdXRjLCAke2V2ZW50LnJlcGVhdHMuZW5kRGF0ZX0sIGAgK1xuICAgICAgICAgICAgYCR7ZXZlbnQucmVwZWF0cy5lbmREYXRlfSwgdHJ1ZV1dYDtcbiAgICAgICAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCJwbHVnaW4tY2FsZW5kYXItZXZlbnQtcmVwZWF0c1wiPlxuICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1yZXBlYXRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgJHtOdW1iZXIuaXNGaW5pdGUoZXZlbnQucmVwZWF0cy5lbmREYXRlKSA/IGBcbiAgICAgICAgICAgICAgW1tjYWxlbmRhcjpyZXBlYXRzX3dlZWtseV9vbl91bnRpbCwgJHtlbmREYXRlVGV4dH1dXSAke2RheXN9XG4gICAgICAgICAgICAgIGAgOiBgXG4gICAgICAgICAgICAgIFtbY2FsZW5kYXI6cmVwZWF0c193ZWVrbHlfb25fZm9yZXZlcl1dICR7ZGF5c31cbiAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSkoKX1cbiAgICAke2V2ZW50Lm1hbmRhdG9yeSA/IGBcbiAgICA8ZGl2IGNsYXNzPVwicGx1Z2luLWNhbGVuZGFyLWV2ZW50LW1hbmRhdG9yeVwiPlxuICAgICAgPGkgY2xhc3M9XCJmYSBmYS1leGNsYW1hdGlvbi1jaXJjbGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgICA8c3Bhbj5bW2NhbGVuZGFyOm1hbmRhdG9yeV1dPC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIGAgOiByZXNwb25zZXN9XG4gIDwvZGl2PlxuPC9kaXY+YDtcblxuICByZXR1cm4gaHRtbDtcbn07XG5cbmV4cG9ydCB7IGV2ZW50VGVtcGxhdGUgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9saWIvdGVtcGxhdGVzLmpzIiwiLyohXG4gKiBGdWxsQ2FsZW5kYXIgdjMuNC4wXG4gKiBEb2NzICYgTGljZW5zZTogaHR0cHM6Ly9mdWxsY2FsZW5kYXIuaW8vXG4gKiAoYykgMjAxNyBBZGFtIFNoYXdcbiAqL1xuXG5pbXBvcnQgbW9tZW50IGZyb20gXCJtb21lbnRcIjtcbihmdW5jdGlvbihmYWN0b3J5KSB7XG4gIGZhY3RvcnkoalF1ZXJ5LCBtb21lbnQpO1xufSkoZnVuY3Rpb24oJCwgbW9tZW50KSB7XG5cbjs7XG5cbnZhciBGQyA9ICQuZnVsbENhbGVuZGFyID0ge1xuXHR2ZXJzaW9uOiBcIjMuNC4wXCIsXG5cdC8vIFdoZW4gaW50cm9kdWNpbmcgaW50ZXJuYWwgQVBJIGluY29tcGF0aWJpbGl0aWVzICh3aGVyZSBmdWxsY2FsZW5kYXIgcGx1Z2lucyB3b3VsZCBicmVhayksXG5cdC8vIHRoZSBtaW5vciB2ZXJzaW9uIG9mIHRoZSBjYWxlbmRhciBzaG91bGQgYmUgdXBwZWQgKGV4OiAyLjcuMiAtPiAyLjguMClcblx0Ly8gYW5kIHRoZSBiZWxvdyBpbnRlZ2VyIHNob3VsZCBiZSBpbmNyZW1lbnRlZC5cblx0aW50ZXJuYWxBcGlWZXJzaW9uOiA5XG59O1xudmFyIGZjVmlld3MgPSBGQy52aWV3cyA9IHt9O1xuXG5cbiQuZm4uZnVsbENhbGVuZGFyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBhIHBvc3NpYmxlIG1ldGhvZCBjYWxsXG5cdHZhciByZXMgPSB0aGlzOyAvLyB3aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gKHRoaXMgalF1ZXJ5IG9iamVjdCBieSBkZWZhdWx0KVxuXG5cdHRoaXMuZWFjaChmdW5jdGlvbihpLCBfZWxlbWVudCkgeyAvLyBsb29wIGVhY2ggRE9NIGVsZW1lbnQgaW52b2x2ZWRcblx0XHR2YXIgZWxlbWVudCA9ICQoX2VsZW1lbnQpO1xuXHRcdHZhciBjYWxlbmRhciA9IGVsZW1lbnQuZGF0YSgnZnVsbENhbGVuZGFyJyk7IC8vIGdldCB0aGUgZXhpc3RpbmcgY2FsZW5kYXIgb2JqZWN0IChpZiBhbnkpXG5cdFx0dmFyIHNpbmdsZVJlczsgLy8gdGhlIHJldHVybmVkIHZhbHVlIG9mIHRoaXMgc2luZ2xlIG1ldGhvZCBjYWxsXG5cblx0XHQvLyBhIG1ldGhvZCBjYWxsXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuXHRcdFx0aWYgKGNhbGVuZGFyICYmICQuaXNGdW5jdGlvbihjYWxlbmRhcltvcHRpb25zXSkpIHtcblx0XHRcdFx0c2luZ2xlUmVzID0gY2FsZW5kYXJbb3B0aW9uc10uYXBwbHkoY2FsZW5kYXIsIGFyZ3MpO1xuXHRcdFx0XHRpZiAoIWkpIHtcblx0XHRcdFx0XHRyZXMgPSBzaW5nbGVSZXM7IC8vIHJlY29yZCB0aGUgZmlyc3QgbWV0aG9kIGNhbGwgcmVzdWx0XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9wdGlvbnMgPT09ICdkZXN0cm95JykgeyAvLyBmb3IgdGhlIGRlc3Ryb3kgbWV0aG9kLCBtdXN0IHJlbW92ZSBDYWxlbmRhciBvYmplY3QgZGF0YVxuXHRcdFx0XHRcdGVsZW1lbnQucmVtb3ZlRGF0YSgnZnVsbENhbGVuZGFyJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gYSBuZXcgY2FsZW5kYXIgaW5pdGlhbGl6YXRpb25cblx0XHRlbHNlIGlmICghY2FsZW5kYXIpIHsgLy8gZG9uJ3QgaW5pdGlhbGl6ZSB0d2ljZVxuXHRcdFx0Y2FsZW5kYXIgPSBuZXcgQ2FsZW5kYXIoZWxlbWVudCwgb3B0aW9ucyk7XG5cdFx0XHRlbGVtZW50LmRhdGEoJ2Z1bGxDYWxlbmRhcicsIGNhbGVuZGFyKTtcblx0XHRcdGNhbGVuZGFyLnJlbmRlcigpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHJlcztcbn07XG5cblxudmFyIGNvbXBsZXhPcHRpb25zID0gWyAvLyBuYW1lcyBvZiBvcHRpb25zIHRoYXQgYXJlIG9iamVjdHMgd2hvc2UgcHJvcGVydGllcyBzaG91bGQgYmUgY29tYmluZWRcblx0J2hlYWRlcicsXG5cdCdmb290ZXInLFxuXHQnYnV0dG9uVGV4dCcsXG5cdCdidXR0b25JY29ucycsXG5cdCd0aGVtZUJ1dHRvbkljb25zJ1xuXTtcblxuXG4vLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb3B0aW9uIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3RcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25PYmpzKSB7XG5cdHJldHVybiBtZXJnZVByb3BzKG9wdGlvbk9ianMsIGNvbXBsZXhPcHRpb25zKTtcbn1cblxuOztcblxuLy8gZXhwb3J0c1xuRkMuaW50ZXJzZWN0UmFuZ2VzID0gaW50ZXJzZWN0UmFuZ2VzO1xuRkMuYXBwbHlBbGwgPSBhcHBseUFsbDtcbkZDLmRlYm91bmNlID0gZGVib3VuY2U7XG5GQy5pc0ludCA9IGlzSW50O1xuRkMuaHRtbEVzY2FwZSA9IGh0bWxFc2NhcGU7XG5GQy5jc3NUb1N0ciA9IGNzc1RvU3RyO1xuRkMucHJveHkgPSBwcm94eTtcbkZDLmNhcGl0YWxpc2VGaXJzdExldHRlciA9IGNhcGl0YWxpc2VGaXJzdExldHRlcjtcblxuXG4vKiBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgRE9NIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuLy8gR2l2ZW4gdGhlIHNjcm9sbGJhciB3aWR0aHMgb2Ygc29tZSBvdGhlciBjb250YWluZXIsIGNyZWF0ZSBib3JkZXJzL21hcmdpbnMgb24gcm93RWxzIGluIG9yZGVyIHRvIG1hdGNoIHRoZSBsZWZ0XG4vLyBhbmQgcmlnaHQgc3BhY2UgdGhhdCB3YXMgb2Zmc2V0IGJ5IHRoZSBzY3JvbGxiYXJzLiBBIDEtcGl4ZWwgYm9yZGVyIGZpcnN0LCB0aGVuIG1hcmdpbiBiZXlvbmQgdGhhdC5cbmZ1bmN0aW9uIGNvbXBlbnNhdGVTY3JvbGwocm93RWxzLCBzY3JvbGxiYXJXaWR0aHMpIHtcblx0aWYgKHNjcm9sbGJhcldpZHRocy5sZWZ0KSB7XG5cdFx0cm93RWxzLmNzcyh7XG5cdFx0XHQnYm9yZGVyLWxlZnQtd2lkdGgnOiAxLFxuXHRcdFx0J21hcmdpbi1sZWZ0Jzogc2Nyb2xsYmFyV2lkdGhzLmxlZnQgLSAxXG5cdFx0fSk7XG5cdH1cblx0aWYgKHNjcm9sbGJhcldpZHRocy5yaWdodCkge1xuXHRcdHJvd0Vscy5jc3Moe1xuXHRcdFx0J2JvcmRlci1yaWdodC13aWR0aCc6IDEsXG5cdFx0XHQnbWFyZ2luLXJpZ2h0Jzogc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0IC0gMVxuXHRcdH0pO1xuXHR9XG59XG5cblxuLy8gVW5kb2VzIGNvbXBlbnNhdGVTY3JvbGwgYW5kIHJlc3RvcmVzIGFsbCBib3JkZXJzL21hcmdpbnNcbmZ1bmN0aW9uIHVuY29tcGVuc2F0ZVNjcm9sbChyb3dFbHMpIHtcblx0cm93RWxzLmNzcyh7XG5cdFx0J21hcmdpbi1sZWZ0JzogJycsXG5cdFx0J21hcmdpbi1yaWdodCc6ICcnLFxuXHRcdCdib3JkZXItbGVmdC13aWR0aCc6ICcnLFxuXHRcdCdib3JkZXItcmlnaHQtd2lkdGgnOiAnJ1xuXHR9KTtcbn1cblxuXG4vLyBNYWtlIHRoZSBtb3VzZSBjdXJzb3IgZXhwcmVzcyB0aGF0IGFuIGV2ZW50IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBjdXJyZW50IGFyZWFcbmZ1bmN0aW9uIGRpc2FibGVDdXJzb3IoKSB7XG5cdCQoJ2JvZHknKS5hZGRDbGFzcygnZmMtbm90LWFsbG93ZWQnKTtcbn1cblxuXG4vLyBSZXR1cm5zIHRoZSBtb3VzZSBjdXJzb3IgdG8gaXRzIG9yaWdpbmFsIGxvb2tcbmZ1bmN0aW9uIGVuYWJsZUN1cnNvcigpIHtcblx0JCgnYm9keScpLnJlbW92ZUNsYXNzKCdmYy1ub3QtYWxsb3dlZCcpO1xufVxuXG5cbi8vIEdpdmVuIGEgdG90YWwgYXZhaWxhYmxlIGhlaWdodCB0byBmaWxsLCBoYXZlIGBlbHNgIChlc3NlbnRpYWxseSBjaGlsZCByb3dzKSBleHBhbmQgdG8gYWNjb21vZGF0ZS5cbi8vIEJ5IGRlZmF1bHQsIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBzaG9ydGVyIHRoYW4gdGhlIHJlY29tbWVuZGVkIGhlaWdodCBhcmUgZXhwYW5kZWQgdW5pZm9ybWx5LCBub3QgY29uc2lkZXJpbmdcbi8vIGFueSBvdGhlciBlbHMgdGhhdCBhcmUgYWxyZWFkeSB0b28gdGFsbC4gaWYgYHNob3VsZFJlZGlzdHJpYnV0ZWAgaXMgb24sIGl0IGNvbnNpZGVycyB0aGVzZSB0YWxsIHJvd3MgYW5kIFxuLy8gcmVkdWNlcyB0aGUgYXZhaWxhYmxlIGhlaWdodC5cbmZ1bmN0aW9uIGRpc3RyaWJ1dGVIZWlnaHQoZWxzLCBhdmFpbGFibGVIZWlnaHQsIHNob3VsZFJlZGlzdHJpYnV0ZSkge1xuXG5cdC8vICpGTE9PUklORyBOT1RFKjogd2UgZmxvb3IgaW4gY2VydGFpbiBwbGFjZXMgYmVjYXVzZSB6b29tIGNhbiBnaXZlIGluYWNjdXJhdGUgZmxvYXRpbmctcG9pbnQgZGltZW5zaW9ucyxcblx0Ly8gYW5kIGl0IGlzIGJldHRlciB0byBiZSBzaG9ydGVyIHRoYW4gdGFsbGVyLCB0byBhdm9pZCBjcmVhdGluZyB1bm5lY2Vzc2FyeSBzY3JvbGxiYXJzLlxuXG5cdHZhciBtaW5PZmZzZXQxID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLyBlbHMubGVuZ3RoKTsgLy8gZm9yIG5vbi1sYXN0IGVsZW1lbnRcblx0dmFyIG1pbk9mZnNldDIgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAtIG1pbk9mZnNldDEgKiAoZWxzLmxlbmd0aCAtIDEpKTsgLy8gZm9yIGxhc3QgZWxlbWVudCAqRkxPT1JJTkcgTk9URSpcblx0dmFyIGZsZXhFbHMgPSBbXTsgLy8gZWxlbWVudHMgdGhhdCBhcmUgYWxsb3dlZCB0byBleHBhbmQuIGFycmF5IG9mIERPTSBub2Rlc1xuXHR2YXIgZmxleE9mZnNldHMgPSBbXTsgLy8gYW1vdW50IG9mIHZlcnRpY2FsIHNwYWNlIGl0IHRha2VzIHVwXG5cdHZhciBmbGV4SGVpZ2h0cyA9IFtdOyAvLyBhY3R1YWwgY3NzIGhlaWdodFxuXHR2YXIgdXNlZEhlaWdodCA9IDA7XG5cblx0dW5kaXN0cmlidXRlSGVpZ2h0KGVscyk7IC8vIGdpdmUgYWxsIGVsZW1lbnRzIHRoZWlyIG5hdHVyYWwgaGVpZ2h0XG5cblx0Ly8gZmluZCBlbGVtZW50cyB0aGF0IGFyZSBiZWxvdyB0aGUgcmVjb21tZW5kZWQgaGVpZ2h0IChleHBhbmRhYmxlKS5cblx0Ly8gaW1wb3J0YW50IHRvIHF1ZXJ5IGZvciBoZWlnaHRzIGluIGEgc2luZ2xlIGZpcnN0IHBhc3MgKHRvIGF2b2lkIHJlZmxvdyBvc2NpbGxhdGlvbikuXG5cdGVscy5lYWNoKGZ1bmN0aW9uKGksIGVsKSB7XG5cdFx0dmFyIG1pbk9mZnNldCA9IGkgPT09IGVscy5sZW5ndGggLSAxID8gbWluT2Zmc2V0MiA6IG1pbk9mZnNldDE7XG5cdFx0dmFyIG5hdHVyYWxPZmZzZXQgPSAkKGVsKS5vdXRlckhlaWdodCh0cnVlKTtcblxuXHRcdGlmIChuYXR1cmFsT2Zmc2V0IDwgbWluT2Zmc2V0KSB7XG5cdFx0XHRmbGV4RWxzLnB1c2goZWwpO1xuXHRcdFx0ZmxleE9mZnNldHMucHVzaChuYXR1cmFsT2Zmc2V0KTtcblx0XHRcdGZsZXhIZWlnaHRzLnB1c2goJChlbCkuaGVpZ2h0KCkpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIHRoaXMgZWxlbWVudCBzdHJldGNoZXMgcGFzdCByZWNvbW1lbmRlZCBoZWlnaHQgKG5vbi1leHBhbmRhYmxlKS4gbWFyayB0aGUgc3BhY2UgYXMgb2NjdXBpZWQuXG5cdFx0XHR1c2VkSGVpZ2h0ICs9IG5hdHVyYWxPZmZzZXQ7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyByZWFkanVzdCB0aGUgcmVjb21tZW5kZWQgaGVpZ2h0IHRvIG9ubHkgY29uc2lkZXIgdGhlIGhlaWdodCBhdmFpbGFibGUgdG8gbm9uLW1heGVkLW91dCByb3dzLlxuXHRpZiAoc2hvdWxkUmVkaXN0cmlidXRlKSB7XG5cdFx0YXZhaWxhYmxlSGVpZ2h0IC09IHVzZWRIZWlnaHQ7XG5cdFx0bWluT2Zmc2V0MSA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC8gZmxleEVscy5sZW5ndGgpO1xuXHRcdG1pbk9mZnNldDIgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAtIG1pbk9mZnNldDEgKiAoZmxleEVscy5sZW5ndGggLSAxKSk7IC8vICpGTE9PUklORyBOT1RFKlxuXHR9XG5cblx0Ly8gYXNzaWduIGhlaWdodHMgdG8gYWxsIGV4cGFuZGFibGUgZWxlbWVudHNcblx0JChmbGV4RWxzKS5lYWNoKGZ1bmN0aW9uKGksIGVsKSB7XG5cdFx0dmFyIG1pbk9mZnNldCA9IGkgPT09IGZsZXhFbHMubGVuZ3RoIC0gMSA/IG1pbk9mZnNldDIgOiBtaW5PZmZzZXQxO1xuXHRcdHZhciBuYXR1cmFsT2Zmc2V0ID0gZmxleE9mZnNldHNbaV07XG5cdFx0dmFyIG5hdHVyYWxIZWlnaHQgPSBmbGV4SGVpZ2h0c1tpXTtcblx0XHR2YXIgbmV3SGVpZ2h0ID0gbWluT2Zmc2V0IC0gKG5hdHVyYWxPZmZzZXQgLSBuYXR1cmFsSGVpZ2h0KTsgLy8gc3VidHJhY3QgdGhlIG1hcmdpbi9wYWRkaW5nXG5cblx0XHRpZiAobmF0dXJhbE9mZnNldCA8IG1pbk9mZnNldCkgeyAvLyB3ZSBjaGVjayB0aGlzIGFnYWluIGJlY2F1c2UgcmVkaXN0cmlidXRpb24gbWlnaHQgaGF2ZSBjaGFuZ2VkIHRoaW5nc1xuXHRcdFx0JChlbCkuaGVpZ2h0KG5ld0hlaWdodCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuXG4vLyBVbmRvZXMgZGlzdHJ1YnV0ZUhlaWdodCwgcmVzdG9yaW5nIGFsbCBlbHMgdG8gdGhlaXIgbmF0dXJhbCBoZWlnaHRcbmZ1bmN0aW9uIHVuZGlzdHJpYnV0ZUhlaWdodChlbHMpIHtcblx0ZWxzLmhlaWdodCgnJyk7XG59XG5cblxuLy8gR2l2ZW4gYGVsc2AsIGEgalF1ZXJ5IHNldCBvZiA8dGQ+IGNlbGxzLCBmaW5kIHRoZSBjZWxsIHdpdGggdGhlIGxhcmdlc3QgbmF0dXJhbCB3aWR0aCBhbmQgc2V0IHRoZSB3aWR0aHMgb2YgYWxsIHRoZVxuLy8gY2VsbHMgdG8gYmUgdGhhdCB3aWR0aC5cbi8vIFBSRVJFUVVJU0lURTogaWYgeW91IHdhbnQgYSBjZWxsIHRvIHRha2UgdXAgd2lkdGgsIGl0IG5lZWRzIHRvIGhhdmUgYSBzaW5nbGUgaW5uZXIgZWxlbWVudCB3LyBkaXNwbGF5OmlubGluZVxuZnVuY3Rpb24gbWF0Y2hDZWxsV2lkdGhzKGVscykge1xuXHR2YXIgbWF4SW5uZXJXaWR0aCA9IDA7XG5cblx0ZWxzLmZpbmQoJz4gKicpLmVhY2goZnVuY3Rpb24oaSwgaW5uZXJFbCkge1xuXHRcdHZhciBpbm5lcldpZHRoID0gJChpbm5lckVsKS5vdXRlcldpZHRoKCk7XG5cdFx0aWYgKGlubmVyV2lkdGggPiBtYXhJbm5lcldpZHRoKSB7XG5cdFx0XHRtYXhJbm5lcldpZHRoID0gaW5uZXJXaWR0aDtcblx0XHR9XG5cdH0pO1xuXG5cdG1heElubmVyV2lkdGgrKzsgLy8gc29tZXRpbWVzIG5vdCBhY2N1cmF0ZSBvZiB3aWR0aCB0aGUgdGV4dCBuZWVkcyB0byBzdGF5IG9uIG9uZSBsaW5lLiBpbnN1cmFuY2VcblxuXHRlbHMud2lkdGgobWF4SW5uZXJXaWR0aCk7XG5cblx0cmV0dXJuIG1heElubmVyV2lkdGg7XG59XG5cblxuLy8gR2l2ZW4gb25lIGVsZW1lbnQgdGhhdCByZXNpZGVzIGluc2lkZSBhbm90aGVyLFxuLy8gU3VidHJhY3RzIHRoZSBoZWlnaHQgb2YgdGhlIGlubmVyIGVsZW1lbnQgZnJvbSB0aGUgb3V0ZXIgZWxlbWVudC5cbmZ1bmN0aW9uIHN1YnRyYWN0SW5uZXJFbEhlaWdodChvdXRlckVsLCBpbm5lckVsKSB7XG5cdHZhciBib3RoID0gb3V0ZXJFbC5hZGQoaW5uZXJFbCk7XG5cdHZhciBkaWZmO1xuXG5cdC8vIGVmZmluJyBJRTgvOS8xMC8xMSBzb21ldGltZXMgcmV0dXJucyAwIGZvciBkaW1lbnNpb25zLiB0aGlzIHdlaXJkIGhhY2sgd2FzIHRoZSBvbmx5IHRoaW5nIHRoYXQgd29ya2VkXG5cdGJvdGguY3NzKHtcblx0XHRwb3NpdGlvbjogJ3JlbGF0aXZlJywgLy8gY2F1c2UgYSByZWZsb3csIHdoaWNoIHdpbGwgZm9yY2UgZnJlc2ggZGltZW5zaW9uIHJlY2FsY3VsYXRpb25cblx0XHRsZWZ0OiAtMSAvLyBlbnN1cmUgcmVmbG93IGluIGNhc2UgdGhlIGVsIHdhcyBhbHJlYWR5IHJlbGF0aXZlLiBuZWdhdGl2ZSBpcyBsZXNzIGxpa2VseSB0byBjYXVzZSBuZXcgc2Nyb2xsXG5cdH0pO1xuXHRkaWZmID0gb3V0ZXJFbC5vdXRlckhlaWdodCgpIC0gaW5uZXJFbC5vdXRlckhlaWdodCgpOyAvLyBncmFiIHRoZSBkaW1lbnNpb25zXG5cdGJvdGguY3NzKHsgcG9zaXRpb246ICcnLCBsZWZ0OiAnJyB9KTsgLy8gdW5kbyBoYWNrXG5cblx0cmV0dXJuIGRpZmY7XG59XG5cblxuLyogRWxlbWVudCBHZW9tIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbkZDLmdldE91dGVyUmVjdCA9IGdldE91dGVyUmVjdDtcbkZDLmdldENsaWVudFJlY3QgPSBnZXRDbGllbnRSZWN0O1xuRkMuZ2V0Q29udGVudFJlY3QgPSBnZXRDb250ZW50UmVjdDtcbkZDLmdldFNjcm9sbGJhcldpZHRocyA9IGdldFNjcm9sbGJhcldpZHRocztcblxuXG4vLyBib3Jyb3dlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5LXVpL2Jsb2IvMS4xMS4wL3VpL2NvcmUuanMjTDUxXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWwpIHtcblx0dmFyIHBvc2l0aW9uID0gZWwuY3NzKCdwb3NpdGlvbicpLFxuXHRcdHNjcm9sbFBhcmVudCA9IGVsLnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gJCh0aGlzKTtcblx0XHRcdHJldHVybiAoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KFxuXHRcdFx0XHRwYXJlbnQuY3NzKCdvdmVyZmxvdycpICsgcGFyZW50LmNzcygnb3ZlcmZsb3cteScpICsgcGFyZW50LmNzcygnb3ZlcmZsb3cteCcpXG5cdFx0XHQpO1xuXHRcdH0pLmVxKDApO1xuXG5cdHJldHVybiBwb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCAhc2Nyb2xsUGFyZW50Lmxlbmd0aCA/ICQoZWxbMF0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkgOiBzY3JvbGxQYXJlbnQ7XG59XG5cblxuLy8gUXVlcmllcyB0aGUgb3V0ZXIgYm91bmRpbmcgYXJlYSBvZiBhIGpRdWVyeSBlbGVtZW50LlxuLy8gUmV0dXJucyBhIHJlY3RhbmdsZSB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzOiBsZWZ0LCByaWdodCAoZXhjbHVzaXZlKSwgdG9wLCBib3R0b20gKGV4Y2x1c2l2ZSkuXG4vLyBPcmlnaW4gaXMgb3B0aW9uYWwuXG5mdW5jdGlvbiBnZXRPdXRlclJlY3QoZWwsIG9yaWdpbikge1xuXHR2YXIgb2Zmc2V0ID0gZWwub2Zmc2V0KCk7XG5cdHZhciBsZWZ0ID0gb2Zmc2V0LmxlZnQgLSAob3JpZ2luID8gb3JpZ2luLmxlZnQgOiAwKTtcblx0dmFyIHRvcCA9IG9mZnNldC50b3AgLSAob3JpZ2luID8gb3JpZ2luLnRvcCA6IDApO1xuXG5cdHJldHVybiB7XG5cdFx0bGVmdDogbGVmdCxcblx0XHRyaWdodDogbGVmdCArIGVsLm91dGVyV2lkdGgoKSxcblx0XHR0b3A6IHRvcCxcblx0XHRib3R0b206IHRvcCArIGVsLm91dGVySGVpZ2h0KClcblx0fTtcbn1cblxuXG4vLyBRdWVyaWVzIHRoZSBhcmVhIHdpdGhpbiB0aGUgbWFyZ2luL2JvcmRlci9zY3JvbGxiYXJzIG9mIGEgalF1ZXJ5IGVsZW1lbnQuIERvZXMgbm90IGdvIHdpdGhpbiB0aGUgcGFkZGluZy5cbi8vIFJldHVybnMgYSByZWN0YW5nbGUgd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlczogbGVmdCwgcmlnaHQgKGV4Y2x1c2l2ZSksIHRvcCwgYm90dG9tIChleGNsdXNpdmUpLlxuLy8gT3JpZ2luIGlzIG9wdGlvbmFsLlxuLy8gV0FSTklORzogZ2l2ZW4gZWxlbWVudCBjYW4ndCBoYXZlIGJvcmRlcnNcbi8vIE5PVEU6IHNob3VsZCB1c2UgY2xpZW50TGVmdC9jbGllbnRUb3AsIGJ1dCB2ZXJ5IHVucmVsaWFibGUgY3Jvc3MtYnJvd3Nlci5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3QoZWwsIG9yaWdpbikge1xuXHR2YXIgb2Zmc2V0ID0gZWwub2Zmc2V0KCk7XG5cdHZhciBzY3JvbGxiYXJXaWR0aHMgPSBnZXRTY3JvbGxiYXJXaWR0aHMoZWwpO1xuXHR2YXIgbGVmdCA9IG9mZnNldC5sZWZ0ICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItbGVmdC13aWR0aCcpICsgc2Nyb2xsYmFyV2lkdGhzLmxlZnQgLSAob3JpZ2luID8gb3JpZ2luLmxlZnQgOiAwKTtcblx0dmFyIHRvcCA9IG9mZnNldC50b3AgKyBnZXRDc3NGbG9hdChlbCwgJ2JvcmRlci10b3Atd2lkdGgnKSArIHNjcm9sbGJhcldpZHRocy50b3AgLSAob3JpZ2luID8gb3JpZ2luLnRvcCA6IDApO1xuXG5cdHJldHVybiB7XG5cdFx0bGVmdDogbGVmdCxcblx0XHRyaWdodDogbGVmdCArIGVsWzBdLmNsaWVudFdpZHRoLCAvLyBjbGllbnRXaWR0aCBpbmNsdWRlcyBwYWRkaW5nIGJ1dCBOT1Qgc2Nyb2xsYmFyc1xuXHRcdHRvcDogdG9wLFxuXHRcdGJvdHRvbTogdG9wICsgZWxbMF0uY2xpZW50SGVpZ2h0IC8vIGNsaWVudEhlaWdodCBpbmNsdWRlcyBwYWRkaW5nIGJ1dCBOT1Qgc2Nyb2xsYmFyc1xuXHR9O1xufVxuXG5cbi8vIFF1ZXJpZXMgdGhlIGFyZWEgd2l0aGluIHRoZSBtYXJnaW4vYm9yZGVyL3BhZGRpbmcgb2YgYSBqUXVlcnkgZWxlbWVudC4gQXNzdW1lZCBub3QgdG8gaGF2ZSBzY3JvbGxiYXJzLlxuLy8gUmV0dXJucyBhIHJlY3RhbmdsZSB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzOiBsZWZ0LCByaWdodCAoZXhjbHVzaXZlKSwgdG9wLCBib3R0b20gKGV4Y2x1c2l2ZSkuXG4vLyBPcmlnaW4gaXMgb3B0aW9uYWwuXG5mdW5jdGlvbiBnZXRDb250ZW50UmVjdChlbCwgb3JpZ2luKSB7XG5cdHZhciBvZmZzZXQgPSBlbC5vZmZzZXQoKTsgLy8ganVzdCBvdXRzaWRlIG9mIGJvcmRlciwgbWFyZ2luIG5vdCBpbmNsdWRlZFxuXHR2YXIgbGVmdCA9IG9mZnNldC5sZWZ0ICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItbGVmdC13aWR0aCcpICsgZ2V0Q3NzRmxvYXQoZWwsICdwYWRkaW5nLWxlZnQnKSAtXG5cdFx0KG9yaWdpbiA/IG9yaWdpbi5sZWZ0IDogMCk7XG5cdHZhciB0b3AgPSBvZmZzZXQudG9wICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItdG9wLXdpZHRoJykgKyBnZXRDc3NGbG9hdChlbCwgJ3BhZGRpbmctdG9wJykgLVxuXHRcdChvcmlnaW4gPyBvcmlnaW4udG9wIDogMCk7XG5cblx0cmV0dXJuIHtcblx0XHRsZWZ0OiBsZWZ0LFxuXHRcdHJpZ2h0OiBsZWZ0ICsgZWwud2lkdGgoKSxcblx0XHR0b3A6IHRvcCxcblx0XHRib3R0b206IHRvcCArIGVsLmhlaWdodCgpXG5cdH07XG59XG5cblxuLy8gUmV0dXJucyB0aGUgY29tcHV0ZWQgbGVmdC9yaWdodC90b3AvYm90dG9tIHNjcm9sbGJhciB3aWR0aHMgZm9yIHRoZSBnaXZlbiBqUXVlcnkgZWxlbWVudC5cbi8vIFdBUk5JTkc6IGdpdmVuIGVsZW1lbnQgY2FuJ3QgaGF2ZSBib3JkZXJzICh3aGljaCB3aWxsIGNhdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB0byBiZSBsYXJnZXIpLlxuLy8gTk9URTogc2hvdWxkIHVzZSBjbGllbnRMZWZ0L2NsaWVudFRvcCwgYnV0IHZlcnkgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyLlxuZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGhzKGVsKSB7XG5cdHZhciBsZWZ0UmlnaHRXaWR0aCA9IGVsWzBdLm9mZnNldFdpZHRoIC0gZWxbMF0uY2xpZW50V2lkdGg7XG5cdHZhciBib3R0b21XaWR0aCA9IGVsWzBdLm9mZnNldEhlaWdodCAtIGVsWzBdLmNsaWVudEhlaWdodDtcblx0dmFyIHdpZHRocztcblxuXHRsZWZ0UmlnaHRXaWR0aCA9IHNhbml0aXplU2Nyb2xsYmFyV2lkdGgobGVmdFJpZ2h0V2lkdGgpO1xuXHRib3R0b21XaWR0aCA9IHNhbml0aXplU2Nyb2xsYmFyV2lkdGgoYm90dG9tV2lkdGgpO1xuXG5cdHdpZHRocyA9IHsgbGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiBib3R0b21XaWR0aCB9O1xuXG5cdGlmIChnZXRJc0xlZnRSdGxTY3JvbGxiYXJzKCkgJiYgZWwuY3NzKCdkaXJlY3Rpb24nKSA9PSAncnRsJykgeyAvLyBpcyB0aGUgc2Nyb2xsYmFyIG9uIHRoZSBsZWZ0IHNpZGU/XG5cdFx0d2lkdGhzLmxlZnQgPSBsZWZ0UmlnaHRXaWR0aDtcblx0fVxuXHRlbHNlIHtcblx0XHR3aWR0aHMucmlnaHQgPSBsZWZ0UmlnaHRXaWR0aDtcblx0fVxuXG5cdHJldHVybiB3aWR0aHM7XG59XG5cblxuLy8gVGhlIHNjcm9sbGJhciB3aWR0aCBjb21wdXRhdGlvbnMgaW4gZ2V0U2Nyb2xsYmFyV2lkdGhzIGFyZSBzb21ldGltZXMgZmxhd2VkIHdoZW4gaXQgY29tZXMgdG9cbi8vIHJldGluYSBkaXNwbGF5cywgcm91bmRpbmcsIGFuZCBJRTExLiBNYXNzYWdlIHRoZW0gaW50byBhIHVzYWJsZSB2YWx1ZS5cbmZ1bmN0aW9uIHNhbml0aXplU2Nyb2xsYmFyV2lkdGgod2lkdGgpIHtcblx0d2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCk7IC8vIG5vIG5lZ2F0aXZlc1xuXHR3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuXHRyZXR1cm4gd2lkdGg7XG59XG5cblxuLy8gTG9naWMgZm9yIGRldGVybWluaW5nIGlmLCB3aGVuIHRoZSBlbGVtZW50IGlzIHJpZ2h0LXRvLWxlZnQsIHRoZSBzY3JvbGxiYXIgYXBwZWFycyBvbiB0aGUgbGVmdCBzaWRlXG5cbnZhciBfaXNMZWZ0UnRsU2Nyb2xsYmFycyA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldElzTGVmdFJ0bFNjcm9sbGJhcnMoKSB7IC8vIHJlc3BvbnNpYmxlIGZvciBjYWNoaW5nIHRoZSBjb21wdXRhdGlvblxuXHRpZiAoX2lzTGVmdFJ0bFNjcm9sbGJhcnMgPT09IG51bGwpIHtcblx0XHRfaXNMZWZ0UnRsU2Nyb2xsYmFycyA9IGNvbXB1dGVJc0xlZnRSdGxTY3JvbGxiYXJzKCk7XG5cdH1cblx0cmV0dXJuIF9pc0xlZnRSdGxTY3JvbGxiYXJzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSXNMZWZ0UnRsU2Nyb2xsYmFycygpIHsgLy8gY3JlYXRlcyBhbiBvZmZzY3JlZW4gdGVzdCBlbGVtZW50LCB0aGVuIHJlbW92ZXMgaXRcblx0dmFyIGVsID0gJCgnPGRpdj48ZGl2Lz48L2Rpdj4nKVxuXHRcdC5jc3Moe1xuXHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHR0b3A6IC0xMDAwLFxuXHRcdFx0bGVmdDogMCxcblx0XHRcdGJvcmRlcjogMCxcblx0XHRcdHBhZGRpbmc6IDAsXG5cdFx0XHRvdmVyZmxvdzogJ3Njcm9sbCcsXG5cdFx0XHRkaXJlY3Rpb246ICdydGwnXG5cdFx0fSlcblx0XHQuYXBwZW5kVG8oJ2JvZHknKTtcblx0dmFyIGlubmVyRWwgPSBlbC5jaGlsZHJlbigpO1xuXHR2YXIgcmVzID0gaW5uZXJFbC5vZmZzZXQoKS5sZWZ0ID4gZWwub2Zmc2V0KCkubGVmdDsgLy8gaXMgdGhlIGlubmVyIGRpdiBzaGlmdGVkIHRvIGFjY29tbW9kYXRlIGEgbGVmdCBzY3JvbGxiYXI/XG5cdGVsLnJlbW92ZSgpO1xuXHRyZXR1cm4gcmVzO1xufVxuXG5cbi8vIFJldHJpZXZlcyBhIGpRdWVyeSBlbGVtZW50J3MgY29tcHV0ZWQgQ1NTIHZhbHVlIGFzIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuLy8gSWYgdGhlIHF1ZXJpZWQgdmFsdWUgaXMgbm9uLW51bWVyaWMgKGV4OiBJRSBjYW4gcmV0dXJuIFwibWVkaXVtXCIgZm9yIGJvcmRlciB3aWR0aCksIHdpbGwganVzdCByZXR1cm4gemVyby5cbmZ1bmN0aW9uIGdldENzc0Zsb2F0KGVsLCBwcm9wKSB7XG5cdHJldHVybiBwYXJzZUZsb2F0KGVsLmNzcyhwcm9wKSkgfHwgMDtcbn1cblxuXG4vKiBNb3VzZSAvIFRvdWNoIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbkZDLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XG5cblxuLy8gUmV0dXJucyBhIGJvb2xlYW4gd2hldGhlciB0aGlzIHdhcyBhIGxlZnQgbW91c2UgY2xpY2sgYW5kIG5vIGN0cmwga2V5ICh3aGljaCBtZWFucyByaWdodCBjbGljayBvbiBNYWMpXG5mdW5jdGlvbiBpc1ByaW1hcnlNb3VzZUJ1dHRvbihldikge1xuXHRyZXR1cm4gZXYud2hpY2ggPT0gMSAmJiAhZXYuY3RybEtleTtcbn1cblxuXG5mdW5jdGlvbiBnZXRFdlgoZXYpIHtcblx0dmFyIHRvdWNoZXMgPSBldi5vcmlnaW5hbEV2ZW50LnRvdWNoZXM7XG5cblx0Ly8gb24gbW9iaWxlIEZGLCBwYWdlWCBmb3IgdG91Y2ggZXZlbnRzIGlzIHByZXNlbnQsIGJ1dCBpbmNvcnJlY3QsXG5cdC8vIHNvLCBsb29rIGF0IHRvdWNoIGNvb3JkaW5hdGVzIGZpcnN0LlxuXHRpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCkge1xuXHRcdHJldHVybiB0b3VjaGVzWzBdLnBhZ2VYO1xuXHR9XG5cblx0cmV0dXJuIGV2LnBhZ2VYO1xufVxuXG5cbmZ1bmN0aW9uIGdldEV2WShldikge1xuXHR2YXIgdG91Y2hlcyA9IGV2Lm9yaWdpbmFsRXZlbnQudG91Y2hlcztcblxuXHQvLyBvbiBtb2JpbGUgRkYsIHBhZ2VYIGZvciB0b3VjaCBldmVudHMgaXMgcHJlc2VudCwgYnV0IGluY29ycmVjdCxcblx0Ly8gc28sIGxvb2sgYXQgdG91Y2ggY29vcmRpbmF0ZXMgZmlyc3QuXG5cdGlmICh0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIHRvdWNoZXNbMF0ucGFnZVk7XG5cdH1cblxuXHRyZXR1cm4gZXYucGFnZVk7XG59XG5cblxuZnVuY3Rpb24gZ2V0RXZJc1RvdWNoKGV2KSB7XG5cdHJldHVybiAvXnRvdWNoLy50ZXN0KGV2LnR5cGUpO1xufVxuXG5cbmZ1bmN0aW9uIHByZXZlbnRTZWxlY3Rpb24oZWwpIHtcblx0ZWwuYWRkQ2xhc3MoJ2ZjLXVuc2VsZWN0YWJsZScpXG5cdFx0Lm9uKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbn1cblxuXG5mdW5jdGlvbiBhbGxvd1NlbGVjdGlvbihlbCkge1xuXHRlbC5yZW1vdmVDbGFzcygnZmMtdW5zZWxlY3RhYmxlJylcblx0XHQub2ZmKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbn1cblxuXG4vLyBTdG9wcyBhIG1vdXNlL3RvdWNoIGV2ZW50IGZyb20gZG9pbmcgaXQncyBuYXRpdmUgYnJvd3NlciBhY3Rpb25cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2KSB7XG5cdGV2LnByZXZlbnREZWZhdWx0KCk7XG59XG5cblxuLyogR2VuZXJhbCBHZW9tZXRyeSBVdGlsc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbkZDLmludGVyc2VjdFJlY3RzID0gaW50ZXJzZWN0UmVjdHM7XG5cbi8vIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RhbmdsZXMuIElmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIGZhbHNlXG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0cyhyZWN0MSwgcmVjdDIpIHtcblx0dmFyIHJlcyA9IHtcblx0XHRsZWZ0OiBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSxcblx0XHRyaWdodDogTWF0aC5taW4ocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KSxcblx0XHR0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcblx0XHRib3R0b206IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKVxuXHR9O1xuXG5cdGlmIChyZXMubGVmdCA8IHJlcy5yaWdodCAmJiByZXMudG9wIDwgcmVzLmJvdHRvbSkge1xuXHRcdHJldHVybiByZXM7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5cbi8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XG5cdHJldHVybiB7XG5cdFx0bGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXG5cdFx0dG9wOiBNYXRoLm1pbihNYXRoLm1heChwb2ludC50b3AsIHJlY3QudG9wKSwgcmVjdC5ib3R0b20pXG5cdH07XG59XG5cblxuLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3QpIHtcblx0cmV0dXJuIHtcblx0XHRsZWZ0OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLFxuXHRcdHRvcDogKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMlxuXHR9O1xufVxuXG5cbi8vIFN1YnRyYWN0cyBwb2ludDIncyBjb29yZGluYXRlcyBmcm9tIHBvaW50MSdzIGNvb3JkaW5hdGVzLCByZXR1cm5pbmcgYSBkZWx0YVxuZnVuY3Rpb24gZGlmZlBvaW50cyhwb2ludDEsIHBvaW50Mikge1xuXHRyZXR1cm4ge1xuXHRcdGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXG5cdFx0dG9wOiBwb2ludDEudG9wIC0gcG9pbnQyLnRvcFxuXHR9O1xufVxuXG5cbi8qIE9iamVjdCBPcmRlcmluZyBieSBGaWVsZFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbkZDLnBhcnNlRmllbGRTcGVjcyA9IHBhcnNlRmllbGRTcGVjcztcbkZDLmNvbXBhcmVCeUZpZWxkU3BlY3MgPSBjb21wYXJlQnlGaWVsZFNwZWNzO1xuRkMuY29tcGFyZUJ5RmllbGRTcGVjID0gY29tcGFyZUJ5RmllbGRTcGVjO1xuRkMuZmxleGlibGVDb21wYXJlID0gZmxleGlibGVDb21wYXJlO1xuXG5cbmZ1bmN0aW9uIHBhcnNlRmllbGRTcGVjcyhpbnB1dCkge1xuXHR2YXIgc3BlY3MgPSBbXTtcblx0dmFyIHRva2VucyA9IFtdO1xuXHR2YXIgaSwgdG9rZW47XG5cblx0aWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcblx0XHR0b2tlbnMgPSBpbnB1dC5zcGxpdCgvXFxzKixcXHMqLyk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dG9rZW5zID0gWyBpbnB1dCBdO1xuXHR9XG5cdGVsc2UgaWYgKCQuaXNBcnJheShpbnB1dCkpIHtcblx0XHR0b2tlbnMgPSBpbnB1dDtcblx0fVxuXG5cdGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRzcGVjcy5wdXNoKFxuXHRcdFx0XHR0b2tlbi5jaGFyQXQoMCkgPT0gJy0nID9cblx0XHRcdFx0XHR7IGZpZWxkOiB0b2tlbi5zdWJzdHJpbmcoMSksIG9yZGVyOiAtMSB9IDpcblx0XHRcdFx0XHR7IGZpZWxkOiB0b2tlbiwgb3JkZXI6IDEgfVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRzcGVjcy5wdXNoKHsgZnVuYzogdG9rZW4gfSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHNwZWNzO1xufVxuXG5cbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMSwgb2JqMiwgZmllbGRTcGVjcykge1xuXHR2YXIgaTtcblx0dmFyIGNtcDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgZmllbGRTcGVjcy5sZW5ndGg7IGkrKykge1xuXHRcdGNtcCA9IGNvbXBhcmVCeUZpZWxkU3BlYyhvYmoxLCBvYmoyLCBmaWVsZFNwZWNzW2ldKTtcblx0XHRpZiAoY21wKSB7XG5cdFx0XHRyZXR1cm4gY21wO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiAwO1xufVxuXG5cbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlYyhvYmoxLCBvYmoyLCBmaWVsZFNwZWMpIHtcblx0aWYgKGZpZWxkU3BlYy5mdW5jKSB7XG5cdFx0cmV0dXJuIGZpZWxkU3BlYy5mdW5jKG9iajEsIG9iajIpO1xuXHR9XG5cdHJldHVybiBmbGV4aWJsZUNvbXBhcmUob2JqMVtmaWVsZFNwZWMuZmllbGRdLCBvYmoyW2ZpZWxkU3BlYy5maWVsZF0pICpcblx0XHQoZmllbGRTcGVjLm9yZGVyIHx8IDEpO1xufVxuXG5cbmZ1bmN0aW9uIGZsZXhpYmxlQ29tcGFyZShhLCBiKSB7XG5cdGlmICghYSAmJiAhYikge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cdGlmIChiID09IG51bGwpIHtcblx0XHRyZXR1cm4gLTE7XG5cdH1cblx0aWYgKGEgPT0gbnVsbCkge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cdGlmICgkLnR5cGUoYSkgPT09ICdzdHJpbmcnIHx8ICQudHlwZShiKSA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcblx0fVxuXHRyZXR1cm4gYSAtIGI7XG59XG5cblxuLyogRnVsbENhbGVuZGFyLXNwZWNpZmljIE1pc2MgVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG4vLyBDb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gcmFuZ2VzLiBXaWxsIHJldHVybiBmcmVzaCBkYXRlIGNsb25lcyBpbiBhIHJhbmdlLlxuLy8gUmV0dXJucyB1bmRlZmluZWQgaWYgbm8gaW50ZXJzZWN0aW9uLlxuLy8gRXhwZWN0cyBhbGwgZGF0ZXMgdG8gYmUgbm9ybWFsaXplZCB0byB0aGUgc2FtZSB0aW1lem9uZSBiZWZvcmVoYW5kLlxuLy8gVE9ETzogbW92ZSB0byBkYXRlIHNlY3Rpb24/XG5mdW5jdGlvbiBpbnRlcnNlY3RSYW5nZXMoc3ViamVjdFJhbmdlLCBjb25zdHJhaW50UmFuZ2UpIHtcblx0dmFyIHN1YmplY3RTdGFydCA9IHN1YmplY3RSYW5nZS5zdGFydDtcblx0dmFyIHN1YmplY3RFbmQgPSBzdWJqZWN0UmFuZ2UuZW5kO1xuXHR2YXIgY29uc3RyYWludFN0YXJ0ID0gY29uc3RyYWludFJhbmdlLnN0YXJ0O1xuXHR2YXIgY29uc3RyYWludEVuZCA9IGNvbnN0cmFpbnRSYW5nZS5lbmQ7XG5cdHZhciBzZWdTdGFydCwgc2VnRW5kO1xuXHR2YXIgaXNTdGFydCwgaXNFbmQ7XG5cblx0aWYgKHN1YmplY3RFbmQgPiBjb25zdHJhaW50U3RhcnQgJiYgc3ViamVjdFN0YXJ0IDwgY29uc3RyYWludEVuZCkgeyAvLyBpbiBib3VuZHMgYXQgYWxsP1xuXG5cdFx0aWYgKHN1YmplY3RTdGFydCA+PSBjb25zdHJhaW50U3RhcnQpIHtcblx0XHRcdHNlZ1N0YXJ0ID0gc3ViamVjdFN0YXJ0LmNsb25lKCk7XG5cdFx0XHRpc1N0YXJ0ID0gdHJ1ZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzZWdTdGFydCA9IGNvbnN0cmFpbnRTdGFydC5jbG9uZSgpO1xuXHRcdFx0aXNTdGFydCA9ICBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoc3ViamVjdEVuZCA8PSBjb25zdHJhaW50RW5kKSB7XG5cdFx0XHRzZWdFbmQgPSBzdWJqZWN0RW5kLmNsb25lKCk7XG5cdFx0XHRpc0VuZCA9IHRydWU7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2VnRW5kID0gY29uc3RyYWludEVuZC5jbG9uZSgpO1xuXHRcdFx0aXNFbmQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnQ6IHNlZ1N0YXJ0LFxuXHRcdFx0ZW5kOiBzZWdFbmQsXG5cdFx0XHRpc1N0YXJ0OiBpc1N0YXJ0LFxuXHRcdFx0aXNFbmQ6IGlzRW5kXG5cdFx0fTtcblx0fVxufVxuXG5cbi8qIERhdGUgVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuRkMuY29tcHV0ZUdyZWF0ZXN0VW5pdCA9IGNvbXB1dGVHcmVhdGVzdFVuaXQ7XG5GQy5kaXZpZGVSYW5nZUJ5RHVyYXRpb24gPSBkaXZpZGVSYW5nZUJ5RHVyYXRpb247XG5GQy5kaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24gPSBkaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb247XG5GQy5tdWx0aXBseUR1cmF0aW9uID0gbXVsdGlwbHlEdXJhdGlvbjtcbkZDLmR1cmF0aW9uSGFzVGltZSA9IGR1cmF0aW9uSGFzVGltZTtcblxudmFyIGRheUlEcyA9IFsgJ3N1bicsICdtb24nLCAndHVlJywgJ3dlZCcsICd0aHUnLCAnZnJpJywgJ3NhdCcgXTtcbnZhciB1bml0c0Rlc2MgPSBbICd5ZWFyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCcgXTsgLy8gZGVzY2VuZGluZ1xuXG5cbi8vIERpZmZzIHRoZSB0d28gbW9tZW50cyBpbnRvIGEgRHVyYXRpb24gd2hlcmUgZnVsbC1kYXlzIGFyZSByZWNvcmRlZCBmaXJzdCwgdGhlbiB0aGUgcmVtYWluaW5nIHRpbWUuXG4vLyBNb21lbnRzIHdpbGwgaGF2ZSB0aGVpciB0aW1lem9uZXMgbm9ybWFsaXplZC5cbmZ1bmN0aW9uIGRpZmZEYXlUaW1lKGEsIGIpIHtcblx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbih7XG5cdFx0ZGF5czogYS5jbG9uZSgpLnN0cmlwVGltZSgpLmRpZmYoYi5jbG9uZSgpLnN0cmlwVGltZSgpLCAnZGF5cycpLFxuXHRcdG1zOiBhLnRpbWUoKSAtIGIudGltZSgpIC8vIHRpbWUtb2YtZGF5IGZyb20gZGF5IHN0YXJ0LiBkaXNyZWdhcmRzIHRpbWV6b25lXG5cdH0pO1xufVxuXG5cbi8vIERpZmZzIHRoZSB0d28gbW9tZW50cyB2aWEgdGhlaXIgc3RhcnQtb2YtZGF5IChyZWdhcmRsZXNzIG9mIHRpbWV6b25lKS4gUHJvZHVjZXMgd2hvbGUtZGF5IGR1cmF0aW9ucy5cbmZ1bmN0aW9uIGRpZmZEYXkoYSwgYikge1xuXHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKHtcblx0XHRkYXlzOiBhLmNsb25lKCkuc3RyaXBUaW1lKCkuZGlmZihiLmNsb25lKCkuc3RyaXBUaW1lKCksICdkYXlzJylcblx0fSk7XG59XG5cblxuLy8gRGlmZnMgdHdvIG1vbWVudHMsIHByb2R1Y2luZyBhIGR1cmF0aW9uLCBtYWRlIG9mIGEgd2hvbGUtdW5pdC1pbmNyZW1lbnQgb2YgdGhlIGdpdmVuIHVuaXQuIFVzZXMgcm91bmRpbmcuXG5mdW5jdGlvbiBkaWZmQnlVbml0KGEsIGIsIHVuaXQpIHtcblx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbihcblx0XHRNYXRoLnJvdW5kKGEuZGlmZihiLCB1bml0LCB0cnVlKSksIC8vIHJldHVybkZsb2F0PXRydWVcblx0XHR1bml0XG5cdCk7XG59XG5cblxuLy8gQ29tcHV0ZXMgdGhlIHVuaXQgbmFtZSBvZiB0aGUgbGFyZ2VzdCB3aG9sZS11bml0IHBlcmlvZCBvZiB0aW1lLlxuLy8gRm9yIGV4YW1wbGUsIDQ4IGhvdXJzIHdpbGwgYmUgXCJkYXlzXCIgd2hlcmVhcyA0OSBob3VycyB3aWxsIGJlIFwiaG91cnNcIi5cbi8vIEFjY2VwdHMgc3RhcnQvZW5kLCBhIHJhbmdlIG9iamVjdCwgb3IgYW4gb3JpZ2luYWwgZHVyYXRpb24gb2JqZWN0LlxuZnVuY3Rpb24gY29tcHV0ZUdyZWF0ZXN0VW5pdChzdGFydCwgZW5kKSB7XG5cdHZhciBpLCB1bml0O1xuXHR2YXIgdmFsO1xuXG5cdGZvciAoaSA9IDA7IGkgPCB1bml0c0Rlc2MubGVuZ3RoOyBpKyspIHtcblx0XHR1bml0ID0gdW5pdHNEZXNjW2ldO1xuXHRcdHZhbCA9IGNvbXB1dGVSYW5nZUFzKHVuaXQsIHN0YXJ0LCBlbmQpO1xuXG5cdFx0aWYgKHZhbCA+PSAxICYmIGlzSW50KHZhbCkpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB1bml0OyAvLyB3aWxsIGJlIFwibWlsbGlzZWNvbmRzXCIgaWYgbm90aGluZyBlbHNlIG1hdGNoZXNcbn1cblxuXG4vLyBsaWtlIGNvbXB1dGVHcmVhdGVzdFVuaXQsIGJ1dCBoYXMgc3BlY2lhbCBhYmlsaXRpZXMgdG8gaW50ZXJwcmV0IHRoZSBzb3VyY2UgaW5wdXQgZm9yIGNsdWVzXG5mdW5jdGlvbiBjb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQoZHVyYXRpb24sIGR1cmF0aW9uSW5wdXQpIHtcblx0dmFyIHVuaXQgPSBjb21wdXRlR3JlYXRlc3RVbml0KGR1cmF0aW9uKTtcblxuXHQvLyBwcmV2ZW50IGRheXM6NyBmcm9tIGJlaW5nIGludGVycHJldGVkIGFzIGEgd2Vla1xuXHRpZiAodW5pdCA9PT0gJ3dlZWsnICYmIHR5cGVvZiBkdXJhdGlvbklucHV0ID09PSAnb2JqZWN0JyAmJiBkdXJhdGlvbklucHV0LmRheXMpIHtcblx0XHR1bml0ID0gJ2RheSc7XG5cdH1cblxuXHRyZXR1cm4gdW5pdDtcbn1cblxuXG4vLyBDb21wdXRlcyB0aGUgbnVtYmVyIG9mIHVuaXRzIChsaWtlIFwiaG91cnNcIikgaW4gdGhlIGdpdmVuIHJhbmdlLlxuLy8gUmFuZ2UgY2FuIGJlIGEge3N0YXJ0LGVuZH0gb2JqZWN0LCBzZXBhcmF0ZSBzdGFydC9lbmQgYXJncywgb3IgYSBEdXJhdGlvbi5cbi8vIFJlc3VsdHMgYXJlIGJhc2VkIG9uIE1vbWVudCdzIC5hcygpIGFuZCAuZGlmZigpIG1ldGhvZHMsIHNvIHJlc3VsdHMgY2FuIGRlcGVuZCBvbiBpbnRlcm5hbCBoYW5kbGluZ1xuLy8gb2YgbW9udGgtZGlmZmluZyBsb2dpYyAod2hpY2ggdGVuZHMgdG8gdmFyeSBmcm9tIHZlcnNpb24gdG8gdmVyc2lvbikuXG5mdW5jdGlvbiBjb21wdXRlUmFuZ2VBcyh1bml0LCBzdGFydCwgZW5kKSB7XG5cblx0aWYgKGVuZCAhPSBudWxsKSB7IC8vIGdpdmVuIHN0YXJ0LCBlbmRcblx0XHRyZXR1cm4gZW5kLmRpZmYoc3RhcnQsIHVuaXQsIHRydWUpO1xuXHR9XG5cdGVsc2UgaWYgKG1vbWVudC5pc0R1cmF0aW9uKHN0YXJ0KSkgeyAvLyBnaXZlbiBkdXJhdGlvblxuXHRcdHJldHVybiBzdGFydC5hcyh1bml0KTtcblx0fVxuXHRlbHNlIHsgLy8gZ2l2ZW4geyBzdGFydCwgZW5kIH0gcmFuZ2Ugb2JqZWN0XG5cdFx0cmV0dXJuIHN0YXJ0LmVuZC5kaWZmKHN0YXJ0LnN0YXJ0LCB1bml0LCB0cnVlKTtcblx0fVxufVxuXG5cbi8vIEludGVsbGlnZW50bHkgZGl2aWRlcyBhIHJhbmdlIChzcGVjaWZpZWQgYnkgYSBzdGFydC9lbmQgcGFyYW1zKSBieSBhIGR1cmF0aW9uXG5mdW5jdGlvbiBkaXZpZGVSYW5nZUJ5RHVyYXRpb24oc3RhcnQsIGVuZCwgZHVyKSB7XG5cdHZhciBtb250aHM7XG5cblx0aWYgKGR1cmF0aW9uSGFzVGltZShkdXIpKSB7XG5cdFx0cmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXI7XG5cdH1cblx0bW9udGhzID0gZHVyLmFzTW9udGhzKCk7XG5cdGlmIChNYXRoLmFicyhtb250aHMpID49IDEgJiYgaXNJbnQobW9udGhzKSkge1xuXHRcdHJldHVybiBlbmQuZGlmZihzdGFydCwgJ21vbnRocycsIHRydWUpIC8gbW9udGhzO1xuXHR9XG5cdHJldHVybiBlbmQuZGlmZihzdGFydCwgJ2RheXMnLCB0cnVlKSAvIGR1ci5hc0RheXMoKTtcbn1cblxuXG4vLyBJbnRlbGxpZ2VudGx5IGRpdmlkZXMgb25lIGR1cmF0aW9uIGJ5IGFub3RoZXJcbmZ1bmN0aW9uIGRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbihkdXIxLCBkdXIyKSB7XG5cdHZhciBtb250aHMxLCBtb250aHMyO1xuXG5cdGlmIChkdXJhdGlvbkhhc1RpbWUoZHVyMSkgfHwgZHVyYXRpb25IYXNUaW1lKGR1cjIpKSB7XG5cdFx0cmV0dXJuIGR1cjEgLyBkdXIyO1xuXHR9XG5cdG1vbnRoczEgPSBkdXIxLmFzTW9udGhzKCk7XG5cdG1vbnRoczIgPSBkdXIyLmFzTW9udGhzKCk7XG5cdGlmIChcblx0XHRNYXRoLmFicyhtb250aHMxKSA+PSAxICYmIGlzSW50KG1vbnRoczEpICYmXG5cdFx0TWF0aC5hYnMobW9udGhzMikgPj0gMSAmJiBpc0ludChtb250aHMyKVxuXHQpIHtcblx0XHRyZXR1cm4gbW9udGhzMSAvIG1vbnRoczI7XG5cdH1cblx0cmV0dXJuIGR1cjEuYXNEYXlzKCkgLyBkdXIyLmFzRGF5cygpO1xufVxuXG5cbi8vIEludGVsbGlnZW50bHkgbXVsdGlwbGllcyBhIGR1cmF0aW9uIGJ5IGEgbnVtYmVyXG5mdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGR1ciwgbikge1xuXHR2YXIgbW9udGhzO1xuXG5cdGlmIChkdXJhdGlvbkhhc1RpbWUoZHVyKSkge1xuXHRcdHJldHVybiBtb21lbnQuZHVyYXRpb24oZHVyICogbik7XG5cdH1cblx0bW9udGhzID0gZHVyLmFzTW9udGhzKCk7XG5cdGlmIChNYXRoLmFicyhtb250aHMpID49IDEgJiYgaXNJbnQobW9udGhzKSkge1xuXHRcdHJldHVybiBtb21lbnQuZHVyYXRpb24oeyBtb250aHM6IG1vbnRocyAqIG4gfSk7XG5cdH1cblx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbih7IGRheXM6IGR1ci5hc0RheXMoKSAqIG4gfSk7XG59XG5cblxuZnVuY3Rpb24gY2xvbmVSYW5nZShyYW5nZSkge1xuXHRyZXR1cm4ge1xuXHRcdHN0YXJ0OiByYW5nZS5zdGFydC5jbG9uZSgpLFxuXHRcdGVuZDogcmFuZ2UuZW5kLmNsb25lKClcblx0fTtcbn1cblxuXG4vLyBUcmltcyB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgaW5uZXIgcmFuZ2UgdG8gYmUgY29tcGxldGVseSB3aXRoaW4gb3V0ZXJSYW5nZS5cbi8vIFJldHVybnMgYSBuZXcgcmFuZ2Ugb2JqZWN0LlxuZnVuY3Rpb24gY29uc3RyYWluUmFuZ2UoaW5uZXJSYW5nZSwgb3V0ZXJSYW5nZSkge1xuXHRpbm5lclJhbmdlID0gY2xvbmVSYW5nZShpbm5lclJhbmdlKTtcblxuXHRpZiAob3V0ZXJSYW5nZS5zdGFydCkge1xuXHRcdC8vIG5lZWRzIHRvIGJlIGluY2x1c2l2ZWx5IGJlZm9yZSBvdXRlclJhbmdlJ3MgZW5kXG5cdFx0aW5uZXJSYW5nZS5zdGFydCA9IGNvbnN0cmFpbkRhdGUoaW5uZXJSYW5nZS5zdGFydCwgb3V0ZXJSYW5nZSk7XG5cdH1cblxuXHRpZiAob3V0ZXJSYW5nZS5lbmQpIHtcblx0XHRpbm5lclJhbmdlLmVuZCA9IG1pbk1vbWVudChpbm5lclJhbmdlLmVuZCwgb3V0ZXJSYW5nZS5lbmQpO1xuXHR9XG5cblx0cmV0dXJuIGlubmVyUmFuZ2U7XG59XG5cblxuLy8gSWYgdGhlIGdpdmVuIGRhdGUgaXMgbm90IHdpdGhpbiB0aGUgZ2l2ZW4gcmFuZ2UsIG1vdmUgaXQgaW5zaWRlLlxuLy8gKElmIGl0J3MgcGFzdCB0aGUgZW5kLCBtYWtlIGl0IG9uZSBtaWxsaXNlY29uZCBiZWZvcmUgdGhlIGVuZCkuXG4vLyBBbHdheXMgcmV0dXJucyBhIG5ldyBtb21lbnQuXG5mdW5jdGlvbiBjb25zdHJhaW5EYXRlKGRhdGUsIHJhbmdlKSB7XG5cdGRhdGUgPSBkYXRlLmNsb25lKCk7XG5cblx0aWYgKHJhbmdlLnN0YXJ0KSB7XG5cdFx0ZGF0ZSA9IG1heE1vbWVudChkYXRlLCByYW5nZS5zdGFydCk7XG5cdH1cblxuXHRpZiAocmFuZ2UuZW5kICYmIGRhdGUgPj0gcmFuZ2UuZW5kKSB7XG5cdFx0ZGF0ZSA9IHJhbmdlLmVuZC5jbG9uZSgpLnN1YnRyYWN0KDEpO1xuXHR9XG5cblx0cmV0dXJuIGRhdGU7XG59XG5cblxuZnVuY3Rpb24gaXNEYXRlV2l0aGluUmFuZ2UoZGF0ZSwgcmFuZ2UpIHtcblx0cmV0dXJuICghcmFuZ2Uuc3RhcnQgfHwgZGF0ZSA+PSByYW5nZS5zdGFydCkgJiZcblx0XHQoIXJhbmdlLmVuZCB8fCBkYXRlIDwgcmFuZ2UuZW5kKTtcbn1cblxuXG4vLyBUT0RPOiBkZWFsIHdpdGggcmVwZWF0IGNvZGUgaW4gaW50ZXJzZWN0UmFuZ2VzXG4vLyBjb25zdHJhaW50UmFuZ2UgY2FuIGhhdmUgdW5zcGVjaWZpZWQgc3RhcnQvZW5kLCBhbiBvcGVuLWVuZGVkIHJhbmdlLlxuZnVuY3Rpb24gZG9SYW5nZXNJbnRlcnNlY3Qoc3ViamVjdFJhbmdlLCBjb25zdHJhaW50UmFuZ2UpIHtcblx0cmV0dXJuICghY29uc3RyYWludFJhbmdlLnN0YXJ0IHx8IHN1YmplY3RSYW5nZS5lbmQgPj0gY29uc3RyYWludFJhbmdlLnN0YXJ0KSAmJlxuXHRcdCghY29uc3RyYWludFJhbmdlLmVuZCB8fCBzdWJqZWN0UmFuZ2Uuc3RhcnQgPCBjb25zdHJhaW50UmFuZ2UuZW5kKTtcbn1cblxuXG5mdW5jdGlvbiBpc1JhbmdlV2l0aGluUmFuZ2UoaW5uZXJSYW5nZSwgb3V0ZXJSYW5nZSkge1xuXHRyZXR1cm4gKCFvdXRlclJhbmdlLnN0YXJ0IHx8IGlubmVyUmFuZ2Uuc3RhcnQgPj0gb3V0ZXJSYW5nZS5zdGFydCkgJiZcblx0XHQoIW91dGVyUmFuZ2UuZW5kIHx8IGlubmVyUmFuZ2UuZW5kIDw9IG91dGVyUmFuZ2UuZW5kKTtcbn1cblxuXG5mdW5jdGlvbiBpc1Jhbmdlc0VxdWFsKHJhbmdlMCwgcmFuZ2UxKSB7XG5cdHJldHVybiAoKHJhbmdlMC5zdGFydCAmJiByYW5nZTEuc3RhcnQgJiYgcmFuZ2UwLnN0YXJ0LmlzU2FtZShyYW5nZTEuc3RhcnQpKSB8fCAoIXJhbmdlMC5zdGFydCAmJiAhcmFuZ2UxLnN0YXJ0KSkgJiZcblx0XHQoKHJhbmdlMC5lbmQgJiYgcmFuZ2UxLmVuZCAmJiByYW5nZTAuZW5kLmlzU2FtZShyYW5nZTEuZW5kKSkgfHwgKCFyYW5nZTAuZW5kICYmICFyYW5nZTEuZW5kKSk7XG59XG5cblxuLy8gUmV0dXJucyB0aGUgbW9tZW50IHRoYXQncyBlYXJsaWVyIGluIHRpbWUuIEFsd2F5cyBhIGNvcHkuXG5mdW5jdGlvbiBtaW5Nb21lbnQobW9tMSwgbW9tMikge1xuXHRyZXR1cm4gKG1vbTEuaXNCZWZvcmUobW9tMikgPyBtb20xIDogbW9tMikuY2xvbmUoKTtcbn1cblxuXG4vLyBSZXR1cm5zIHRoZSBtb21lbnQgdGhhdCdzIGxhdGVyIGluIHRpbWUuIEFsd2F5cyBhIGNvcHkuXG5mdW5jdGlvbiBtYXhNb21lbnQobW9tMSwgbW9tMikge1xuXHRyZXR1cm4gKG1vbTEuaXNBZnRlcihtb20yKSA/IG1vbTEgOiBtb20yKS5jbG9uZSgpO1xufVxuXG5cbi8vIFJldHVybnMgYSBib29sZWFuIGFib3V0IHdoZXRoZXIgdGhlIGdpdmVuIGR1cmF0aW9uIGhhcyBhbnkgdGltZSBwYXJ0cyAoaG91cnMvbWludXRlcy9zZWNvbmRzL21zKVxuZnVuY3Rpb24gZHVyYXRpb25IYXNUaW1lKGR1cikge1xuXHRyZXR1cm4gQm9vbGVhbihkdXIuaG91cnMoKSB8fCBkdXIubWludXRlcygpIHx8IGR1ci5zZWNvbmRzKCkgfHwgZHVyLm1pbGxpc2Vjb25kcygpKTtcbn1cblxuXG5mdW5jdGlvbiBpc05hdGl2ZURhdGUoaW5wdXQpIHtcblx0cmV0dXJuICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXScgfHwgaW5wdXQgaW5zdGFuY2VvZiBEYXRlO1xufVxuXG5cbi8vIFJldHVybnMgYSBib29sZWFuIGFib3V0IHdoZXRoZXIgdGhlIGdpdmVuIGlucHV0IGlzIGEgdGltZSBzdHJpbmcsIGxpa2UgXCIwNjo0MDowMFwiIG9yIFwiMDY6MDBcIlxuZnVuY3Rpb24gaXNUaW1lU3RyaW5nKHN0cikge1xuXHRyZXR1cm4gL15cXGQrXFw6XFxkKyg/OlxcOlxcZCtcXC4/KD86XFxkezN9KT8pPyQvLnRlc3Qoc3RyKTtcbn1cblxuXG4vKiBMb2dnaW5nIGFuZCBEZWJ1Z1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbkZDLmxvZyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xuXG5cdGlmIChjb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XG5cdFx0cmV0dXJuIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG5cdH1cbn07XG5cbkZDLndhcm4gPSBmdW5jdGlvbigpIHtcblx0dmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcblxuXHRpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcblx0XHRyZXR1cm4gY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0cmV0dXJuIEZDLmxvZy5hcHBseShGQywgYXJndW1lbnRzKTtcblx0fVxufTtcblxuXG4vKiBHZW5lcmFsIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbnZhciBoYXNPd25Qcm9wTWV0aG9kID0ge30uaGFzT3duUHJvcGVydHk7XG5cblxuLy8gTWVyZ2VzIGFuIGFycmF5IG9mIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3QuXG4vLyBUaGUgc2Vjb25kIGFyZ3VtZW50IGFsbG93cyBmb3IgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgd2hvJ3Mgb2JqZWN0IHZhbHVlcyB3aWxsIGJlIG1lcmdlZCB0b2dldGhlci5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMocHJvcE9ianMsIGNvbXBsZXhQcm9wcykge1xuXHR2YXIgZGVzdCA9IHt9O1xuXHR2YXIgaSwgbmFtZTtcblx0dmFyIGNvbXBsZXhPYmpzO1xuXHR2YXIgaiwgdmFsO1xuXHR2YXIgcHJvcHM7XG5cblx0aWYgKGNvbXBsZXhQcm9wcykge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBjb21wbGV4UHJvcHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG5hbWUgPSBjb21wbGV4UHJvcHNbaV07XG5cdFx0XHRjb21wbGV4T2JqcyA9IFtdO1xuXG5cdFx0XHQvLyBjb2xsZWN0IHRoZSB0cmFpbGluZyBvYmplY3QgdmFsdWVzLCBzdG9wcGluZyB3aGVuIGEgbm9uLW9iamVjdCBpcyBkaXNjb3ZlcmVkXG5cdFx0XHRmb3IgKGogPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHR2YWwgPSBwcm9wT2Jqc1tqXVtuYW1lXTtcblxuXHRcdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRjb21wbGV4T2Jqcy51bnNoaWZ0KHZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRkZXN0W25hbWVdID0gdmFsOyAvLyBpZiB0aGVyZSB3ZXJlIG5vIG9iamVjdHMsIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgdGhlIHRyYWlsaW5nIHZhbHVlcyB3ZXJlIG9iamVjdHMsIHVzZSB0aGUgbWVyZ2VkIHZhbHVlXG5cdFx0XHRpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XG5cdFx0XHRcdGRlc3RbbmFtZV0gPSBtZXJnZVByb3BzKGNvbXBsZXhPYmpzKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBjb3B5IHZhbHVlcyBpbnRvIHRoZSBkZXN0aW5hdGlvbiwgZ29pbmcgZnJvbSBsYXN0IHRvIGZpcnN0XG5cdGZvciAoaSA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0cHJvcHMgPSBwcm9wT2Jqc1tpXTtcblxuXHRcdGZvciAobmFtZSBpbiBwcm9wcykge1xuXHRcdFx0aWYgKCEobmFtZSBpbiBkZXN0KSkgeyAvLyBpZiBhbHJlYWR5IGFzc2lnbmVkIGJ5IHByZXZpb3VzIHByb3BzIG9yIGNvbXBsZXggcHJvcHMsIGRvbid0IHJlYXNzaWduXG5cdFx0XHRcdGRlc3RbbmFtZV0gPSBwcm9wc1tuYW1lXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZGVzdDtcbn1cblxuXG4vLyBDcmVhdGUgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBnaXZlbiBwcm90b3R5cGUuIEp1c3QgbGlrZSBPYmplY3QuY3JlYXRlXG5mdW5jdGlvbiBjcmVhdGVPYmplY3QocHJvdG8pIHtcblx0dmFyIGYgPSBmdW5jdGlvbigpIHt9O1xuXHRmLnByb3RvdHlwZSA9IHByb3RvO1xuXHRyZXR1cm4gbmV3IGYoKTtcbn1cbkZDLmNyZWF0ZU9iamVjdCA9IGNyZWF0ZU9iamVjdDtcblxuXG5mdW5jdGlvbiBjb3B5T3duUHJvcHMoc3JjLCBkZXN0KSB7XG5cdGZvciAodmFyIG5hbWUgaW4gc3JjKSB7XG5cdFx0aWYgKGhhc093blByb3Aoc3JjLCBuYW1lKSkge1xuXHRcdFx0ZGVzdFtuYW1lXSA9IHNyY1tuYW1lXTtcblx0XHR9XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBoYXNPd25Qcm9wKG9iaiwgbmFtZSkge1xuXHRyZXR1cm4gaGFzT3duUHJvcE1ldGhvZC5jYWxsKG9iaiwgbmFtZSk7XG59XG5cblxuLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGEgbm9uLW9iamVjdCBub24tZnVuY3Rpb24gdmFsdWU/XG5mdW5jdGlvbiBpc0F0b21pYyh2YWwpIHtcblx0cmV0dXJuIC91bmRlZmluZWR8bnVsbHxib29sZWFufG51bWJlcnxzdHJpbmcvLnRlc3QoJC50eXBlKHZhbCkpO1xufVxuXG5cbmZ1bmN0aW9uIGFwcGx5QWxsKGZ1bmN0aW9ucywgdGhpc09iaiwgYXJncykge1xuXHRpZiAoJC5pc0Z1bmN0aW9uKGZ1bmN0aW9ucykpIHtcblx0XHRmdW5jdGlvbnMgPSBbIGZ1bmN0aW9ucyBdO1xuXHR9XG5cdGlmIChmdW5jdGlvbnMpIHtcblx0XHR2YXIgaTtcblx0XHR2YXIgcmV0O1xuXHRcdGZvciAoaT0wOyBpPGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0cmV0ID0gZnVuY3Rpb25zW2ldLmFwcGx5KHRoaXNPYmosIGFyZ3MpIHx8IHJldDtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fVxufVxuXG5cbmZ1bmN0aW9uIGZpcnN0RGVmaW5lZCgpIHtcblx0Zm9yICh2YXIgaT0wOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGlmIChhcmd1bWVudHNbaV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50c1tpXTtcblx0XHR9XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBodG1sRXNjYXBlKHMpIHtcblx0cmV0dXJuIChzICsgJycpLnJlcGxhY2UoLyYvZywgJyZhbXA7Jylcblx0XHQucmVwbGFjZSgvPC9nLCAnJmx0OycpXG5cdFx0LnJlcGxhY2UoLz4vZywgJyZndDsnKVxuXHRcdC5yZXBsYWNlKC8nL2csICcmIzAzOTsnKVxuXHRcdC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jylcblx0XHQucmVwbGFjZSgvXFxuL2csICc8YnIgLz4nKTtcbn1cblxuXG5mdW5jdGlvbiBzdHJpcEh0bWxFbnRpdGllcyh0ZXh0KSB7XG5cdHJldHVybiB0ZXh0LnJlcGxhY2UoLyYuKj87L2csICcnKTtcbn1cblxuXG4vLyBHaXZlbiBhIGhhc2ggb2YgQ1NTIHByb3BlcnRpZXMsIHJldHVybnMgYSBzdHJpbmcgb2YgQ1NTLlxuLy8gVXNlcyBwcm9wZXJ0eSBuYW1lcyBhcy1pcyAobm8gY2FtZWwtY2FzZSBjb252ZXJzaW9uKS4gV2lsbCBub3QgbWFrZSBzdGF0ZW1lbnRzIGZvciBudWxsL3VuZGVmaW5lZCB2YWx1ZXMuXG5mdW5jdGlvbiBjc3NUb1N0cihjc3NQcm9wcykge1xuXHR2YXIgc3RhdGVtZW50cyA9IFtdO1xuXG5cdCQuZWFjaChjc3NQcm9wcywgZnVuY3Rpb24obmFtZSwgdmFsKSB7XG5cdFx0aWYgKHZhbCAhPSBudWxsKSB7XG5cdFx0XHRzdGF0ZW1lbnRzLnB1c2gobmFtZSArICc6JyArIHZhbCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gc3RhdGVtZW50cy5qb2luKCc7Jyk7XG59XG5cblxuLy8gR2l2ZW4gYW4gb2JqZWN0IGhhc2ggb2YgSFRNTCBhdHRyaWJ1dGUgbmFtZXMgdG8gdmFsdWVzLFxuLy8gZ2VuZXJhdGVzIGEgc3RyaW5nIHRoYXQgY2FuIGJlIGluamVjdGVkIGJldHdlZW4gPCA+IGluIEhUTUxcbmZ1bmN0aW9uIGF0dHJzVG9TdHIoYXR0cnMpIHtcblx0dmFyIHBhcnRzID0gW107XG5cblx0JC5lYWNoKGF0dHJzLCBmdW5jdGlvbihuYW1lLCB2YWwpIHtcblx0XHRpZiAodmFsICE9IG51bGwpIHtcblx0XHRcdHBhcnRzLnB1c2gobmFtZSArICc9XCInICsgaHRtbEVzY2FwZSh2YWwpICsgJ1wiJyk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gcGFydHMuam9pbignICcpO1xufVxuXG5cbmZ1bmN0aW9uIGNhcGl0YWxpc2VGaXJzdExldHRlcihzdHIpIHtcblx0cmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7IC8vIGZvciAuc29ydCgpXG5cdHJldHVybiBhIC0gYjtcbn1cblxuXG5mdW5jdGlvbiBpc0ludChuKSB7XG5cdHJldHVybiBuICUgMSA9PT0gMDtcbn1cblxuXG4vLyBSZXR1cm5zIGEgbWV0aG9kIGJvdW5kIHRvIHRoZSBnaXZlbiBvYmplY3QgY29udGV4dC5cbi8vIEp1c3QgbGlrZSBvbmUgb2YgdGhlIGpRdWVyeS5wcm94eSBzaWduYXR1cmVzLCBidXQgd2l0aG91dCB0aGUgdW5kZXNpcmVkIGJlaGF2aW9yIG9mIHRyZWF0aW5nIHRoZSBzYW1lIG1ldGhvZCB3aXRoXG4vLyBkaWZmZXJlbnQgY29udGV4dHMgYXMgaWRlbnRpY2FsIHdoZW4gYmluZGluZy91bmJpbmRpbmcgZXZlbnRzLlxuZnVuY3Rpb24gcHJveHkob2JqLCBtZXRob2ROYW1lKSB7XG5cdHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuXHR9O1xufVxuXG5cbi8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3Rcbi8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3Jcbi8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9ibG9iLzEuNi4wL3VuZGVyc2NvcmUuanMjTDcxNFxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG5cdHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuXHR2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdCA9ICtuZXcgRGF0ZSgpIC0gdGltZXN0YW1wO1xuXHRcdGlmIChsYXN0IDwgd2FpdCkge1xuXHRcdFx0dGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aW1lb3V0ID0gbnVsbDtcblx0XHRcdGlmICghaW1tZWRpYXRlKSB7XG5cdFx0XHRcdHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG5cdFx0XHRcdGNvbnRleHQgPSBhcmdzID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGNvbnRleHQgPSB0aGlzO1xuXHRcdGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0dGltZXN0YW1wID0gK25ldyBEYXRlKCk7XG5cdFx0dmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG5cdFx0aWYgKCF0aW1lb3V0KSB7XG5cdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG5cdFx0fVxuXHRcdGlmIChjYWxsTm93KSB7XG5cdFx0XHRyZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXHRcdFx0Y29udGV4dCA9IGFyZ3MgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xufVxuXG47O1xuXG4vKlxuR0VORVJBTCBOT1RFIG9uIG1vbWVudHMgdGhyb3VnaG91dCB0aGUgKmVudGlyZSByZXN0KiBvZiB0aGUgY29kZWJhc2U6XG5BbGwgbW9tZW50cyBhcmUgYXNzdW1lZCB0byBiZSBhbWJpZ3VvdXNseS16b25lZCB1bmxlc3Mgb3RoZXJ3aXNlIG5vdGVkLFxud2l0aCB0aGUgTk9UQUJMRSBFWENFT1BUSU9OIG9mIHN0YXJ0L2VuZCBkYXRlcyB0aGF0IGxpdmUgb24gKkV2ZW50IE9iamVjdHMqLlxuQW1iaWd1b3VzbHktVElNRUQgbW9tZW50cyBhcmUgYXNzdW1lZCB0byBiZSBhbWJpZ3VvdXNseS16b25lZCBieSBuYXR1cmUuXG4qL1xuXG52YXIgYW1iaWdEYXRlT2ZNb250aFJlZ2V4ID0gL15cXHMqXFxkezR9LVxcZFxcZCQvO1xudmFyIGFtYmlnVGltZU9yWm9uZVJlZ2V4ID1cblx0L15cXHMqXFxkezR9LSg/OihcXGRcXGQtXFxkXFxkKXwoV1xcZFxcZCQpfChXXFxkXFxkLVxcZCl8KFxcZFxcZFxcZCkpKChUfCApKFxcZFxcZCg6XFxkXFxkKDpcXGRcXGQoXFwuXFxkKyk/KT8pPyk/KT8kLztcbnZhciBuZXdNb21lbnRQcm90byA9IG1vbWVudC5mbjsgLy8gd2hlcmUgd2Ugd2lsbCBhdHRhY2ggb3VyIG5ldyBtZXRob2RzXG52YXIgb2xkTW9tZW50UHJvdG8gPSAkLmV4dGVuZCh7fSwgbmV3TW9tZW50UHJvdG8pOyAvLyBjb3B5IG9mIG9yaWdpbmFsIG1vbWVudCBtZXRob2RzXG5cbi8vIHRlbGwgbW9tZW50anMgdG8gdHJhbnNmZXIgdGhlc2UgcHJvcGVydGllcyB1cG9uIGNsb25lXG52YXIgbW9tZW50UHJvcGVydGllcyA9IG1vbWVudC5tb21lbnRQcm9wZXJ0aWVzO1xubW9tZW50UHJvcGVydGllcy5wdXNoKCdfZnVsbENhbGVuZGFyJyk7XG5tb21lbnRQcm9wZXJ0aWVzLnB1c2goJ19hbWJpZ1RpbWUnKTtcbm1vbWVudFByb3BlcnRpZXMucHVzaCgnX2FtYmlnWm9uZScpO1xuXG5cbi8vIENyZWF0aW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIENyZWF0ZXMgYSBuZXcgbW9tZW50LCBzaW1pbGFyIHRvIHRoZSB2YW5pbGxhIG1vbWVudCguLi4pIGNvbnN0cnVjdG9yLCBidXQgd2l0aFxuLy8gZXh0cmEgZmVhdHVyZXMgKGFtYmlndW91cyB0aW1lLCBlbmhhbmNlZCBmb3JtYXR0aW5nKS4gV2hlbiBnaXZlbiBhbiBleGlzdGluZyBtb21lbnQsXG4vLyBpdCB3aWxsIGZ1bmN0aW9uIGFzIGEgY2xvbmUgKGFuZCByZXRhaW4gdGhlIHpvbmUgb2YgdGhlIG1vbWVudCkuIEFueXRoaW5nIGVsc2Ugd2lsbFxuLy8gcmVzdWx0IGluIGEgbW9tZW50IGluIHRoZSBsb2NhbCB6b25lLlxuRkMubW9tZW50ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBtYWtlTW9tZW50KGFyZ3VtZW50cyk7XG59O1xuXG4vLyBTYW1lcyBhcyBGQy5tb21lbnQsIGJ1dCBmb3JjZXMgdGhlIHJlc3VsdGluZyBtb21lbnQgdG8gYmUgaW4gdGhlIFVUQyB0aW1lem9uZS5cbkZDLm1vbWVudC51dGMgPSBmdW5jdGlvbigpIHtcblx0dmFyIG1vbSA9IG1ha2VNb21lbnQoYXJndW1lbnRzLCB0cnVlKTtcblxuXHQvLyBGb3JjZSBpdCBpbnRvIFVUQyBiZWNhdXNlIG1ha2VNb21lbnQgZG9lc24ndCBndWFyYW50ZWUgaXRcblx0Ly8gKGlmIGdpdmVuIGEgcHJlLWV4aXN0aW5nIG1vbWVudCBmb3IgZXhhbXBsZSlcblx0aWYgKG1vbS5oYXNUaW1lKCkpIHsgLy8gZG9uJ3QgZ2l2ZSBhbWJpZ3VvdXNseS10aW1lZCBtb21lbnRzIGEgVVRDIHpvbmVcblx0XHRtb20udXRjKCk7XG5cdH1cblxuXHRyZXR1cm4gbW9tO1xufTtcblxuLy8gU2FtZSBhcyBGQy5tb21lbnQsIGJ1dCB3aGVuIGdpdmVuIGFuIElTTzg2MDEgc3RyaW5nLCB0aGUgdGltZXpvbmUgb2Zmc2V0IGlzIHByZXNlcnZlZC5cbi8vIElTTzg2MDEgc3RyaW5ncyB3aXRoIG5vIHRpbWV6b25lIG9mZnNldCB3aWxsIGJlY29tZSBhbWJpZ3VvdXNseSB6b25lZC5cbkZDLm1vbWVudC5wYXJzZVpvbmUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIG1ha2VNb21lbnQoYXJndW1lbnRzLCB0cnVlLCB0cnVlKTtcbn07XG5cbi8vIEJ1aWxkcyBhbiBlbmhhbmNlZCBtb21lbnQgZnJvbSBhcmdzLiBXaGVuIGdpdmVuIGFuIGV4aXN0aW5nIG1vbWVudCwgaXQgY2xvbmVzLiBXaGVuIGdpdmVuIGFcbi8vIG5hdGl2ZSBEYXRlLCBvciBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMgKHRoZSBjdXJyZW50IHRpbWUpLCB0aGUgcmVzdWx0aW5nIG1vbWVudCB3aWxsIGJlIGxvY2FsLlxuLy8gQW55dGhpbmcgZWxzZSBuZWVkcyB0byBiZSBcInBhcnNlZFwiIChhIHN0cmluZyBvciBhbiBhcnJheSksIGFuZCB3aWxsIGJlIGFmZmVjdGVkIGJ5OlxuLy8gICAgcGFyc2VBc1VUQyAtIGlmIHRoZXJlIGlzIG5vIHpvbmUgaW5mb3JtYXRpb24sIHNob3VsZCB3ZSBwYXJzZSB0aGUgaW5wdXQgaW4gVVRDP1xuLy8gICAgcGFyc2Vab25lIC0gaWYgdGhlcmUgaXMgem9uZSBpbmZvcm1hdGlvbiwgc2hvdWxkIHdlIGZvcmNlIHRoZSB6b25lIG9mIHRoZSBtb21lbnQ/XG5mdW5jdGlvbiBtYWtlTW9tZW50KGFyZ3MsIHBhcnNlQXNVVEMsIHBhcnNlWm9uZSkge1xuXHR2YXIgaW5wdXQgPSBhcmdzWzBdO1xuXHR2YXIgaXNTaW5nbGVTdHJpbmcgPSBhcmdzLmxlbmd0aCA9PSAxICYmIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZyc7XG5cdHZhciBpc0FtYmlnVGltZTtcblx0dmFyIGlzQW1iaWdab25lO1xuXHR2YXIgYW1iaWdNYXRjaDtcblx0dmFyIG1vbTtcblxuXHRpZiAobW9tZW50LmlzTW9tZW50KGlucHV0KSB8fCBpc05hdGl2ZURhdGUoaW5wdXQpIHx8IGlucHV0ID09PSB1bmRlZmluZWQpIHtcblx0XHRtb20gPSBtb21lbnQuYXBwbHkobnVsbCwgYXJncyk7XG5cdH1cblx0ZWxzZSB7IC8vIFwicGFyc2luZ1wiIGlzIHJlcXVpcmVkXG5cdFx0aXNBbWJpZ1RpbWUgPSBmYWxzZTtcblx0XHRpc0FtYmlnWm9uZSA9IGZhbHNlO1xuXG5cdFx0aWYgKGlzU2luZ2xlU3RyaW5nKSB7XG5cdFx0XHRpZiAoYW1iaWdEYXRlT2ZNb250aFJlZ2V4LnRlc3QoaW5wdXQpKSB7XG5cdFx0XHRcdC8vIGFjY2VwdCBzdHJpbmdzIGxpa2UgJzIwMTQtMDUnLCBidXQgY29udmVydCB0byB0aGUgZmlyc3Qgb2YgdGhlIG1vbnRoXG5cdFx0XHRcdGlucHV0ICs9ICctMDEnO1xuXHRcdFx0XHRhcmdzID0gWyBpbnB1dCBdOyAvLyBmb3Igd2hlbiB3ZSBwYXNzIGl0IG9uIHRvIG1vbWVudCdzIGNvbnN0cnVjdG9yXG5cdFx0XHRcdGlzQW1iaWdUaW1lID0gdHJ1ZTtcblx0XHRcdFx0aXNBbWJpZ1pvbmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoKGFtYmlnTWF0Y2ggPSBhbWJpZ1RpbWVPclpvbmVSZWdleC5leGVjKGlucHV0KSkpIHtcblx0XHRcdFx0aXNBbWJpZ1RpbWUgPSAhYW1iaWdNYXRjaFs1XTsgLy8gbm8gdGltZSBwYXJ0P1xuXHRcdFx0XHRpc0FtYmlnWm9uZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCQuaXNBcnJheShpbnB1dCkpIHtcblx0XHRcdC8vIGFycmF5cyBoYXZlIG5vIHRpbWV6b25lIGluZm9ybWF0aW9uLCBzbyBhc3N1bWUgYW1iaWd1b3VzIHpvbmVcblx0XHRcdGlzQW1iaWdab25lID0gdHJ1ZTtcblx0XHR9XG5cdFx0Ly8gb3RoZXJ3aXNlLCBwcm9iYWJseSBhIHN0cmluZyB3aXRoIGEgZm9ybWF0XG5cblx0XHRpZiAocGFyc2VBc1VUQyB8fCBpc0FtYmlnVGltZSkge1xuXHRcdFx0bW9tID0gbW9tZW50LnV0Yy5hcHBseShtb21lbnQsIGFyZ3MpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG1vbSA9IG1vbWVudC5hcHBseShudWxsLCBhcmdzKTtcblx0XHR9XG5cblx0XHRpZiAoaXNBbWJpZ1RpbWUpIHtcblx0XHRcdG1vbS5fYW1iaWdUaW1lID0gdHJ1ZTtcblx0XHRcdG1vbS5fYW1iaWdab25lID0gdHJ1ZTsgLy8gYW1iaWd1b3VzIHRpbWUgYWx3YXlzIG1lYW5zIGFtYmlndW91cyB6b25lXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBhcnNlWm9uZSkgeyAvLyBsZXQncyByZWNvcmQgdGhlIGlucHV0dGVkIHpvbmUgc29tZWhvd1xuXHRcdFx0aWYgKGlzQW1iaWdab25lKSB7XG5cdFx0XHRcdG1vbS5fYW1iaWdab25lID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGlzU2luZ2xlU3RyaW5nKSB7XG5cdFx0XHRcdG1vbS51dGNPZmZzZXQoaW5wdXQpOyAvLyBpZiBub3QgYSB2YWxpZCB6b25lLCB3aWxsIGFzc2lnbiBVVENcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRtb20uX2Z1bGxDYWxlbmRhciA9IHRydWU7IC8vIGZsYWcgZm9yIGV4dGVuZGVkIGZ1bmN0aW9uYWxpdHlcblxuXHRyZXR1cm4gbW9tO1xufVxuXG5cbi8vIFdlZWsgTnVtYmVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLy8gUmV0dXJucyB0aGUgd2VlayBudW1iZXIsIGNvbnNpZGVyaW5nIHRoZSBsb2NhbGUncyBjdXN0b20gd2VlayBudW1iZXIgY2FsY3VhdGlvblxuLy8gYHdlZWtzYCBpcyBhbiBhbGlhcyBmb3IgYHdlZWtgXG5uZXdNb21lbnRQcm90by53ZWVrID0gbmV3TW9tZW50UHJvdG8ud2Vla3MgPSBmdW5jdGlvbihpbnB1dCkge1xuXHR2YXIgd2Vla0NhbGMgPSB0aGlzLl9sb2NhbGUuX2Z1bGxDYWxlbmRhcl93ZWVrQ2FsYztcblxuXHRpZiAoaW5wdXQgPT0gbnVsbCAmJiB0eXBlb2Ygd2Vla0NhbGMgPT09ICdmdW5jdGlvbicpIHsgLy8gY3VzdG9tIGZ1bmN0aW9uIG9ubHkgd29ya3MgZm9yIGdldHRlclxuXHRcdHJldHVybiB3ZWVrQ2FsYyh0aGlzKTtcblx0fVxuXHRlbHNlIGlmICh3ZWVrQ2FsYyA9PT0gJ0lTTycpIHtcblx0XHRyZXR1cm4gb2xkTW9tZW50UHJvdG8uaXNvV2Vlay5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBJU08gZ2V0dGVyL3NldHRlclxuXHR9XG5cblx0cmV0dXJuIG9sZE1vbWVudFByb3RvLndlZWsuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gbG9jYWwgZ2V0dGVyL3NldHRlclxufTtcblxuXG4vLyBUaW1lLW9mLWRheVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBHRVRURVJcbi8vIFJldHVybnMgYSBEdXJhdGlvbiB3aXRoIHRoZSBob3Vycy9taW51dGVzL3NlY29uZHMvbXMgdmFsdWVzIG9mIHRoZSBtb21lbnQuXG4vLyBJZiB0aGUgbW9tZW50IGhhcyBhbiBhbWJpZ3VvdXMgdGltZSwgYSBkdXJhdGlvbiBvZiAwMDowMCB3aWxsIGJlIHJldHVybmVkLlxuLy9cbi8vIFNFVFRFUlxuLy8gWW91IGNhbiBzdXBwbHkgYSBEdXJhdGlvbiwgYSBNb21lbnQsIG9yIGEgRHVyYXRpb24tbGlrZSBhcmd1bWVudC5cbi8vIFdoZW4gc2V0dGluZyB0aGUgdGltZSwgYW5kIHRoZSBtb21lbnQgaGFzIGFuIGFtYmlndW91cyB0aW1lLCBpdCB0aGVuIGJlY29tZXMgdW5hbWJpZ3VvdXMuXG5uZXdNb21lbnRQcm90by50aW1lID0gZnVuY3Rpb24odGltZSkge1xuXG5cdC8vIEZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QgKGlmIHRoZXJlIGlzIG9uZSkgaWYgdGhpcyBtb21lbnQgd2Fzbid0IGNyZWF0ZWQgdmlhIEZ1bGxDYWxlbmRhci5cblx0Ly8gYHRpbWVgIGlzIGEgZ2VuZXJpYyBlbm91Z2ggbWV0aG9kIG5hbWUgd2hlcmUgdGhpcyBwcmVjYXV0aW9uIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCBjb2xsaXNpb25zIHcvIG90aGVyIHBsdWdpbnMuXG5cdGlmICghdGhpcy5fZnVsbENhbGVuZGFyKSB7XG5cdFx0cmV0dXJuIG9sZE1vbWVudFByb3RvLnRpbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fVxuXG5cdGlmICh0aW1lID09IG51bGwpIHsgLy8gZ2V0dGVyXG5cdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbih7XG5cdFx0XHRob3VyczogdGhpcy5ob3VycygpLFxuXHRcdFx0bWludXRlczogdGhpcy5taW51dGVzKCksXG5cdFx0XHRzZWNvbmRzOiB0aGlzLnNlY29uZHMoKSxcblx0XHRcdG1pbGxpc2Vjb25kczogdGhpcy5taWxsaXNlY29uZHMoKVxuXHRcdH0pO1xuXHR9XG5cdGVsc2UgeyAvLyBzZXR0ZXJcblxuXHRcdHRoaXMuX2FtYmlnVGltZSA9IGZhbHNlOyAvLyBtYXJrIHRoYXQgdGhlIG1vbWVudCBub3cgaGFzIGEgdGltZVxuXG5cdFx0aWYgKCFtb21lbnQuaXNEdXJhdGlvbih0aW1lKSAmJiAhbW9tZW50LmlzTW9tZW50KHRpbWUpKSB7XG5cdFx0XHR0aW1lID0gbW9tZW50LmR1cmF0aW9uKHRpbWUpO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBkYXkgdmFsdWUgc2hvdWxkIGNhdXNlIG92ZXJmbG93IChzbyAyNCBob3VycyBiZWNvbWVzIDAwOjAwOjAwIG9mIG5leHQgZGF5KS5cblx0XHQvLyBPbmx5IGZvciBEdXJhdGlvbiB0aW1lcywgbm90IE1vbWVudCB0aW1lcy5cblx0XHR2YXIgZGF5SG91cnMgPSAwO1xuXHRcdGlmIChtb21lbnQuaXNEdXJhdGlvbih0aW1lKSkge1xuXHRcdFx0ZGF5SG91cnMgPSBNYXRoLmZsb29yKHRpbWUuYXNEYXlzKCkpICogMjQ7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgbmVlZCB0byBzZXQgdGhlIGluZGl2aWR1YWwgZmllbGRzLlxuXHRcdC8vIENhbid0IHVzZSBzdGFydE9mKCdkYXknKSB0aGVuIGFkZCBkdXJhdGlvbi4gSW4gY2FzZSBvZiBEU1QgYXQgc3RhcnQgb2YgZGF5LlxuXHRcdHJldHVybiB0aGlzLmhvdXJzKGRheUhvdXJzICsgdGltZS5ob3VycygpKVxuXHRcdFx0Lm1pbnV0ZXModGltZS5taW51dGVzKCkpXG5cdFx0XHQuc2Vjb25kcyh0aW1lLnNlY29uZHMoKSlcblx0XHRcdC5taWxsaXNlY29uZHModGltZS5taWxsaXNlY29uZHMoKSk7XG5cdH1cbn07XG5cbi8vIENvbnZlcnRzIHRoZSBtb21lbnQgdG8gVVRDLCBzdHJpcHBpbmcgb3V0IGl0cyB0aW1lLW9mLWRheSBhbmQgdGltZXpvbmUgb2Zmc2V0LFxuLy8gYnV0IHByZXNlcnZpbmcgaXRzIFlNRC4gQSBtb21lbnQgd2l0aCBhIHN0cmlwcGVkIHRpbWUgd2lsbCBkaXNwbGF5IG5vIHRpbWVcbi8vIG5vciB0aW1lem9uZSBvZmZzZXQgd2hlbiAuZm9ybWF0KCkgaXMgY2FsbGVkLlxubmV3TW9tZW50UHJvdG8uc3RyaXBUaW1lID0gZnVuY3Rpb24oKSB7XG5cblx0aWYgKCF0aGlzLl9hbWJpZ1RpbWUpIHtcblxuXHRcdHRoaXMudXRjKHRydWUpOyAvLyBrZWVwTG9jYWxUaW1lPXRydWUgKGZvciBrZWVwaW5nICpkYXRlKiB2YWx1ZSlcblxuXHRcdC8vIHNldCB0aW1lIHRvIHplcm9cblx0XHR0aGlzLnNldCh7XG5cdFx0XHRob3VyczogMCxcblx0XHRcdG1pbnV0ZXM6IDAsXG5cdFx0XHRzZWNvbmRzOiAwLFxuXHRcdFx0bXM6IDBcblx0XHR9KTtcblxuXHRcdC8vIE1hcmsgdGhlIHRpbWUgYXMgYW1iaWd1b3VzLiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBhZnRlciB0aGUgLnV0YygpIGNhbGwsIHdoaWNoIG1pZ2h0IGNhbGwgLnV0Y09mZnNldCgpLFxuXHRcdC8vIHdoaWNoIGNsZWFycyBhbGwgYW1iaWcgZmxhZ3MuXG5cdFx0dGhpcy5fYW1iaWdUaW1lID0gdHJ1ZTtcblx0XHR0aGlzLl9hbWJpZ1pvbmUgPSB0cnVlOyAvLyBpZiBhbWJpZ3VvdXMgdGltZSwgYWxzbyBhbWJpZ3VvdXMgdGltZXpvbmUgb2Zmc2V0XG5cdH1cblxuXHRyZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG4vLyBSZXR1cm5zIGlmIHRoZSBtb21lbnQgaGFzIGEgbm9uLWFtYmlndW91cyB0aW1lIChib29sZWFuKVxubmV3TW9tZW50UHJvdG8uaGFzVGltZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gIXRoaXMuX2FtYmlnVGltZTtcbn07XG5cblxuLy8gVGltZXpvbmVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQ29udmVydHMgdGhlIG1vbWVudCB0byBVVEMsIHN0cmlwcGluZyBvdXQgaXRzIHRpbWV6b25lIG9mZnNldCwgYnV0IHByZXNlcnZpbmcgaXRzXG4vLyBZTUQgYW5kIHRpbWUtb2YtZGF5LiBBIG1vbWVudCB3aXRoIGEgc3RyaXBwZWQgdGltZXpvbmUgb2Zmc2V0IHdpbGwgZGlzcGxheSBub1xuLy8gdGltZXpvbmUgb2Zmc2V0IHdoZW4gLmZvcm1hdCgpIGlzIGNhbGxlZC5cbm5ld01vbWVudFByb3RvLnN0cmlwWm9uZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgd2FzQW1iaWdUaW1lO1xuXG5cdGlmICghdGhpcy5fYW1iaWdab25lKSB7XG5cblx0XHR3YXNBbWJpZ1RpbWUgPSB0aGlzLl9hbWJpZ1RpbWU7XG5cblx0XHR0aGlzLnV0Yyh0cnVlKTsgLy8ga2VlcExvY2FsVGltZT10cnVlIChmb3Iga2VlcGluZyBkYXRlIGFuZCB0aW1lIHZhbHVlcylcblxuXHRcdC8vIHRoZSBhYm92ZSBjYWxsIHRvIC51dGMoKS8udXRjT2Zmc2V0KCkgdW5mb3J0dW5hdGVseSBtaWdodCBjbGVhciB0aGUgYW1iaWcgZmxhZ3MsIHNvIHJlc3RvcmVcblx0XHR0aGlzLl9hbWJpZ1RpbWUgPSB3YXNBbWJpZ1RpbWUgfHwgZmFsc2U7XG5cblx0XHQvLyBNYXJrIHRoZSB6b25lIGFzIGFtYmlndW91cy4gVGhpcyBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgdGhlIC51dGMoKSBjYWxsLCB3aGljaCBtaWdodCBjYWxsIC51dGNPZmZzZXQoKSxcblx0XHQvLyB3aGljaCBjbGVhcnMgdGhlIGFtYmlnIGZsYWdzLlxuXHRcdHRoaXMuX2FtYmlnWm9uZSA9IHRydWU7XG5cdH1cblxuXHRyZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG4vLyBSZXR1cm5zIG9mIHRoZSBtb21lbnQgaGFzIGEgbm9uLWFtYmlndW91cyB0aW1lem9uZSBvZmZzZXQgKGJvb2xlYW4pXG5uZXdNb21lbnRQcm90by5oYXNab25lID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAhdGhpcy5fYW1iaWdab25lO1xufTtcblxuXG4vLyBpbXBsaWNpdGx5IG1hcmtzIGEgem9uZVxubmV3TW9tZW50UHJvdG8ubG9jYWwgPSBmdW5jdGlvbihrZWVwTG9jYWxUaW1lKSB7XG5cblx0Ly8gZm9yIHdoZW4gY29udmVydGluZyBmcm9tIGFtYmlndW91c2x5LXpvbmVkIHRvIGxvY2FsLFxuXHQvLyBrZWVwIHRoZSB0aW1lIHZhbHVlcyB3aGVuIGNvbnZlcnRpbmcgZnJvbSBVVEMgLT4gbG9jYWxcblx0b2xkTW9tZW50UHJvdG8ubG9jYWwuY2FsbCh0aGlzLCB0aGlzLl9hbWJpZ1pvbmUgfHwga2VlcExvY2FsVGltZSk7XG5cblx0Ly8gZW5zdXJlIG5vbi1hbWJpZ3VvdXNcblx0Ly8gdGhpcyBwcm9iYWJseSBhbHJlYWR5IGhhcHBlbmVkIHZpYSBsb2NhbCgpIC0+IHV0Y09mZnNldCgpLCBidXQgZG9uJ3QgcmVseSBvbiBNb21lbnQncyBpbnRlcm5hbHNcblx0dGhpcy5fYW1iaWdUaW1lID0gZmFsc2U7XG5cdHRoaXMuX2FtYmlnWm9uZSA9IGZhbHNlO1xuXG5cdHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cblxuLy8gaW1wbGljaXRseSBtYXJrcyBhIHpvbmVcbm5ld01vbWVudFByb3RvLnV0YyA9IGZ1bmN0aW9uKGtlZXBMb2NhbFRpbWUpIHtcblxuXHRvbGRNb21lbnRQcm90by51dGMuY2FsbCh0aGlzLCBrZWVwTG9jYWxUaW1lKTtcblxuXHQvLyBlbnN1cmUgbm9uLWFtYmlndW91c1xuXHQvLyB0aGlzIHByb2JhYmx5IGFscmVhZHkgaGFwcGVuZWQgdmlhIHV0YygpIC0+IHV0Y09mZnNldCgpLCBidXQgZG9uJ3QgcmVseSBvbiBNb21lbnQncyBpbnRlcm5hbHNcblx0dGhpcy5fYW1iaWdUaW1lID0gZmFsc2U7XG5cdHRoaXMuX2FtYmlnWm9uZSA9IGZhbHNlO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBpbXBsaWNpdGx5IG1hcmtzIGEgem9uZSAod2lsbCBwcm9iYWJseSBnZXQgY2FsbGVkIHVwb24gLnV0YygpIGFuZCAubG9jYWwoKSlcbm5ld01vbWVudFByb3RvLnV0Y09mZnNldCA9IGZ1bmN0aW9uKHR6bykge1xuXG5cdGlmICh0em8gIT0gbnVsbCkgeyAvLyBzZXR0ZXJcblx0XHQvLyB0aGVzZSBhc3NpZ25tZW50cyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBvcmlnaW5hbCB6b25lIG1ldGhvZCBpcyBjYWxsZWQuXG5cdFx0Ly8gSSBmb3JnZXQgd2h5LCBzb21ldGhpbmcgdG8gZG8gd2l0aCBhIGJyb3dzZXIgY3Jhc2guXG5cdFx0dGhpcy5fYW1iaWdUaW1lID0gZmFsc2U7XG5cdFx0dGhpcy5fYW1iaWdab25lID0gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gb2xkTW9tZW50UHJvdG8udXRjT2Zmc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5cbi8vIEZvcm1hdHRpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubmV3TW9tZW50UHJvdG8uZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG5cblx0aWYgKHRoaXMuX2Z1bGxDYWxlbmRhciAmJiBhcmd1bWVudHNbMF0pIHsgLy8gYW4gZW5oYW5jZWQgbW9tZW50PyBhbmQgYSBmb3JtYXQgc3RyaW5nIHByb3ZpZGVkP1xuXHRcdHJldHVybiBmb3JtYXREYXRlKHRoaXMsIGFyZ3VtZW50c1swXSk7IC8vIG91ciBleHRlbmRlZCBmb3JtYXR0aW5nXG5cdH1cblx0aWYgKHRoaXMuX2FtYmlnVGltZSkge1xuXHRcdHJldHVybiBvbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSwgJ1lZWVktTU0tREQnKTtcblx0fVxuXHRpZiAodGhpcy5fYW1iaWdab25lKSB7XG5cdFx0cmV0dXJuIG9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzJyk7XG5cdH1cblx0aWYgKHRoaXMuX2Z1bGxDYWxlbmRhcikgeyAvLyBlbmhhbmNlZCBub24tYW1iaWcgbW9tZW50P1xuXHRcdC8vIG1vbWVudC5mb3JtYXQoKSBkb2Vzbid0IGVuc3VyZSBlbmdsaXNoLCBidXQgd2Ugd2FudCB0by5cblx0XHRyZXR1cm4gb2xkTW9tZW50Rm9ybWF0KGVuZ2xpc2hNb21lbnQodGhpcykpO1xuXHR9XG5cblx0cmV0dXJuIG9sZE1vbWVudFByb3RvLmZvcm1hdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxubmV3TW9tZW50UHJvdG8udG9JU09TdHJpbmcgPSBmdW5jdGlvbigpIHtcblxuXHRpZiAodGhpcy5fYW1iaWdUaW1lKSB7XG5cdFx0cmV0dXJuIG9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpLCAnWVlZWS1NTS1ERCcpO1xuXHR9XG5cdGlmICh0aGlzLl9hbWJpZ1pvbmUpIHtcblx0XHRyZXR1cm4gb2xkTW9tZW50Rm9ybWF0KGVuZ2xpc2hNb21lbnQodGhpcyksICdZWVlZLU1NLUREW1RdSEg6bW06c3MnKTtcblx0fVxuXHRpZiAodGhpcy5fZnVsbENhbGVuZGFyKSB7IC8vIGVuaGFuY2VkIG5vbi1hbWJpZyBtb21lbnQ/XG5cdFx0Ly8gZGVwZW5kaW5nIG9uIGJyb3dzZXIsIG1vbWVudCBtaWdodCBub3Qgb3V0cHV0IGVuZ2xpc2guIGVuc3VyZSBlbmdsaXNoLlxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2Jsb2IvMi4xOC4xL3NyYy9saWIvbW9tZW50L2Zvcm1hdC5qcyNMMjJcblx0XHRyZXR1cm4gb2xkTW9tZW50UHJvdG8udG9JU09TdHJpbmcuYXBwbHkoZW5nbGlzaE1vbWVudCh0aGlzKSwgYXJndW1lbnRzKTtcblx0fVxuXG5cdHJldHVybiBvbGRNb21lbnRQcm90by50b0lTT1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuZnVuY3Rpb24gZW5nbGlzaE1vbWVudChtb20pIHtcblx0aWYgKG1vbS5sb2NhbGUoKSAhPT0gJ2VuJykge1xuXHRcdHJldHVybiBtb20uY2xvbmUoKS5sb2NhbGUoJ2VuJyk7XG5cdH1cblx0cmV0dXJuIG1vbTtcbn1cblxuOztcbihmdW5jdGlvbigpIHtcblxuLy8gZXhwb3J0c1xuRkMuZm9ybWF0RGF0ZSA9IGZvcm1hdERhdGU7XG5GQy5mb3JtYXRSYW5nZSA9IGZvcm1hdFJhbmdlO1xuRkMub2xkTW9tZW50Rm9ybWF0ID0gb2xkTW9tZW50Rm9ybWF0O1xuRkMucXVlcnlNb3N0R3JhbnVsYXJGb3JtYXRVbml0ID0gcXVlcnlNb3N0R3JhbnVsYXJGb3JtYXRVbml0O1xuXG5cbi8vIENvbmZpZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG5JbnNlcnRlZCBiZXR3ZWVuIGNodW5rcyBpbiB0aGUgZmFrZSAoXCJpbnRlcm1lZGlhdGVcIikgZm9ybWF0dGluZyBzdHJpbmcuXG5JbXBvcnRhbnQgdGhhdCBpdCBwYXNzZXMgYXMgd2hpdGVzcGFjZSAoXFxzKSBiZWNhdXNlIG1vbWVudCBvZnRlbiBpZGVudGlmaWVzIG5vbi1zdGFuZGFsb25lIG1vbnRoc1xudmlhIGEgcmVnZXhwIHdpdGggYW4gXFxzLlxuKi9cbnZhciBQQVJUX1NFUEFSQVRPUiA9ICdcXHUwMDBiJzsgLy8gdmVydGljYWwgdGFiXG5cbi8qXG5JbnNlcnRlZCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgbGl0ZXJhbC10ZXh0IGNodW5rIHRvIGluZGljYXRlIHRoYXQgdGhlIGxpdGVyYWwgdGV4dCBpcyBub3QgYWN0dWFsbHkgbGl0ZXJhbCB0ZXh0LFxuYnV0IHJhdGhlciwgYSBcInNwZWNpYWxcIiB0b2tlbiB0aGF0IGhhcyBjdXN0b20gcmVuZGVyaW5nIChzZWUgc3BlY2lhbFRva2VucyBtYXApLlxuKi9cbnZhciBTUEVDSUFMX1RPS0VOX01BUktFUiA9ICdcXHUwMDFmJzsgLy8gaW5mb3JtYXRpb24gc2VwYXJhdG9yIDFcblxuLypcbkluc2VydGVkIGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHNwYW4gb2YgdGV4dCB0aGF0IG11c3QgaGF2ZSBub24temVybyBudW1lcmljIGNoYXJhY3RlcnMuXG5IYW5kbGluZyBvZiB0aGVzZSBtYXJrZXJzIGlzIGRvbmUgaW4gYSBwb3N0LXByb2Nlc3Npbmcgc3RlcCBhdCB0aGUgdmVyeSBlbmQgb2YgdGV4dCByZW5kZXJpbmcuXG4qL1xudmFyIE1BWUJFX01BUktFUiA9ICdcXHUwMDFlJzsgLy8gaW5mb3JtYXRpb24gc2VwYXJhdG9yIDJcbnZhciBNQVlCRV9SRUdFWFAgPSBuZXcgUmVnRXhwKE1BWUJFX01BUktFUiArICcoW14nICsgTUFZQkVfTUFSS0VSICsgJ10qKScgKyBNQVlCRV9NQVJLRVIsICdnJyk7IC8vIG11c3QgYmUgZ2xvYmFsXG5cbi8qXG5BZGRpdGlvbiBmb3JtYXR0aW5nIHRva2VucyB3ZSB3YW50IHJlY29nbml6ZWRcbiovXG52YXIgc3BlY2lhbFRva2VucyA9IHtcblx0dDogZnVuY3Rpb24oZGF0ZSkgeyAvLyBcImFcIiBvciBcInBcIlxuXHRcdHJldHVybiBvbGRNb21lbnRGb3JtYXQoZGF0ZSwgJ2EnKS5jaGFyQXQoMCk7XG5cdH0sXG5cdFQ6IGZ1bmN0aW9uKGRhdGUpIHsgLy8gXCJBXCIgb3IgXCJQXCJcblx0XHRyZXR1cm4gb2xkTW9tZW50Rm9ybWF0KGRhdGUsICdBJykuY2hhckF0KDApO1xuXHR9XG59O1xuXG4vKlxuVGhlIGZpcnN0IGNoYXJhY3RlcnMgb2YgZm9ybWF0dGluZyB0b2tlbnMgZm9yIHVuaXRzIHRoYXQgYXJlIDEgZGF5IG9yIGxhcmdlci5cbmB2YWx1ZWAgaXMgZm9yIHJhbmtpbmcgcmVsYXRpdmUgc2l6ZSAobG93ZXIgbWVhbnMgYmlnZ2VyKS5cbmB1bml0YCBpcyBhIG5vcm1hbGl6ZWQgdW5pdCwgdXNlZCBmb3IgY29tcGFyaW5nIG1vbWVudHMuXG4qL1xudmFyIGxhcmdlVG9rZW5NYXAgPSB7XG5cdFk6IHsgdmFsdWU6IDEsIHVuaXQ6ICd5ZWFyJyB9LFxuXHRNOiB7IHZhbHVlOiAyLCB1bml0OiAnbW9udGgnIH0sXG5cdFc6IHsgdmFsdWU6IDMsIHVuaXQ6ICd3ZWVrJyB9LCAvLyBJU08gd2Vla1xuXHR3OiB7IHZhbHVlOiAzLCB1bml0OiAnd2VlaycgfSwgLy8gbG9jYWwgd2Vla1xuXHREOiB7IHZhbHVlOiA0LCB1bml0OiAnZGF5JyB9LCAvLyBkYXkgb2YgbW9udGhcblx0ZDogeyB2YWx1ZTogNCwgdW5pdDogJ2RheScgfSAvLyBkYXkgb2Ygd2Vla1xufTtcblxuXG4vLyBTaW5nbGUgRGF0ZSBGb3JtYXR0aW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbkZvcm1hdHMgYGRhdGVgIHdpdGggYSBNb21lbnQgZm9ybWF0dGluZyBzdHJpbmcsIGJ1dCBhbGxvdyBvdXIgbm9uLXplcm8gYXJlYXMgYW5kIHNwZWNpYWwgdG9rZW5cbiovXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdFN0cikge1xuXHRyZXR1cm4gcmVuZGVyRmFrZUZvcm1hdFN0cmluZyhcblx0XHRnZXRQYXJzZWRGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKS5mYWtlRm9ybWF0U3RyaW5nLFxuXHRcdGRhdGVcblx0KTtcbn1cblxuLypcbkNhbGwgdGhpcyBpZiB5b3Ugd2FudCBNb21lbnQncyBvcmlnaW5hbCBmb3JtYXQgbWV0aG9kIHRvIGJlIHVzZWRcbiovXG5mdW5jdGlvbiBvbGRNb21lbnRGb3JtYXQobW9tLCBmb3JtYXRTdHIpIHtcblx0cmV0dXJuIG9sZE1vbWVudFByb3RvLmZvcm1hdC5jYWxsKG1vbSwgZm9ybWF0U3RyKTsgLy8gb2xkTW9tZW50UHJvdG8gZGVmaW5lZCBpbiBtb21lbnQtZXh0LmpzXG59XG5cblxuLy8gRGF0ZSBSYW5nZSBGb3JtYXR0aW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUT0RPOiBtYWtlIGl0IHdvcmsgd2l0aCB0aW1lem9uZSBvZmZzZXRcblxuLypcblVzaW5nIGEgZm9ybWF0dGluZyBzdHJpbmcgbWVhbnQgZm9yIGEgc2luZ2xlIGRhdGUsIGdlbmVyYXRlIGEgcmFuZ2Ugc3RyaW5nLCBsaWtlXG5cIlNlcCAyIC0gOSAyMDEzXCIsIHRoYXQgaW50ZWxsaWdlbnRseSBpbnNlcnRzIGEgc2VwYXJhdG9yIHdoZXJlIHRoZSBkYXRlcyBkaWZmZXIuXG5JZiB0aGUgZGF0ZXMgYXJlIHRoZSBzYW1lIGFzIGZhciBhcyB0aGUgZm9ybWF0IHN0cmluZyBpcyBjb25jZXJuZWQsIGp1c3QgcmV0dXJuIGEgc2luZ2xlXG5yZW5kZXJpbmcgb2Ygb25lIGRhdGUsIHdpdGhvdXQgYW55IHNlcGFyYXRvci5cbiovXG5mdW5jdGlvbiBmb3JtYXRSYW5nZShkYXRlMSwgZGF0ZTIsIGZvcm1hdFN0ciwgc2VwYXJhdG9yLCBpc1JUTCkge1xuXHR2YXIgbG9jYWxlRGF0YTtcblxuXHRkYXRlMSA9IEZDLm1vbWVudC5wYXJzZVpvbmUoZGF0ZTEpO1xuXHRkYXRlMiA9IEZDLm1vbWVudC5wYXJzZVpvbmUoZGF0ZTIpO1xuXG5cdGxvY2FsZURhdGEgPSBkYXRlMS5sb2NhbGVEYXRhKCk7XG5cblx0Ly8gRXhwYW5kIGxvY2FsaXplZCBmb3JtYXQgc3RyaW5ncywgbGlrZSBcIkxMXCIgLT4gXCJNTU1NIEQgWVlZWVwiLlxuXHQvLyBCVFcsIHRoaXMgaXMgbm90IGltcG9ydGFudCBmb3IgYGZvcm1hdERhdGVgIGJlY2F1c2UgaXQgaXMgaW1wb3NzaWJsZSB0byBwdXQgY3VzdG9tIHRva2Vuc1xuXHQvLyBvciBub24temVybyBhcmVhcyBpbiBNb21lbnQncyBsb2NhbGl6ZWQgZm9ybWF0IHN0cmluZ3MuXG5cdGZvcm1hdFN0ciA9IGxvY2FsZURhdGEubG9uZ0RhdGVGb3JtYXQoZm9ybWF0U3RyKSB8fCBmb3JtYXRTdHI7XG5cblx0cmV0dXJuIHJlbmRlclBhcnNlZEZvcm1hdChcblx0XHRnZXRQYXJzZWRGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSxcblx0XHRkYXRlMSxcblx0XHRkYXRlMixcblx0XHRzZXBhcmF0b3IgfHwgJyAtICcsXG5cdFx0aXNSVExcblx0KTtcbn1cblxuLypcblJlbmRlcnMgYSByYW5nZSB3aXRoIGFuIGFscmVhZHktcGFyc2VkIGZvcm1hdCBzdHJpbmcuXG4qL1xuZnVuY3Rpb24gcmVuZGVyUGFyc2VkRm9ybWF0KHBhcnNlZEZvcm1hdCwgZGF0ZTEsIGRhdGUyLCBzZXBhcmF0b3IsIGlzUlRMKSB7XG5cdHZhciBzYW1lVW5pdHMgPSBwYXJzZWRGb3JtYXQuc2FtZVVuaXRzO1xuXHR2YXIgdW56b25lZERhdGUxID0gZGF0ZTEuY2xvbmUoKS5zdHJpcFpvbmUoKTsgLy8gZm9yIHNhbWUtdW5pdCBjb21wYXJpc29uc1xuXHR2YXIgdW56b25lZERhdGUyID0gZGF0ZTIuY2xvbmUoKS5zdHJpcFpvbmUoKTsgLy8gXCJcblxuXHR2YXIgcmVuZGVyZWRQYXJ0czEgPSByZW5kZXJGYWtlRm9ybWF0U3RyaW5nUGFydHMocGFyc2VkRm9ybWF0LmZha2VGb3JtYXRTdHJpbmcsIGRhdGUxKTtcblx0dmFyIHJlbmRlcmVkUGFydHMyID0gcmVuZGVyRmFrZUZvcm1hdFN0cmluZ1BhcnRzKHBhcnNlZEZvcm1hdC5mYWtlRm9ybWF0U3RyaW5nLCBkYXRlMik7XG5cblx0dmFyIGxlZnRJO1xuXHR2YXIgbGVmdFN0ciA9ICcnO1xuXHR2YXIgcmlnaHRJO1xuXHR2YXIgcmlnaHRTdHIgPSAnJztcblx0dmFyIG1pZGRsZUk7XG5cdHZhciBtaWRkbGVTdHIxID0gJyc7XG5cdHZhciBtaWRkbGVTdHIyID0gJyc7XG5cdHZhciBtaWRkbGVTdHIgPSAnJztcblxuXHQvLyBTdGFydCBhdCB0aGUgbGVmdG1vc3Qgc2lkZSBvZiB0aGUgZm9ybWF0dGluZyBzdHJpbmcgYW5kIGNvbnRpbnVlIHVudGlsIHlvdSBoaXQgYSB0b2tlblxuXHQvLyB0aGF0IGlzIG5vdCB0aGUgc2FtZSBiZXR3ZWVuIGRhdGVzLlxuXHRmb3IgKFxuXHRcdGxlZnRJID0gMDtcblx0XHRsZWZ0SSA8IHNhbWVVbml0cy5sZW5ndGggJiYgKCFzYW1lVW5pdHNbbGVmdEldIHx8IHVuem9uZWREYXRlMS5pc1NhbWUodW56b25lZERhdGUyLCBzYW1lVW5pdHNbbGVmdEldKSk7XG5cdFx0bGVmdEkrK1xuXHQpIHtcblx0XHRsZWZ0U3RyICs9IHJlbmRlcmVkUGFydHMxW2xlZnRJXTtcblx0fVxuXG5cdC8vIFNpbWlsYXJseSwgc3RhcnQgYXQgdGhlIHJpZ2h0bW9zdCBzaWRlIG9mIHRoZSBmb3JtYXR0aW5nIHN0cmluZyBhbmQgbW92ZSBsZWZ0XG5cdGZvciAoXG5cdFx0cmlnaHRJID0gc2FtZVVuaXRzLmxlbmd0aCAtIDE7XG5cdFx0cmlnaHRJID4gbGVmdEkgJiYgKCFzYW1lVW5pdHNbcmlnaHRJXSB8fCB1bnpvbmVkRGF0ZTEuaXNTYW1lKHVuem9uZWREYXRlMiwgc2FtZVVuaXRzW3JpZ2h0SV0pKTtcblx0XHRyaWdodEktLVxuXHQpIHtcblx0XHQvLyBJZiBjdXJyZW50IGNodW5rIGlzIG9uIHRoZSBib3VuZGFyeSBvZiB1bmlxdWUgZGF0ZS1jb250ZW50LCBhbmQgaXMgYSBzcGVjaWFsLWNhc2Vcblx0XHQvLyBkYXRlLWZvcm1hdHRpbmcgcG9zdGZpeCBjaGFyYWN0ZXIsIHRoZW4gZG9uJ3QgY29uc3VtZSBpdC4gQ29uc2lkZXIgaXQgdW5pcXVlIGRhdGUtY29udGVudC5cblx0XHQvLyBUT0RPOiBtYWtlIGNvbmZpZ3VyYWJsZVxuXHRcdGlmIChyaWdodEkgLSAxID09PSBsZWZ0SSAmJiByZW5kZXJlZFBhcnRzMVtyaWdodEldID09PSAnLicpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdHJpZ2h0U3RyID0gcmVuZGVyZWRQYXJ0czFbcmlnaHRJXSArIHJpZ2h0U3RyO1xuXHR9XG5cblx0Ly8gVGhlIGFyZWEgaW4gdGhlIG1pZGRsZSBpcyBkaWZmZXJlbnQgZm9yIGJvdGggb2YgdGhlIGRhdGVzLlxuXHQvLyBDb2xsZWN0IHRoZW0gZGlzdGluY3RseSBzbyB3ZSBjYW4gamFtIHRoZW0gdG9nZXRoZXIgbGF0ZXIuXG5cdGZvciAobWlkZGxlSSA9IGxlZnRJOyBtaWRkbGVJIDw9IHJpZ2h0STsgbWlkZGxlSSsrKSB7XG5cdFx0bWlkZGxlU3RyMSArPSByZW5kZXJlZFBhcnRzMVttaWRkbGVJXTtcblx0XHRtaWRkbGVTdHIyICs9IHJlbmRlcmVkUGFydHMyW21pZGRsZUldO1xuXHR9XG5cblx0aWYgKG1pZGRsZVN0cjEgfHwgbWlkZGxlU3RyMikge1xuXHRcdGlmIChpc1JUTCkge1xuXHRcdFx0bWlkZGxlU3RyID0gbWlkZGxlU3RyMiArIHNlcGFyYXRvciArIG1pZGRsZVN0cjE7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bWlkZGxlU3RyID0gbWlkZGxlU3RyMSArIHNlcGFyYXRvciArIG1pZGRsZVN0cjI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHByb2Nlc3NNYXliZU1hcmtlcnMoXG5cdFx0bGVmdFN0ciArIG1pZGRsZVN0ciArIHJpZ2h0U3RyXG5cdCk7XG59XG5cblxuLy8gRm9ybWF0IFN0cmluZyBQYXJzaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHBhcnNlZEZvcm1hdFN0ckNhY2hlID0ge307XG5cbi8qXG5SZXR1cm5zIGEgcGFyc2VkIGZvcm1hdCBzdHJpbmcsIGxldmVyYWdpbmcgYSBjYWNoZS5cbiovXG5mdW5jdGlvbiBnZXRQYXJzZWRGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSB7XG5cdHJldHVybiBwYXJzZWRGb3JtYXRTdHJDYWNoZVtmb3JtYXRTdHJdIHx8XG5cdFx0KHBhcnNlZEZvcm1hdFN0ckNhY2hlW2Zvcm1hdFN0cl0gPSBwYXJzZUZvcm1hdFN0cmluZyhmb3JtYXRTdHIpKTtcbn1cblxuLypcblBhcnNlcyBhIGZvcm1hdCBzdHJpbmcgaW50byB0aGUgZm9sbG93aW5nOlxuLSBmYWtlRm9ybWF0U3RyaW5nOiBhIG1vbWVudEpTIGZvcm1hdHRpbmcgc3RyaW5nLCBsaXR0ZXJlZCB3aXRoIHNwZWNpYWwgY29udHJvbCBjaGFyYWN0ZXJzIHRoYXQgZ2V0IHBvc3QtcHJvY2Vzc2VkLlxuLSBzYW1lVW5pdHM6IGZvciBldmVyeSBwYXJ0IGluIGZha2VGb3JtYXRTdHJpbmcsIGlmIHRoZSBwYXJ0IGlzIGEgdG9rZW4sIHRoZSB2YWx1ZSB3aWxsIGJlIGEgdW5pdCBzdHJpbmcgKGxpa2UgXCJkYXlcIiksXG4gIHRoYXQgaW5kaWNhdGVzIGhvdyBzaW1pbGFyIGEgcmFuZ2UncyBzdGFydCAmIGVuZCBtdXN0IGJlIGluIG9yZGVyIHRvIHNoYXJlIHRoZSBzYW1lIGZvcm1hdHRlZCB0ZXh0LlxuICBJZiBub3QgYSB0b2tlbiwgdGhlbiB0aGUgdmFsdWUgaXMgbnVsbC5cbiAgQWx3YXlzIGEgZmxhdCBhcnJheSAobm90IG5lc3RlZCBsaWtlZCBcImNodW5rc1wiKS5cbiovXG5mdW5jdGlvbiBwYXJzZUZvcm1hdFN0cmluZyhmb3JtYXRTdHIpIHtcblx0dmFyIGNodW5rcyA9IGNodW5rRm9ybWF0U3RyaW5nKGZvcm1hdFN0cik7XG5cdFxuXHRyZXR1cm4ge1xuXHRcdGZha2VGb3JtYXRTdHJpbmc6IGJ1aWxkRmFrZUZvcm1hdFN0cmluZyhjaHVua3MpLFxuXHRcdHNhbWVVbml0czogYnVpbGRTYW1lVW5pdHMoY2h1bmtzKVxuXHR9O1xufVxuXG4vKlxuQnJlYWsgdGhlIGZvcm1hdHRpbmcgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgY2h1bmtzLlxuQSAnbWF5YmUnIGNodW5rIHdpbGwgaGF2ZSBuZXN0ZWQgY2h1bmtzLlxuKi9cbmZ1bmN0aW9uIGNodW5rRm9ybWF0U3RyaW5nKGZvcm1hdFN0cikge1xuXHR2YXIgY2h1bmtzID0gW107XG5cdHZhciBtYXRjaDtcblxuXHQvLyBUT0RPOiBtb3JlIGRlc2NyaW1pbmF0aW9uXG5cdC8vIFxcNCBpcyBhIGJhY2tyZWZlcmVuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIG11bHRpLWNoYXJhY3RlciBzZXQuXG5cdHZhciBjaHVua2VyID0gL1xcWyhbXlxcXV0qKVxcXXxcXCgoW15cXCldKilcXCl8KExUU3xMVHwoXFx3KVxcNCpvPyl8KFteXFx3XFxbXFwoXSspL2c7XG5cblx0d2hpbGUgKChtYXRjaCA9IGNodW5rZXIuZXhlYyhmb3JtYXRTdHIpKSkge1xuXHRcdGlmIChtYXRjaFsxXSkgeyAvLyBhIGxpdGVyYWwgc3RyaW5nIGluc2lkZSBbIC4uLiBdXG5cdFx0XHRjaHVua3MucHVzaC5hcHBseShjaHVua3MsIC8vIGFwcGVuZFxuXHRcdFx0XHRzcGxpdFN0cmluZ0xpdGVyYWwobWF0Y2hbMV0pXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRlbHNlIGlmIChtYXRjaFsyXSkgeyAvLyBub24temVybyBmb3JtYXR0aW5nIGluc2lkZSAoIC4uLiApXG5cdFx0XHRjaHVua3MucHVzaCh7IG1heWJlOiBjaHVua0Zvcm1hdFN0cmluZyhtYXRjaFsyXSkgfSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdKSB7IC8vIGEgZm9ybWF0dGluZyB0b2tlblxuXHRcdFx0Y2h1bmtzLnB1c2goeyB0b2tlbjogbWF0Y2hbM10gfSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKG1hdGNoWzVdKSB7IC8vIGFuIHVuZW5jbG9zZWQgbGl0ZXJhbCBzdHJpbmdcblx0XHRcdGNodW5rcy5wdXNoLmFwcGx5KGNodW5rcywgLy8gYXBwZW5kXG5cdFx0XHRcdHNwbGl0U3RyaW5nTGl0ZXJhbChtYXRjaFs1XSlcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNodW5rcztcbn1cblxuLypcblBvdGVudGlhbGx5IHNwbGl0cyBhIGxpdGVyYWwtdGV4dCBzdHJpbmcgaW50byBtdWx0aXBsZSBwYXJ0cy4gRm9yIHNwZWNpYWwgY2FzZXMuXG4qL1xuZnVuY3Rpb24gc3BsaXRTdHJpbmdMaXRlcmFsKHMpIHtcblx0aWYgKHMgPT09ICcuICcpIHtcblx0XHRyZXR1cm4gWyAnLicsICcgJyBdOyAvLyBmb3IgbG9jYWxlcyB3aXRoIHBlcmlvZHMgYm91bmQgdG8gdGhlIGVuZCBvZiBlYWNoIHllYXIvbW9udGgvZGF0ZVxuXHR9XG5cdGVsc2Uge1xuXHRcdHJldHVybiBbIHMgXTtcblx0fVxufVxuXG4vKlxuR2l2ZW4gY2h1bmtzIHBhcnNlZCBmcm9tIGEgcmVhbCBmb3JtYXQgc3RyaW5nLCBnZW5lcmF0ZSBhIGZha2UgKGFrYSBcImludGVybWVkaWF0ZVwiKSBmb3JtYXQgc3RyaW5nIHdpdGggc3BlY2lhbCBjb250cm9sXG5jaGFyYWN0ZXJzIHRoYXQgd2lsbCBldmVudHVhbGx5IGJlIGdpdmVuIHRvIG1vbWVudCBmb3IgZm9ybWF0dGluZywgYW5kIHRoZW4gcG9zdC1wcm9jZXNzZWQuXG4qL1xuZnVuY3Rpb24gYnVpbGRGYWtlRm9ybWF0U3RyaW5nKGNodW5rcykge1xuXHR2YXIgcGFydHMgPSBbXTtcblx0dmFyIGksIGNodW5rO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcblx0XHRjaHVuayA9IGNodW5rc1tpXTtcblxuXHRcdGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRwYXJ0cy5wdXNoKCdbJyArIGNodW5rICsgJ10nKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY2h1bmsudG9rZW4pIHtcblx0XHRcdGlmIChjaHVuay50b2tlbiBpbiBzcGVjaWFsVG9rZW5zKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goXG5cdFx0XHRcdFx0U1BFQ0lBTF9UT0tFTl9NQVJLRVIgKyAvLyB1c2VmdWwgZHVyaW5nIHBvc3QtcHJvY2Vzc2luZ1xuXHRcdFx0XHRcdCdbJyArIGNodW5rLnRva2VuICsgJ10nIC8vIHByZXNlcnZlIGFzIGxpdGVyYWwgdGV4dFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goY2h1bmsudG9rZW4pOyAvLyB1bnByb3RlY3RlZCB0ZXh0IGltcGxpZXMgYSBmb3JtYXQgc3RyaW5nXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGNodW5rLm1heWJlKSB7XG5cdFx0XHRwYXJ0cy5wdXNoKFxuXHRcdFx0XHRNQVlCRV9NQVJLRVIgKyAvLyB1c2VmdWwgZHVyaW5nIHBvc3QtcHJvY2Vzc2luZ1xuXHRcdFx0XHRidWlsZEZha2VGb3JtYXRTdHJpbmcoY2h1bmsubWF5YmUpICtcblx0XHRcdFx0TUFZQkVfTUFSS0VSXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwYXJ0cy5qb2luKFBBUlRfU0VQQVJBVE9SKTtcbn1cblxuLypcbkdpdmVuIHBhcnNlZCBjaHVua3MgZnJvbSBhIHJlYWwgZm9ybWF0dGluZyBzdHJpbmcsIGdlbmVyYXRlcyBhbiBhcnJheSBvZiB1bml0IHN0cmluZ3MgKGxpa2UgXCJkYXlcIikgdGhhdCBpbmRpY2F0ZVxuaW4gd2hpY2ggcmVnYXJkIHR3byBkYXRlcyBtdXN0IGJlIHNpbWlsYXIgaW4gb3JkZXIgdG8gc2hhcmUgcmFuZ2UgZm9ybWF0dGluZyB0ZXh0LlxuVGhlIGBjaHVua3NgIGNhbiBiZSBuZXN0ZWQgKGJlY2F1c2Ugb2YgXCJtYXliZVwiIGNodW5rcyksIGhvd2V2ZXIsIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGJlIGZsYXQuXG4qL1xuZnVuY3Rpb24gYnVpbGRTYW1lVW5pdHMoY2h1bmtzKSB7XG5cdHZhciB1bml0cyA9IFtdO1xuXHR2YXIgaSwgY2h1bms7XG5cdHZhciB0b2tlbkluZm87XG5cblx0Zm9yIChpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuXHRcdGNodW5rID0gY2h1bmtzW2ldO1xuXG5cdFx0aWYgKGNodW5rLnRva2VuKSB7XG5cdFx0XHR0b2tlbkluZm8gPSBsYXJnZVRva2VuTWFwW2NodW5rLnRva2VuLmNoYXJBdCgwKV07XG5cdFx0XHR1bml0cy5wdXNoKHRva2VuSW5mbyA/IHRva2VuSW5mby51bml0IDogJ3NlY29uZCcpOyAvLyBkZWZhdWx0IHRvIGEgdmVyeSBzdHJpY3Qgc2FtZS1zZWNvbmRcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY2h1bmsubWF5YmUpIHtcblx0XHRcdHVuaXRzLnB1c2guYXBwbHkodW5pdHMsIC8vIGFwcGVuZFxuXHRcdFx0XHRidWlsZFNhbWVVbml0cyhjaHVuay5tYXliZSlcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dW5pdHMucHVzaChudWxsKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdW5pdHM7XG59XG5cblxuLy8gUmVuZGVyaW5nIHRvIHRleHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuRm9ybWF0cyBhIGRhdGUgd2l0aCBhIGZha2UgZm9ybWF0IHN0cmluZywgcG9zdC1wcm9jZXNzZXMgdGhlIGNvbnRyb2wgY2hhcmFjdGVycywgdGhlbiByZXR1cm5zLlxuKi9cbmZ1bmN0aW9uIHJlbmRlckZha2VGb3JtYXRTdHJpbmcoZmFrZUZvcm1hdFN0cmluZywgZGF0ZSkge1xuXHRyZXR1cm4gcHJvY2Vzc01heWJlTWFya2Vycyhcblx0XHRyZW5kZXJGYWtlRm9ybWF0U3RyaW5nUGFydHMoZmFrZUZvcm1hdFN0cmluZywgZGF0ZSkuam9pbignJylcblx0KTtcbn1cblxuLypcbkZvcm1hdHMgYSBkYXRlIGludG8gcGFydHMgdGhhdCB3aWxsIGhhdmUgYmVlbiBwb3N0LXByb2Nlc3NlZCwgRVhDRVBUIGZvciB0aGUgXCJtYXliZVwiIG1hcmtlcnMuXG4qL1xuZnVuY3Rpb24gcmVuZGVyRmFrZUZvcm1hdFN0cmluZ1BhcnRzKGZha2VGb3JtYXRTdHJpbmcsIGRhdGUpIHtcblx0dmFyIHBhcnRzID0gW107XG5cdHZhciBmYWtlUmVuZGVyID0gb2xkTW9tZW50Rm9ybWF0KGRhdGUsIGZha2VGb3JtYXRTdHJpbmcpO1xuXHR2YXIgZmFrZVBhcnRzID0gZmFrZVJlbmRlci5zcGxpdChQQVJUX1NFUEFSQVRPUik7XG5cdHZhciBpLCBmYWtlUGFydDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgZmFrZVBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZmFrZVBhcnQgPSBmYWtlUGFydHNbaV07XG5cblx0XHRpZiAoZmFrZVBhcnQuY2hhckF0KDApID09PSBTUEVDSUFMX1RPS0VOX01BUktFUikge1xuXHRcdFx0cGFydHMucHVzaChcblx0XHRcdFx0Ly8gdGhlIGxpdGVyYWwgc3RyaW5nIElTIHRoZSB0b2tlbidzIG5hbWUuXG5cdFx0XHRcdC8vIGNhbGwgc3BlY2lhbCB0b2tlbidzIHJlZ2lzdGVyZWQgZnVuY3Rpb24uXG5cdFx0XHRcdHNwZWNpYWxUb2tlbnNbZmFrZVBhcnQuc3Vic3RyaW5nKDEpXShkYXRlKVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRwYXJ0cy5wdXNoKGZha2VQYXJ0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcGFydHM7XG59XG5cbi8qXG5BY2NlcHRzIGFuIGFsbW9zdC1maW5hbGx5LWZvcm1hdHRlZCBzdHJpbmcgYW5kIHByb2Nlc3NlcyB0aGUgXCJtYXliZVwiIGNvbnRyb2wgY2hhcmFjdGVycywgcmV0dXJuaW5nIGEgbmV3IHN0cmluZy5cbiovXG5mdW5jdGlvbiBwcm9jZXNzTWF5YmVNYXJrZXJzKHMpIHtcblx0cmV0dXJuIHMucmVwbGFjZShNQVlCRV9SRUdFWFAsIGZ1bmN0aW9uKG0wLCBtMSkgeyAvLyByZWdleCBhc3N1bWVkIHRvIGhhdmUgJ2cnIGZsYWdcblx0XHRpZiAobTEubWF0Y2goL1sxLTldLykpIHsgLy8gYW55IG5vbi16ZXJvIG51bWVyaWMgY2hhcmFjdGVycz9cblx0XHRcdHJldHVybiBtMTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHR9KTtcbn1cblxuXG4vLyBNaXNjIFV0aWxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG5SZXR1cm5zIGEgdW5pdCBzdHJpbmcsIGVpdGhlciAneWVhcicsICdtb250aCcsICdkYXknLCBvciBudWxsIGZvciB0aGUgbW9zdCBncmFudWxhciBmb3JtYXR0aW5nIHRva2VuIGluIHRoZSBzdHJpbmcuXG4qL1xuZnVuY3Rpb24gcXVlcnlNb3N0R3JhbnVsYXJGb3JtYXRVbml0KGZvcm1hdFN0cikge1xuXHR2YXIgY2h1bmtzID0gY2h1bmtGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKTtcblx0dmFyIGksIGNodW5rO1xuXHR2YXIgY2FuZGlkYXRlO1xuXHR2YXIgYmVzdDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2h1bmsgPSBjaHVua3NbaV07XG5cblx0XHRpZiAoY2h1bmsudG9rZW4pIHtcblx0XHRcdGNhbmRpZGF0ZSA9IGxhcmdlVG9rZW5NYXBbY2h1bmsudG9rZW4uY2hhckF0KDApXTtcblx0XHRcdGlmIChjYW5kaWRhdGUpIHtcblx0XHRcdFx0aWYgKCFiZXN0IHx8IGNhbmRpZGF0ZS52YWx1ZSA+IGJlc3QudmFsdWUpIHtcblx0XHRcdFx0XHRiZXN0ID0gY2FuZGlkYXRlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGJlc3QpIHtcblx0XHRyZXR1cm4gYmVzdC51bml0O1xuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59O1xuXG59KSgpO1xuXG4vLyBxdWljayBsb2NhbCByZWZlcmVuY2VzXG52YXIgZm9ybWF0RGF0ZSA9IEZDLmZvcm1hdERhdGU7XG52YXIgZm9ybWF0UmFuZ2UgPSBGQy5mb3JtYXRSYW5nZTtcbnZhciBvbGRNb21lbnRGb3JtYXQgPSBGQy5vbGRNb21lbnRGb3JtYXQ7XG5cbjs7XG5cbkZDLkNsYXNzID0gQ2xhc3M7IC8vIGV4cG9ydFxuXG4vLyBDbGFzcyB0aGF0IGFsbCBvdGhlciBjbGFzc2VzIHdpbGwgaW5oZXJpdCBmcm9tXG5mdW5jdGlvbiBDbGFzcygpIHsgfVxuXG5cbi8vIENhbGxlZCBvbiBhIGNsYXNzIHRvIGNyZWF0ZSBhIHN1YmNsYXNzLlxuLy8gTGFzdCBhcmd1bWVudCBjb250YWlucyBpbnN0YW5jZSBtZXRob2RzLiBBbnkgYXJndW1lbnQgYmVmb3JlIHRoZSBsYXN0IGFyZSBjb25zaWRlcmVkIG1peGlucy5cbkNsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblx0dmFyIGk7XG5cdHZhciBtZW1iZXJzO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdG1lbWJlcnMgPSBhcmd1bWVudHNbaV07XG5cdFx0aWYgKGkgPCBsZW4gLSAxKSB7IC8vIG5vdCB0aGUgbGFzdCBhcmd1bWVudD9cblx0XHRcdG1peEludG9DbGFzcyh0aGlzLCBtZW1iZXJzKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZXh0ZW5kQ2xhc3ModGhpcywgbWVtYmVycyB8fCB7fSk7IC8vIG1lbWJlcnMgd2lsbCBiZSB1bmRlZmluZWQgaWYgbm8gYXJndW1lbnRzXG59O1xuXG5cbi8vIEFkZHMgbmV3IG1lbWJlciB2YXJpYWJsZXMvbWV0aG9kcyB0byB0aGUgY2xhc3MncyBwcm90b3R5cGUuXG4vLyBDYW4gYmUgY2FsbGVkIHdpdGggYW5vdGhlciBjbGFzcywgb3IgYSBwbGFpbiBvYmplY3QgaGFzaCBjb250YWluaW5nIG5ldyBtZW1iZXJzLlxuQ2xhc3MubWl4aW4gPSBmdW5jdGlvbihtZW1iZXJzKSB7XG5cdG1peEludG9DbGFzcyh0aGlzLCBtZW1iZXJzKTtcbn07XG5cblxuZnVuY3Rpb24gZXh0ZW5kQ2xhc3Moc3VwZXJDbGFzcywgbWVtYmVycykge1xuXHR2YXIgc3ViQ2xhc3M7XG5cblx0Ly8gZW5zdXJlIGEgY29uc3RydWN0b3IgZm9yIHRoZSBzdWJjbGFzcywgZm9yd2FyZGluZyBhbGwgYXJndW1lbnRzIHRvIHRoZSBzdXBlci1jb25zdHJ1Y3RvciBpZiBpdCBkb2Vzbid0IGV4aXN0XG5cdGlmIChoYXNPd25Qcm9wKG1lbWJlcnMsICdjb25zdHJ1Y3RvcicpKSB7XG5cdFx0c3ViQ2xhc3MgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuXHR9XG5cdGlmICh0eXBlb2Ygc3ViQ2xhc3MgIT09ICdmdW5jdGlvbicpIHtcblx0XHRzdWJDbGFzcyA9IG1lbWJlcnMuY29uc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdHN1cGVyQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gYnVpbGQgdGhlIGJhc2UgcHJvdG90eXBlIGZvciB0aGUgc3ViY2xhc3MsIHdoaWNoIGlzIGFuIG5ldyBvYmplY3QgY2hhaW5lZCB0byB0aGUgc3VwZXJjbGFzcydzIHByb3RvdHlwZVxuXHRzdWJDbGFzcy5wcm90b3R5cGUgPSBjcmVhdGVPYmplY3Qoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuXG5cdC8vIGNvcHkgZWFjaCBtZW1iZXIgdmFyaWFibGUvbWV0aG9kIG9udG8gdGhlIHRoZSBzdWJjbGFzcydzIHByb3RvdHlwZVxuXHRjb3B5T3duUHJvcHMobWVtYmVycywgc3ViQ2xhc3MucHJvdG90eXBlKTtcblxuXHQvLyBjb3B5IG92ZXIgYWxsIGNsYXNzIHZhcmlhYmxlcy9tZXRob2RzIHRvIHRoZSBzdWJjbGFzcywgc3VjaCBhcyBgZXh0ZW5kYCBhbmQgYG1peGluYFxuXHRjb3B5T3duUHJvcHMoc3VwZXJDbGFzcywgc3ViQ2xhc3MpO1xuXG5cdHJldHVybiBzdWJDbGFzcztcbn1cblxuXG5mdW5jdGlvbiBtaXhJbnRvQ2xhc3ModGhlQ2xhc3MsIG1lbWJlcnMpIHtcblx0Y29weU93blByb3BzKG1lbWJlcnMsIHRoZUNsYXNzLnByb3RvdHlwZSk7XG59XG47O1xuXG52YXIgTW9kZWwgPSBDbGFzcy5leHRlbmQoRW1pdHRlck1peGluLCBMaXN0ZW5lck1peGluLCB7XG5cblx0X3Byb3BzOiBudWxsLFxuXHRfd2F0Y2hlcnM6IG51bGwsXG5cdF9nbG9iYWxXYXRjaEFyZ3M6IG51bGwsXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3dhdGNoZXJzID0ge307XG5cdFx0dGhpcy5fcHJvcHMgPSB7fTtcblx0XHR0aGlzLmFwcGx5R2xvYmFsV2F0Y2hlcnMoKTtcblx0fSxcblxuXHRhcHBseUdsb2JhbFdhdGNoZXJzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJnU2V0cyA9IHRoaXMuX2dsb2JhbFdhdGNoQXJncyB8fCBbXTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBhcmdTZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLndhdGNoLmFwcGx5KHRoaXMsIGFyZ1NldHNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRoYXM6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRyZXR1cm4gbmFtZSBpbiB0aGlzLl9wcm9wcztcblx0fSxcblxuXHRnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcHJvcHM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3Byb3BzW25hbWVdO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24obmFtZSwgdmFsKSB7XG5cdFx0dmFyIG5ld1Byb3BzO1xuXG5cdFx0aWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuXHRcdFx0bmV3UHJvcHMgPSB7fTtcblx0XHRcdG5ld1Byb3BzW25hbWVdID0gdmFsID09PSB1bmRlZmluZWQgPyBudWxsIDogdmFsO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG5ld1Byb3BzID0gbmFtZTtcblx0XHR9XG5cblx0XHR0aGlzLnNldFByb3BzKG5ld1Byb3BzKTtcblx0fSxcblxuXHRyZXNldDogZnVuY3Rpb24obmV3UHJvcHMpIHtcblx0XHR2YXIgb2xkUHJvcHMgPSB0aGlzLl9wcm9wcztcblx0XHR2YXIgY2hhbmdlc2V0ID0ge307IC8vIHdpbGwgaGF2ZSB1bmRlZmluZWQncyB0byBzaWduYWwgdW5zZXRzXG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKG5hbWUgaW4gb2xkUHJvcHMpIHtcblx0XHRcdGNoYW5nZXNldFtuYW1lXSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRmb3IgKG5hbWUgaW4gbmV3UHJvcHMpIHtcblx0XHRcdGNoYW5nZXNldFtuYW1lXSA9IG5ld1Byb3BzW25hbWVdO1xuXHRcdH1cblxuXHRcdHRoaXMuc2V0UHJvcHMoY2hhbmdlc2V0KTtcblx0fSxcblxuXHR1bnNldDogZnVuY3Rpb24obmFtZSkgeyAvLyBhY2NlcHRzIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3Ncblx0XHR2YXIgbmV3UHJvcHMgPSB7fTtcblx0XHR2YXIgbmFtZXM7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRuYW1lcyA9IFsgbmFtZSBdO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG5hbWVzID0gbmFtZTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG5ld1Byb3BzW25hbWVzW2ldXSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHR0aGlzLnNldFByb3BzKG5ld1Byb3BzKTtcblx0fSxcblxuXHRzZXRQcm9wczogZnVuY3Rpb24obmV3UHJvcHMpIHtcblx0XHR2YXIgY2hhbmdlZFByb3BzID0ge307XG5cdFx0dmFyIGNoYW5nZWRDbnQgPSAwO1xuXHRcdHZhciBuYW1lLCB2YWw7XG5cblx0XHRmb3IgKG5hbWUgaW4gbmV3UHJvcHMpIHtcblx0XHRcdHZhbCA9IG5ld1Byb3BzW25hbWVdO1xuXG5cdFx0XHQvLyBhIGNoYW5nZSBpbiB2YWx1ZT9cblx0XHRcdC8vIGlmIGFuIG9iamVjdCwgZG9uJ3QgY2hlY2sgZXF1YWxpdHksIGJlY2F1c2UgbWlnaHQgaGF2ZSBiZWVuIG11dGF0ZWQgaW50ZXJuYWxseS5cblx0XHRcdC8vIFRPRE86IGV2ZW50dWFsbHkgZW5mb3JjZSBpbW11dGFiaWxpdHkuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8XG5cdFx0XHRcdHZhbCAhPT0gdGhpcy5fcHJvcHNbbmFtZV1cblx0XHRcdCkge1xuXHRcdFx0XHRjaGFuZ2VkUHJvcHNbbmFtZV0gPSB2YWw7XG5cdFx0XHRcdGNoYW5nZWRDbnQrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY2hhbmdlZENudCkge1xuXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2JlZm9yZTpiYXRjaENoYW5nZScsIGNoYW5nZWRQcm9wcyk7XG5cblx0XHRcdGZvciAobmFtZSBpbiBjaGFuZ2VkUHJvcHMpIHtcblx0XHRcdFx0dmFsID0gY2hhbmdlZFByb3BzW25hbWVdO1xuXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignYmVmb3JlOmNoYW5nZScsIG5hbWUsIHZhbCk7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignYmVmb3JlOmNoYW5nZTonICsgbmFtZSwgdmFsKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChuYW1lIGluIGNoYW5nZWRQcm9wcykge1xuXHRcdFx0XHR2YWwgPSBjaGFuZ2VkUHJvcHNbbmFtZV07XG5cblx0XHRcdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3Byb3BzW25hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Byb3BzW25hbWVdID0gdmFsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2U6JyArIG5hbWUsIHZhbCk7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcignY2hhbmdlJywgbmFtZSwgdmFsKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy50cmlnZ2VyKCdiYXRjaENoYW5nZScsIGNoYW5nZWRQcm9wcyk7XG5cdFx0fVxuXHR9LFxuXG5cdHdhdGNoOiBmdW5jdGlvbihuYW1lLCBkZXBMaXN0LCBzdGFydEZ1bmMsIHN0b3BGdW5jKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHRoaXMudW53YXRjaChuYW1lKTtcblxuXHRcdHRoaXMuX3dhdGNoZXJzW25hbWVdID0gdGhpcy5fd2F0Y2hEZXBzKGRlcExpc3QsIGZ1bmN0aW9uKGRlcHMpIHtcblx0XHRcdHZhciByZXMgPSBzdGFydEZ1bmMuY2FsbChfdGhpcywgZGVwcyk7XG5cblx0XHRcdGlmIChyZXMgJiYgcmVzLnRoZW4pIHtcblx0XHRcdFx0X3RoaXMudW5zZXQobmFtZSk7IC8vIHB1dCBpbiBhbiB1bnNldCBzdGF0ZSB3aGlsZSByZXNvbHZpbmdcblx0XHRcdFx0cmVzLnRoZW4oZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRcdFx0X3RoaXMuc2V0KG5hbWUsIHZhbCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdF90aGlzLnNldChuYW1lLCByZXMpO1xuXHRcdFx0fVxuXHRcdH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0X3RoaXMudW5zZXQobmFtZSk7XG5cblx0XHRcdGlmIChzdG9wRnVuYykge1xuXHRcdFx0XHRzdG9wRnVuYy5jYWxsKF90aGlzKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHR1bndhdGNoOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyc1tuYW1lXTtcblxuXHRcdGlmICh3YXRjaGVyKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fd2F0Y2hlcnNbbmFtZV07XG5cdFx0XHR3YXRjaGVyLnRlYXJkb3duKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF93YXRjaERlcHM6IGZ1bmN0aW9uKGRlcExpc3QsIHN0YXJ0RnVuYywgc3RvcEZ1bmMpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBxdWV1ZWRDaGFuZ2VDbnQgPSAwO1xuXHRcdHZhciBkZXBDbnQgPSBkZXBMaXN0Lmxlbmd0aDtcblx0XHR2YXIgc2F0aXNmeUNudCA9IDA7XG5cdFx0dmFyIHZhbHVlcyA9IHt9OyAvLyB3aGF0J3MgcGFzc2VkIGFzIHRoZSBgZGVwc2AgYXJndW1lbnRzXG5cdFx0dmFyIGJpbmRUdXBsZXMgPSBbXTsgLy8gYXJyYXkgb2YgWyBldmVudE5hbWUsIGhhbmRsZXJGdW5jIF0gYXJyYXlzXG5cdFx0dmFyIGlzQ2FsbGluZ1N0b3AgPSBmYWxzZTtcblxuXHRcdGZ1bmN0aW9uIG9uQmVmb3JlRGVwQ2hhbmdlKGRlcE5hbWUsIHZhbCwgaXNPcHRpb25hbCkge1xuXHRcdFx0cXVldWVkQ2hhbmdlQ250Kys7XG5cdFx0XHRpZiAocXVldWVkQ2hhbmdlQ250ID09PSAxKSB7IC8vIGZpcnN0IGNoYW5nZSB0byBjYXVzZSBhIFwic3RvcFwiID9cblx0XHRcdFx0aWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkgeyAvLyBhbGwgZGVwcyBwcmV2aW91c2x5IHNhdGlzZmllZD9cblx0XHRcdFx0XHRpc0NhbGxpbmdTdG9wID0gdHJ1ZTtcblx0XHRcdFx0XHRzdG9wRnVuYygpO1xuXHRcdFx0XHRcdGlzQ2FsbGluZ1N0b3AgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uRGVwQ2hhbmdlKGRlcE5hbWUsIHZhbCwgaXNPcHRpb25hbCkge1xuXG5cdFx0XHRpZiAodmFsID09PSB1bmRlZmluZWQpIHsgLy8gdW5zZXR0aW5nIGEgdmFsdWU/XG5cblx0XHRcdFx0Ly8gcmVxdWlyZWQgZGVwZW5kZW5jeSB0aGF0IHdhcyBwcmV2aW91c2x5IHNldD9cblx0XHRcdFx0aWYgKCFpc09wdGlvbmFsICYmIHZhbHVlc1tkZXBOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0c2F0aXNmeUNudC0tO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIHZhbHVlc1tkZXBOYW1lXTtcblx0XHRcdH1cblx0XHRcdGVsc2UgeyAvLyBzZXR0aW5nIGEgdmFsdWU/XG5cblx0XHRcdFx0Ly8gcmVxdWlyZWQgZGVwZW5kZW5jeSB0aGF0IHdhcyBwcmV2aW91c2x5IHVuc2V0P1xuXHRcdFx0XHRpZiAoIWlzT3B0aW9uYWwgJiYgdmFsdWVzW2RlcE5hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzYXRpc2Z5Q250Kys7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YWx1ZXNbZGVwTmFtZV0gPSB2YWw7XG5cdFx0XHR9XG5cblx0XHRcdHF1ZXVlZENoYW5nZUNudC0tO1xuXHRcdFx0aWYgKCFxdWV1ZWRDaGFuZ2VDbnQpIHsgLy8gbGFzdCBjaGFuZ2UgdG8gY2F1c2UgYSBcInN0YXJ0XCI/XG5cblx0XHRcdFx0Ly8gbm93IGZpbmFsbHkgc2F0aXNmaWVkIG9yIHNhdGlzZmllZCBhbGwgYWxvbmc/XG5cdFx0XHRcdGlmIChzYXRpc2Z5Q250ID09PSBkZXBDbnQpIHtcblxuXHRcdFx0XHRcdC8vIGlmIHRoZSBzdG9wRnVuYyBpbml0aWF0ZWQgYW5vdGhlciB2YWx1ZSBjaGFuZ2UsIGlnbm9yZSBpdC5cblx0XHRcdFx0XHQvLyBpdCB3aWxsIGJlIHByb2Nlc3NlZCBieSBhbm90aGVyIGNoYW5nZSBldmVudCBhbnl3YXkuXG5cdFx0XHRcdFx0aWYgKCFpc0NhbGxpbmdTdG9wKSB7XG5cdFx0XHRcdFx0XHRzdGFydEZ1bmModmFsdWVzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBpbnRlcmNlcHQgZm9yIC5vbigpIHRoYXQgcmVtZW1iZXJzIGhhbmRsZXJzXG5cdFx0ZnVuY3Rpb24gYmluZChldmVudE5hbWUsIGhhbmRsZXIpIHtcblx0XHRcdF90aGlzLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XG5cdFx0XHRiaW5kVHVwbGVzLnB1c2goWyBldmVudE5hbWUsIGhhbmRsZXIgXSk7XG5cdFx0fVxuXG5cdFx0Ly8gbGlzdGVuIHRvIGRlcGVuZGVuY3kgY2hhbmdlc1xuXHRcdGRlcExpc3QuZm9yRWFjaChmdW5jdGlvbihkZXBOYW1lKSB7XG5cdFx0XHR2YXIgaXNPcHRpb25hbCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoZGVwTmFtZS5jaGFyQXQoMCkgPT09ICc/JykgeyAvLyBUT0RPOiBtb3JlIERSWVxuXHRcdFx0XHRkZXBOYW1lID0gZGVwTmFtZS5zdWJzdHJpbmcoMSk7XG5cdFx0XHRcdGlzT3B0aW9uYWwgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRiaW5kKCdiZWZvcmU6Y2hhbmdlOicgKyBkZXBOYW1lLCBmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0b25CZWZvcmVEZXBDaGFuZ2UoZGVwTmFtZSwgdmFsLCBpc09wdGlvbmFsKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRiaW5kKCdjaGFuZ2U6JyArIGRlcE5hbWUsIGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHRvbkRlcENoYW5nZShkZXBOYW1lLCB2YWwsIGlzT3B0aW9uYWwpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHQvLyBwcm9jZXNzIGN1cnJlbnQgZGVwZW5kZW5jeSB2YWx1ZXNcblx0XHRkZXBMaXN0LmZvckVhY2goZnVuY3Rpb24oZGVwTmFtZSkge1xuXHRcdFx0dmFyIGlzT3B0aW9uYWwgPSBmYWxzZTtcblxuXHRcdFx0aWYgKGRlcE5hbWUuY2hhckF0KDApID09PSAnPycpIHsgLy8gVE9ETzogbW9yZSBEUllcblx0XHRcdFx0ZGVwTmFtZSA9IGRlcE5hbWUuc3Vic3RyaW5nKDEpO1xuXHRcdFx0XHRpc09wdGlvbmFsID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKF90aGlzLmhhcyhkZXBOYW1lKSkge1xuXHRcdFx0XHR2YWx1ZXNbZGVwTmFtZV0gPSBfdGhpcy5nZXQoZGVwTmFtZSk7XG5cdFx0XHRcdHNhdGlzZnlDbnQrKztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGlzT3B0aW9uYWwpIHtcblx0XHRcdFx0c2F0aXNmeUNudCsrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gaW5pdGlhbGx5IHNhdGlzZmllZFxuXHRcdGlmIChzYXRpc2Z5Q250ID09PSBkZXBDbnQpIHtcblx0XHRcdHN0YXJ0RnVuYyh2YWx1ZXMpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiaW5kVHVwbGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0X3RoaXMub2ZmKGJpbmRUdXBsZXNbaV1bMF0sIGJpbmRUdXBsZXNbaV1bMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJpbmRUdXBsZXMgPSBudWxsO1xuXG5cdFx0XHRcdC8vIHdhcyBzYXRpc2ZpZWQsIHNvIGNhbGwgc3RvcEZ1bmNcblx0XHRcdFx0aWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xuXHRcdFx0XHRcdHN0b3BGdW5jKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmbGFzaDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChzYXRpc2Z5Q250ID09PSBkZXBDbnQpIHtcblx0XHRcdFx0XHRzdG9wRnVuYygpO1xuXHRcdFx0XHRcdHN0YXJ0RnVuYyh2YWx1ZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSxcblxuXHRmbGFzaDogZnVuY3Rpb24obmFtZSkge1xuXHRcdHZhciB3YXRjaGVyID0gdGhpcy5fd2F0Y2hlcnNbbmFtZV07XG5cblx0XHRpZiAod2F0Y2hlcikge1xuXHRcdFx0d2F0Y2hlci5mbGFzaCgpO1xuXHRcdH1cblx0fVxuXG59KTtcblxuXG5Nb2RlbC53YXRjaCA9IGZ1bmN0aW9uKC8qIHNhbWUgYXJndW1lbnRzIGFzIHRoaXMud2F0Y2goKSAqLykge1xuXHR2YXIgcHJvdG8gPSB0aGlzLnByb3RvdHlwZTtcblxuXHRpZiAoIXByb3RvLl9nbG9iYWxXYXRjaEFyZ3MpIHtcblx0XHRwcm90by5fZ2xvYmFsV2F0Y2hBcmdzID0gW107XG5cdH1cblxuXHRwcm90by5fZ2xvYmFsV2F0Y2hBcmdzLnB1c2goYXJndW1lbnRzKTtcbn07XG5cblxuRkMuTW9kZWwgPSBNb2RlbDtcblxuXG47O1xuXG52YXIgUHJvbWlzZSA9IHtcblxuXHRjb25zdHJ1Y3Q6IGZ1bmN0aW9uKGV4ZWN1dG9yKSB7XG5cdFx0dmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuXHRcdHZhciBwcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZSgpO1xuXG5cdFx0aWYgKHR5cGVvZiBleGVjdXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0ZXhlY3V0b3IoXG5cdFx0XHRcdGZ1bmN0aW9uKHZhbCkgeyAvLyByZXNvbHZlXG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZSh2YWwpO1xuXHRcdFx0XHRcdGF0dGFjaEltbWVkaWF0ZWx5UmVzb2x2aW5nVGhlbihwcm9taXNlLCB2YWwpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbigpIHsgLy8gcmVqZWN0XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KCk7XG5cdFx0XHRcdFx0YXR0YWNoSW1tZWRpYXRlbHlSZWplY3RpbmdUaGVuKHByb21pc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwcm9taXNlO1xuXHR9LFxuXG5cdHJlc29sdmU6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKS5yZXNvbHZlKHZhbCk7XG5cdFx0dmFyIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XG5cblx0XHRhdHRhY2hJbW1lZGlhdGVseVJlc29sdmluZ1RoZW4ocHJvbWlzZSwgdmFsKTtcblxuXHRcdHJldHVybiBwcm9taXNlO1xuXHR9LFxuXG5cdHJlamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpLnJlamVjdCgpO1xuXHRcdHZhciBwcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZSgpO1xuXG5cdFx0YXR0YWNoSW1tZWRpYXRlbHlSZWplY3RpbmdUaGVuKHByb21pc2UpO1xuXG5cdFx0cmV0dXJuIHByb21pc2U7XG5cdH1cblxufTtcblxuXG5mdW5jdGlvbiBhdHRhY2hJbW1lZGlhdGVseVJlc29sdmluZ1RoZW4ocHJvbWlzZSwgdmFsKSB7XG5cdHByb21pc2UudGhlbiA9IGZ1bmN0aW9uKG9uUmVzb2x2ZSkge1xuXHRcdGlmICh0eXBlb2Ygb25SZXNvbHZlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvblJlc29sdmUodmFsKTtcblx0XHR9XG5cdFx0cmV0dXJuIHByb21pc2U7IC8vIGZvciBjaGFpbmluZ1xuXHR9O1xufVxuXG5cbmZ1bmN0aW9uIGF0dGFjaEltbWVkaWF0ZWx5UmVqZWN0aW5nVGhlbihwcm9taXNlKSB7XG5cdHByb21pc2UudGhlbiA9IGZ1bmN0aW9uKG9uUmVzb2x2ZSwgb25SZWplY3QpIHtcblx0XHRpZiAodHlwZW9mIG9uUmVqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvblJlamVjdCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcHJvbWlzZTsgLy8gZm9yIGNoYWluaW5nXG5cdH07XG59XG5cblxuRkMuUHJvbWlzZSA9IFByb21pc2U7XG5cbjs7XG5cbnZhciBUYXNrUXVldWUgPSBDbGFzcy5leHRlbmQoRW1pdHRlck1peGluLCB7XG5cblx0cTogbnVsbCxcblx0aXNQYXVzZWQ6IGZhbHNlLFxuXHRpc1J1bm5pbmc6IGZhbHNlLFxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucSA9IFtdO1xuXHR9LFxuXG5cblx0cXVldWU6IGZ1bmN0aW9uKC8qIHRhc2tGdW5jLCB0YXNrRnVuYy4uLiAqLykge1xuXHRcdHRoaXMucS5wdXNoLmFwcGx5KHRoaXMucSwgYXJndW1lbnRzKTsgLy8gYXBwZW5kXG5cdFx0dGhpcy50cnlTdGFydCgpO1xuXHR9LFxuXG5cblx0cGF1c2U6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuXHR9LFxuXG5cblx0cmVzdW1lOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy50cnlTdGFydCgpO1xuXHR9LFxuXG5cblx0dHJ5U3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc1J1bm5pbmcgJiYgdGhpcy5jYW5SdW5OZXh0KCkpIHtcblx0XHRcdHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMudHJpZ2dlcignc3RhcnQnKTtcblx0XHRcdHRoaXMucnVuTmV4dCgpO1xuXHRcdH1cblx0fSxcblxuXG5cdGNhblJ1bk5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5pc1BhdXNlZCAmJiB0aGlzLnEubGVuZ3RoO1xuXHR9LFxuXG5cblx0cnVuTmV4dDogZnVuY3Rpb24oKSB7IC8vIGRvZXMgbm90IGNoZWNrIGNhblJ1bk5leHRcblx0XHR0aGlzLnJ1blRhc2sodGhpcy5xLnNoaWZ0KCkpO1xuXHR9LFxuXG5cblx0cnVuVGFzazogZnVuY3Rpb24odGFzaykge1xuXHRcdHRoaXMucnVuVGFza0Z1bmModGFzayk7XG5cdH0sXG5cblxuXHRydW5UYXNrRnVuYzogZnVuY3Rpb24odGFza0Z1bmMpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciByZXMgPSB0YXNrRnVuYygpO1xuXG5cdFx0aWYgKHJlcyAmJiByZXMudGhlbikge1xuXHRcdFx0cmVzLnRoZW4oZG9uZSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZG9uZSgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRvbmUoKSB7XG5cdFx0XHRpZiAoX3RoaXMuY2FuUnVuTmV4dCgpKSB7XG5cdFx0XHRcdF90aGlzLnJ1bk5leHQoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRfdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcblx0XHRcdFx0X3RoaXMudHJpZ2dlcignc3RvcCcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG59KTtcblxuRkMuVGFza1F1ZXVlID0gVGFza1F1ZXVlO1xuXG47O1xuXG52YXIgUmVuZGVyUXVldWUgPSBUYXNrUXVldWUuZXh0ZW5kKHtcblxuXHR3YWl0c0J5TmFtZXNwYWNlOiBudWxsLFxuXHR3YWl0TmFtZXNwYWNlOiBudWxsLFxuXHR3YWl0SWQ6IG51bGwsXG5cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24od2FpdHNCeU5hbWVzcGFjZSkge1xuXHRcdFRhc2tRdWV1ZS5jYWxsKHRoaXMpOyAvLyBzdXBlci1jb25zdHJ1Y3RvclxuXG5cdFx0dGhpcy53YWl0c0J5TmFtZXNwYWNlID0gd2FpdHNCeU5hbWVzcGFjZSB8fCB7fTtcblx0fSxcblxuXG5cdHF1ZXVlOiBmdW5jdGlvbih0YXNrRnVuYywgbmFtZXNwYWNlLCB0eXBlKSB7XG5cdFx0dmFyIHRhc2sgPSB7XG5cdFx0XHRmdW5jOiB0YXNrRnVuYyxcblx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuXHRcdFx0dHlwZTogdHlwZVxuXHRcdH07XG5cdFx0dmFyIHdhaXRNcztcblxuXHRcdGlmIChuYW1lc3BhY2UpIHtcblx0XHRcdHdhaXRNcyA9IHRoaXMud2FpdHNCeU5hbWVzcGFjZVtuYW1lc3BhY2VdO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLndhaXROYW1lc3BhY2UpIHtcblx0XHRcdGlmIChuYW1lc3BhY2UgPT09IHRoaXMud2FpdE5hbWVzcGFjZSAmJiB3YWl0TXMgIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmRlbGF5V2FpdCh3YWl0TXMpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMuY2xlYXJXYWl0KCk7XG5cdFx0XHRcdHRoaXMudHJ5U3RhcnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5jb21wb3VuZFRhc2sodGFzaykpIHsgLy8gYXBwZW5kZWQgdG8gcXVldWU/XG5cblx0XHRcdGlmICghdGhpcy53YWl0TmFtZXNwYWNlICYmIHdhaXRNcyAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc3RhcnRXYWl0KG5hbWVzcGFjZSwgd2FpdE1zKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLnRyeVN0YXJ0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0c3RhcnRXYWl0OiBmdW5jdGlvbihuYW1lc3BhY2UsIHdhaXRNcykge1xuXHRcdHRoaXMud2FpdE5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHR0aGlzLnNwYXduV2FpdCh3YWl0TXMpO1xuXHR9LFxuXG5cblx0ZGVsYXlXYWl0OiBmdW5jdGlvbih3YWl0TXMpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy53YWl0SWQpO1xuXHRcdHRoaXMuc3Bhd25XYWl0KHdhaXRNcyk7XG5cdH0sXG5cblxuXHRzcGF3bldhaXQ6IGZ1bmN0aW9uKHdhaXRNcykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHR0aGlzLndhaXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRfdGhpcy53YWl0TmFtZXNwYWNlID0gbnVsbDtcblx0XHRcdF90aGlzLnRyeVN0YXJ0KCk7XG5cdFx0fSwgd2FpdE1zKTtcblx0fSxcblxuXG5cdGNsZWFyV2FpdDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMud2FpdE5hbWVzcGFjZSkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMud2FpdElkKTtcblx0XHRcdHRoaXMud2FpdElkID0gbnVsbDtcblx0XHRcdHRoaXMud2FpdE5hbWVzcGFjZSA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cblx0Y2FuUnVuTmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCFUYXNrUXVldWUucHJvdG90eXBlLmNhblJ1bk5leHQuYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIHdhaXRpbmcgZm9yIGEgY2VydGFpbiBuYW1lc3BhY2UgdG8gc3RvcCByZWNlaXZpbmcgdGFza3M/XG5cdFx0aWYgKHRoaXMud2FpdE5hbWVzcGFjZSkge1xuXG5cdFx0XHQvLyBpZiB0aGVyZSB3YXMgYSBkaWZmZXJlbnQgbmFtZXNwYWNlIHRhc2sgaW4gdGhlIG1lYW50aW1lLFxuXHRcdFx0Ly8gdGhhdCBmb3JjZXMgYWxsIHByZXZpb3VzbHktd2FpdGluZyB0YXNrcyB0byBzdWRkZW5seSBleGVjdXRlLlxuXHRcdFx0Ly8gVE9ETzogZmluZCBhIHdheSB0byBkbyB0aGlzIGluIGNvbnN0YW50IHRpbWUuXG5cdFx0XHRmb3IgKHZhciBxID0gdGhpcy5xLCBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHFbaV0ubmFtZXNwYWNlICE9PSB0aGlzLndhaXROYW1lc3BhY2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gYWxsb3cgZXhlY3V0aW9uXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cblx0cnVuVGFzazogZnVuY3Rpb24odGFzaykge1xuXHRcdHRoaXMucnVuVGFza0Z1bmModGFzay5mdW5jKTtcblx0fSxcblxuXG5cdGNvbXBvdW5kVGFzazogZnVuY3Rpb24obmV3VGFzaykge1xuXHRcdHZhciBxID0gdGhpcy5xO1xuXHRcdHZhciBzaG91bGRBcHBlbmQgPSB0cnVlO1xuXHRcdHZhciBpLCB0YXNrO1xuXG5cdFx0aWYgKG5ld1Rhc2submFtZXNwYWNlKSB7XG5cblx0XHRcdGlmIChuZXdUYXNrLnR5cGUgPT09ICdkZXN0cm95JyB8fCBuZXdUYXNrLnR5cGUgPT09ICdpbml0Jykge1xuXG5cdFx0XHRcdC8vIHJlbW92ZSBhbGwgYWRkL3JlbW92ZSBvcHMgd2l0aCBzYW1lIG5hbWVzcGFjZSwgcmVnYXJkbGVzcyBvZiBvcmRlclxuXHRcdFx0XHRmb3IgKGkgPSBxLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0dGFzayA9IHFbaV07XG5cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHR0YXNrLm5hbWVzcGFjZSA9PT0gbmV3VGFzay5uYW1lc3BhY2UgJiZcblx0XHRcdFx0XHRcdCh0YXNrLnR5cGUgPT09ICdhZGQnIHx8IHRhc2sudHlwZSA9PT0gJ3JlbW92ZScpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRxLnNwbGljZShpLCAxKTsgLy8gcmVtb3ZlIHRhc2tcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobmV3VGFzay50eXBlID09PSAnZGVzdHJveScpIHtcblx0XHRcdFx0XHQvLyBlYXQgYXdheSBmaW5hbCBpbml0L2Rlc3Ryb3kgb3BlcmF0aW9uXG5cdFx0XHRcdFx0aWYgKHEubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0YXNrID0gcVtxLmxlbmd0aCAtIDFdOyAvLyBsYXN0IHRhc2tcblxuXHRcdFx0XHRcdFx0aWYgKHRhc2submFtZXNwYWNlID09PSBuZXdUYXNrLm5hbWVzcGFjZSkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHRoZSBpbml0IGFuZCBvdXIgZGVzdHJveSBjYW5jZWwgZWFjaCBvdGhlciBvdXRcblx0XHRcdFx0XHRcdFx0aWYgKHRhc2sudHlwZSA9PT0gJ2luaXQnKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2hvdWxkQXBwZW5kID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0cS5wb3AoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvLyBwcmVmZXIgdG8gdXNlIHRoZSBkZXN0cm95IG9wZXJhdGlvbiB0aGF0J3MgYWxyZWFkeSBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYgKHRhc2sudHlwZSA9PT0gJ2Rlc3Ryb3knKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2hvdWxkQXBwZW5kID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAobmV3VGFzay50eXBlID09PSAnaW5pdCcpIHtcblx0XHRcdFx0XHQvLyBlYXQgYXdheSBmaW5hbCBpbml0IG9wZXJhdGlvblxuXHRcdFx0XHRcdGlmIChxLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dGFzayA9IHFbcS5sZW5ndGggLSAxXTsgLy8gbGFzdCB0YXNrXG5cblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0dGFzay5uYW1lc3BhY2UgPT09IG5ld1Rhc2submFtZXNwYWNlICYmXG5cdFx0XHRcdFx0XHRcdHRhc2sudHlwZSA9PT0gJ2luaXQnXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0Ly8gb3VyIGluaXQgb3BlcmF0aW9uIHRha2VzIHByZWNlZGVuY2Vcblx0XHRcdFx0XHRcdFx0cS5wb3AoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoc2hvdWxkQXBwZW5kKSB7XG5cdFx0XHRxLnB1c2gobmV3VGFzayk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNob3VsZEFwcGVuZDtcblx0fVxuXG59KTtcblxuRkMuUmVuZGVyUXVldWUgPSBSZW5kZXJRdWV1ZTtcblxuOztcblxudmFyIEVtaXR0ZXJNaXhpbiA9IEZDLkVtaXR0ZXJNaXhpbiA9IHtcblxuXHQvLyBqUXVlcnktaWZpY2F0aW9uIHZpYSAkKHRoaXMpIGFsbG93cyBhIG5vbi1ET00gb2JqZWN0IHRvIGhhdmVcblx0Ly8gdGhlIHNhbWUgZXZlbnQgaGFuZGxpbmcgY2FwYWJpbGl0aWVzIChpbmNsdWRpbmcgbmFtZXNwYWNlcykuXG5cblxuXHRvbjogZnVuY3Rpb24odHlwZXMsIGhhbmRsZXIpIHtcblx0XHQkKHRoaXMpLm9uKHR5cGVzLCB0aGlzLl9wcmVwYXJlSW50ZXJjZXB0KGhhbmRsZXIpKTtcblx0XHRyZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG5cdH0sXG5cblxuXHRvbmU6IGZ1bmN0aW9uKHR5cGVzLCBoYW5kbGVyKSB7XG5cdFx0JCh0aGlzKS5vbmUodHlwZXMsIHRoaXMuX3ByZXBhcmVJbnRlcmNlcHQoaGFuZGxlcikpO1xuXHRcdHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcblx0fSxcblxuXG5cdF9wcmVwYXJlSW50ZXJjZXB0OiBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdFx0Ly8gaGFuZGxlcnMgYXJlIGFsd2F5cyBjYWxsZWQgd2l0aCBhbiBcImV2ZW50XCIgb2JqZWN0IGFzIHRoZWlyIGZpcnN0IHBhcmFtLlxuXHRcdC8vIHNuZWFrIHRoZSBgdGhpc2AgY29udGV4dCBhbmQgYXJndW1lbnRzIGludG8gdGhlIGV4dHJhIHBhcmFtZXRlciBvYmplY3Rcblx0XHQvLyBhbmQgZm9yd2FyZCB0aGVtIG9uIHRvIHRoZSBvcmlnaW5hbCBoYW5kbGVyLlxuXHRcdHZhciBpbnRlcmNlcHQgPSBmdW5jdGlvbihldiwgZXh0cmEpIHtcblx0XHRcdHJldHVybiBoYW5kbGVyLmFwcGx5KFxuXHRcdFx0XHRleHRyYS5jb250ZXh0IHx8IHRoaXMsXG5cdFx0XHRcdGV4dHJhLmFyZ3MgfHwgW11cblx0XHRcdCk7XG5cdFx0fTtcblxuXHRcdC8vIG1pbWljayBqUXVlcnkncyBpbnRlcm5hbCBcInByb3h5XCIgc3lzdGVtIChyaXNreSwgSSBrbm93KVxuXHRcdC8vIGNhdXNpbmcgYWxsIGZ1bmN0aW9ucyB3aXRoIHRoZSBzYW1lIC5ndWlkIHRvIGFwcGVhciB0byBiZSB0aGUgc2FtZS5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iLzIuMi40L3NyYy9jb3JlLmpzI0w0NDhcblx0XHQvLyB0aGlzIGlzIG5lZWRlZCBmb3IgY2FsbGluZyAub2ZmIHdpdGggdGhlIG9yaWdpbmFsIG5vbi1pbnRlcmNlcHQgaGFuZGxlci5cblx0XHRpZiAoIWhhbmRsZXIuZ3VpZCkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0gJC5ndWlkKys7XG5cdFx0fVxuXHRcdGludGVyY2VwdC5ndWlkID0gaGFuZGxlci5ndWlkO1xuXG5cdFx0cmV0dXJuIGludGVyY2VwdDtcblx0fSxcblxuXG5cdG9mZjogZnVuY3Rpb24odHlwZXMsIGhhbmRsZXIpIHtcblx0XHQkKHRoaXMpLm9mZih0eXBlcywgaGFuZGxlcik7XG5cblx0XHRyZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG5cdH0sXG5cblxuXHR0cmlnZ2VyOiBmdW5jdGlvbih0eXBlcykge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gYXJndW1lbnRzIGFmdGVyIHRoZSBmaXJzdFxuXG5cdFx0Ly8gcGFzcyBpbiBcImV4dHJhXCIgaW5mbyB0byB0aGUgaW50ZXJjZXB0XG5cdFx0JCh0aGlzKS50cmlnZ2VySGFuZGxlcih0eXBlcywgeyBhcmdzOiBhcmdzIH0pO1xuXG5cdFx0cmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xuXHR9LFxuXG5cblx0dHJpZ2dlcldpdGg6IGZ1bmN0aW9uKHR5cGVzLCBjb250ZXh0LCBhcmdzKSB7XG5cblx0XHQvLyBgdHJpZ2dlckhhbmRsZXJgIGlzIGxlc3MgcmVsaWFudCBvbiB0aGUgRE9NIGNvbXBhcmVkIHRvIGB0cmlnZ2VyYC5cblx0XHQvLyBwYXNzIGluIFwiZXh0cmFcIiBpbmZvIHRvIHRoZSBpbnRlcmNlcHQuXG5cdFx0JCh0aGlzKS50cmlnZ2VySGFuZGxlcih0eXBlcywgeyBjb250ZXh0OiBjb250ZXh0LCBhcmdzOiBhcmdzIH0pO1xuXG5cdFx0cmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xuXHR9XG5cbn07XG5cbjs7XG5cbi8qXG5VdGlsaXR5IG1ldGhvZHMgZm9yIGVhc2lseSBsaXN0ZW5pbmcgdG8gZXZlbnRzIG9uIGFub3RoZXIgb2JqZWN0LFxuYW5kIG1vcmUgaW1wb3J0YW50bHksIGVhc2lseSB1bmxpc3RlbmluZyBmcm9tIHRoZW0uXG4qL1xudmFyIExpc3RlbmVyTWl4aW4gPSBGQy5MaXN0ZW5lck1peGluID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgZ3VpZCA9IDA7XG5cdHZhciBMaXN0ZW5lck1peGluID0ge1xuXG5cdFx0bGlzdGVuZXJJZDogbnVsbCxcblxuXHRcdC8qXG5cdFx0R2l2ZW4gYW4gYG90aGVyYCBvYmplY3QgdGhhdCBoYXMgb24vb2ZmIG1ldGhvZHMsIGJpbmQgdGhlIGdpdmVuIGBjYWxsYmFja2AgdG8gYW4gZXZlbnQgYnkgdGhlIGdpdmVuIG5hbWUuXG5cdFx0VGhlIGBjYWxsYmFja2Agd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIG9iamVjdCB0aGF0IC5saXN0ZW5UbyBpcyBiZWluZyBjYWxsZWQgb24uXG5cdFx0Q2FuIGJlIGNhbGxlZDpcblx0XHRcdC5saXN0ZW5UbyhvdGhlciwgZXZlbnROYW1lLCBjYWxsYmFjaylcblx0XHRPUlxuXHRcdFx0Lmxpc3RlblRvKG90aGVyLCB7XG5cdFx0XHRcdGV2ZW50TmFtZTE6IGNhbGxiYWNrMSxcblx0XHRcdFx0ZXZlbnROYW1lMjogY2FsbGJhY2syXG5cdFx0XHR9KVxuXHRcdCovXG5cdFx0bGlzdGVuVG86IGZ1bmN0aW9uKG90aGVyLCBhcmcsIGNhbGxiYWNrKSB7XG5cdFx0XHRpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHsgLy8gZ2l2ZW4gZGljdGlvbmFyeSBvZiBjYWxsYmFja3Ncblx0XHRcdFx0Zm9yICh2YXIgZXZlbnROYW1lIGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChhcmcuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5saXN0ZW5UbyhvdGhlciwgZXZlbnROYW1lLCBhcmdbZXZlbnROYW1lXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRvdGhlci5vbihcblx0XHRcdFx0XHRhcmcgKyAnLicgKyB0aGlzLmdldExpc3RlbmVyTmFtZXNwYWNlKCksIC8vIHVzZSBldmVudCBuYW1lc3BhY2luZyB0byBpZGVudGlmeSB0aGlzIG9iamVjdFxuXHRcdFx0XHRcdCQucHJveHkoY2FsbGJhY2ssIHRoaXMpIC8vIGFsd2F5cyB1c2UgYHRoaXNgIGNvbnRleHRcblx0XHRcdFx0XHRcdC8vIHRoZSB1c3VhbGx5LXVuZGVzaXJlZCBqUXVlcnkgZ3VpZCBiZWhhdmlvciBkb2Vzbid0IG1hdHRlcixcblx0XHRcdFx0XHRcdC8vIGJlY2F1c2Ugd2UgYWx3YXlzIHVuYmluZCB2aWEgbmFtZXNwYWNlXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0Q2F1c2VzIHRoZSBjdXJyZW50IG9iamVjdCB0byBzdG9wIGxpc3RlbmluZyB0byBldmVudHMgb24gdGhlIGBvdGhlcmAgb2JqZWN0LlxuXHRcdGBldmVudE5hbWVgIGlzIG9wdGlvbmFsLiBJZiBvbWl0dGVkLCB3aWxsIHN0b3AgbGlzdGVuaW5nIHRvIEFMTCBldmVudHMgb24gYG90aGVyYC5cblx0XHQqL1xuXHRcdHN0b3BMaXN0ZW5pbmdUbzogZnVuY3Rpb24ob3RoZXIsIGV2ZW50TmFtZSkge1xuXHRcdFx0b3RoZXIub2ZmKChldmVudE5hbWUgfHwgJycpICsgJy4nICsgdGhpcy5nZXRMaXN0ZW5lck5hbWVzcGFjZSgpKTtcblx0XHR9LFxuXG5cdFx0Lypcblx0XHRSZXR1cm5zIGEgc3RyaW5nLCB1bmlxdWUgdG8gdGhpcyBvYmplY3QsIHRvIGJlIHVzZWQgZm9yIGV2ZW50IG5hbWVzcGFjaW5nXG5cdFx0Ki9cblx0XHRnZXRMaXN0ZW5lck5hbWVzcGFjZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5saXN0ZW5lcklkID09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5saXN0ZW5lcklkID0gZ3VpZCsrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICdfbGlzdGVuZXInICsgdGhpcy5saXN0ZW5lcklkO1xuXHRcdH1cblxuXHR9O1xuXHRyZXR1cm4gTGlzdGVuZXJNaXhpbjtcbn0pKCk7XG47O1xuXG4vKiBBIHJlY3Rhbmd1bGFyIHBhbmVsIHRoYXQgaXMgYWJzb2x1dGVseSBwb3NpdGlvbmVkIG92ZXIgb3RoZXIgY29udGVudFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5PcHRpb25zOlxuXHQtIGNsYXNzTmFtZSAoc3RyaW5nKVxuXHQtIGNvbnRlbnQgKEhUTUwgc3RyaW5nIG9yIGpRdWVyeSBlbGVtZW50IHNldClcblx0LSBwYXJlbnRFbFxuXHQtIHRvcFxuXHQtIGxlZnRcblx0LSByaWdodCAodGhlIHggY29vcmQgb2Ygd2hlcmUgdGhlIHJpZ2h0IGVkZ2Ugc2hvdWxkIGJlLiBub3QgYSBcIkNTU1wiIHJpZ2h0KVxuXHQtIGF1dG9IaWRlIChib29sZWFuKVxuXHQtIHNob3cgKGNhbGxiYWNrKVxuXHQtIGhpZGUgKGNhbGxiYWNrKVxuKi9cblxudmFyIFBvcG92ZXIgPSBDbGFzcy5leHRlbmQoTGlzdGVuZXJNaXhpbiwge1xuXG5cdGlzSGlkZGVuOiB0cnVlLFxuXHRvcHRpb25zOiBudWxsLFxuXHRlbDogbnVsbCwgLy8gdGhlIGNvbnRhaW5lciBlbGVtZW50IGZvciB0aGUgcG9wb3Zlci4gZ2VuZXJhdGVkIGJ5IHRoaXMgb2JqZWN0XG5cdG1hcmdpbjogMTAsIC8vIHRoZSBzcGFjZSByZXF1aXJlZCBiZXR3ZWVuIHRoZSBwb3BvdmVyIGFuZCB0aGUgZWRnZXMgb2YgdGhlIHNjcm9sbCBjb250YWluZXJcblxuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0fSxcblxuXG5cdC8vIFNob3dzIHRoZSBwb3BvdmVyIG9uIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uIFJlbmRlcnMgaXQgaWYgbm90IGFscmVhZHlcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaXNIaWRkZW4pIHtcblx0XHRcdGlmICghdGhpcy5lbCkge1xuXHRcdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5lbC5zaG93KCk7XG5cdFx0XHR0aGlzLnBvc2l0aW9uKCk7XG5cdFx0XHR0aGlzLmlzSGlkZGVuID0gZmFsc2U7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3Nob3cnKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBIaWRlcyB0aGUgcG9wb3ZlciwgdGhyb3VnaCBDU1MsIGJ1dCBkb2VzIG5vdCByZW1vdmUgaXQgZnJvbSB0aGUgRE9NXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc0hpZGRlbikge1xuXHRcdFx0dGhpcy5lbC5oaWRlKCk7XG5cdFx0XHR0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcblx0XHRcdHRoaXMudHJpZ2dlcignaGlkZScpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIENyZWF0ZXMgYHRoaXMuZWxgIGFuZCByZW5kZXJzIGNvbnRlbnQgaW5zaWRlIG9mIGl0XG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMuZWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtcG9wb3ZlclwiLz4nKVxuXHRcdFx0LmFkZENsYXNzKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKVxuXHRcdFx0LmNzcyh7XG5cdFx0XHRcdC8vIHBvc2l0aW9uIGluaXRpYWxseSB0byB0aGUgdG9wIGxlZnQgdG8gYXZvaWQgY3JlYXRpbmcgc2Nyb2xsYmFyc1xuXHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdGxlZnQ6IDBcblx0XHRcdH0pXG5cdFx0XHQuYXBwZW5kKG9wdGlvbnMuY29udGVudClcblx0XHRcdC5hcHBlbmRUbyhvcHRpb25zLnBhcmVudEVsKTtcblxuXHRcdC8vIHdoZW4gYSBjbGljayBoYXBwZW5zIG9uIGFueXRoaW5nIGluc2lkZSB3aXRoIGEgJ2ZjLWNsb3NlJyBjbGFzc05hbWUsIGhpZGUgdGhlIHBvcG92ZXJcblx0XHR0aGlzLmVsLm9uKCdjbGljaycsICcuZmMtY2xvc2UnLCBmdW5jdGlvbigpIHtcblx0XHRcdF90aGlzLmhpZGUoKTtcblx0XHR9KTtcblxuXHRcdGlmIChvcHRpb25zLmF1dG9IaWRlKSB7XG5cdFx0XHR0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCAnbW91c2Vkb3duJywgdGhpcy5kb2N1bWVudE1vdXNlZG93bik7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzICphbnl3aGVyZSogaW4gdGhlIGRvY3VtZW50LCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmVcblx0ZG9jdW1lbnRNb3VzZWRvd246IGZ1bmN0aW9uKGV2KSB7XG5cdFx0Ly8gb25seSBoaWRlIHRoZSBwb3BvdmVyIGlmIHRoZSBjbGljayBoYXBwZW5lZCBvdXRzaWRlIHRoZSBwb3BvdmVyXG5cdFx0aWYgKHRoaXMuZWwgJiYgISQoZXYudGFyZ2V0KS5jbG9zZXN0KHRoaXMuZWwpLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gSGlkZXMgYW5kIHVucmVnaXN0ZXJzIGFueSBoYW5kbGVyc1xuXHRyZW1vdmVFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhpZGUoKTtcblxuXHRcdGlmICh0aGlzLmVsKSB7XG5cdFx0XHR0aGlzLmVsLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5lbCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCksICdtb3VzZWRvd24nKTtcblx0fSxcblxuXG5cdC8vIFBvc2l0aW9ucyB0aGUgcG9wb3ZlciBvcHRpbWFsbHksIHVzaW5nIHRoZSB0b3AvbGVmdC9yaWdodCBvcHRpb25zXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHR2YXIgb3JpZ2luID0gdGhpcy5lbC5vZmZzZXRQYXJlbnQoKS5vZmZzZXQoKTtcblx0XHR2YXIgd2lkdGggPSB0aGlzLmVsLm91dGVyV2lkdGgoKTtcblx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5lbC5vdXRlckhlaWdodCgpO1xuXHRcdHZhciB3aW5kb3dFbCA9ICQod2luZG93KTtcblx0XHR2YXIgdmlld3BvcnRFbCA9IGdldFNjcm9sbFBhcmVudCh0aGlzLmVsKTtcblx0XHR2YXIgdmlld3BvcnRUb3A7XG5cdFx0dmFyIHZpZXdwb3J0TGVmdDtcblx0XHR2YXIgdmlld3BvcnRPZmZzZXQ7XG5cdFx0dmFyIHRvcDsgLy8gdGhlIFwicG9zaXRpb25cIiAobm90IFwib2Zmc2V0XCIpIHZhbHVlcyBmb3IgdGhlIHBvcG92ZXJcblx0XHR2YXIgbGVmdDsgLy9cblxuXHRcdC8vIGNvbXB1dGUgdG9wIGFuZCBsZWZ0XG5cdFx0dG9wID0gb3B0aW9ucy50b3AgfHwgMDtcblx0XHRpZiAob3B0aW9ucy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGxlZnQgPSBvcHRpb25zLmxlZnQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9wdGlvbnMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bGVmdCA9IG9wdGlvbnMucmlnaHQgLSB3aWR0aDsgLy8gZGVyaXZlIHRoZSBsZWZ0IHZhbHVlIGZyb20gdGhlIHJpZ2h0IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bGVmdCA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKHZpZXdwb3J0RWwuaXMod2luZG93KSB8fCB2aWV3cG9ydEVsLmlzKGRvY3VtZW50KSkgeyAvLyBub3JtYWxpemUgZ2V0U2Nyb2xsUGFyZW50J3MgcmVzdWx0XG5cdFx0XHR2aWV3cG9ydEVsID0gd2luZG93RWw7XG5cdFx0XHR2aWV3cG9ydFRvcCA9IDA7IC8vIHRoZSB3aW5kb3cgaXMgYWx3YXlzIGF0IHRoZSB0b3AgbGVmdFxuXHRcdFx0dmlld3BvcnRMZWZ0ID0gMDsgLy8gKGFuZCAub2Zmc2V0KCkgd29uJ3Qgd29yayBpZiBjYWxsZWQgaGVyZSlcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2aWV3cG9ydE9mZnNldCA9IHZpZXdwb3J0RWwub2Zmc2V0KCk7XG5cdFx0XHR2aWV3cG9ydFRvcCA9IHZpZXdwb3J0T2Zmc2V0LnRvcDtcblx0XHRcdHZpZXdwb3J0TGVmdCA9IHZpZXdwb3J0T2Zmc2V0LmxlZnQ7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlIHdpbmRvdyBpcyBzY3JvbGxlZCwgaXQgY2F1c2VzIHRoZSB2aXNpYmxlIGFyZWEgdG8gYmUgZnVydGhlciBkb3duXG5cdFx0dmlld3BvcnRUb3AgKz0gd2luZG93RWwuc2Nyb2xsVG9wKCk7XG5cdFx0dmlld3BvcnRMZWZ0ICs9IHdpbmRvd0VsLnNjcm9sbExlZnQoKTtcblxuXHRcdC8vIGNvbnN0cmFpbiB0byB0aGUgdmlldyBwb3J0LiBpZiBjb25zdHJhaW5lZCBieSB0d28gZWRnZXMsIGdpdmUgcHJlY2VkZW5jZSB0byB0b3AvbGVmdFxuXHRcdGlmIChvcHRpb25zLnZpZXdwb3J0Q29uc3RyYWluICE9PSBmYWxzZSkge1xuXHRcdFx0dG9wID0gTWF0aC5taW4odG9wLCB2aWV3cG9ydFRvcCArIHZpZXdwb3J0RWwub3V0ZXJIZWlnaHQoKSAtIGhlaWdodCAtIHRoaXMubWFyZ2luKTtcblx0XHRcdHRvcCA9IE1hdGgubWF4KHRvcCwgdmlld3BvcnRUb3AgKyB0aGlzLm1hcmdpbik7XG5cdFx0XHRsZWZ0ID0gTWF0aC5taW4obGVmdCwgdmlld3BvcnRMZWZ0ICsgdmlld3BvcnRFbC5vdXRlcldpZHRoKCkgLSB3aWR0aCAtIHRoaXMubWFyZ2luKTtcblx0XHRcdGxlZnQgPSBNYXRoLm1heChsZWZ0LCB2aWV3cG9ydExlZnQgKyB0aGlzLm1hcmdpbik7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbC5jc3Moe1xuXHRcdFx0dG9wOiB0b3AgLSBvcmlnaW4udG9wLFxuXHRcdFx0bGVmdDogbGVmdCAtIG9yaWdpbi5sZWZ0XG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvLyBUcmlnZ2VycyBhIGNhbGxiYWNrLiBDYWxscyBhIGZ1bmN0aW9uIGluIHRoZSBvcHRpb24gaGFzaCBvZiB0aGUgc2FtZSBuYW1lLlxuXHQvLyBBcmd1bWVudHMgYmV5b25kIHRoZSBmaXJzdCBgbmFtZWAgYXJlIGZvcndhcmRlZCBvbi5cblx0Ly8gVE9ETzogYmV0dGVyIGNvZGUgcmV1c2UgZm9yIHRoaXMuIFJlcGVhdCBjb2RlXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnNbbmFtZV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0fVxuXHR9XG5cbn0pO1xuXG47O1xuXG4vKlxuQSBjYWNoZSBmb3IgdGhlIGxlZnQvcmlnaHQvdG9wL2JvdHRvbS93aWR0aC9oZWlnaHQgdmFsdWVzIGZvciBvbmUgb3IgbW9yZSBlbGVtZW50cy5cbldvcmtzIHdpdGggYm90aCBvZmZzZXQgKGZyb20gdG9wbGVmdCBkb2N1bWVudCkgYW5kIHBvc2l0aW9uIChmcm9tIG9mZnNldFBhcmVudCkuXG5cbm9wdGlvbnM6XG4tIGVsc1xuLSBpc0hvcml6b250YWxcbi0gaXNWZXJ0aWNhbFxuKi9cbnZhciBDb29yZENhY2hlID0gRkMuQ29vcmRDYWNoZSA9IENsYXNzLmV4dGVuZCh7XG5cblx0ZWxzOiBudWxsLCAvLyBqUXVlcnkgc2V0IChhc3N1bWVkIHRvIGJlIHNpYmxpbmdzKVxuXHRmb3JjZWRPZmZzZXRQYXJlbnRFbDogbnVsbCwgLy8gb3B0aW9ucyBjYW4gb3ZlcnJpZGUgdGhlIG5hdHVyYWwgb2Zmc2V0UGFyZW50XG5cdG9yaWdpbjogbnVsbCwgLy8ge2xlZnQsdG9wfSBwb3NpdGlvbiBvZiBvZmZzZXRQYXJlbnQgb2YgZWxzXG5cdGJvdW5kaW5nUmVjdDogbnVsbCwgLy8gY29uc3RyYWluIGNvcmRpbmF0ZXMgdG8gdGhpcyByZWN0YW5nbGUuIHtsZWZ0LHJpZ2h0LHRvcCxib3R0b219IG9yIG51bGxcblx0aXNIb3Jpem9udGFsOiBmYWxzZSwgLy8gd2hldGhlciB0byBxdWVyeSBmb3IgbGVmdC9yaWdodC93aWR0aFxuXHRpc1ZlcnRpY2FsOiBmYWxzZSwgLy8gd2hldGhlciB0byBxdWVyeSBmb3IgdG9wL2JvdHRvbS9oZWlnaHRcblxuXHQvLyBhcnJheXMgb2YgY29vcmRpbmF0ZXMgKG9mZnNldHMgZnJvbSB0b3BsZWZ0IG9mIGRvY3VtZW50KVxuXHRsZWZ0czogbnVsbCxcblx0cmlnaHRzOiBudWxsLFxuXHR0b3BzOiBudWxsLFxuXHRib3R0b21zOiBudWxsLFxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR0aGlzLmVscyA9ICQob3B0aW9ucy5lbHMpO1xuXHRcdHRoaXMuaXNIb3Jpem9udGFsID0gb3B0aW9ucy5pc0hvcml6b250YWw7XG5cdFx0dGhpcy5pc1ZlcnRpY2FsID0gb3B0aW9ucy5pc1ZlcnRpY2FsO1xuXHRcdHRoaXMuZm9yY2VkT2Zmc2V0UGFyZW50RWwgPSBvcHRpb25zLm9mZnNldFBhcmVudCA/ICQob3B0aW9ucy5vZmZzZXRQYXJlbnQpIDogbnVsbDtcblx0fSxcblxuXG5cdC8vIFF1ZXJpZXMgdGhlIGVscyBmb3IgY29vcmRpbmF0ZXMgYW5kIHN0b3JlcyB0aGVtLlxuXHQvLyBDYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSB1c2luZyBhbmQgb2YgdGhlIGdldCogbWV0aG9kcyBiZWxvdy5cblx0YnVpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvZmZzZXRQYXJlbnRFbCA9IHRoaXMuZm9yY2VkT2Zmc2V0UGFyZW50RWw7XG5cdFx0aWYgKCFvZmZzZXRQYXJlbnRFbCAmJiB0aGlzLmVscy5sZW5ndGggPiAwKSB7XG5cdFx0XHRvZmZzZXRQYXJlbnRFbCA9IHRoaXMuZWxzLmVxKDApLm9mZnNldFBhcmVudCgpO1xuXHRcdH1cblxuXHRcdHRoaXMub3JpZ2luID0gb2Zmc2V0UGFyZW50RWwgP1xuXHRcdFx0b2Zmc2V0UGFyZW50RWwub2Zmc2V0KCkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdHRoaXMuYm91bmRpbmdSZWN0ID0gdGhpcy5xdWVyeUJvdW5kaW5nUmVjdCgpO1xuXG5cdFx0aWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XG5cdFx0XHR0aGlzLmJ1aWxkRWxIb3Jpem9udGFscygpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XG5cdFx0XHR0aGlzLmJ1aWxkRWxWZXJ0aWNhbHMoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBEZXN0cm95cyBhbGwgaW50ZXJuYWwgZGF0YSBhYm91dCBjb29yZGluYXRlcywgZnJlZWluZyBtZW1vcnlcblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMub3JpZ2luID0gbnVsbDtcblx0XHR0aGlzLmJvdW5kaW5nUmVjdCA9IG51bGw7XG5cdFx0dGhpcy5sZWZ0cyA9IG51bGw7XG5cdFx0dGhpcy5yaWdodHMgPSBudWxsO1xuXHRcdHRoaXMudG9wcyA9IG51bGw7XG5cdFx0dGhpcy5ib3R0b21zID0gbnVsbDtcblx0fSxcblxuXG5cdC8vIFdoZW4gY2FsbGVkLCBpZiBjb29yZCBjYWNoZXMgYXJlbid0IGJ1aWx0LCBidWlsZHMgdGhlbVxuXHRlbnN1cmVCdWlsdDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLm9yaWdpbikge1xuXHRcdFx0dGhpcy5idWlsZCgpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFBvcHVsYXRlcyB0aGUgbGVmdC9yaWdodCBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuXHRidWlsZEVsSG9yaXpvbnRhbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsZWZ0cyA9IFtdO1xuXHRcdHZhciByaWdodHMgPSBbXTtcblxuXHRcdHRoaXMuZWxzLmVhY2goZnVuY3Rpb24oaSwgbm9kZSkge1xuXHRcdFx0dmFyIGVsID0gJChub2RlKTtcblx0XHRcdHZhciBsZWZ0ID0gZWwub2Zmc2V0KCkubGVmdDtcblx0XHRcdHZhciB3aWR0aCA9IGVsLm91dGVyV2lkdGgoKTtcblxuXHRcdFx0bGVmdHMucHVzaChsZWZ0KTtcblx0XHRcdHJpZ2h0cy5wdXNoKGxlZnQgKyB3aWR0aCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLmxlZnRzID0gbGVmdHM7XG5cdFx0dGhpcy5yaWdodHMgPSByaWdodHM7XG5cdH0sXG5cblxuXHQvLyBQb3B1bGF0ZXMgdGhlIHRvcC9ib3R0b20gaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcblx0YnVpbGRFbFZlcnRpY2FsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRvcHMgPSBbXTtcblx0XHR2YXIgYm90dG9tcyA9IFtdO1xuXG5cdFx0dGhpcy5lbHMuZWFjaChmdW5jdGlvbihpLCBub2RlKSB7XG5cdFx0XHR2YXIgZWwgPSAkKG5vZGUpO1xuXHRcdFx0dmFyIHRvcCA9IGVsLm9mZnNldCgpLnRvcDtcblx0XHRcdHZhciBoZWlnaHQgPSBlbC5vdXRlckhlaWdodCgpO1xuXG5cdFx0XHR0b3BzLnB1c2godG9wKTtcblx0XHRcdGJvdHRvbXMucHVzaCh0b3AgKyBoZWlnaHQpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy50b3BzID0gdG9wcztcblx0XHR0aGlzLmJvdHRvbXMgPSBib3R0b21zO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdHMuXG5cdC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cblx0Z2V0SG9yaXpvbnRhbEluZGV4OiBmdW5jdGlvbihsZWZ0T2Zmc2V0KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXG5cdFx0dmFyIGxlZnRzID0gdGhpcy5sZWZ0cztcblx0XHR2YXIgcmlnaHRzID0gdGhpcy5yaWdodHM7XG5cdFx0dmFyIGxlbiA9IGxlZnRzLmxlbmd0aDtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGxlZnRPZmZzZXQgPj0gbGVmdHNbaV0gJiYgbGVmdE9mZnNldCA8IHJpZ2h0c1tpXSkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIHRvcCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgdG9wKSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgdmVydGljYWxseSBpbnRlcnNlY3RzLlxuXHQvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG5cdGdldFZlcnRpY2FsSW5kZXg6IGZ1bmN0aW9uKHRvcE9mZnNldCkge1xuXHRcdHRoaXMuZW5zdXJlQnVpbHQoKTtcblxuXHRcdHZhciB0b3BzID0gdGhpcy50b3BzO1xuXHRcdHZhciBib3R0b21zID0gdGhpcy5ib3R0b21zO1xuXHRcdHZhciBsZW4gPSB0b3BzLmxlbmd0aDtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKHRvcE9mZnNldCA+PSB0b3BzW2ldICYmIHRvcE9mZnNldCA8IGJvdHRvbXNbaV0pIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgbGVmdCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG5cdGdldExlZnRPZmZzZXQ6IGZ1bmN0aW9uKGxlZnRJbmRleCkge1xuXHRcdHRoaXMuZW5zdXJlQnVpbHQoKTtcblx0XHRyZXR1cm4gdGhpcy5sZWZ0c1tsZWZ0SW5kZXhdO1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgbGVmdCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG5cdGdldExlZnRQb3NpdGlvbjogZnVuY3Rpb24obGVmdEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLmxlZnRzW2xlZnRJbmRleF0gLSB0aGlzLm9yaWdpbi5sZWZ0O1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgcmlnaHQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleC5cblx0Ly8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50J3MgcmlnaHQgZWRnZSwgbGlrZSB0aGUgQ1NTIGNvbmNlcHQgb2YgXCJyaWdodFwiIHdvdWxkIGJlLlxuXHRnZXRSaWdodE9mZnNldDogZnVuY3Rpb24obGVmdEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdO1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgcmlnaHQgcG9zaXRpb24gKGZyb20gb2Zmc2V0UGFyZW50IGxlZnQpIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleC5cblx0Ly8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIG9mZnNldFBhcmVudCdzIHJpZ2h0IGVkZ2UsIGxpa2UgdGhlIENTUyBjb25jZXB0IG9mIFwicmlnaHRcIiB3b3VsZCBiZS5cblx0Z2V0UmlnaHRQb3NpdGlvbjogZnVuY3Rpb24obGVmdEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdIC0gdGhpcy5vcmlnaW4ubGVmdDtcblx0fSxcblxuXG5cdC8vIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuXHRnZXRXaWR0aDogZnVuY3Rpb24obGVmdEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdIC0gdGhpcy5sZWZ0c1tsZWZ0SW5kZXhdO1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuXHRnZXRUb3BPZmZzZXQ6IGZ1bmN0aW9uKHRvcEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLnRvcHNbdG9wSW5kZXhdO1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgdG9wIHBvc2l0aW9uIChmcm9tIG9mZnNldFBhcmVudCB0b3ApIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuXHRnZXRUb3BQb3NpdGlvbjogZnVuY3Rpb24odG9wSW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMudG9wc1t0b3BJbmRleF0gLSB0aGlzLm9yaWdpbi50b3A7XG5cdH0sXG5cblx0Ly8gR2V0cyB0aGUgYm90dG9tIG9mZnNldCAoZnJvbSB0aGUgZG9jdW1lbnQgdG9wKSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5cdC8vIFRoaXMgdmFsdWUgaXMgTk9UIHJlbGF0aXZlIHRvIHRoZSBvZmZzZXRQYXJlbnQncyBib3R0b20gZWRnZSwgbGlrZSB0aGUgQ1NTIGNvbmNlcHQgb2YgXCJib3R0b21cIiB3b3VsZCBiZS5cblx0Z2V0Qm90dG9tT2Zmc2V0OiBmdW5jdGlvbih0b3BJbmRleCkge1xuXHRcdHRoaXMuZW5zdXJlQnVpbHQoKTtcblx0XHRyZXR1cm4gdGhpcy5ib3R0b21zW3RvcEluZGV4XTtcblx0fSxcblxuXG5cdC8vIEdldHMgdGhlIGJvdHRvbSBwb3NpdGlvbiAoZnJvbSB0aGUgb2Zmc2V0UGFyZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgb2Zmc2V0UGFyZW50J3MgYm90dG9tIGVkZ2UsIGxpa2UgdGhlIENTUyBjb25jZXB0IG9mIFwiYm90dG9tXCIgd291bGQgYmUuXG5cdGdldEJvdHRvbVBvc2l0aW9uOiBmdW5jdGlvbih0b3BJbmRleCkge1xuXHRcdHRoaXMuZW5zdXJlQnVpbHQoKTtcblx0XHRyZXR1cm4gdGhpcy5ib3R0b21zW3RvcEluZGV4XSAtIHRoaXMub3JpZ2luLnRvcDtcblx0fSxcblxuXG5cdC8vIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0Z2V0SGVpZ2h0OiBmdW5jdGlvbih0b3BJbmRleCkge1xuXHRcdHRoaXMuZW5zdXJlQnVpbHQoKTtcblx0XHRyZXR1cm4gdGhpcy5ib3R0b21zW3RvcEluZGV4XSAtIHRoaXMudG9wc1t0b3BJbmRleF07XG5cdH0sXG5cblxuXHQvLyBCb3VuZGluZyBSZWN0XG5cdC8vIFRPRE86IGRlY291cGxlIHRoaXMgZnJvbSBDb29yZENhY2hlXG5cblx0Ly8gQ29tcHV0ZSBhbmQgcmV0dXJuIHdoYXQgdGhlIGVsZW1lbnRzJyBib3VuZGluZyByZWN0YW5nbGUgaXMsIGZyb20gdGhlIHVzZXIncyBwZXJzcGVjdGl2ZS5cblx0Ly8gUmlnaHQgbm93LCBvbmx5IHJldHVybnMgYSByZWN0YW5nbGUgaWYgY29uc3RyYWluZWQgYnkgYW4gb3ZlcmZsb3c6c2Nyb2xsIGVsZW1lbnQuXG5cdC8vIFJldHVybnMgbnVsbCBpZiB0aGVyZSBhcmUgbm8gZWxlbWVudHNcblx0cXVlcnlCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY3JvbGxQYXJlbnRFbDtcblxuXHRcdGlmICh0aGlzLmVscy5sZW5ndGggPiAwKSB7XG5cdFx0XHRzY3JvbGxQYXJlbnRFbCA9IGdldFNjcm9sbFBhcmVudCh0aGlzLmVscy5lcSgwKSk7XG5cblx0XHRcdGlmICghc2Nyb2xsUGFyZW50RWwuaXMoZG9jdW1lbnQpKSB7XG5cdFx0XHRcdHJldHVybiBnZXRDbGllbnRSZWN0KHNjcm9sbFBhcmVudEVsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRpc1BvaW50SW5Cb3VuZHM6IGZ1bmN0aW9uKGxlZnRPZmZzZXQsIHRvcE9mZnNldCkge1xuXHRcdHJldHVybiB0aGlzLmlzTGVmdEluQm91bmRzKGxlZnRPZmZzZXQpICYmIHRoaXMuaXNUb3BJbkJvdW5kcyh0b3BPZmZzZXQpO1xuXHR9LFxuXG5cdGlzTGVmdEluQm91bmRzOiBmdW5jdGlvbihsZWZ0T2Zmc2V0KSB7XG5cdFx0cmV0dXJuICF0aGlzLmJvdW5kaW5nUmVjdCB8fCAobGVmdE9mZnNldCA+PSB0aGlzLmJvdW5kaW5nUmVjdC5sZWZ0ICYmIGxlZnRPZmZzZXQgPCB0aGlzLmJvdW5kaW5nUmVjdC5yaWdodCk7XG5cdH0sXG5cblx0aXNUb3BJbkJvdW5kczogZnVuY3Rpb24odG9wT2Zmc2V0KSB7XG5cdFx0cmV0dXJuICF0aGlzLmJvdW5kaW5nUmVjdCB8fCAodG9wT2Zmc2V0ID49IHRoaXMuYm91bmRpbmdSZWN0LnRvcCAmJiB0b3BPZmZzZXQgPCB0aGlzLmJvdW5kaW5nUmVjdC5ib3R0b20pO1xuXHR9XG5cbn0pO1xuXG47O1xuXG4vKiBUcmFja3MgYSBkcmFnJ3MgbW91c2UgbW92ZW1lbnQsIGZpcmluZyB2YXJpb3VzIGhhbmRsZXJzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIFRPRE86IHVzZSBFbWl0dGVyXG5cbnZhciBEcmFnTGlzdGVuZXIgPSBGQy5EcmFnTGlzdGVuZXIgPSBDbGFzcy5leHRlbmQoTGlzdGVuZXJNaXhpbiwge1xuXG5cdG9wdGlvbnM6IG51bGwsXG5cdHN1YmplY3RFbDogbnVsbCxcblxuXHQvLyBjb29yZGluYXRlcyBvZiB0aGUgaW5pdGlhbCBtb3VzZWRvd25cblx0b3JpZ2luWDogbnVsbCxcblx0b3JpZ2luWTogbnVsbCxcblxuXHQvLyB0aGUgd3JhcHBpbmcgZWxlbWVudCB0aGF0IHNjcm9sbHMsIG9yIE1JR0hUIHNjcm9sbCBpZiB0aGVyZSdzIG92ZXJmbG93LlxuXHQvLyBUT0RPOiBkbyB0aGlzIGZvciB3cmFwcGVycyB0aGF0IGhhdmUgb3ZlcmZsb3c6aGlkZGVuIGFzIHdlbGwuXG5cdHNjcm9sbEVsOiBudWxsLFxuXG5cdGlzSW50ZXJhY3Rpbmc6IGZhbHNlLFxuXHRpc0Rpc3RhbmNlU3VycGFzc2VkOiBmYWxzZSxcblx0aXNEZWxheUVuZGVkOiBmYWxzZSxcblx0aXNEcmFnZ2luZzogZmFsc2UsXG5cdGlzVG91Y2g6IGZhbHNlLFxuXHRpc0dlbmVyaWM6IGZhbHNlLCAvLyBpbml0aWF0ZWQgYnkgJ2RyYWdzdGFydCcgKGpxdWkpXG5cblx0ZGVsYXk6IG51bGwsXG5cdGRlbGF5VGltZW91dElkOiBudWxsLFxuXHRtaW5EaXN0YW5jZTogbnVsbCxcblxuXHRzaG91bGRDYW5jZWxUb3VjaFNjcm9sbDogdHJ1ZSxcblx0c2Nyb2xsQWx3YXlzS2lsbHM6IGZhbHNlLFxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHR9LFxuXG5cblx0Ly8gSW50ZXJhY3Rpb24gKGhpZ2gtbGV2ZWwpXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRzdGFydEludGVyYWN0aW9uOiBmdW5jdGlvbihldiwgZXh0cmFPcHRpb25zKSB7XG5cblx0XHRpZiAoZXYudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcblx0XHRcdGlmIChHbG9iYWxFbWl0dGVyLmdldCgpLnNob3VsZElnbm9yZU1vdXNlKCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIWlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2KSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZXYucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudHMgbmF0aXZlIHNlbGVjdGlvbiBpbiBtb3N0IGJyb3dzZXJzXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzSW50ZXJhY3RpbmcpIHtcblxuXHRcdFx0Ly8gcHJvY2VzcyBvcHRpb25zXG5cdFx0XHRleHRyYU9wdGlvbnMgPSBleHRyYU9wdGlvbnMgfHwge307XG5cdFx0XHR0aGlzLmRlbGF5ID0gZmlyc3REZWZpbmVkKGV4dHJhT3B0aW9ucy5kZWxheSwgdGhpcy5vcHRpb25zLmRlbGF5LCAwKTtcblx0XHRcdHRoaXMubWluRGlzdGFuY2UgPSBmaXJzdERlZmluZWQoZXh0cmFPcHRpb25zLmRpc3RhbmNlLCB0aGlzLm9wdGlvbnMuZGlzdGFuY2UsIDApO1xuXHRcdFx0dGhpcy5zdWJqZWN0RWwgPSB0aGlzLm9wdGlvbnMuc3ViamVjdEVsO1xuXG5cdFx0XHRwcmV2ZW50U2VsZWN0aW9uKCQoJ2JvZHknKSk7XG5cblx0XHRcdHRoaXMuaXNJbnRlcmFjdGluZyA9IHRydWU7XG5cdFx0XHR0aGlzLmlzVG91Y2ggPSBnZXRFdklzVG91Y2goZXYpO1xuXHRcdFx0dGhpcy5pc0dlbmVyaWMgPSBldi50eXBlID09PSAnZHJhZ3N0YXJ0Jztcblx0XHRcdHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSBmYWxzZTtcblxuXHRcdFx0dGhpcy5vcmlnaW5YID0gZ2V0RXZYKGV2KTtcblx0XHRcdHRoaXMub3JpZ2luWSA9IGdldEV2WShldik7XG5cdFx0XHR0aGlzLnNjcm9sbEVsID0gZ2V0U2Nyb2xsUGFyZW50KCQoZXYudGFyZ2V0KSk7XG5cblx0XHRcdHRoaXMuYmluZEhhbmRsZXJzKCk7XG5cdFx0XHR0aGlzLmluaXRBdXRvU2Nyb2xsKCk7XG5cdFx0XHR0aGlzLmhhbmRsZUludGVyYWN0aW9uU3RhcnQoZXYpO1xuXHRcdFx0dGhpcy5zdGFydERlbGF5KGV2KTtcblxuXHRcdFx0aWYgKCF0aGlzLm1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdGhhbmRsZUludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy50cmlnZ2VyKCdpbnRlcmFjdGlvblN0YXJ0JywgZXYpO1xuXHR9LFxuXG5cblx0ZW5kSW50ZXJhY3Rpb246IGZ1bmN0aW9uKGV2LCBpc0NhbmNlbGxlZCkge1xuXHRcdGlmICh0aGlzLmlzSW50ZXJhY3RpbmcpIHtcblx0XHRcdHRoaXMuZW5kRHJhZyhldik7XG5cblx0XHRcdGlmICh0aGlzLmRlbGF5VGltZW91dElkKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZW91dElkKTtcblx0XHRcdFx0dGhpcy5kZWxheVRpbWVvdXRJZCA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZGVzdHJveUF1dG9TY3JvbGwoKTtcblx0XHRcdHRoaXMudW5iaW5kSGFuZGxlcnMoKTtcblxuXHRcdFx0dGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLmhhbmRsZUludGVyYWN0aW9uRW5kKGV2LCBpc0NhbmNlbGxlZCk7XG5cblx0XHRcdGFsbG93U2VsZWN0aW9uKCQoJ2JvZHknKSk7XG5cdFx0fVxuXHR9LFxuXG5cblx0aGFuZGxlSW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uKGV2LCBpc0NhbmNlbGxlZCkge1xuXHRcdHRoaXMudHJpZ2dlcignaW50ZXJhY3Rpb25FbmQnLCBldiwgaXNDYW5jZWxsZWQgfHwgZmFsc2UpO1xuXHR9LFxuXG5cblx0Ly8gQmluZGluZyBUbyBET01cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdGJpbmRIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc29tZSBicm93c2VycyAoU2FmYXJpIGluIGlPUyAxMCkgZG9uJ3QgYWxsb3cgcHJldmVudERlZmF1bHQgb24gdG91Y2ggZXZlbnRzIHRoYXQgYXJlIGJvdW5kIGFmdGVyIHRvdWNoc3RhcnQsXG5cdFx0Ly8gc28gbGlzdGVuIHRvIHRoZSBHbG9iYWxFbWl0dGVyIHNpbmdsZXRvbiwgd2hpY2ggaXMgYWx3YXlzIGJvdW5kLCBpbnN0ZWFkIG9mIHRoZSBkb2N1bWVudCBkaXJlY3RseS5cblx0XHR2YXIgZ2xvYmFsRW1pdHRlciA9IEdsb2JhbEVtaXR0ZXIuZ2V0KCk7XG5cblx0XHRpZiAodGhpcy5pc0dlbmVyaWMpIHtcblx0XHRcdHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksIHsgLy8gbWlnaHQgb25seSB3b3JrIG9uIGlPUyBiZWNhdXNlIG9mIEdsb2JhbEVtaXR0ZXIncyBiaW5kIDooXG5cdFx0XHRcdGRyYWc6IHRoaXMuaGFuZGxlTW92ZSxcblx0XHRcdFx0ZHJhZ3N0b3A6IHRoaXMuZW5kSW50ZXJhY3Rpb25cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLmlzVG91Y2gpIHtcblx0XHRcdHRoaXMubGlzdGVuVG8oZ2xvYmFsRW1pdHRlciwge1xuXHRcdFx0XHR0b3VjaG1vdmU6IHRoaXMuaGFuZGxlVG91Y2hNb3ZlLFxuXHRcdFx0XHR0b3VjaGVuZDogdGhpcy5lbmRJbnRlcmFjdGlvbixcblx0XHRcdFx0c2Nyb2xsOiB0aGlzLmhhbmRsZVRvdWNoU2Nyb2xsXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLmxpc3RlblRvKGdsb2JhbEVtaXR0ZXIsIHtcblx0XHRcdFx0bW91c2Vtb3ZlOiB0aGlzLmhhbmRsZU1vdXNlTW92ZSxcblx0XHRcdFx0bW91c2V1cDogdGhpcy5lbmRJbnRlcmFjdGlvblxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5saXN0ZW5UbyhnbG9iYWxFbWl0dGVyLCB7XG5cdFx0XHRzZWxlY3RzdGFydDogcHJldmVudERlZmF1bHQsIC8vIGRvbid0IGFsbG93IHNlbGVjdGlvbiB3aGlsZSBkcmFnZ2luZ1xuXHRcdFx0Y29udGV4dG1lbnU6IHByZXZlbnREZWZhdWx0IC8vIGxvbmcgdGFwcyB3b3VsZCBvcGVuIG1lbnUgb24gQ2hyb21lIGRldiB0b29sc1xuXHRcdH0pO1xuXHR9LFxuXG5cblx0dW5iaW5kSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RvcExpc3RlbmluZ1RvKEdsb2JhbEVtaXR0ZXIuZ2V0KCkpO1xuXHRcdHRoaXMuc3RvcExpc3RlbmluZ1RvKCQoZG9jdW1lbnQpKTsgLy8gZm9yIGlzR2VuZXJpY1xuXHR9LFxuXG5cblx0Ly8gRHJhZyAoaGlnaC1sZXZlbClcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdC8vIGV4dHJhT3B0aW9ucyBpZ25vcmVkIGlmIGRyYWcgYWxyZWFkeSBzdGFydGVkXG5cdHN0YXJ0RHJhZzogZnVuY3Rpb24oZXYsIGV4dHJhT3B0aW9ucykge1xuXHRcdHRoaXMuc3RhcnRJbnRlcmFjdGlvbihldiwgZXh0cmFPcHRpb25zKTsgLy8gZW5zdXJlIGludGVyYWN0aW9uIGJlZ2FuXG5cblx0XHRpZiAoIXRoaXMuaXNEcmFnZ2luZykge1xuXHRcdFx0dGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KGV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHRoYW5kbGVEcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy50cmlnZ2VyKCdkcmFnU3RhcnQnLCBldik7XG5cdH0sXG5cblxuXHRoYW5kbGVNb3ZlOiBmdW5jdGlvbihldikge1xuXHRcdHZhciBkeCA9IGdldEV2WChldikgLSB0aGlzLm9yaWdpblg7XG5cdFx0dmFyIGR5ID0gZ2V0RXZZKGV2KSAtIHRoaXMub3JpZ2luWTtcblx0XHR2YXIgbWluRGlzdGFuY2UgPSB0aGlzLm1pbkRpc3RhbmNlO1xuXHRcdHZhciBkaXN0YW5jZVNxOyAvLyBjdXJyZW50IGRpc3RhbmNlIGZyb20gdGhlIG9yaWdpbiwgc3F1YXJlZFxuXG5cdFx0aWYgKCF0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcblx0XHRcdGRpc3RhbmNlU3EgPSBkeCAqIGR4ICsgZHkgKiBkeTtcblx0XHRcdGlmIChkaXN0YW5jZVNxID49IG1pbkRpc3RhbmNlICogbWluRGlzdGFuY2UpIHsgLy8gdXNlIHB5dGhhZ29yZWFuIHRoZW9yZW1cblx0XHRcdFx0dGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaXNEcmFnZ2luZykge1xuXHRcdFx0dGhpcy5oYW5kbGVEcmFnKGR4LCBkeSwgZXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGlsZSB0aGUgbW91c2UgaXMgYmVpbmcgbW92ZWQgYW5kIHdoZW4gd2Uga25vdyBhIGxlZ2l0aW1hdGUgZHJhZyBpcyB0YWtpbmcgcGxhY2Vcblx0aGFuZGxlRHJhZzogZnVuY3Rpb24oZHgsIGR5LCBldikge1xuXHRcdHRoaXMudHJpZ2dlcignZHJhZycsIGR4LCBkeSwgZXYpO1xuXHRcdHRoaXMudXBkYXRlQXV0b1Njcm9sbChldik7IC8vIHdpbGwgcG9zc2libHkgY2F1c2Ugc2Nyb2xsaW5nXG5cdH0sXG5cblxuXHRlbmREcmFnOiBmdW5jdGlvbihldikge1xuXHRcdGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcblx0XHRcdHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5oYW5kbGVEcmFnRW5kKGV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHRoYW5kbGVEcmFnRW5kOiBmdW5jdGlvbihldikge1xuXHRcdHRoaXMudHJpZ2dlcignZHJhZ0VuZCcsIGV2KTtcblx0fSxcblxuXG5cdC8vIERlbGF5XG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRzdGFydERlbGF5OiBmdW5jdGlvbihpbml0aWFsRXYpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0aWYgKHRoaXMuZGVsYXkpIHtcblx0XHRcdHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfdGhpcy5oYW5kbGVEZWxheUVuZChpbml0aWFsRXYpO1xuXHRcdFx0fSwgdGhpcy5kZWxheSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5oYW5kbGVEZWxheUVuZChpbml0aWFsRXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdGhhbmRsZURlbGF5RW5kOiBmdW5jdGlvbihpbml0aWFsRXYpIHtcblx0XHR0aGlzLmlzRGVsYXlFbmRlZCA9IHRydWU7XG5cblx0XHRpZiAodGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XG5cdFx0XHR0aGlzLnN0YXJ0RHJhZyhpbml0aWFsRXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIERpc3RhbmNlXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRoYW5kbGVEaXN0YW5jZVN1cnBhc3NlZDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSB0cnVlO1xuXG5cdFx0aWYgKHRoaXMuaXNEZWxheUVuZGVkKSB7XG5cdFx0XHR0aGlzLnN0YXJ0RHJhZyhldik7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gTW91c2UgLyBUb3VjaFxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0aGFuZGxlVG91Y2hNb3ZlOiBmdW5jdGlvbihldikge1xuXG5cdFx0Ly8gcHJldmVudCBpbmVydGlhIGFuZCB0b3VjaG1vdmUtc2Nyb2xsaW5nIHdoaWxlIGRyYWdnaW5nXG5cdFx0aWYgKHRoaXMuaXNEcmFnZ2luZyAmJiB0aGlzLnNob3VsZENhbmNlbFRvdWNoU2Nyb2xsKSB7XG5cdFx0XHRldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuaGFuZGxlTW92ZShldik7XG5cdH0sXG5cblxuXHRoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy5oYW5kbGVNb3ZlKGV2KTtcblx0fSxcblxuXG5cdC8vIFNjcm9sbGluZyAodW5yZWxhdGVkIHRvIGF1dG8tc2Nyb2xsKVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0aGFuZGxlVG91Y2hTY3JvbGw6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0Ly8gaWYgdGhlIGRyYWcgaXMgYmVpbmcgaW5pdGlhdGVkIGJ5IHRvdWNoLCBidXQgYSBzY3JvbGwgaGFwcGVucyBiZWZvcmVcblx0XHQvLyB0aGUgZHJhZy1pbml0aWF0aW5nIGRlbGF5IGlzIG92ZXIsIGNhbmNlbCB0aGUgZHJhZ1xuXHRcdGlmICghdGhpcy5pc0RyYWdnaW5nIHx8IHRoaXMuc2Nyb2xsQWx3YXlzS2lsbHMpIHtcblx0XHRcdHRoaXMuZW5kSW50ZXJhY3Rpb24oZXYsIHRydWUpOyAvLyBpc0NhbmNlbGxlZD10cnVlXG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVXRpbHNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdC8vIFRyaWdnZXJzIGEgY2FsbGJhY2suIENhbGxzIGEgZnVuY3Rpb24gaW4gdGhlIG9wdGlvbiBoYXNoIG9mIHRoZSBzYW1lIG5hbWUuXG5cdC8vIEFyZ3VtZW50cyBiZXlvbmQgdGhlIGZpcnN0IGBuYW1lYCBhcmUgZm9yd2FyZGVkIG9uLlxuXHR0cmlnZ2VyOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xuXHRcdFx0dGhpcy5vcHRpb25zW25hbWVdLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuXHRcdH1cblx0XHQvLyBtYWtlcyBfbWV0aG9kcyBjYWxsYWJsZSBieSBldmVudCBuYW1lLiBUT0RPOiBraWxsIHRoaXNcblx0XHRpZiAodGhpc1snXycgKyBuYW1lXSkge1xuXHRcdFx0dGhpc1snXycgKyBuYW1lXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcblx0XHR9XG5cdH1cblxuXG59KTtcblxuOztcbi8qXG50aGlzLnNjcm9sbEVsIGlzIHNldCBpbiBEcmFnTGlzdGVuZXJcbiovXG5EcmFnTGlzdGVuZXIubWl4aW4oe1xuXG5cdGlzQXV0b1Njcm9sbDogZmFsc2UsXG5cblx0c2Nyb2xsQm91bmRzOiBudWxsLCAvLyB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9XG5cdHNjcm9sbFRvcFZlbDogbnVsbCwgLy8gcGl4ZWxzIHBlciBzZWNvbmRcblx0c2Nyb2xsTGVmdFZlbDogbnVsbCwgLy8gcGl4ZWxzIHBlciBzZWNvbmRcblx0c2Nyb2xsSW50ZXJ2YWxJZDogbnVsbCwgLy8gSUQgb2Ygc2V0VGltZW91dCBmb3Igc2Nyb2xsaW5nIGFuaW1hdGlvbiBsb29wXG5cblx0Ly8gZGVmYXVsdHNcblx0c2Nyb2xsU2Vuc2l0aXZpdHk6IDMwLCAvLyBwaXhlbHMgZnJvbSBlZGdlIGZvciBzY3JvbGxpbmcgdG8gc3RhcnRcblx0c2Nyb2xsU3BlZWQ6IDIwMCwgLy8gcGl4ZWxzIHBlciBzZWNvbmQsIGF0IG1heGltdW0gc3BlZWRcblx0c2Nyb2xsSW50ZXJ2YWxNczogNTAsIC8vIG1pbGxpc2Vjb25kIHdhaXQgYmV0d2VlbiBzY3JvbGwgaW5jcmVtZW50XG5cblxuXHRpbml0QXV0b1Njcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjcm9sbEVsID0gdGhpcy5zY3JvbGxFbDtcblxuXHRcdHRoaXMuaXNBdXRvU2Nyb2xsID1cblx0XHRcdHRoaXMub3B0aW9ucy5zY3JvbGwgJiZcblx0XHRcdHNjcm9sbEVsICYmXG5cdFx0XHQhc2Nyb2xsRWwuaXMod2luZG93KSAmJlxuXHRcdFx0IXNjcm9sbEVsLmlzKGRvY3VtZW50KTtcblxuXHRcdGlmICh0aGlzLmlzQXV0b1Njcm9sbCkge1xuXHRcdFx0Ly8gZGVib3VuY2UgbWFrZXMgc3VyZSByYXBpZCBjYWxscyBkb24ndCBoYXBwZW5cblx0XHRcdHRoaXMubGlzdGVuVG8oc2Nyb2xsRWwsICdzY3JvbGwnLCBkZWJvdW5jZSh0aGlzLmhhbmRsZURlYm91bmNlZFNjcm9sbCwgMTAwKSk7XG5cdFx0fVxuXHR9LFxuXG5cblx0ZGVzdHJveUF1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZW5kQXV0b1Njcm9sbCgpOyAvLyBraWxsIGFueSBhbmltYXRpb24gbG9vcFxuXG5cdFx0Ly8gcmVtb3ZlIHRoZSBzY3JvbGwgaGFuZGxlciBpZiB0aGVyZSBpcyBhIHNjcm9sbEVsXG5cdFx0aWYgKHRoaXMuaXNBdXRvU2Nyb2xsKSB7XG5cdFx0XHR0aGlzLnN0b3BMaXN0ZW5pbmdUbyh0aGlzLnNjcm9sbEVsLCAnc2Nyb2xsJyk7IC8vIHdpbGwgcHJvYmFibHkgZ2V0IHJlbW92ZWQgYnkgdW5iaW5kSGFuZGxlcnMgdG9vIDooXG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgYW5kIHN0b3JlcyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIG9mIHNjcm9sbEVsXG5cdGNvbXB1dGVTY3JvbGxCb3VuZHM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmlzQXV0b1Njcm9sbCkge1xuXHRcdFx0dGhpcy5zY3JvbGxCb3VuZHMgPSBnZXRPdXRlclJlY3QodGhpcy5zY3JvbGxFbCk7XG5cdFx0XHQvLyBUT0RPOiB1c2UgZ2V0Q2xpZW50UmVjdCBpbiBmdXR1cmUuIGJ1dCBwcmV2ZW50cyBhdXRvIHNjcm9sbGluZyB3aGVuIG9uIHRvcCBvZiBzY3JvbGxiYXJzXG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGRyYWdnaW5nIGlzIGluIHByb2dyZXNzIGFuZCBzY3JvbGxpbmcgc2hvdWxkIGJlIHVwZGF0ZWRcblx0dXBkYXRlQXV0b1Njcm9sbDogZnVuY3Rpb24oZXYpIHtcblx0XHR2YXIgc2Vuc2l0aXZpdHkgPSB0aGlzLnNjcm9sbFNlbnNpdGl2aXR5O1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLnNjcm9sbEJvdW5kcztcblx0XHR2YXIgdG9wQ2xvc2VuZXNzLCBib3R0b21DbG9zZW5lc3M7XG5cdFx0dmFyIGxlZnRDbG9zZW5lc3MsIHJpZ2h0Q2xvc2VuZXNzO1xuXHRcdHZhciB0b3BWZWwgPSAwO1xuXHRcdHZhciBsZWZ0VmVsID0gMDtcblxuXHRcdGlmIChib3VuZHMpIHsgLy8gb25seSBzY3JvbGwgaWYgc2Nyb2xsRWwgZXhpc3RzXG5cblx0XHRcdC8vIGNvbXB1dGUgY2xvc2VuZXNzIHRvIGVkZ2VzLiB2YWxpZCByYW5nZSBpcyBmcm9tIDAuMCAtIDEuMFxuXHRcdFx0dG9wQ2xvc2VuZXNzID0gKHNlbnNpdGl2aXR5IC0gKGdldEV2WShldikgLSBib3VuZHMudG9wKSkgLyBzZW5zaXRpdml0eTtcblx0XHRcdGJvdHRvbUNsb3NlbmVzcyA9IChzZW5zaXRpdml0eSAtIChib3VuZHMuYm90dG9tIC0gZ2V0RXZZKGV2KSkpIC8gc2Vuc2l0aXZpdHk7XG5cdFx0XHRsZWZ0Q2xvc2VuZXNzID0gKHNlbnNpdGl2aXR5IC0gKGdldEV2WChldikgLSBib3VuZHMubGVmdCkpIC8gc2Vuc2l0aXZpdHk7XG5cdFx0XHRyaWdodENsb3NlbmVzcyA9IChzZW5zaXRpdml0eSAtIChib3VuZHMucmlnaHQgLSBnZXRFdlgoZXYpKSkgLyBzZW5zaXRpdml0eTtcblxuXHRcdFx0Ly8gdHJhbnNsYXRlIHZlcnRpY2FsIGNsb3NlbmVzcyBpbnRvIHZlbG9jaXR5LlxuXHRcdFx0Ly8gbW91c2UgbXVzdCBiZSBjb21wbGV0ZWx5IGluIGJvdW5kcyBmb3IgdmVsb2NpdHkgdG8gaGFwcGVuLlxuXHRcdFx0aWYgKHRvcENsb3NlbmVzcyA+PSAwICYmIHRvcENsb3NlbmVzcyA8PSAxKSB7XG5cdFx0XHRcdHRvcFZlbCA9IHRvcENsb3NlbmVzcyAqIHRoaXMuc2Nyb2xsU3BlZWQgKiAtMTsgLy8gbmVnYXRpdmUuIGZvciBzY3JvbGxpbmcgdXBcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGJvdHRvbUNsb3NlbmVzcyA+PSAwICYmIGJvdHRvbUNsb3NlbmVzcyA8PSAxKSB7XG5cdFx0XHRcdHRvcFZlbCA9IGJvdHRvbUNsb3NlbmVzcyAqIHRoaXMuc2Nyb2xsU3BlZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRyYW5zbGF0ZSBob3Jpem9udGFsIGNsb3NlbmVzcyBpbnRvIHZlbG9jaXR5XG5cdFx0XHRpZiAobGVmdENsb3NlbmVzcyA+PSAwICYmIGxlZnRDbG9zZW5lc3MgPD0gMSkge1xuXHRcdFx0XHRsZWZ0VmVsID0gbGVmdENsb3NlbmVzcyAqIHRoaXMuc2Nyb2xsU3BlZWQgKiAtMTsgLy8gbmVnYXRpdmUuIGZvciBzY3JvbGxpbmcgbGVmdFxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAocmlnaHRDbG9zZW5lc3MgPj0gMCAmJiByaWdodENsb3NlbmVzcyA8PSAxKSB7XG5cdFx0XHRcdGxlZnRWZWwgPSByaWdodENsb3NlbmVzcyAqIHRoaXMuc2Nyb2xsU3BlZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRTY3JvbGxWZWwodG9wVmVsLCBsZWZ0VmVsKTtcblx0fSxcblxuXG5cdC8vIFNldHMgdGhlIHNwZWVkLW9mLXNjcm9sbGluZyBmb3IgdGhlIHNjcm9sbEVsXG5cdHNldFNjcm9sbFZlbDogZnVuY3Rpb24odG9wVmVsLCBsZWZ0VmVsKSB7XG5cblx0XHR0aGlzLnNjcm9sbFRvcFZlbCA9IHRvcFZlbDtcblx0XHR0aGlzLnNjcm9sbExlZnRWZWwgPSBsZWZ0VmVsO1xuXG5cdFx0dGhpcy5jb25zdHJhaW5TY3JvbGxWZWwoKTsgLy8gbWFzc2FnZXMgaW50byByZWFsaXN0aWMgdmFsdWVzXG5cblx0XHQvLyBpZiB0aGVyZSBpcyBub24temVybyB2ZWxvY2l0eSwgYW5kIGFuIGFuaW1hdGlvbiBsb29wIGhhc24ndCBhbHJlYWR5IHN0YXJ0ZWQsIHRoZW4gU1RBUlRcblx0XHRpZiAoKHRoaXMuc2Nyb2xsVG9wVmVsIHx8IHRoaXMuc2Nyb2xsTGVmdFZlbCkgJiYgIXRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCkge1xuXHRcdFx0dGhpcy5zY3JvbGxJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoXG5cdFx0XHRcdHByb3h5KHRoaXMsICdzY3JvbGxJbnRlcnZhbEZ1bmMnKSwgLy8gc2NvcGUgdG8gYHRoaXNgXG5cdFx0XHRcdHRoaXMuc2Nyb2xsSW50ZXJ2YWxNc1xuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBGb3JjZXMgc2Nyb2xsVG9wVmVsIGFuZCBzY3JvbGxMZWZ0VmVsIHRvIGJlIHplcm8gaWYgc2Nyb2xsaW5nIGhhcyBhbHJlYWR5IGdvbmUgYWxsIHRoZSB3YXlcblx0Y29uc3RyYWluU2Nyb2xsVmVsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWwgPSB0aGlzLnNjcm9sbEVsO1xuXG5cdFx0aWYgKHRoaXMuc2Nyb2xsVG9wVmVsIDwgMCkgeyAvLyBzY3JvbGxpbmcgdXA/XG5cdFx0XHRpZiAoZWwuc2Nyb2xsVG9wKCkgPD0gMCkgeyAvLyBhbHJlYWR5IHNjcm9sbGVkIGFsbCB0aGUgd2F5IHVwP1xuXHRcdFx0XHR0aGlzLnNjcm9sbFRvcFZlbCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuc2Nyb2xsVG9wVmVsID4gMCkgeyAvLyBzY3JvbGxpbmcgZG93bj9cblx0XHRcdGlmIChlbC5zY3JvbGxUb3AoKSArIGVsWzBdLmNsaWVudEhlaWdodCA+PSBlbFswXS5zY3JvbGxIZWlnaHQpIHsgLy8gYWxyZWFkeSBzY3JvbGxlZCBhbGwgdGhlIHdheSBkb3duP1xuXHRcdFx0XHR0aGlzLnNjcm9sbFRvcFZlbCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuc2Nyb2xsTGVmdFZlbCA8IDApIHsgLy8gc2Nyb2xsaW5nIGxlZnQ/XG5cdFx0XHRpZiAoZWwuc2Nyb2xsTGVmdCgpIDw9IDApIHsgLy8gYWxyZWFkeSBzY3JvbGxlZCBhbGwgdGhlIGxlZnQ/XG5cdFx0XHRcdHRoaXMuc2Nyb2xsTGVmdFZlbCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuc2Nyb2xsTGVmdFZlbCA+IDApIHsgLy8gc2Nyb2xsaW5nIHJpZ2h0P1xuXHRcdFx0aWYgKGVsLnNjcm9sbExlZnQoKSArIGVsWzBdLmNsaWVudFdpZHRoID49IGVsWzBdLnNjcm9sbFdpZHRoKSB7IC8vIGFscmVhZHkgc2Nyb2xsZWQgYWxsIHRoZSB3YXkgcmlnaHQ/XG5cdFx0XHRcdHRoaXMuc2Nyb2xsTGVmdFZlbCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBkdXJpbmcgZXZlcnkgaXRlcmF0aW9uIG9mIHRoZSBzY3JvbGxpbmcgYW5pbWF0aW9uIGxvb3Bcblx0c2Nyb2xsSW50ZXJ2YWxGdW5jOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWwgPSB0aGlzLnNjcm9sbEVsO1xuXHRcdHZhciBmcmFjID0gdGhpcy5zY3JvbGxJbnRlcnZhbE1zIC8gMTAwMDsgLy8gY29uc2lkZXJpbmcgYW5pbWF0aW9uIGZyZXF1ZW5jeSwgd2hhdCB0aGUgdmVsIHNob3VsZCBiZSBtdWx0J2QgYnlcblxuXHRcdC8vIGNoYW5nZSB0aGUgdmFsdWUgb2Ygc2Nyb2xsRWwncyBzY3JvbGxcblx0XHRpZiAodGhpcy5zY3JvbGxUb3BWZWwpIHtcblx0XHRcdGVsLnNjcm9sbFRvcChlbC5zY3JvbGxUb3AoKSArIHRoaXMuc2Nyb2xsVG9wVmVsICogZnJhYyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnNjcm9sbExlZnRWZWwpIHtcblx0XHRcdGVsLnNjcm9sbExlZnQoZWwuc2Nyb2xsTGVmdCgpICsgdGhpcy5zY3JvbGxMZWZ0VmVsICogZnJhYyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jb25zdHJhaW5TY3JvbGxWZWwoKTsgLy8gc2luY2UgdGhlIHNjcm9sbCB2YWx1ZXMgY2hhbmdlZCwgcmVjb21wdXRlIHRoZSB2ZWxvY2l0aWVzXG5cblx0XHQvLyBpZiBzY3JvbGxlZCBhbGwgdGhlIHdheSwgd2hpY2ggY2F1c2VzIHRoZSB2ZWxzIHRvIGJlIHplcm8sIHN0b3AgdGhlIGFuaW1hdGlvbiBsb29wXG5cdFx0aWYgKCF0aGlzLnNjcm9sbFRvcFZlbCAmJiAhdGhpcy5zY3JvbGxMZWZ0VmVsKSB7XG5cdFx0XHR0aGlzLmVuZEF1dG9TY3JvbGwoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBLaWxscyBhbnkgZXhpc3Rpbmcgc2Nyb2xsaW5nIGFuaW1hdGlvbiBsb29wXG5cdGVuZEF1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLnNjcm9sbEludGVydmFsSWQpIHtcblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy5zY3JvbGxJbnRlcnZhbElkKTtcblx0XHRcdHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCA9IG51bGw7XG5cblx0XHRcdHRoaXMuaGFuZGxlU2Nyb2xsRW5kKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2V0IGNhbGxlZCB3aGVuIHRoZSBzY3JvbGxFbCBpcyBzY3JvbGxlZCAoTk9URTogdGhpcyBpcyBkZWxheWVkIHZpYSBkZWJvdW5jZSlcblx0aGFuZGxlRGVib3VuY2VkU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHQvLyByZWNvbXB1dGUgYWxsIGNvb3JkaW5hdGVzLCBidXQgKm9ubHkqIGlmIHRoaXMgaXMgKm5vdCogcGFydCBvZiBvdXIgc2Nyb2xsaW5nIGFuaW1hdGlvblxuXHRcdGlmICghdGhpcy5zY3JvbGxJbnRlcnZhbElkKSB7XG5cdFx0XHR0aGlzLmhhbmRsZVNjcm9sbEVuZCgpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIHNjcm9sbGluZyBoYXMgc3RvcHBlZCwgd2hldGhlciB0aHJvdWdoIGF1dG8gc2Nyb2xsLCBvciB0aGUgdXNlciBzY3JvbGxpbmdcblx0aGFuZGxlU2Nyb2xsRW5kOiBmdW5jdGlvbigpIHtcblx0fVxuXG59KTtcbjs7XG5cbi8qIFRyYWNrcyBtb3VzZSBtb3ZlbWVudHMgb3ZlciBhIGNvbXBvbmVudCBhbmQgcmFpc2VzIGV2ZW50cyBhYm91dCB3aGljaCBoaXQgdGhlIG1vdXNlIGlzIG92ZXIuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm9wdGlvbnM6XG4tIHN1YmplY3RFbFxuLSBzdWJqZWN0Q2VudGVyXG4qL1xuXG52YXIgSGl0RHJhZ0xpc3RlbmVyID0gRHJhZ0xpc3RlbmVyLmV4dGVuZCh7XG5cblx0Y29tcG9uZW50OiBudWxsLCAvLyBjb252ZXJ0cyBjb29yZGluYXRlcyB0byBoaXRzXG5cdFx0Ly8gbWV0aG9kczogaGl0c05lZWRlZCwgaGl0c05vdE5lZWRlZCwgcXVlcnlIaXRcblxuXHRvcmlnSGl0OiBudWxsLCAvLyB0aGUgaGl0IHRoZSBtb3VzZSB3YXMgb3ZlciB3aGVuIGxpc3RlbmluZyBzdGFydGVkXG5cdGhpdDogbnVsbCwgLy8gdGhlIGhpdCB0aGUgbW91c2UgaXMgb3ZlclxuXHRjb29yZEFkanVzdDogbnVsbCwgLy8gZGVsdGEgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtb3VzZSBjb29yZGluYXRlcyB3aGVuIGNvbXB1dGluZyBjb2xsaXNpb25zXG5cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdFx0RHJhZ0xpc3RlbmVyLmNhbGwodGhpcywgb3B0aW9ucyk7IC8vIGNhbGwgdGhlIHN1cGVyLWNvbnN0cnVjdG9yXG5cblx0XHR0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIGRyYWcgbGlzdGVuaW5nIHN0YXJ0cyAoYnV0IGEgcmVhbCBkcmFnIGhhcyBub3QgbmVjZXNzYXJpbHkgYmVnYW4pLlxuXHQvLyBldiBtaWdodCBiZSB1bmRlZmluZWQgaWYgZHJhZ2dpbmcgd2FzIHN0YXJ0ZWQgbWFudWFsbHkuXG5cdGhhbmRsZUludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIHN1YmplY3RFbCA9IHRoaXMuc3ViamVjdEVsO1xuXHRcdHZhciBzdWJqZWN0UmVjdDtcblx0XHR2YXIgb3JpZ1BvaW50O1xuXHRcdHZhciBwb2ludDtcblxuXHRcdHRoaXMuY29tcG9uZW50LmhpdHNOZWVkZWQoKTtcblx0XHR0aGlzLmNvbXB1dGVTY3JvbGxCb3VuZHMoKTsgLy8gZm9yIGF1dG9zY3JvbGxcblxuXHRcdGlmIChldikge1xuXHRcdFx0b3JpZ1BvaW50ID0geyBsZWZ0OiBnZXRFdlgoZXYpLCB0b3A6IGdldEV2WShldikgfTtcblx0XHRcdHBvaW50ID0gb3JpZ1BvaW50O1xuXG5cdFx0XHQvLyBjb25zdHJhaW4gdGhlIHBvaW50IHRvIGJvdW5kcyBvZiB0aGUgZWxlbWVudCBiZWluZyBkcmFnZ2VkXG5cdFx0XHRpZiAoc3ViamVjdEVsKSB7XG5cdFx0XHRcdHN1YmplY3RSZWN0ID0gZ2V0T3V0ZXJSZWN0KHN1YmplY3RFbCk7IC8vIHVzZWQgZm9yIGNlbnRlcmluZyBhcyB3ZWxsXG5cdFx0XHRcdHBvaW50ID0gY29uc3RyYWluUG9pbnQocG9pbnQsIHN1YmplY3RSZWN0KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5vcmlnSGl0ID0gdGhpcy5xdWVyeUhpdChwb2ludC5sZWZ0LCBwb2ludC50b3ApO1xuXG5cdFx0XHQvLyB0cmVhdCB0aGUgY2VudGVyIG9mIHRoZSBzdWJqZWN0IGFzIHRoZSBjb2xsaXNpb24gcG9pbnQ/XG5cdFx0XHRpZiAoc3ViamVjdEVsICYmIHRoaXMub3B0aW9ucy5zdWJqZWN0Q2VudGVyKSB7XG5cblx0XHRcdFx0Ly8gb25seSBjb25zaWRlciB0aGUgYXJlYSB0aGUgc3ViamVjdCBvdmVybGFwcyB0aGUgaGl0LiBiZXN0IGZvciBsYXJnZSBzdWJqZWN0cy5cblx0XHRcdFx0Ly8gVE9ETzogc2tpcCB0aGlzIGlmIGhpdCBkaWRuJ3Qgc3VwcGx5IGxlZnQvcmlnaHQvdG9wL2JvdHRvbVxuXHRcdFx0XHRpZiAodGhpcy5vcmlnSGl0KSB7XG5cdFx0XHRcdFx0c3ViamVjdFJlY3QgPSBpbnRlcnNlY3RSZWN0cyh0aGlzLm9yaWdIaXQsIHN1YmplY3RSZWN0KSB8fFxuXHRcdFx0XHRcdFx0c3ViamVjdFJlY3Q7IC8vIGluIGNhc2UgdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwb2ludCA9IGdldFJlY3RDZW50ZXIoc3ViamVjdFJlY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNvb3JkQWRqdXN0ID0gZGlmZlBvaW50cyhwb2ludCwgb3JpZ1BvaW50KTsgLy8gcG9pbnQgLSBvcmlnUG9pbnRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLm9yaWdIaXQgPSBudWxsO1xuXHRcdFx0dGhpcy5jb29yZEFkanVzdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gY2FsbCB0aGUgc3VwZXItbWV0aG9kLiBkbyBpdCBhZnRlciBvcmlnSGl0IGhhcyBiZWVuIGNvbXB1dGVkXG5cdFx0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvblN0YXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgYWN0dWFsIGRyYWcgaGFzIHN0YXJ0ZWRcblx0aGFuZGxlRHJhZ1N0YXJ0OiBmdW5jdGlvbihldikge1xuXHRcdHZhciBoaXQ7XG5cblx0XHREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWdTdGFydC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2RcblxuXHRcdC8vIG1pZ2h0IGJlIGRpZmZlcmVudCBmcm9tIHRoaXMub3JpZ0hpdCBpZiB0aGUgbWluLWRpc3RhbmNlIGlzIGxhcmdlXG5cdFx0aGl0ID0gdGhpcy5xdWVyeUhpdChnZXRFdlgoZXYpLCBnZXRFdlkoZXYpKTtcblxuXHRcdC8vIHJlcG9ydCB0aGUgaW5pdGlhbCBoaXQgdGhlIG1vdXNlIGlzIG92ZXJcblx0XHQvLyBlc3BlY2lhbGx5IGltcG9ydGFudCBpZiBubyBtaW4tZGlzdGFuY2UgYW5kIGRyYWcgc3RhcnRzIGltbWVkaWF0ZWx5XG5cdFx0aWYgKGhpdCkge1xuXHRcdFx0dGhpcy5oYW5kbGVIaXRPdmVyKGhpdCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGRyYWcgbW92ZXNcblx0aGFuZGxlRHJhZzogZnVuY3Rpb24oZHgsIGR5LCBldikge1xuXHRcdHZhciBoaXQ7XG5cblx0XHREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gY2FsbCB0aGUgc3VwZXItbWV0aG9kXG5cblx0XHRoaXQgPSB0aGlzLnF1ZXJ5SGl0KGdldEV2WChldiksIGdldEV2WShldikpO1xuXG5cdFx0aWYgKCFpc0hpdHNFcXVhbChoaXQsIHRoaXMuaGl0KSkgeyAvLyBhIGRpZmZlcmVudCBoaXQgdGhhbiBiZWZvcmU/XG5cdFx0XHRpZiAodGhpcy5oaXQpIHtcblx0XHRcdFx0dGhpcy5oYW5kbGVIaXRPdXQoKTtcblx0XHRcdH1cblx0XHRcdGlmIChoaXQpIHtcblx0XHRcdFx0dGhpcy5oYW5kbGVIaXRPdmVyKGhpdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gZHJhZ2dpbmcgaGFzIGJlZW4gc3RvcHBlZFxuXHRoYW5kbGVEcmFnRW5kOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhhbmRsZUhpdERvbmUoKTtcblx0XHREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWdFbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gY2FsbCB0aGUgc3VwZXItbWV0aG9kXG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiBhIHRoZSBtb3VzZSBoYXMganVzdCBtb3ZlZCBvdmVyIGEgbmV3IGhpdFxuXHRoYW5kbGVIaXRPdmVyOiBmdW5jdGlvbihoaXQpIHtcblx0XHR2YXIgaXNPcmlnID0gaXNIaXRzRXF1YWwoaGl0LCB0aGlzLm9yaWdIaXQpO1xuXG5cdFx0dGhpcy5oaXQgPSBoaXQ7XG5cblx0XHR0aGlzLnRyaWdnZXIoJ2hpdE92ZXInLCB0aGlzLmhpdCwgaXNPcmlnLCB0aGlzLm9yaWdIaXQpO1xuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIG1vdXNlIGhhcyBqdXN0IG1vdmVkIG91dCBvZiBhIGhpdFxuXHRoYW5kbGVIaXRPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmhpdCkge1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdoaXRPdXQnLCB0aGlzLmhpdCk7XG5cdFx0XHR0aGlzLmhhbmRsZUhpdERvbmUoKTtcblx0XHRcdHRoaXMuaGl0ID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgYWZ0ZXIgYSBoaXRPdXQuIEFsc28gY2FsbGVkIGJlZm9yZSBhIGRyYWdTdG9wXG5cdGhhbmRsZUhpdERvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmhpdCkge1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdoaXREb25lJywgdGhpcy5oaXQpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBpbnRlcmFjdGlvbiBlbmRzLCB3aGV0aGVyIHRoZXJlIHdhcyBhIHJlYWwgZHJhZyBvciBub3Rcblx0aGFuZGxlSW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25FbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gY2FsbCB0aGUgc3VwZXItbWV0aG9kXG5cblx0XHR0aGlzLm9yaWdIaXQgPSBudWxsO1xuXHRcdHRoaXMuaGl0ID0gbnVsbDtcblxuXHRcdHRoaXMuY29tcG9uZW50LmhpdHNOb3ROZWVkZWQoKTtcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIHNjcm9sbGluZyBoYXMgc3RvcHBlZCwgd2hldGhlciB0aHJvdWdoIGF1dG8gc2Nyb2xsLCBvciB0aGUgdXNlciBzY3JvbGxpbmdcblx0aGFuZGxlU2Nyb2xsRW5kOiBmdW5jdGlvbigpIHtcblx0XHREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVNjcm9sbEVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2RcblxuXHRcdC8vIGhpdHMnIGFic29sdXRlIHBvc2l0aW9ucyB3aWxsIGJlIGluIG5ldyBwbGFjZXMgYWZ0ZXIgYSB1c2VyJ3Mgc2Nyb2xsLlxuXHRcdC8vIEhBQ0sgZm9yIHJlY29tcHV0aW5nLlxuXHRcdGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcblx0XHRcdHRoaXMuY29tcG9uZW50LnJlbGVhc2VIaXRzKCk7XG5cdFx0XHR0aGlzLmNvbXBvbmVudC5wcmVwYXJlSGl0cygpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEdldHMgdGhlIGhpdCB1bmRlcm5lYXRoIHRoZSBjb29yZGluYXRlcyBmb3IgdGhlIGdpdmVuIG1vdXNlIGV2ZW50XG5cdHF1ZXJ5SGl0OiBmdW5jdGlvbihsZWZ0LCB0b3ApIHtcblxuXHRcdGlmICh0aGlzLmNvb3JkQWRqdXN0KSB7XG5cdFx0XHRsZWZ0ICs9IHRoaXMuY29vcmRBZGp1c3QubGVmdDtcblx0XHRcdHRvcCArPSB0aGlzLmNvb3JkQWRqdXN0LnRvcDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5jb21wb25lbnQucXVlcnlIaXQobGVmdCwgdG9wKTtcblx0fVxuXG59KTtcblxuXG4vLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaGl0cyBhcmUgaWRlbnRpY2FsbHkgZXF1YWwuIGBmYWxzZWAgb3RoZXJ3aXNlLiBNdXN0IGJlIGZyb20gdGhlIHNhbWUgY29tcG9uZW50LlxuLy8gVHdvIG51bGwgdmFsdWVzIHdpbGwgYmUgY29uc2lkZXJlZCBlcXVhbCwgYXMgdHdvIFwib3V0IG9mIHRoZSBjb21wb25lbnRcIiBzdGF0ZXMgYXJlIHRoZSBzYW1lLlxuZnVuY3Rpb24gaXNIaXRzRXF1YWwoaGl0MCwgaGl0MSkge1xuXG5cdGlmICghaGl0MCAmJiAhaGl0MSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKGhpdDAgJiYgaGl0MSkge1xuXHRcdHJldHVybiBoaXQwLmNvbXBvbmVudCA9PT0gaGl0MS5jb21wb25lbnQgJiZcblx0XHRcdGlzSGl0UHJvcHNXaXRoaW4oaGl0MCwgaGl0MSkgJiZcblx0XHRcdGlzSGl0UHJvcHNXaXRoaW4oaGl0MSwgaGl0MCk7IC8vIGVuc3VyZXMgYWxsIHByb3BzIGFyZSBpZGVudGljYWxcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuXG4vLyBSZXR1cm5zIHRydWUgaWYgYWxsIG9mIHN1YkhpdCdzIG5vbi1zdGFuZGFyZCBwcm9wZXJ0aWVzIGFyZSB3aXRoaW4gc3VwZXJIaXRcbmZ1bmN0aW9uIGlzSGl0UHJvcHNXaXRoaW4oc3ViSGl0LCBzdXBlckhpdCkge1xuXHRmb3IgKHZhciBwcm9wTmFtZSBpbiBzdWJIaXQpIHtcblx0XHRpZiAoIS9eKGNvbXBvbmVudHxsZWZ0fHJpZ2h0fHRvcHxib3R0b20pJC8udGVzdChwcm9wTmFtZSkpIHtcblx0XHRcdGlmIChzdWJIaXRbcHJvcE5hbWVdICE9PSBzdXBlckhpdFtwcm9wTmFtZV0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuOztcblxuLypcbkxpc3RlbnMgdG8gZG9jdW1lbnQgYW5kIHdpbmRvdy1sZXZlbCB1c2VyLWludGVyYWN0aW9uIGV2ZW50cywgbGlrZSB0b3VjaCBldmVudHMgYW5kIG1vdXNlIGV2ZW50cyxcbmFuZCBmaXJlcyB0aGVzZSBldmVudHMgYXMtaXMgdG8gd2hvZXZlciBpcyBvYnNlcnZpbmcgYSBHbG9iYWxFbWl0dGVyLlxuQmVzdCB3aGVuIHVzZWQgYXMgYSBzaW5nbGV0b24gdmlhIEdsb2JhbEVtaXR0ZXIuZ2V0KClcblxuTm9ybWFsaXplcyBtb3VzZS90b3VjaCBldmVudHMuIEZvciBleGFtcGxlczpcbi0gaWdub3JlcyB0aGUgdGhlIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgdGhhdCBoYXBwZW4gYWZ0ZXIgYSBxdWljayB0YXA6IG1vdXNlbW92ZSttb3VzZWRvd24rbW91c2V1cCtjbGlja1xuLSBjb21wZW5zYXRlcyBmb3IgdmFyaW91cyBidWdneSBzY2VuYXJpb3Mgd2hlcmUgYSB0b3VjaGVuZCBkb2VzIG5vdCBmaXJlXG4qL1xuXG5GQy50b3VjaE1vdXNlSWdub3JlV2FpdCA9IDUwMDtcblxudmFyIEdsb2JhbEVtaXR0ZXIgPSBDbGFzcy5leHRlbmQoTGlzdGVuZXJNaXhpbiwgRW1pdHRlck1peGluLCB7XG5cblx0aXNUb3VjaGluZzogZmFsc2UsXG5cdG1vdXNlSWdub3JlRGVwdGg6IDAsXG5cdGhhbmRsZVNjcm9sbFByb3h5OiBudWxsLFxuXG5cblx0YmluZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksIHtcblx0XHRcdHRvdWNoc3RhcnQ6IHRoaXMuaGFuZGxlVG91Y2hTdGFydCxcblx0XHRcdHRvdWNoY2FuY2VsOiB0aGlzLmhhbmRsZVRvdWNoQ2FuY2VsLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuaGFuZGxlVG91Y2hFbmQsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuaGFuZGxlTW91c2VEb3duLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLmhhbmRsZU1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuaGFuZGxlTW91c2VVcCxcblx0XHRcdGNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLFxuXHRcdFx0c2VsZWN0c3RhcnQ6IHRoaXMuaGFuZGxlU2VsZWN0U3RhcnQsXG5cdFx0XHRjb250ZXh0bWVudTogdGhpcy5oYW5kbGVDb250ZXh0TWVudVxuXHRcdH0pO1xuXG5cdFx0Ly8gYmVjYXVzZSB3ZSBuZWVkIHRvIGNhbGwgcHJldmVudERlZmF1bHRcblx0XHQvLyBiZWNhdXNlIGh0dHBzOi8vd3d3LmNocm9tZXN0YXR1cy5jb20vZmVhdHVyZXMvNTA5MzU2NjAwNzIxNDA4MFxuXHRcdC8vIFRPRE86IGludmVzdGlnYXRlIHBlcmZvcm1hbmNlIGJlY2F1c2UgdGhpcyBpcyBhIGdsb2JhbCBoYW5kbGVyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG5cdFx0XHQndG91Y2htb3ZlJyxcblx0XHRcdHRoaXMuaGFuZGxlVG91Y2hNb3ZlUHJveHkgPSBmdW5jdGlvbihldikge1xuXHRcdFx0XHRfdGhpcy5oYW5kbGVUb3VjaE1vdmUoJC5FdmVudChldikpO1xuXHRcdFx0fSxcblx0XHRcdHsgcGFzc2l2ZTogZmFsc2UgfSAvLyBhbGxvd3MgcHJldmVudERlZmF1bHQoKVxuXHRcdCk7XG5cblx0XHQvLyBhdHRhY2ggYSBoYW5kbGVyIHRvIGdldCBjYWxsZWQgd2hlbiBBTlkgc2Nyb2xsIGFjdGlvbiBoYXBwZW5zIG9uIHRoZSBwYWdlLlxuXHRcdC8vIHRoaXMgd2FzIGltcG9zc2libGUgdG8gZG8gd2l0aCBub3JtYWwgb24vb2ZmIGJlY2F1c2UgJ3Njcm9sbCcgZG9lc24ndCBidWJibGUuXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI5NTQ1NjUvOTYzNDJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcblx0XHRcdCdzY3JvbGwnLFxuXHRcdFx0dGhpcy5oYW5kbGVTY3JvbGxQcm94eSA9IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdF90aGlzLmhhbmRsZVNjcm9sbCgkLkV2ZW50KGV2KSk7XG5cdFx0XHR9LFxuXHRcdFx0dHJ1ZSAvLyB1c2VDYXB0dXJlXG5cdFx0KTtcblx0fSxcblxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RvcExpc3RlbmluZ1RvKCQoZG9jdW1lbnQpKTtcblxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFxuXHRcdFx0J3RvdWNobW92ZScsXG5cdFx0XHR0aGlzLmhhbmRsZVRvdWNoTW92ZVByb3h5XG5cdFx0KTtcblxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFxuXHRcdFx0J3Njcm9sbCcsXG5cdFx0XHR0aGlzLmhhbmRsZVNjcm9sbFByb3h5LFxuXHRcdFx0dHJ1ZSAvLyB1c2VDYXB0dXJlXG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIFRvdWNoIEhhbmRsZXJzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0aGFuZGxlVG91Y2hTdGFydDogZnVuY3Rpb24oZXYpIHtcblxuXHRcdC8vIGlmIGEgcHJldmlvdXMgdG91Y2ggaW50ZXJhY3Rpb24gbmV2ZXIgZW5kZWQgd2l0aCBhIHRvdWNoZW5kLCB0aGVuIGltcGxpY2l0bHkgZW5kIGl0LFxuXHRcdC8vIGJ1dCBzaW5jZSBhIG5ldyB0b3VjaCBpbnRlcmFjdGlvbiBpcyBhYm91dCB0byBiZWdpbiwgZG9uJ3Qgc3RhcnQgdGhlIG1vdXNlIGlnbm9yZSBwZXJpb2QuXG5cdFx0dGhpcy5zdG9wVG91Y2goZXYsIHRydWUpOyAvLyBza2lwTW91c2VJZ25vcmU9dHJ1ZVxuXG5cdFx0dGhpcy5pc1RvdWNoaW5nID0gdHJ1ZTtcblx0XHR0aGlzLnRyaWdnZXIoJ3RvdWNoc3RhcnQnLCBldik7XG5cdH0sXG5cblx0aGFuZGxlVG91Y2hNb3ZlOiBmdW5jdGlvbihldikge1xuXHRcdGlmICh0aGlzLmlzVG91Y2hpbmcpIHtcblx0XHRcdHRoaXMudHJpZ2dlcigndG91Y2htb3ZlJywgZXYpO1xuXHRcdH1cblx0fSxcblxuXHRoYW5kbGVUb3VjaENhbmNlbDogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAodGhpcy5pc1RvdWNoaW5nKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3RvdWNoY2FuY2VsJywgZXYpO1xuXG5cdFx0XHQvLyBIYXZlIHRvdWNoY2FuY2VsIGZpcmUgYW4gYXJ0aWZpY2lhbCB0b3VjaGVuZC4gVGhhdCB3YXksIGhhbmRsZXJzIHdvbid0IG5lZWQgdG8gbGlzdGVuIHRvIGJvdGguXG5cdFx0XHQvLyBJZiB0b3VjaGVuZCBmaXJlcyBsYXRlciwgaXQgd29uJ3QgaGF2ZSBhbnkgZWZmZWN0IGIvYyBpc1RvdWNoaW5nIHdpbGwgYmUgZmFsc2UuXG5cdFx0XHR0aGlzLnN0b3BUb3VjaChldik7XG5cdFx0fVxuXHR9LFxuXG5cdGhhbmRsZVRvdWNoRW5kOiBmdW5jdGlvbihldikge1xuXHRcdHRoaXMuc3RvcFRvdWNoKGV2KTtcblx0fSxcblxuXG5cdC8vIE1vdXNlIEhhbmRsZXJzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0aGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihldikge1xuXHRcdGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ21vdXNlZG93bicsIGV2KTtcblx0XHR9XG5cdH0sXG5cblx0aGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihldikge1xuXHRcdGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ21vdXNlbW92ZScsIGV2KTtcblx0XHR9XG5cdH0sXG5cblx0aGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW91c2UoKSkge1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdtb3VzZXVwJywgZXYpO1xuXHRcdH1cblx0fSxcblxuXHRoYW5kbGVDbGljazogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW91c2UoKSkge1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdjbGljaycsIGV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBNaXNjIEhhbmRsZXJzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0aGFuZGxlU2VsZWN0U3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy50cmlnZ2VyKCdzZWxlY3RzdGFydCcsIGV2KTtcblx0fSxcblxuXHRoYW5kbGVDb250ZXh0TWVudTogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ2NvbnRleHRtZW51JywgZXYpO1xuXHR9LFxuXG5cdGhhbmRsZVNjcm9sbDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ3Njcm9sbCcsIGV2KTtcblx0fSxcblxuXG5cdC8vIFV0aWxzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0c3RvcFRvdWNoOiBmdW5jdGlvbihldiwgc2tpcE1vdXNlSWdub3JlKSB7XG5cdFx0aWYgKHRoaXMuaXNUb3VjaGluZykge1xuXHRcdFx0dGhpcy5pc1RvdWNoaW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3RvdWNoZW5kJywgZXYpO1xuXG5cdFx0XHRpZiAoIXNraXBNb3VzZUlnbm9yZSkge1xuXHRcdFx0XHR0aGlzLnN0YXJ0VG91Y2hNb3VzZUlnbm9yZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzdGFydFRvdWNoTW91c2VJZ25vcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHdhaXQgPSBGQy50b3VjaE1vdXNlSWdub3JlV2FpdDtcblxuXHRcdGlmICh3YWl0KSB7XG5cdFx0XHR0aGlzLm1vdXNlSWdub3JlRGVwdGgrKztcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF90aGlzLm1vdXNlSWdub3JlRGVwdGgtLTtcblx0XHRcdH0sIHdhaXQpO1xuXHRcdH1cblx0fSxcblxuXHRzaG91bGRJZ25vcmVNb3VzZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNUb3VjaGluZyB8fCBCb29sZWFuKHRoaXMubW91c2VJZ25vcmVEZXB0aCk7XG5cdH1cblxufSk7XG5cblxuLy8gU2luZ2xldG9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgZ2xvYmFsRW1pdHRlciA9IG51bGw7XG5cdHZhciBuZWVkZWRDb3VudCA9IDA7XG5cblxuXHQvLyBnZXRzIHRoZSBzaW5nbGV0b25cblx0R2xvYmFsRW1pdHRlci5nZXQgPSBmdW5jdGlvbigpIHtcblxuXHRcdGlmICghZ2xvYmFsRW1pdHRlcikge1xuXHRcdFx0Z2xvYmFsRW1pdHRlciA9IG5ldyBHbG9iYWxFbWl0dGVyKCk7XG5cdFx0XHRnbG9iYWxFbWl0dGVyLmJpbmQoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZ2xvYmFsRW1pdHRlcjtcblx0fTtcblxuXG5cdC8vIGNhbGxlZCB3aGVuIGFuIG9iamVjdCBrbm93cyBpdCB3aWxsIG5lZWQgYSBHbG9iYWxFbWl0dGVyIGluIHRoZSBuZWFyIGZ1dHVyZS5cblx0R2xvYmFsRW1pdHRlci5uZWVkZWQgPSBmdW5jdGlvbigpIHtcblx0XHRHbG9iYWxFbWl0dGVyLmdldCgpOyAvLyBlbnN1cmVzIGdsb2JhbEVtaXR0ZXJcblx0XHRuZWVkZWRDb3VudCsrO1xuXHR9O1xuXG5cblx0Ly8gY2FsbGVkIHdoZW4gdGhlIG9iamVjdCB0aGF0IG9yaWdpbmFsbHkgY2FsbGVkIG5lZWRlZCgpIGRvZXNuJ3QgbmVlZCBhIEdsb2JhbEVtaXR0ZXIgYW55bW9yZS5cblx0R2xvYmFsRW1pdHRlci51bm5lZWRlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdG5lZWRlZENvdW50LS07XG5cblx0XHRpZiAoIW5lZWRlZENvdW50KSB7IC8vIG5vYm9keSBlbHNlIG5lZWRzIGl0XG5cdFx0XHRnbG9iYWxFbWl0dGVyLnVuYmluZCgpO1xuXHRcdFx0Z2xvYmFsRW1pdHRlciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG59KSgpO1xuXG47O1xuXG4vKiBDcmVhdGVzIGEgY2xvbmUgb2YgYW4gZWxlbWVudCBhbmQgbGV0cyBpdCB0cmFjayB0aGUgbW91c2UgYXMgaXQgbW92ZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG52YXIgTW91c2VGb2xsb3dlciA9IENsYXNzLmV4dGVuZChMaXN0ZW5lck1peGluLCB7XG5cblx0b3B0aW9uczogbnVsbCxcblxuXHRzb3VyY2VFbDogbnVsbCwgLy8gdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIGNsb25lZCBhbmQgbWFkZSB0byBsb29rIGxpa2UgaXQgaXMgZHJhZ2dpbmdcblx0ZWw6IG51bGwsIC8vIHRoZSBjbG9uZSBvZiBgc291cmNlRWxgIHRoYXQgd2lsbCB0cmFjayB0aGUgbW91c2Vcblx0cGFyZW50RWw6IG51bGwsIC8vIHRoZSBlbGVtZW50IHRoYXQgYGVsYCAodGhlIGNsb25lKSB3aWxsIGJlIGF0dGFjaGVkIHRvXG5cblx0Ly8gdGhlIGluaXRpYWwgcG9zaXRpb24gb2YgZWwsIHJlbGF0aXZlIHRvIHRoZSBvZmZzZXQgcGFyZW50LiBtYWRlIHRvIG1hdGNoIHRoZSBpbml0aWFsIG9mZnNldCBvZiBzb3VyY2VFbFxuXHR0b3AwOiBudWxsLFxuXHRsZWZ0MDogbnVsbCxcblxuXHQvLyB0aGUgYWJzb2x1dGUgY29vcmRpbmF0ZXMgb2YgdGhlIGluaXRpYXRpbmcgdG91Y2gvbW91c2UgYWN0aW9uXG5cdHkwOiBudWxsLFxuXHR4MDogbnVsbCxcblxuXHQvLyB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGUgbW91c2UgaGFzIG1vdmVkIGZyb20gaXRzIGluaXRpYWwgcG9zaXRpb25cblx0dG9wRGVsdGE6IG51bGwsXG5cdGxlZnREZWx0YTogbnVsbCxcblxuXHRpc0ZvbGxvd2luZzogZmFsc2UsXG5cdGlzSGlkZGVuOiBmYWxzZSxcblx0aXNBbmltYXRpbmc6IGZhbHNlLCAvLyBkb2luZyB0aGUgcmV2ZXJ0IGFuaW1hdGlvbj9cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oc291cmNlRWwsIG9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHR0aGlzLnNvdXJjZUVsID0gc291cmNlRWw7XG5cdFx0dGhpcy5wYXJlbnRFbCA9IG9wdGlvbnMucGFyZW50RWwgPyAkKG9wdGlvbnMucGFyZW50RWwpIDogc291cmNlRWwucGFyZW50KCk7IC8vIGRlZmF1bHQgdG8gc291cmNlRWwncyBwYXJlbnRcblx0fSxcblxuXG5cdC8vIENhdXNlcyB0aGUgZWxlbWVudCB0byBzdGFydCBmb2xsb3dpbmcgdGhlIG1vdXNlXG5cdHN0YXJ0OiBmdW5jdGlvbihldikge1xuXHRcdGlmICghdGhpcy5pc0ZvbGxvd2luZykge1xuXHRcdFx0dGhpcy5pc0ZvbGxvd2luZyA9IHRydWU7XG5cblx0XHRcdHRoaXMueTAgPSBnZXRFdlkoZXYpO1xuXHRcdFx0dGhpcy54MCA9IGdldEV2WChldik7XG5cdFx0XHR0aGlzLnRvcERlbHRhID0gMDtcblx0XHRcdHRoaXMubGVmdERlbHRhID0gMDtcblxuXHRcdFx0aWYgKCF0aGlzLmlzSGlkZGVuKSB7XG5cdFx0XHRcdHRoaXMudXBkYXRlUG9zaXRpb24oKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGdldEV2SXNUb3VjaChldikpIHtcblx0XHRcdFx0dGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW92ZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW92ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2F1c2VzIHRoZSBlbGVtZW50IHRvIHN0b3AgZm9sbG93aW5nIHRoZSBtb3VzZS4gSWYgc2hvdWxkUmV2ZXJ0IGlzIHRydWUsIHdpbGwgYW5pbWF0ZSBiYWNrIHRvIG9yaWdpbmFsIHBvc2l0aW9uLlxuXHQvLyBgY2FsbGJhY2tgIGdldHMgaW52b2tlZCB3aGVuIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUuIElmIG5vIGFuaW1hdGlvbiwgaXQgaXMgaW52b2tlZCBpbW1lZGlhdGVseS5cblx0c3RvcDogZnVuY3Rpb24oc2hvdWxkUmV2ZXJ0LCBjYWxsYmFjaykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHJldmVydER1cmF0aW9uID0gdGhpcy5vcHRpb25zLnJldmVydER1cmF0aW9uO1xuXG5cdFx0ZnVuY3Rpb24gY29tcGxldGUoKSB7IC8vIG1pZ2h0IGJlIGNhbGxlZCBieSAuYW5pbWF0ZSgpLCB3aGljaCBtaWdodCBjaGFuZ2UgYHRoaXNgIGNvbnRleHRcblx0XHRcdF90aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHRfdGhpcy5yZW1vdmVFbGVtZW50KCk7XG5cblx0XHRcdF90aGlzLnRvcDAgPSBfdGhpcy5sZWZ0MCA9IG51bGw7IC8vIHJlc2V0IHN0YXRlIGZvciBmdXR1cmUgdXBkYXRlUG9zaXRpb24gY2FsbHNcblxuXHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaXNGb2xsb3dpbmcgJiYgIXRoaXMuaXNBbmltYXRpbmcpIHsgLy8gZGlzYWxsb3cgbW9yZSB0aGFuIG9uZSBzdG9wIGFuaW1hdGlvbiBhdCBhIHRpbWVcblx0XHRcdHRoaXMuaXNGb2xsb3dpbmcgPSBmYWxzZTtcblxuXHRcdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpO1xuXG5cdFx0XHRpZiAoc2hvdWxkUmV2ZXJ0ICYmIHJldmVydER1cmF0aW9uICYmICF0aGlzLmlzSGlkZGVuKSB7IC8vIGRvIGEgcmV2ZXJ0IGFuaW1hdGlvbj9cblx0XHRcdFx0dGhpcy5pc0FuaW1hdGluZyA9IHRydWU7XG5cdFx0XHRcdHRoaXMuZWwuYW5pbWF0ZSh7XG5cdFx0XHRcdFx0dG9wOiB0aGlzLnRvcDAsXG5cdFx0XHRcdFx0bGVmdDogdGhpcy5sZWZ0MFxuXHRcdFx0XHR9LCB7XG5cdFx0XHRcdFx0ZHVyYXRpb246IHJldmVydER1cmF0aW9uLFxuXHRcdFx0XHRcdGNvbXBsZXRlOiBjb21wbGV0ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjb21wbGV0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIEdldHMgdGhlIHRyYWNraW5nIGVsZW1lbnQuIENyZWF0ZSBpdCBpZiBuZWNlc3Nhcnlcblx0Z2V0RWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbCA9IHRoaXMuZWw7XG5cblx0XHRpZiAoIWVsKSB7XG5cdFx0XHRlbCA9IHRoaXMuZWwgPSB0aGlzLnNvdXJjZUVsLmNsb25lKClcblx0XHRcdFx0LmFkZENsYXNzKHRoaXMub3B0aW9ucy5hZGRpdGlvbmFsQ2xhc3MgfHwgJycpXG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdHZpc2liaWxpdHk6ICcnLCAvLyBpbiBjYXNlIG9yaWdpbmFsIGVsZW1lbnQgd2FzIGhpZGRlbiAoY29tbW9ubHkgdGhyb3VnaCBoaWRlRXZlbnRzKCkpXG5cdFx0XHRcdFx0ZGlzcGxheTogdGhpcy5pc0hpZGRlbiA/ICdub25lJyA6ICcnLCAvLyBmb3Igd2hlbiBpbml0aWFsbHkgaGlkZGVuXG5cdFx0XHRcdFx0bWFyZ2luOiAwLFxuXHRcdFx0XHRcdHJpZ2h0OiAnYXV0bycsIC8vIGVyYXNlIGFuZCBzZXQgd2lkdGggaW5zdGVhZFxuXHRcdFx0XHRcdGJvdHRvbTogJ2F1dG8nLCAvLyBlcmFzZSBhbmQgc2V0IGhlaWdodCBpbnN0ZWFkXG5cdFx0XHRcdFx0d2lkdGg6IHRoaXMuc291cmNlRWwud2lkdGgoKSwgLy8gZXhwbGljaXQgaGVpZ2h0IGluIGNhc2UgdGhlcmUgd2FzIGEgJ3JpZ2h0JyB2YWx1ZVxuXHRcdFx0XHRcdGhlaWdodDogdGhpcy5zb3VyY2VFbC5oZWlnaHQoKSwgLy8gZXhwbGljaXQgd2lkdGggaW4gY2FzZSB0aGVyZSB3YXMgYSAnYm90dG9tJyB2YWx1ZVxuXHRcdFx0XHRcdG9wYWNpdHk6IHRoaXMub3B0aW9ucy5vcGFjaXR5IHx8ICcnLFxuXHRcdFx0XHRcdHpJbmRleDogdGhpcy5vcHRpb25zLnpJbmRleFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0Ly8gd2UgZG9uJ3Qgd2FudCBsb25nIHRhcHMgb3IgYW55IG1vdXNlIGludGVyYWN0aW9uIGNhdXNpbmcgc2VsZWN0aW9uL21lbnVzLlxuXHRcdFx0Ly8gd291bGQgdXNlIHByZXZlbnRTZWxlY3Rpb24oKSwgYnV0IHRoYXQgcHJldmVudHMgc2VsZWN0c3RhcnQsIGNhdXNpbmcgcHJvYmxlbXMuXG5cdFx0XHRlbC5hZGRDbGFzcygnZmMtdW5zZWxlY3RhYmxlJyk7XG5cblx0XHRcdGVsLmFwcGVuZFRvKHRoaXMucGFyZW50RWwpO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbDtcblx0fSxcblxuXG5cdC8vIFJlbW92ZXMgdGhlIHRyYWNraW5nIGVsZW1lbnQgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkXG5cdHJlbW92ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmVsKSB7XG5cdFx0XHR0aGlzLmVsLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5lbCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVXBkYXRlIHRoZSBDU1MgcG9zaXRpb24gb2YgdGhlIHRyYWNraW5nIGVsZW1lbnRcblx0dXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzb3VyY2VPZmZzZXQ7XG5cdFx0dmFyIG9yaWdpbjtcblxuXHRcdHRoaXMuZ2V0RWwoKTsgLy8gZW5zdXJlIHRoaXMuZWxcblxuXHRcdC8vIG1ha2Ugc3VyZSBvcmlnaW4gaW5mbyB3YXMgY29tcHV0ZWRcblx0XHRpZiAodGhpcy50b3AwID09PSBudWxsKSB7XG5cdFx0XHRzb3VyY2VPZmZzZXQgPSB0aGlzLnNvdXJjZUVsLm9mZnNldCgpO1xuXHRcdFx0b3JpZ2luID0gdGhpcy5lbC5vZmZzZXRQYXJlbnQoKS5vZmZzZXQoKTtcblx0XHRcdHRoaXMudG9wMCA9IHNvdXJjZU9mZnNldC50b3AgLSBvcmlnaW4udG9wO1xuXHRcdFx0dGhpcy5sZWZ0MCA9IHNvdXJjZU9mZnNldC5sZWZ0IC0gb3JpZ2luLmxlZnQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbC5jc3Moe1xuXHRcdFx0dG9wOiB0aGlzLnRvcDAgKyB0aGlzLnRvcERlbHRhLFxuXHRcdFx0bGVmdDogdGhpcy5sZWZ0MCArIHRoaXMubGVmdERlbHRhXG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvLyBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIG1vdmVzIHRoZSBtb3VzZVxuXHRoYW5kbGVNb3ZlOiBmdW5jdGlvbihldikge1xuXHRcdHRoaXMudG9wRGVsdGEgPSBnZXRFdlkoZXYpIC0gdGhpcy55MDtcblx0XHR0aGlzLmxlZnREZWx0YSA9IGdldEV2WChldikgLSB0aGlzLngwO1xuXG5cdFx0aWYgKCF0aGlzLmlzSGlkZGVuKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVGVtcG9yYXJpbHkgbWFrZXMgdGhlIHRyYWNraW5nIGVsZW1lbnQgaW52aXNpYmxlLiBDYW4gYmUgY2FsbGVkIGJlZm9yZSBmb2xsb3dpbmcgc3RhcnRzXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc0hpZGRlbikge1xuXHRcdFx0dGhpcy5pc0hpZGRlbiA9IHRydWU7XG5cdFx0XHRpZiAodGhpcy5lbCkge1xuXHRcdFx0XHR0aGlzLmVsLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBTaG93IHRoZSB0cmFja2luZyBlbGVtZW50IGFmdGVyIGl0IGhhcyBiZWVuIHRlbXBvcmFyaWx5IGhpZGRlblxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5pc0hpZGRlbikge1xuXHRcdFx0dGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xuXHRcdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHRcdFx0dGhpcy5nZXRFbCgpLnNob3coKTtcblx0XHR9XG5cdH1cblxufSk7XG5cbjs7XG5cbi8qIEFuIGFic3RyYWN0IGNsYXNzIGNvbXByaXNlZCBvZiBhIFwiZ3JpZFwiIG9mIGFyZWFzIHRoYXQgZWFjaCByZXByZXNlbnQgYSBzcGVjaWZpYyBkYXRldGltZVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbnZhciBHcmlkID0gRkMuR3JpZCA9IENsYXNzLmV4dGVuZChMaXN0ZW5lck1peGluLCB7XG5cblx0Ly8gc2VsZi1jb25maWcsIG92ZXJyaWRhYmxlIGJ5IHN1YmNsYXNzZXNcblx0aGFzRGF5SW50ZXJhY3Rpb25zOiB0cnVlLCAvLyBjYW4gdXNlciBjbGljay9zZWxlY3QgcmFuZ2VzIG9mIHRpbWU/XG5cblx0dmlldzogbnVsbCwgLy8gYSBWaWV3IG9iamVjdFxuXHRpc1JUTDogbnVsbCwgLy8gc2hvcnRjdXQgdG8gdGhlIHZpZXcncyBpc1JUTCBvcHRpb25cblxuXHRzdGFydDogbnVsbCxcblx0ZW5kOiBudWxsLFxuXG5cdGVsOiBudWxsLCAvLyB0aGUgY29udGFpbmluZyBlbGVtZW50XG5cdGVsc0J5RmlsbDogbnVsbCwgLy8gYSBoYXNoIG9mIGpRdWVyeSBlbGVtZW50IHNldHMgdXNlZCBmb3IgcmVuZGVyaW5nIGVhY2ggZmlsbC4gS2V5ZWQgYnkgZmlsbCBuYW1lLlxuXG5cdC8vIGRlcml2ZWQgZnJvbSBvcHRpb25zXG5cdGV2ZW50VGltZUZvcm1hdDogbnVsbCxcblx0ZGlzcGxheUV2ZW50VGltZTogbnVsbCxcblx0ZGlzcGxheUV2ZW50RW5kOiBudWxsLFxuXG5cdG1pblJlc2l6ZUR1cmF0aW9uOiBudWxsLCAvLyBUT0RPOiBoYWNrLiBzZXQgYnkgc3ViY2xhc3Nlcy4gbWludW11bSBldmVudCByZXNpemUgZHVyYXRpb25cblxuXHQvLyBpZiBkZWZpbmVkLCBob2xkcyB0aGUgdW5pdCBpZGVudGlmaWVkIChleDogXCJ5ZWFyXCIgb3IgXCJtb250aFwiKSB0aGF0IGRldGVybWluZXMgdGhlIGxldmVsIG9mIGdyYW51bGFyaXR5XG5cdC8vIG9mIHRoZSBkYXRlIGFyZWFzLiBpZiBub3QgZGVmaW5lZCwgYXNzdW1lcyB0byBiZSBkYXkgYW5kIHRpbWUgZ3JhbnVsYXJpdHkuXG5cdC8vIFRPRE86IHBvcnQgaXNUaW1lU2NhbGUgaW50byBzYW1lIHN5c3RlbT9cblx0bGFyZ2VVbml0OiBudWxsLFxuXG5cdGRheUNsaWNrTGlzdGVuZXI6IG51bGwsXG5cdGRheVNlbGVjdExpc3RlbmVyOiBudWxsLFxuXHRzZWdEcmFnTGlzdGVuZXI6IG51bGwsXG5cdHNlZ1Jlc2l6ZUxpc3RlbmVyOiBudWxsLFxuXHRleHRlcm5hbERyYWdMaXN0ZW5lcjogbnVsbCxcblxuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbih2aWV3KSB7XG5cdFx0dGhpcy52aWV3ID0gdmlldztcblx0XHR0aGlzLmlzUlRMID0gdmlldy5vcHQoJ2lzUlRMJyk7XG5cdFx0dGhpcy5lbHNCeUZpbGwgPSB7fTtcblxuXHRcdHRoaXMuZGF5Q2xpY2tMaXN0ZW5lciA9IHRoaXMuYnVpbGREYXlDbGlja0xpc3RlbmVyKCk7XG5cdFx0dGhpcy5kYXlTZWxlY3RMaXN0ZW5lciA9IHRoaXMuYnVpbGREYXlTZWxlY3RMaXN0ZW5lcigpO1xuXHR9LFxuXG5cblx0LyogT3B0aW9uc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHVzZWQgZm9yIGV2ZW50IHRpbWUgdGV4dCwgaWYgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBieSAndGltZUZvcm1hdCdcblx0Y29tcHV0ZUV2ZW50VGltZUZvcm1hdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudmlldy5vcHQoJ3NtYWxsVGltZUZvcm1hdCcpO1xuXHR9LFxuXG5cblx0Ly8gRGV0ZXJtaW5lcyB3aGV0aGVyIGV2ZW50cyBzaG91bGQgaGF2ZSB0aGVpciBlbmQgdGltZXMgZGlzcGxheWVkLCBpZiBub3QgZXhwbGljaXRseSBkZWZpbmVkIGJ5ICdkaXNwbGF5RXZlbnRUaW1lJy5cblx0Ly8gT25seSBhcHBsaWVzIHRvIG5vbi1hbGwtZGF5IGV2ZW50cy5cblx0Y29tcHV0ZURpc3BsYXlFdmVudFRpbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cblx0Ly8gRGV0ZXJtaW5lcyB3aGV0aGVyIGV2ZW50cyBzaG91bGQgaGF2ZSB0aGVpciBlbmQgdGltZXMgZGlzcGxheWVkLCBpZiBub3QgZXhwbGljaXRseSBkZWZpbmVkIGJ5ICdkaXNwbGF5RXZlbnRFbmQnXG5cdGNvbXB1dGVEaXNwbGF5RXZlbnRFbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cblx0LyogRGF0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFRlbGxzIHRoZSBncmlkIGFib3V0IHdoYXQgcGVyaW9kIG9mIHRpbWUgdG8gZGlzcGxheS5cblx0Ly8gQW55IGRhdGUtcmVsYXRlZCBpbnRlcm5hbCBkYXRhIHNob3VsZCBiZSBnZW5lcmF0ZWQuXG5cdHNldFJhbmdlOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdHRoaXMuc3RhcnQgPSByYW5nZS5zdGFydC5jbG9uZSgpO1xuXHRcdHRoaXMuZW5kID0gcmFuZ2UuZW5kLmNsb25lKCk7XG5cblx0XHR0aGlzLnJhbmdlVXBkYXRlZCgpO1xuXHRcdHRoaXMucHJvY2Vzc1JhbmdlT3B0aW9ucygpO1xuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gaW50ZXJuYWwgdmFyaWFibGVzIHRoYXQgcmVseSBvbiB0aGUgcmFuZ2Ugc2hvdWxkIGJlIHVwZGF0ZWRcblx0cmFuZ2VVcGRhdGVkOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdC8vIFVwZGF0ZXMgdmFsdWVzIHRoYXQgcmVseSBvbiBvcHRpb25zIGFuZCBhbHNvIHJlbGF0ZSB0byByYW5nZVxuXHRwcm9jZXNzUmFuZ2VPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgZGlzcGxheUV2ZW50VGltZTtcblx0XHR2YXIgZGlzcGxheUV2ZW50RW5kO1xuXG5cdFx0dGhpcy5ldmVudFRpbWVGb3JtYXQgPVxuXHRcdFx0dmlldy5vcHQoJ2V2ZW50VGltZUZvcm1hdCcpIHx8XG5cdFx0XHR2aWV3Lm9wdCgndGltZUZvcm1hdCcpIHx8IC8vIGRlcHJlY2F0ZWRcblx0XHRcdHRoaXMuY29tcHV0ZUV2ZW50VGltZUZvcm1hdCgpO1xuXG5cdFx0ZGlzcGxheUV2ZW50VGltZSA9IHZpZXcub3B0KCdkaXNwbGF5RXZlbnRUaW1lJyk7XG5cdFx0aWYgKGRpc3BsYXlFdmVudFRpbWUgPT0gbnVsbCkge1xuXHRcdFx0ZGlzcGxheUV2ZW50VGltZSA9IHRoaXMuY29tcHV0ZURpc3BsYXlFdmVudFRpbWUoKTsgLy8gbWlnaHQgYmUgYmFzZWQgb2ZmIG9mIHJhbmdlXG5cdFx0fVxuXG5cdFx0ZGlzcGxheUV2ZW50RW5kID0gdmlldy5vcHQoJ2Rpc3BsYXlFdmVudEVuZCcpO1xuXHRcdGlmIChkaXNwbGF5RXZlbnRFbmQgPT0gbnVsbCkge1xuXHRcdFx0ZGlzcGxheUV2ZW50RW5kID0gdGhpcy5jb21wdXRlRGlzcGxheUV2ZW50RW5kKCk7IC8vIG1pZ2h0IGJlIGJhc2VkIG9mZiBvZiByYW5nZVxuXHRcdH1cblxuXHRcdHRoaXMuZGlzcGxheUV2ZW50VGltZSA9IGRpc3BsYXlFdmVudFRpbWU7XG5cdFx0dGhpcy5kaXNwbGF5RXZlbnRFbmQgPSBkaXNwbGF5RXZlbnRFbmQ7XG5cdH0sXG5cblxuXHQvLyBDb252ZXJ0cyBhIHNwYW4gKGhhcyB1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgYW55IG90aGVyIGdyaWQtc3BlY2lmaWMgbG9jYXRpb24gaW5mb3JtYXRpb24pXG5cdC8vIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHMgKHBpZWNlcyBvZiBldmVudHMgd2hvc2UgZm9ybWF0IGlzIGRlY2lkZWQgYnkgdGhlIGdyaWQpLlxuXHRzcGFuVG9TZWdzOiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gRGlmZnMgdGhlIHR3byBkYXRlcywgcmV0dXJuaW5nIGEgZHVyYXRpb24sIGJhc2VkIG9uIGdyYW51bGFyaXR5IG9mIHRoZSBncmlkXG5cdC8vIFRPRE86IHBvcnQgaXNUaW1lU2NhbGUgaW50byB0aGlzIHN5c3RlbT9cblx0ZGlmZkRhdGVzOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0aWYgKHRoaXMubGFyZ2VVbml0KSB7XG5cdFx0XHRyZXR1cm4gZGlmZkJ5VW5pdChhLCBiLCB0aGlzLmxhcmdlVW5pdCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuIGRpZmZEYXlUaW1lKGEsIGIpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8qIEhpdCBBcmVhXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0aGl0c05lZWRlZERlcHRoOiAwLCAvLyBuZWNlc3NhcnkgYmVjYXVzZSBtdWx0aXBsZSBjYWxsZXJzIG1pZ2h0IG5lZWQgdGhlIHNhbWUgaGl0c1xuXG5cdGhpdHNOZWVkZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghKHRoaXMuaGl0c05lZWRlZERlcHRoKyspKSB7XG5cdFx0XHR0aGlzLnByZXBhcmVIaXRzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGhpdHNOb3ROZWVkZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmhpdHNOZWVkZWREZXB0aCAmJiAhKC0tdGhpcy5oaXRzTmVlZGVkRGVwdGgpKSB7XG5cdFx0XHR0aGlzLnJlbGVhc2VIaXRzKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIGJlZm9yZSBvbmUgb3IgbW9yZSBxdWVyeUhpdCBjYWxscyBtaWdodCBoYXBwZW4uIFNob3VsZCBwcmVwYXJlIGFueSBjYWNoZWQgY29vcmRpbmF0ZXMgZm9yIHF1ZXJ5SGl0XG5cdHByZXBhcmVIaXRzOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIHF1ZXJ5SGl0IGNhbGxzIGhhdmUgc3Vic2lkZWQuIEdvb2QgcGxhY2UgdG8gY2xlYXIgYW55IGNvb3JkaW5hdGUgY2FjaGVzLlxuXHRyZWxlYXNlSGl0czogZnVuY3Rpb24oKSB7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBjb29yZGluYXRlcyBmcm9tIHRoZSB0b3BsZWZ0IG9mIHRoZSBkb2N1bWVudCwgcmV0dXJuIGRhdGEgYWJvdXQgdGhlIGRhdGUtcmVsYXRlZCBhcmVhIHVuZGVybmVhdGguXG5cdC8vIENhbiByZXR1cm4gYW4gb2JqZWN0IHdpdGggYXJiaXRyYXJ5IHByb3BlcnRpZXMgKGFsdGhvdWdoIHRvcC9yaWdodC9sZWZ0L2JvdHRvbSBhcmUgZW5jb3VyYWdlZCkuXG5cdC8vIE11c3QgaGF2ZSBhIGBncmlkYCBwcm9wZXJ0eSwgYSByZWZlcmVuY2UgdG8gdGhpcyBjdXJyZW50IGdyaWQuIFRPRE86IGF2b2lkIHRoaXNcblx0Ly8gVGhlIHJldHVybmVkIG9iamVjdCB3aWxsIGJlIHByb2Nlc3NlZCBieSBnZXRIaXRTcGFuIGFuZCBnZXRIaXRFbC5cblx0cXVlcnlIaXQ6IGZ1bmN0aW9uKGxlZnRPZmZzZXQsIHRvcE9mZnNldCkge1xuXHR9LFxuXG5cblx0Ly8gbGlrZSBnZXRIaXRTcGFuLCBidXQgcmV0dXJucyBudWxsIGlmIHRoZSByZXN1bHRpbmcgc3BhbidzIHJhbmdlIGlzIGludmFsaWRcblx0Z2V0U2FmZUhpdFNwYW46IGZ1bmN0aW9uKGhpdCkge1xuXHRcdHZhciBoaXRTcGFuID0gdGhpcy5nZXRIaXRTcGFuKGhpdCk7XG5cblx0XHRpZiAoIWlzUmFuZ2VXaXRoaW5SYW5nZShoaXRTcGFuLCB0aGlzLnZpZXcuYWN0aXZlUmFuZ2UpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGl0U3Bhbjtcblx0fSxcblxuXG5cdC8vIEdpdmVuIHBvc2l0aW9uLWxldmVsIGluZm9ybWF0aW9uIGFib3V0IGEgZGF0ZS1yZWxhdGVkIGFyZWEgd2l0aGluIHRoZSBncmlkLFxuXHQvLyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGF0IGxlYXN0IGEgc3RhcnQvZW5kIGRhdGUuIENhbiBwcm92aWRlIG90aGVyIGluZm9ybWF0aW9uIGFzIHdlbGwuXG5cdGdldEhpdFNwYW46IGZ1bmN0aW9uKGhpdCkge1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gcG9zaXRpb24tbGV2ZWwgaW5mb3JtYXRpb24gYWJvdXQgYSBkYXRlLXJlbGF0ZWQgYXJlYSB3aXRoaW4gdGhlIGdyaWQsXG5cdC8vIHNob3VsZCByZXR1cm4gYSBqUXVlcnkgZWxlbWVudCB0aGF0IGJlc3QgcmVwcmVzZW50cyBpdC4gcGFzc2VkIHRvIGRheUNsaWNrIGNhbGxiYWNrLlxuXHRnZXRIaXRFbDogZnVuY3Rpb24oaGl0KSB7XG5cdH0sXG5cblxuXHQvKiBSZW5kZXJpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFNldHMgdGhlIGNvbnRhaW5lciBlbGVtZW50IHRoYXQgdGhlIGdyaWQgc2hvdWxkIHJlbmRlciBpbnNpZGUgb2YuXG5cdC8vIERvZXMgb3RoZXIgRE9NLXJlbGF0ZWQgaW5pdGlhbGl6YXRpb25zLlxuXHRzZXRFbGVtZW50OiBmdW5jdGlvbihlbCkge1xuXHRcdHRoaXMuZWwgPSBlbDtcblxuXHRcdGlmICh0aGlzLmhhc0RheUludGVyYWN0aW9ucykge1xuXHRcdFx0cHJldmVudFNlbGVjdGlvbihlbCk7XG5cblx0XHRcdHRoaXMuYmluZERheUhhbmRsZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmRheVRvdWNoU3RhcnQpO1xuXHRcdFx0dGhpcy5iaW5kRGF5SGFuZGxlcignbW91c2Vkb3duJywgdGhpcy5kYXlNb3VzZWRvd24pO1xuXHRcdH1cblxuXHRcdC8vIGF0dGFjaCBldmVudC1lbGVtZW50LXJlbGF0ZWQgaGFuZGxlcnMuIGluIEdyaWQuZXZlbnRzXG5cdFx0Ly8gc2FtZSBnYXJiYWdlIGNvbGxlY3Rpb24gbm90ZSBhcyBhYm92ZS5cblx0XHR0aGlzLmJpbmRTZWdIYW5kbGVycygpO1xuXG5cdFx0dGhpcy5iaW5kR2xvYmFsSGFuZGxlcnMoKTtcblx0fSxcblxuXG5cdGJpbmREYXlIYW5kbGVyOiBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdC8vIGF0dGFjaCBhIGhhbmRsZXIgdG8gdGhlIGdyaWQncyByb290IGVsZW1lbnQuXG5cdFx0Ly8galF1ZXJ5IHdpbGwgdGFrZSBjYXJlIG9mIHVucmVnaXN0ZXJpbmcgdGhlbSB3aGVuIHJlbW92ZUVsZW1lbnQgZ2V0cyBjYWxsZWQuXG5cdFx0dGhpcy5lbC5vbihuYW1lLCBmdW5jdGlvbihldikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQhJChldi50YXJnZXQpLmlzKFxuXHRcdFx0XHRcdF90aGlzLnNlZ1NlbGVjdG9yICsgJywnICsgLy8gZGlyZWN0bHkgb24gYW4gZXZlbnQgZWxlbWVudFxuXHRcdFx0XHRcdF90aGlzLnNlZ1NlbGVjdG9yICsgJyAqLCcgKyAvLyB3aXRoaW4gYW4gZXZlbnQgZWxlbWVudFxuXHRcdFx0XHRcdCcuZmMtbW9yZSwnICsgLy8gYSBcIm1vcmUuLlwiIGxpbmtcblx0XHRcdFx0XHQnYVtkYXRhLWdvdG9dJyAvLyBhIGNsaWNrYWJsZSBuYXYgbGlua1xuXHRcdFx0XHQpXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIGhhbmRsZXIuY2FsbChfdGhpcywgZXYpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gUmVtb3ZlcyB0aGUgZ3JpZCdzIGNvbnRhaW5lciBlbGVtZW50IGZyb20gdGhlIERPTS4gVW5kb2VzIGFueSBvdGhlciBET00tcmVsYXRlZCBhdHRhY2htZW50cy5cblx0Ly8gRE9FUyBOT1QgcmVtb3ZlIGFueSBjb250ZW50IGJlZm9yZWhhbmQgKGRvZXNuJ3QgY2xlYXIgZXZlbnRzIG9yIGNhbGwgdW5yZW5kZXJEYXRlcyksIHVubGlrZSBWaWV3XG5cdHJlbW92ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5iaW5kR2xvYmFsSGFuZGxlcnMoKTtcblx0XHR0aGlzLmNsZWFyRHJhZ0xpc3RlbmVycygpO1xuXG5cdFx0dGhpcy5lbC5yZW1vdmUoKTtcblxuXHRcdC8vIE5PVEU6IHdlIGRvbid0IG51bGwtb3V0IHRoaXMuZWwgZm9yIHRoZSBzYW1lIHJlYXNvbnMgd2UgZG9uJ3QgZG8gaXQgd2l0aGluIFZpZXc6OnJlbW92ZUVsZW1lbnRcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIGJhc2ljIHN0cnVjdHVyZSBvZiBncmlkIHZpZXcgYmVmb3JlIGFueSBjb250ZW50IGlzIHJlbmRlcmVkXG5cdHJlbmRlclNrZWxldG9uOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIGdyaWQncyBkYXRlLXJlbGF0ZWQgY29udGVudCAobGlrZSBhcmVhcyB0aGF0IHJlcHJlc2VudCBkYXlzL3RpbWVzKS5cblx0Ly8gQXNzdW1lcyBzZXRSYW5nZSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCBhbmQgdGhlIHNrZWxldG9uIGhhcyBhbHJlYWR5IGJlZW4gcmVuZGVyZWQuXG5cdHJlbmRlckRhdGVzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyB0aGUgZ3JpZCdzIGRhdGUtcmVsYXRlZCBjb250ZW50XG5cdHVucmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogSGFuZGxlcnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEJpbmRzIERPTSBoYW5kbGVycyB0byBlbGVtZW50cyB0aGF0IHJlc2lkZSBvdXRzaWRlIHRoZSBncmlkLCBzdWNoIGFzIHRoZSBkb2N1bWVudFxuXHRiaW5kR2xvYmFsSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksIHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5leHRlcm5hbERyYWdTdGFydCwgLy8ganF1aVxuXHRcdFx0c29ydHN0YXJ0OiB0aGlzLmV4dGVybmFsRHJhZ1N0YXJ0IC8vIGpxdWlcblx0XHR9KTtcblx0fSxcblxuXG5cdC8vIFVuYmluZHMgRE9NIGhhbmRsZXJzIGZyb20gZWxlbWVudHMgdGhhdCByZXNpZGUgb3V0c2lkZSB0aGUgZ3JpZFxuXHR1bmJpbmRHbG9iYWxIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpO1xuXHR9LFxuXG5cblx0Ly8gUHJvY2VzcyBhIG1vdXNlZG93biBvbiBhbiBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyBhIGRheS4gRm9yIGRheSBjbGlja2luZyBhbmQgc2VsZWN0aW5nLlxuXHRkYXlNb3VzZWRvd246IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHQvLyBIQUNLXG5cdFx0Ly8gVGhpcyB3aWxsIHN0aWxsIHdvcmsgZXZlbiB0aG91Z2ggYmluZERheUhhbmRsZXIgZG9lc24ndCB1c2UgR2xvYmFsRW1pdHRlci5cblx0XHRpZiAoR2xvYmFsRW1pdHRlci5nZXQoKS5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5kYXlDbGlja0xpc3RlbmVyLnN0YXJ0SW50ZXJhY3Rpb24oZXYpO1xuXG5cdFx0aWYgKHZpZXcub3B0KCdzZWxlY3RhYmxlJykpIHtcblx0XHRcdHRoaXMuZGF5U2VsZWN0TGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldiwge1xuXHRcdFx0XHRkaXN0YW5jZTogdmlldy5vcHQoJ3NlbGVjdE1pbkRpc3RhbmNlJylcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXG5cdGRheVRvdWNoU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIHNlbGVjdExvbmdQcmVzc0RlbGF5O1xuXG5cdFx0Ly8gT24gaU9TIChhbmQgQW5kcm9pZD8pIHdoZW4gYSBuZXcgc2VsZWN0aW9uIGlzIGluaXRpYXRlZCBvdmVydG9wIGFub3RoZXIgc2VsZWN0aW9uLFxuXHRcdC8vIHRoZSB0b3VjaGVuZCBuZXZlciBmaXJlcyBiZWNhdXNlIHRoZSBlbGVtZW50cyBnZXRzIHJlbW92ZWQgbWlkLXRvdWNoLWludGVyYWN0aW9uIChteSB0aGVvcnkpLlxuXHRcdC8vIEhBQ0s6IHNpbXBseSBkb24ndCBhbGxvdyB0aGlzIHRvIGhhcHBlbi5cblx0XHQvLyBBTFNPOiBwcmV2ZW50IHNlbGVjdGlvbiB3aGVuIGFuICpldmVudCogaXMgYWxyZWFkeSByYWlzZWQuXG5cdFx0aWYgKHZpZXcuaXNTZWxlY3RlZCB8fCB2aWV3LnNlbGVjdGVkRXZlbnQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzZWxlY3RMb25nUHJlc3NEZWxheSA9IHZpZXcub3B0KCdzZWxlY3RMb25nUHJlc3NEZWxheScpO1xuXHRcdGlmIChzZWxlY3RMb25nUHJlc3NEZWxheSA9PSBudWxsKSB7XG5cdFx0XHRzZWxlY3RMb25nUHJlc3NEZWxheSA9IHZpZXcub3B0KCdsb25nUHJlc3NEZWxheScpOyAvLyBmYWxsYmFja1xuXHRcdH1cblxuXHRcdHRoaXMuZGF5Q2xpY2tMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2KTtcblxuXHRcdGlmICh2aWV3Lm9wdCgnc2VsZWN0YWJsZScpKSB7XG5cdFx0XHR0aGlzLmRheVNlbGVjdExpc3RlbmVyLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHtcblx0XHRcdFx0ZGVsYXk6IHNlbGVjdExvbmdQcmVzc0RlbGF5XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDcmVhdGVzIGEgbGlzdGVuZXIgdGhhdCB0cmFja3MgdGhlIHVzZXIncyBkcmFnIGFjcm9zcyBkYXkgZWxlbWVudHMsIGZvciBkYXkgY2xpY2tpbmcuXG5cdGJ1aWxkRGF5Q2xpY2tMaXN0ZW5lcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgZGF5Q2xpY2tIaXQ7IC8vIG51bGwgaWYgaW52YWxpZCBkYXlDbGlja1xuXG5cdFx0dmFyIGRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXIodGhpcywge1xuXHRcdFx0c2Nyb2xsOiB2aWV3Lm9wdCgnZHJhZ1Njcm9sbCcpLFxuXHRcdFx0aW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRheUNsaWNrSGl0ID0gZHJhZ0xpc3RlbmVyLm9yaWdIaXQ7XG5cdFx0XHR9LFxuXHRcdFx0aGl0T3ZlcjogZnVuY3Rpb24oaGl0LCBpc09yaWcsIG9yaWdIaXQpIHtcblx0XHRcdFx0Ly8gaWYgdXNlciBkcmFnZ2VkIHRvIGFub3RoZXIgY2VsbCBhdCBhbnkgcG9pbnQsIGl0IGNhbiBubyBsb25nZXIgYmUgYSBkYXlDbGlja1xuXHRcdFx0XHRpZiAoIWlzT3JpZykge1xuXHRcdFx0XHRcdGRheUNsaWNrSGl0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhpdE91dDogZnVuY3Rpb24oKSB7IC8vIGNhbGxlZCBiZWZvcmUgbW91c2UgbW92ZXMgdG8gYSBkaWZmZXJlbnQgaGl0IE9SIG1vdmVkIG91dCBvZiBhbGwgaGl0c1xuXHRcdFx0XHRkYXlDbGlja0hpdCA9IG51bGw7XG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uKGV2LCBpc0NhbmNlbGxlZCkge1xuXHRcdFx0XHR2YXIgaGl0U3BhbjtcblxuXHRcdFx0XHRpZiAoIWlzQ2FuY2VsbGVkICYmIGRheUNsaWNrSGl0KSB7XG5cdFx0XHRcdFx0aGl0U3BhbiA9IF90aGlzLmdldFNhZmVIaXRTcGFuKGRheUNsaWNrSGl0KTtcblxuXHRcdFx0XHRcdGlmIChoaXRTcGFuKSB7XG5cdFx0XHRcdFx0XHR2aWV3LnRyaWdnZXJEYXlDbGljayhoaXRTcGFuLCBfdGhpcy5nZXRIaXRFbChkYXlDbGlja0hpdCksIGV2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGJlY2F1c2UgZGF5Q2xpY2tMaXN0ZW5lciB3b24ndCBiZSBjYWxsZWQgd2l0aCBhbnkgdGltZSBkZWxheSwgXCJkcmFnZ2luZ1wiIHdpbGwgYmVnaW4gaW1tZWRpYXRlbHksXG5cdFx0Ly8gd2hpY2ggd2lsbCBraWxsIGFueSB0b3VjaG1vdmluZy9zY3JvbGxpbmcuIFByZXZlbnQgdGhpcy5cblx0XHRkcmFnTGlzdGVuZXIuc2hvdWxkQ2FuY2VsVG91Y2hTY3JvbGwgPSBmYWxzZTtcblxuXHRcdGRyYWdMaXN0ZW5lci5zY3JvbGxBbHdheXNLaWxscyA9IHRydWU7XG5cblx0XHRyZXR1cm4gZHJhZ0xpc3RlbmVyO1xuXHR9LFxuXG5cblx0Ly8gQ3JlYXRlcyBhIGxpc3RlbmVyIHRoYXQgdHJhY2tzIHRoZSB1c2VyJ3MgZHJhZyBhY3Jvc3MgZGF5IGVsZW1lbnRzLCBmb3IgZGF5IHNlbGVjdGluZy5cblx0YnVpbGREYXlTZWxlY3RMaXN0ZW5lcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgc2VsZWN0aW9uU3BhbjsgLy8gbnVsbCBpZiBpbnZhbGlkIHNlbGVjdGlvblxuXG5cdFx0dmFyIGRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXIodGhpcywge1xuXHRcdFx0c2Nyb2xsOiB2aWV3Lm9wdCgnZHJhZ1Njcm9sbCcpLFxuXHRcdFx0aW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGVjdGlvblNwYW4gPSBudWxsO1xuXHRcdFx0fSxcblx0XHRcdGRyYWdTdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZpZXcudW5zZWxlY3QoKTsgLy8gc2luY2Ugd2UgY291bGQgYmUgcmVuZGVyaW5nIGEgbmV3IHNlbGVjdGlvbiwgd2Ugd2FudCB0byBjbGVhciBhbnkgb2xkIG9uZVxuXHRcdFx0fSxcblx0XHRcdGhpdE92ZXI6IGZ1bmN0aW9uKGhpdCwgaXNPcmlnLCBvcmlnSGl0KSB7XG5cdFx0XHRcdHZhciBvcmlnSGl0U3Bhbjtcblx0XHRcdFx0dmFyIGhpdFNwYW47XG5cblx0XHRcdFx0aWYgKG9yaWdIaXQpIHsgLy8gY2xpY2sgbmVlZHMgdG8gaGF2ZSBzdGFydGVkIG9uIGEgaGl0XG5cblx0XHRcdFx0XHRvcmlnSGl0U3BhbiA9IF90aGlzLmdldFNhZmVIaXRTcGFuKG9yaWdIaXQpO1xuXHRcdFx0XHRcdGhpdFNwYW4gPSBfdGhpcy5nZXRTYWZlSGl0U3BhbihoaXQpO1xuXG5cdFx0XHRcdFx0aWYgKG9yaWdIaXRTcGFuICYmIGhpdFNwYW4pIHtcblx0XHRcdFx0XHRcdHNlbGVjdGlvblNwYW4gPSBfdGhpcy5jb21wdXRlU2VsZWN0aW9uKG9yaWdIaXRTcGFuLCBoaXRTcGFuKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxlY3Rpb25TcGFuID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoc2VsZWN0aW9uU3Bhbikge1xuXHRcdFx0XHRcdFx0X3RoaXMucmVuZGVyU2VsZWN0aW9uKHNlbGVjdGlvblNwYW4pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChzZWxlY3Rpb25TcGFuID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0ZGlzYWJsZUN1cnNvcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhpdE91dDogZnVuY3Rpb24oKSB7IC8vIGNhbGxlZCBiZWZvcmUgbW91c2UgbW92ZXMgdG8gYSBkaWZmZXJlbnQgaGl0IE9SIG1vdmVkIG91dCBvZiBhbGwgaGl0c1xuXHRcdFx0XHRzZWxlY3Rpb25TcGFuID0gbnVsbDtcblx0XHRcdFx0X3RoaXMudW5yZW5kZXJTZWxlY3Rpb24oKTtcblx0XHRcdH0sXG5cdFx0XHRoaXREb25lOiBmdW5jdGlvbigpIHsgLy8gY2FsbGVkIGFmdGVyIGEgaGl0T3V0IE9SIGJlZm9yZSBhIGRyYWdFbmRcblx0XHRcdFx0ZW5hYmxlQ3Vyc29yKCk7XG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uKGV2LCBpc0NhbmNlbGxlZCkge1xuXHRcdFx0XHRpZiAoIWlzQ2FuY2VsbGVkICYmIHNlbGVjdGlvblNwYW4pIHtcblx0XHRcdFx0XHQvLyB0aGUgc2VsZWN0aW9uIHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gcmVuZGVyZWQuIGp1c3QgcmVwb3J0IGl0XG5cdFx0XHRcdFx0dmlldy5yZXBvcnRTZWxlY3Rpb24oc2VsZWN0aW9uU3BhbiwgZXYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZHJhZ0xpc3RlbmVyO1xuXHR9LFxuXG5cblx0Ly8gS2lsbHMgYWxsIGluLXByb2dyZXNzIGRyYWdnaW5nLlxuXHQvLyBVc2VmdWwgZm9yIHdoZW4gcHVibGljIEFQSSBtZXRob2RzIHRoYXQgcmVzdWx0IGluIHJlLXJlbmRlcmluZyBhcmUgaW52b2tlZCBkdXJpbmcgYSBkcmFnLlxuXHQvLyBBbHNvIHVzZWZ1bCBmb3Igd2hlbiB0b3VjaCBkZXZpY2VzIG1pc2JlaGF2ZSBhbmQgZG9uJ3QgZmlyZSB0aGVpciB0b3VjaGVuZC5cblx0Y2xlYXJEcmFnTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUNsaWNrTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTtcblx0XHR0aGlzLmRheVNlbGVjdExpc3RlbmVyLmVuZEludGVyYWN0aW9uKCk7XG5cblx0XHRpZiAodGhpcy5zZWdEcmFnTGlzdGVuZXIpIHtcblx0XHRcdHRoaXMuc2VnRHJhZ0xpc3RlbmVyLmVuZEludGVyYWN0aW9uKCk7IC8vIHdpbGwgY2xlYXIgdGhpcy5zZWdEcmFnTGlzdGVuZXJcblx0XHR9XG5cdFx0aWYgKHRoaXMuc2VnUmVzaXplTGlzdGVuZXIpIHtcblx0XHRcdHRoaXMuc2VnUmVzaXplTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTsgLy8gd2lsbCBjbGVhciB0aGlzLnNlZ1Jlc2l6ZUxpc3RlbmVyXG5cdFx0fVxuXHRcdGlmICh0aGlzLmV4dGVybmFsRHJhZ0xpc3RlbmVyKSB7XG5cdFx0XHR0aGlzLmV4dGVybmFsRHJhZ0xpc3RlbmVyLmVuZEludGVyYWN0aW9uKCk7IC8vIHdpbGwgY2xlYXIgdGhpcy5leHRlcm5hbERyYWdMaXN0ZW5lclxuXHRcdH1cblx0fSxcblxuXG5cdC8qIEV2ZW50IEhlbHBlclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQvLyBUT0RPOiBzaG91bGQgcHJvYmFibHkgbW92ZSB0aGlzIHRvIEdyaWQuZXZlbnRzLCBsaWtlIHdlIGRpZCBldmVudCBkcmFnZ2luZyAvIHJlc2l6aW5nXG5cblxuXHQvLyBSZW5kZXJzIGEgbW9jayBldmVudCBhdCB0aGUgZ2l2ZW4gZXZlbnQgbG9jYXRpb24sIHdoaWNoIGNvbnRhaW5zIHpvbmVkIHN0YXJ0L2VuZCBwcm9wZXJ0aWVzLlxuXHQvLyBSZXR1cm5zIGFsbCBtb2NrIGV2ZW50IGVsZW1lbnRzLlxuXHRyZW5kZXJFdmVudExvY2F0aW9uSGVscGVyOiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBzb3VyY2VTZWcpIHtcblx0XHR2YXIgZmFrZUV2ZW50ID0gdGhpcy5mYWJyaWNhdGVIZWxwZXJFdmVudChldmVudExvY2F0aW9uLCBzb3VyY2VTZWcpO1xuXG5cdFx0cmV0dXJuIHRoaXMucmVuZGVySGVscGVyKGZha2VFdmVudCwgc291cmNlU2VnKTsgLy8gZG8gdGhlIGFjdHVhbCByZW5kZXJpbmdcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyBhIGZha2UgZXZlbnQgZ2l2ZW4gem9uZWQgZXZlbnQgZGF0ZSBwcm9wZXJ0aWVzIGFuZCBhIHNlZ21lbnQgaXMgc2hvdWxkIGJlIGluc3BpcmVkIGZyb20uXG5cdC8vIFRoZSByYW5nZSdzIGVuZCBjYW4gYmUgbnVsbCwgaW4gd2hpY2ggY2FzZSB0aGUgbW9jayBldmVudCB0aGF0IGlzIHJlbmRlcmVkIHdpbGwgaGF2ZSBhIG51bGwgZW5kIHRpbWUuXG5cdC8vIGBzb3VyY2VTZWdgIGlzIHRoZSBpbnRlcm5hbCBzZWdtZW50IG9iamVjdCBpbnZvbHZlZCBpbiB0aGUgZHJhZy4gSWYgbnVsbCwgc29tZXRoaW5nIGV4dGVybmFsIGlzIGRyYWdnaW5nLlxuXHRmYWJyaWNhdGVIZWxwZXJFdmVudDogZnVuY3Rpb24oZXZlbnRMb2NhdGlvbiwgc291cmNlU2VnKSB7XG5cdFx0dmFyIGZha2VFdmVudCA9IHNvdXJjZVNlZyA/IGNyZWF0ZU9iamVjdChzb3VyY2VTZWcuZXZlbnQpIDoge307IC8vIG1hc2sgdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdCBpZiBwb3NzaWJsZVxuXG5cdFx0ZmFrZUV2ZW50LnN0YXJ0ID0gZXZlbnRMb2NhdGlvbi5zdGFydC5jbG9uZSgpO1xuXHRcdGZha2VFdmVudC5lbmQgPSBldmVudExvY2F0aW9uLmVuZCA/IGV2ZW50TG9jYXRpb24uZW5kLmNsb25lKCkgOiBudWxsO1xuXHRcdGZha2VFdmVudC5hbGxEYXkgPSBudWxsOyAvLyBmb3JjZSBpdCB0byBiZSBmcmVzaGx5IGNvbXB1dGVkIGJ5IG5vcm1hbGl6ZUV2ZW50RGF0ZXNcblx0XHR0aGlzLnZpZXcuY2FsZW5kYXIubm9ybWFsaXplRXZlbnREYXRlcyhmYWtlRXZlbnQpO1xuXG5cdFx0Ly8gdGhpcyBleHRyYSBjbGFzc05hbWUgd2lsbCBiZSB1c2VmdWwgZm9yIGRpZmZlcmVudGlhdGluZyByZWFsIGV2ZW50cyBmcm9tIG1vY2sgZXZlbnRzIGluIENTU1xuXHRcdGZha2VFdmVudC5jbGFzc05hbWUgPSAoZmFrZUV2ZW50LmNsYXNzTmFtZSB8fCBbXSkuY29uY2F0KCdmYy1oZWxwZXInKTtcblxuXHRcdC8vIGlmIHNvbWV0aGluZyBleHRlcm5hbCBpcyBiZWluZyBkcmFnZ2VkIGluLCBkb24ndCByZW5kZXIgYSByZXNpemVyXG5cdFx0aWYgKCFzb3VyY2VTZWcpIHtcblx0XHRcdGZha2VFdmVudC5lZGl0YWJsZSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWtlRXZlbnQ7XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIGEgbW9jayBldmVudC4gR2l2ZW4gem9uZWQgZXZlbnQgZGF0ZSBwcm9wZXJ0aWVzLlxuXHQvLyBNdXN0IHJldHVybiBhbGwgbW9jayBldmVudCBlbGVtZW50cy5cblx0cmVuZGVySGVscGVyOiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBzb3VyY2VTZWcpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYSBtb2NrIGV2ZW50XG5cdHVucmVuZGVySGVscGVyOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvKiBTZWxlY3Rpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvbi4gV2lsbCBoaWdobGlnaHQgYnkgZGVmYXVsdCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cblx0Ly8gR2l2ZW4gYSBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgb3RoZXIgbWlzYyBkYXRhKVxuXHRyZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHR0aGlzLnJlbmRlckhpZ2hsaWdodChzcGFuKTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb25zIG9mIGEgc2VsZWN0aW9uLiBXaWxsIHVucmVuZGVyIGEgaGlnaGxpZ2h0IGJ5IGRlZmF1bHQuXG5cdHVucmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiB0aGUgZmlyc3QgYW5kIGxhc3QgZGF0ZS1zcGFucyBvZiBhIHNlbGVjdGlvbiwgcmV0dXJucyBhbm90aGVyIGRhdGUtc3BhbiBvYmplY3QuXG5cdC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIGFuZCBwcm92aWRlIGFkZGl0aW9uYWwgZGF0YSBpbiB0aGUgc3BhbiBvYmplY3QuIFdpbGwgYmUgcGFzc2VkIHRvIHJlbmRlclNlbGVjdGlvbigpLlxuXHQvLyBXaWxsIHJldHVybiBmYWxzZSBpZiB0aGUgc2VsZWN0aW9uIGlzIGludmFsaWQgYW5kIHRoaXMgc2hvdWxkIGJlIGluZGljYXRlZCB0byB0aGUgdXNlci5cblx0Ly8gV2lsbCByZXR1cm4gbnVsbC91bmRlZmluZWQgaWYgYSBzZWxlY3Rpb24gaW52YWxpZCBidXQgbm8gZXJyb3Igc2hvdWxkIGJlIHJlcG9ydGVkLlxuXHRjb21wdXRlU2VsZWN0aW9uOiBmdW5jdGlvbihzcGFuMCwgc3BhbjEpIHtcblx0XHR2YXIgc3BhbiA9IHRoaXMuY29tcHV0ZVNlbGVjdGlvblNwYW4oc3BhbjAsIHNwYW4xKTtcblxuXHRcdGlmIChzcGFuICYmICF0aGlzLnZpZXcuY2FsZW5kYXIuaXNTZWxlY3Rpb25TcGFuQWxsb3dlZChzcGFuKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiBzcGFuO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gdHdvIHNwYW5zLCBtdXN0IHJldHVybiB0aGUgY29tYmluYXRpb24gb2YgdGhlIHR3by5cblx0Ly8gVE9ETzogZG8gdGhpcyBzZXBhcmF0aW9uIG9mIGNvbmNlcm5zIChjb21iaW5pbmcgVlMgdmFsaWRhdGlvbikgZm9yIGV2ZW50IGRuZC9yZXNpemUgdG9vLlxuXHRjb21wdXRlU2VsZWN0aW9uU3BhbjogZnVuY3Rpb24oc3BhbjAsIHNwYW4xKSB7XG5cdFx0dmFyIGRhdGVzID0gWyBzcGFuMC5zdGFydCwgc3BhbjAuZW5kLCBzcGFuMS5zdGFydCwgc3BhbjEuZW5kIF07XG5cblx0XHRkYXRlcy5zb3J0KGNvbXBhcmVOdW1iZXJzKTsgLy8gc29ydHMgY2hyb25vbG9naWNhbGx5LiB3b3JrcyB3aXRoIE1vbWVudHNcblxuXHRcdHJldHVybiB7IHN0YXJ0OiBkYXRlc1swXS5jbG9uZSgpLCBlbmQ6IGRhdGVzWzNdLmNsb25lKCkgfTtcblx0fSxcblxuXG5cdC8qIEhpZ2hsaWdodFxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhbiBlbXBoYXNpcyBvbiB0aGUgZ2l2ZW4gZGF0ZSByYW5nZS4gR2l2ZW4gYSBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgb3RoZXIgbWlzYyBkYXRhKVxuXHRyZW5kZXJIaWdobGlnaHQ6IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHR0aGlzLnJlbmRlckZpbGwoJ2hpZ2hsaWdodCcsIHRoaXMuc3BhblRvU2VncyhzcGFuKSk7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgdGhlIGVtcGhhc2lzIG9uIGEgZGF0ZSByYW5nZVxuXHR1bnJlbmRlckhpZ2hsaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckZpbGwoJ2hpZ2hsaWdodCcpO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIGFuIGFycmF5IG9mIGNsYXNzTmFtZXMgZm9yIHJlbmRlcmluZyB0aGUgaGlnaGxpZ2h0LiBVc2VkIGJ5IHRoZSBmaWxsIHN5c3RlbS5cblx0aGlnaGxpZ2h0U2VnQ2xhc3NlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFsgJ2ZjLWhpZ2hsaWdodCcgXTtcblx0fSxcblxuXG5cdC8qIEJ1c2luZXNzIEhvdXJzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdHVucmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdH0sXG5cblxuXHQvKiBOb3cgSW5kaWNhdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRnZXROb3dJbmRpY2F0b3JVbml0OiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdHJlbmRlck5vd0luZGljYXRvcjogZnVuY3Rpb24oZGF0ZSkge1xuXHR9LFxuXG5cblx0dW5yZW5kZXJOb3dJbmRpY2F0b3I6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cblx0LyogRmlsbCBTeXN0ZW0gKGhpZ2hsaWdodCwgYmFja2dyb3VuZCBldmVudHMsIGJ1c2luZXNzIGhvdXJzKVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRUT0RPOiByZW1vdmUgdGhpcyBzeXN0ZW0uIGxpa2Ugd2UgZGlkIGluIFRpbWVHcmlkXG5cdCovXG5cblxuXHQvLyBSZW5kZXJzIGEgc2V0IG9mIHJlY3RhbmdsZXMgb3ZlciB0aGUgZ2l2ZW4gc2VnbWVudHMgb2YgdGltZS5cblx0Ly8gTVVTVCBSRVRVUk4gYSBzdWJzZXQgb2Ygc2VncywgdGhlIHNlZ3MgdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkLlxuXHQvLyBSZXNwb25zaWJsZSBmb3IgcG9wdWxhdGluZyB0aGlzLmVsc0J5RmlsbC4gVE9ETzogYmV0dGVyIEFQSSBmb3IgZXhwcmVzc2luZyB0aGlzIHJlcXVpcmVtZW50XG5cdHJlbmRlckZpbGw6IGZ1bmN0aW9uKHR5cGUsIHNlZ3MpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYSBzcGVjaWZpYyB0eXBlIG9mIGZpbGwgdGhhdCBpcyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcblx0dW5yZW5kZXJGaWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0dmFyIGVsID0gdGhpcy5lbHNCeUZpbGxbdHlwZV07XG5cblx0XHRpZiAoZWwpIHtcblx0XHRcdGVsLnJlbW92ZSgpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuZWxzQnlGaWxsW3R5cGVdO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgYW5kIGFzc2lnbnMgYW4gYGVsYCBwcm9wZXJ0eSBmb3IgZWFjaCBmaWxsIHNlZ21lbnQuIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBkaWZmZXJlbnQgdHlwZXMuXG5cdC8vIE9ubHkgcmV0dXJucyBzZWdtZW50cyB0aGF0IHN1Y2Nlc3NmdWxseSByZW5kZXJlZC5cblx0Ly8gVG8gYmUgaGFybmVzc2VkIGJ5IHJlbmRlckZpbGwgKGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMpLlxuXHQvLyBBbmFsYWdvdXMgdG8gcmVuZGVyRmdTZWdFbHMuXG5cdHJlbmRlckZpbGxTZWdFbHM6IGZ1bmN0aW9uKHR5cGUsIHNlZ3MpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBzZWdFbE1ldGhvZCA9IHRoaXNbdHlwZSArICdTZWdFbCddO1xuXHRcdHZhciBodG1sID0gJyc7XG5cdFx0dmFyIHJlbmRlcmVkU2VncyA9IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKHNlZ3MubGVuZ3RoKSB7XG5cblx0XHRcdC8vIGJ1aWxkIGEgbGFyZ2UgY29uY2F0ZW5hdGlvbiBvZiBzZWdtZW50IEhUTUxcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGh0bWwgKz0gdGhpcy5maWxsU2VnSHRtbCh0eXBlLCBzZWdzW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXG5cdFx0XHQvLyBUaGVuLCBjb21wdXRlIHRoZSAnZWwnIGZvciBlYWNoIHNlZ21lbnQuXG5cdFx0XHQkKGh0bWwpLmVhY2goZnVuY3Rpb24oaSwgbm9kZSkge1xuXHRcdFx0XHR2YXIgc2VnID0gc2Vnc1tpXTtcblx0XHRcdFx0dmFyIGVsID0gJChub2RlKTtcblxuXHRcdFx0XHQvLyBhbGxvdyBjdXN0b20gZmlsdGVyIG1ldGhvZHMgcGVyLXR5cGVcblx0XHRcdFx0aWYgKHNlZ0VsTWV0aG9kKSB7XG5cdFx0XHRcdFx0ZWwgPSBzZWdFbE1ldGhvZC5jYWxsKF90aGlzLCBzZWcsIGVsKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChlbCkgeyAvLyBjdXN0b20gZmlsdGVycyBkaWQgbm90IGNhbmNlbCB0aGUgcmVuZGVyXG5cdFx0XHRcdFx0ZWwgPSAkKGVsKTsgLy8gYWxsb3cgY3VzdG9tIGZpbHRlciB0byByZXR1cm4gcmF3IERPTSBub2RlXG5cblx0XHRcdFx0XHQvLyBjb3JyZWN0IGVsZW1lbnQgdHlwZT8gKHdvdWxkIGJlIGJhZCBpZiBhIG5vbi1URCB3ZXJlIGluc2VydGVkIGludG8gYSB0YWJsZSBmb3IgZXhhbXBsZSlcblx0XHRcdFx0XHRpZiAoZWwuaXMoX3RoaXMuZmlsbFNlZ1RhZykpIHtcblx0XHRcdFx0XHRcdHNlZy5lbCA9IGVsO1xuXHRcdFx0XHRcdFx0cmVuZGVyZWRTZWdzLnB1c2goc2VnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiByZW5kZXJlZFNlZ3M7XG5cdH0sXG5cblxuXHRmaWxsU2VnVGFnOiAnZGl2JywgLy8gc3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGVcblxuXG5cdC8vIEJ1aWxkcyB0aGUgSFRNTCBuZWVkZWQgZm9yIG9uZSBmaWxsIHNlZ21lbnQuIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBkaWZmZXJlbnQgdHlwZXMuXG5cdGZpbGxTZWdIdG1sOiBmdW5jdGlvbih0eXBlLCBzZWcpIHtcblxuXHRcdC8vIGN1c3RvbSBob29rcyBwZXItdHlwZVxuXHRcdHZhciBjbGFzc2VzTWV0aG9kID0gdGhpc1t0eXBlICsgJ1NlZ0NsYXNzZXMnXTtcblx0XHR2YXIgY3NzTWV0aG9kID0gdGhpc1t0eXBlICsgJ1NlZ0NzcyddO1xuXG5cdFx0dmFyIGNsYXNzZXMgPSBjbGFzc2VzTWV0aG9kID8gY2xhc3Nlc01ldGhvZC5jYWxsKHRoaXMsIHNlZykgOiBbXTtcblx0XHR2YXIgY3NzID0gY3NzVG9TdHIoY3NzTWV0aG9kID8gY3NzTWV0aG9kLmNhbGwodGhpcywgc2VnKSA6IHt9KTtcblxuXHRcdHJldHVybiAnPCcgKyB0aGlzLmZpbGxTZWdUYWcgK1xuXHRcdFx0KGNsYXNzZXMubGVuZ3RoID8gJyBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgOiAnJykgK1xuXHRcdFx0KGNzcyA/ICcgc3R5bGU9XCInICsgY3NzICsgJ1wiJyA6ICcnKSArXG5cdFx0XHQnIC8+Jztcblx0fSxcblxuXG5cblx0LyogR2VuZXJpYyByZW5kZXJpbmcgdXRpbGl0aWVzIGZvciBzdWJjbGFzc2VzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBDb21wdXRlcyBIVE1MIGNsYXNzTmFtZXMgZm9yIGEgc2luZ2xlLWRheSBlbGVtZW50XG5cdGdldERheUNsYXNzZXM6IGZ1bmN0aW9uKGRhdGUsIG5vVGhlbWVIaWdobGlnaHQpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXHRcdHZhciB0b2RheTtcblxuXHRcdGlmICghaXNEYXRlV2l0aGluUmFuZ2UoZGF0ZSwgdmlldy5hY3RpdmVSYW5nZSkpIHtcblx0XHRcdGNsYXNzZXMucHVzaCgnZmMtZGlzYWJsZWQtZGF5Jyk7IC8vIFRPRE86IGpRdWVyeSBVSSB0aGVtZT9cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2ZjLScgKyBkYXlJRHNbZGF0ZS5kYXkoKV0pO1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHZpZXcuY3VycmVudFJhbmdlQXMoJ21vbnRocycpID09IDEgJiYgLy8gVE9ETzogc29tZWhvdyBnZXQgaW50byBNb250aFZpZXdcblx0XHRcdFx0ZGF0ZS5tb250aCgpICE9IHZpZXcuY3VycmVudFJhbmdlLnN0YXJ0Lm1vbnRoKClcblx0XHRcdCkge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goJ2ZjLW90aGVyLW1vbnRoJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRvZGF5ID0gdmlldy5jYWxlbmRhci5nZXROb3coKTtcblxuXHRcdFx0aWYgKGRhdGUuaXNTYW1lKHRvZGF5LCAnZGF5JykpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKCdmYy10b2RheScpO1xuXG5cdFx0XHRcdGlmIChub1RoZW1lSGlnaGxpZ2h0ICE9PSB0cnVlKSB7XG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKHZpZXcuaGlnaGxpZ2h0U3RhdGVDbGFzcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGRhdGUgPCB0b2RheSkge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goJ2ZjLXBhc3QnKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goJ2ZjLWZ1dHVyZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzO1xuXHR9XG5cbn0pO1xuXG47O1xuXG4vKiBFdmVudC1yZW5kZXJpbmcgYW5kIGV2ZW50LWludGVyYWN0aW9uIG1ldGhvZHMgZm9yIHRoZSBhYnN0cmFjdCBHcmlkIGNsYXNzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkRhdGEgVHlwZXM6XG5cdGV2ZW50IC0geyB0aXRsZSwgaWQsIHN0YXJ0LCAoZW5kKSwgd2hhdGV2ZXIgfVxuXHRsb2NhdGlvbiAtIHsgc3RhcnQsIChlbmQpLCBhbGxEYXkgfVxuXHRyYXdFdmVudFJhbmdlIC0geyBzdGFydCwgZW5kIH1cblx0ZXZlbnRSYW5nZSAtIHsgc3RhcnQsIGVuZCwgaXNTdGFydCwgaXNFbmQgfVxuXHRldmVudFNwYW4gLSB7IHN0YXJ0LCBlbmQsIGlzU3RhcnQsIGlzRW5kLCB3aGF0ZXZlciB9XG5cdGV2ZW50U2VnIC0geyBldmVudCwgd2hhdGV2ZXIgfVxuXHRzZWcgLSB7IHdoYXRldmVyIH1cbiovXG5cbkdyaWQubWl4aW4oe1xuXG5cdC8vIHNlbGYtY29uZmlnLCBvdmVycmlkYWJsZSBieSBzdWJjbGFzc2VzXG5cdHNlZ1NlbGVjdG9yOiAnLmZjLWV2ZW50LWNvbnRhaW5lciA+IConLCAvLyB3aGF0IGNvbnN0aXR1dGVzIGFuIGV2ZW50IGVsZW1lbnQ/XG5cblx0bW91c2VkT3ZlclNlZzogbnVsbCwgLy8gdGhlIHNlZ21lbnQgb2JqZWN0IHRoZSB1c2VyJ3MgbW91c2UgaXMgb3Zlci4gbnVsbCBpZiBvdmVyIG5vdGhpbmdcblx0aXNEcmFnZ2luZ1NlZzogZmFsc2UsIC8vIGlzIGEgc2VnbWVudCBiZWluZyBkcmFnZ2VkPyBib29sZWFuXG5cdGlzUmVzaXppbmdTZWc6IGZhbHNlLCAvLyBpcyBhIHNlZ21lbnQgYmVpbmcgcmVzaXplZD8gYm9vbGVhblxuXHRpc0RyYWdnaW5nRXh0ZXJuYWw6IGZhbHNlLCAvLyBqcXVpLWRyYWdnaW5nIGFuIGV4dGVybmFsIGVsZW1lbnQ/IGJvb2xlYW5cblx0c2VnczogbnVsbCwgLy8gdGhlICpldmVudCogc2VnbWVudHMgY3VycmVudGx5IHJlbmRlcmVkIGluIHRoZSBncmlkLiBUT0RPOiByZW5hbWUgdG8gYGV2ZW50U2Vnc2BcblxuXG5cdC8vIFJlbmRlcnMgdGhlIGdpdmVuIGV2ZW50cyBvbnRvIHRoZSBncmlkXG5cdHJlbmRlckV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0dmFyIGJnRXZlbnRzID0gW107XG5cdFx0dmFyIGZnRXZlbnRzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQoaXNCZ0V2ZW50KGV2ZW50c1tpXSkgPyBiZ0V2ZW50cyA6IGZnRXZlbnRzKS5wdXNoKGV2ZW50c1tpXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZWdzID0gW10uY29uY2F0KCAvLyByZWNvcmQgYWxsIHNlZ3Ncblx0XHRcdHRoaXMucmVuZGVyQmdFdmVudHMoYmdFdmVudHMpLFxuXHRcdFx0dGhpcy5yZW5kZXJGZ0V2ZW50cyhmZ0V2ZW50cylcblx0XHQpO1xuXHR9LFxuXG5cblx0cmVuZGVyQmdFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdHZhciBzZWdzID0gdGhpcy5ldmVudHNUb1NlZ3MoZXZlbnRzKTtcblxuXHRcdC8vIHJlbmRlckJnU2VncyBtaWdodCByZXR1cm4gYSBzdWJzZXQgb2Ygc2Vncywgc2VncyB0aGF0IHdlcmUgYWN0dWFsbHkgcmVuZGVyZWRcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJCZ1NlZ3Moc2VncykgfHwgc2Vncztcblx0fSxcblxuXG5cdHJlbmRlckZnRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcblx0XHR2YXIgc2VncyA9IHRoaXMuZXZlbnRzVG9TZWdzKGV2ZW50cyk7XG5cblx0XHQvLyByZW5kZXJGZ1NlZ3MgbWlnaHQgcmV0dXJuIGEgc3Vic2V0IG9mIHNlZ3MsIHNlZ3MgdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkXG5cdFx0cmV0dXJuIHRoaXMucmVuZGVyRmdTZWdzKHNlZ3MpIHx8IHNlZ3M7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYWxsIGV2ZW50cyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcblx0dW5yZW5kZXJFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGFuZGxlU2VnTW91c2VvdXQoKTsgLy8gdHJpZ2dlciBhbiBldmVudE1vdXNlb3V0IGlmIHVzZXIncyBtb3VzZSBpcyBvdmVyIGFuIGV2ZW50XG5cdFx0dGhpcy5jbGVhckRyYWdMaXN0ZW5lcnMoKTtcblxuXHRcdHRoaXMudW5yZW5kZXJGZ1NlZ3MoKTtcblx0XHR0aGlzLnVucmVuZGVyQmdTZWdzKCk7XG5cblx0XHR0aGlzLnNlZ3MgPSBudWxsO1xuXHR9LFxuXG5cblx0Ly8gUmV0cmlldmVzIGFsbCByZW5kZXJlZCBzZWdtZW50IG9iamVjdHMgY3VycmVudGx5IHJlbmRlcmVkIG9uIHRoZSBncmlkXG5cdGdldEV2ZW50U2VnczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VncyB8fCBbXTtcblx0fSxcblxuXG5cdC8qIEZvcmVncm91bmQgU2VnbWVudCBSZW5kZXJpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50cyBvbnRvIHRoZSBncmlkLiBNYXkgcmV0dXJuIGEgc3Vic2V0IG9mIHNlZ3MgdGhhdCB3ZXJlIHJlbmRlcmVkLlxuXHRyZW5kZXJGZ1NlZ3M6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYWxsIGN1cnJlbnRseSByZW5kZXJlZCBmb3JlZ3JvdW5kIHNlZ21lbnRzXG5cdHVucmVuZGVyRmdTZWdzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIGFuZCBhc3NpZ25zIGFuIGBlbGAgcHJvcGVydHkgZm9yIGVhY2ggZm9yZWdyb3VuZCBldmVudCBzZWdtZW50LlxuXHQvLyBPbmx5IHJldHVybnMgc2VnbWVudHMgdGhhdCBzdWNjZXNzZnVsbHkgcmVuZGVyZWQuXG5cdC8vIEEgdXRpbGl0eSB0aGF0IHN1YmNsYXNzZXMgbWF5IHVzZS5cblx0cmVuZGVyRmdTZWdFbHM6IGZ1bmN0aW9uKHNlZ3MsIGRpc2FibGVSZXNpemluZykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBodG1sID0gJyc7XG5cdFx0dmFyIHJlbmRlcmVkU2VncyA9IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKHNlZ3MubGVuZ3RoKSB7IC8vIGRvbid0IGJ1aWxkIGFuIGVtcHR5IGh0bWwgc3RyaW5nXG5cblx0XHRcdC8vIGJ1aWxkIGEgbGFyZ2UgY29uY2F0ZW5hdGlvbiBvZiBldmVudCBzZWdtZW50IEhUTUxcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGh0bWwgKz0gdGhpcy5mZ1NlZ0h0bWwoc2Vnc1tpXSwgZGlzYWJsZVJlc2l6aW5nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXG5cdFx0XHQvLyBUaGVuLCBjb21wdXRlIHRoZSAnZWwnIGZvciBlYWNoIHNlZ21lbnQuIEFuIGVsIG1pZ2h0IGJlIG51bGwgaWYgdGhlIGV2ZW50UmVuZGVyIGNhbGxiYWNrIHJldHVybmVkIGZhbHNlLlxuXHRcdFx0JChodG1sKS5lYWNoKGZ1bmN0aW9uKGksIG5vZGUpIHtcblx0XHRcdFx0dmFyIHNlZyA9IHNlZ3NbaV07XG5cdFx0XHRcdHZhciBlbCA9IHZpZXcucmVzb2x2ZUV2ZW50RWwoc2VnLmV2ZW50LCAkKG5vZGUpKTtcblxuXHRcdFx0XHRpZiAoZWwpIHtcblx0XHRcdFx0XHRlbC5kYXRhKCdmYy1zZWcnLCBzZWcpOyAvLyB1c2VkIGJ5IGhhbmRsZXJzXG5cdFx0XHRcdFx0c2VnLmVsID0gZWw7XG5cdFx0XHRcdFx0cmVuZGVyZWRTZWdzLnB1c2goc2VnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlbmRlcmVkU2Vncztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIG9mIGEgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50LiBVc2VkIGJ5IHJlbmRlckZnU2VnRWxzKClcblx0ZmdTZWdIdG1sOiBmdW5jdGlvbihzZWcsIGRpc2FibGVSZXNpemluZykge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogQmFja2dyb3VuZCBTZWdtZW50IFJlbmRlcmluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyB0aGUgZ2l2ZW4gYmFja2dyb3VuZCBldmVudCBzZWdtZW50cyBvbnRvIHRoZSBncmlkLlxuXHQvLyBSZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBzZWdzIHRoYXQgd2VyZSBhY3R1YWxseSByZW5kZXJlZC5cblx0cmVuZGVyQmdTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVuZGVyRmlsbCgnYmdFdmVudCcsIHNlZ3MpO1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFsbCB0aGUgY3VycmVudGx5IHJlbmRlcmVkIGJhY2tncm91bmQgZXZlbnQgc2VnbWVudHNcblx0dW5yZW5kZXJCZ1NlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJGaWxsKCdiZ0V2ZW50Jyk7XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIGEgYmFja2dyb3VuZCBldmVudCBlbGVtZW50LCBnaXZlbiB0aGUgZGVmYXVsdCByZW5kZXJpbmcuIENhbGxlZCBieSB0aGUgZmlsbCBzeXN0ZW0uXG5cdGJnRXZlbnRTZWdFbDogZnVuY3Rpb24oc2VnLCBlbCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXcucmVzb2x2ZUV2ZW50RWwoc2VnLmV2ZW50LCBlbCk7IC8vIHdpbGwgZmlsdGVyIHRocm91Z2ggZXZlbnRSZW5kZXJcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyBhbiBhcnJheSBvZiBjbGFzc05hbWVzIHRvIGJlIHVzZWQgZm9yIHRoZSBkZWZhdWx0IHJlbmRlcmluZyBvZiBhIGJhY2tncm91bmQgZXZlbnQuXG5cdC8vIENhbGxlZCBieSBmaWxsU2VnSHRtbC5cblx0YmdFdmVudFNlZ0NsYXNzZXM6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHZhciBldmVudCA9IHNlZy5ldmVudDtcblx0XHR2YXIgc291cmNlID0gZXZlbnQuc291cmNlIHx8IHt9O1xuXG5cdFx0cmV0dXJuIFsgJ2ZjLWJnZXZlbnQnIF0uY29uY2F0KFxuXHRcdFx0ZXZlbnQuY2xhc3NOYW1lLFxuXHRcdFx0c291cmNlLmNsYXNzTmFtZSB8fCBbXVxuXHRcdCk7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgYSBzZW1pY29sb24tc2VwYXJhdGVkIENTUyBzdHJpbmcgdG8gYmUgdXNlZCBmb3IgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIG9mIGEgYmFja2dyb3VuZCBldmVudC5cblx0Ly8gQ2FsbGVkIGJ5IGZpbGxTZWdIdG1sLlxuXHRiZ0V2ZW50U2VnQ3NzOiBmdW5jdGlvbihzZWcpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0J2JhY2tncm91bmQtY29sb3InOiB0aGlzLmdldFNlZ1NraW5Dc3Moc2VnKVsnYmFja2dyb3VuZC1jb2xvciddXG5cdFx0fTtcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyBhbiBhcnJheSBvZiBjbGFzc05hbWVzIHRvIGJlIHVzZWQgZm9yIHRoZSByZW5kZXJpbmcgYnVzaW5lc3MgaG91cnMgb3ZlcmxheS4gQ2FsbGVkIGJ5IHRoZSBmaWxsIHN5c3RlbS5cblx0Ly8gQ2FsbGVkIGJ5IGZpbGxTZWdIdG1sLlxuXHRidXNpbmVzc0hvdXJzU2VnQ2xhc3NlczogZnVuY3Rpb24oc2VnKSB7XG5cdFx0cmV0dXJuIFsgJ2ZjLW5vbmJ1c2luZXNzJywgJ2ZjLWJnZXZlbnQnIF07XG5cdH0sXG5cblxuXHQvKiBCdXNpbmVzcyBIb3Vyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ29tcHV0ZSBidXNpbmVzcyBob3VyIHNlZ3MgZm9yIHRoZSBncmlkJ3MgY3VycmVudCBkYXRlIHJhbmdlLlxuXHQvLyBDYWxsZXIgbXVzdCBhc2sgaWYgd2hvbGUtZGF5IGJ1c2luZXNzIGhvdXJzIGFyZSBuZWVkZWQuXG5cdC8vIElmIG5vIGBidXNpbmVzc0hvdXJzYCBjb25maWd1cmF0aW9uIHZhbHVlIGlzIHNwZWNpZmllZCwgYXNzdW1lcyB0aGUgY2FsZW5kYXIgZGVmYXVsdC5cblx0YnVpbGRCdXNpbmVzc0hvdXJTZWdzOiBmdW5jdGlvbih3aG9sZURheSwgYnVzaW5lc3NIb3Vycykge1xuXHRcdHJldHVybiB0aGlzLmV2ZW50c1RvU2Vncyhcblx0XHRcdHRoaXMuYnVpbGRCdXNpbmVzc0hvdXJFdmVudHMod2hvbGVEYXksIGJ1c2luZXNzSG91cnMpXG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGUgYnVzaW5lc3MgaG91ciAqZXZlbnRzKiBmb3IgdGhlIGdyaWQncyBjdXJyZW50IGRhdGUgcmFuZ2UuXG5cdC8vIENhbGxlciBtdXN0IGFzayBpZiB3aG9sZS1kYXkgYnVzaW5lc3MgaG91cnMgYXJlIG5lZWRlZC5cblx0Ly8gSWYgbm8gYGJ1c2luZXNzSG91cnNgIGNvbmZpZ3VyYXRpb24gdmFsdWUgaXMgc3BlY2lmaWVkLCBhc3N1bWVzIHRoZSBjYWxlbmRhciBkZWZhdWx0LlxuXHRidWlsZEJ1c2luZXNzSG91ckV2ZW50czogZnVuY3Rpb24od2hvbGVEYXksIGJ1c2luZXNzSG91cnMpIHtcblx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XG5cdFx0dmFyIGV2ZW50cztcblxuXHRcdGlmIChidXNpbmVzc0hvdXJzID09IG51bGwpIHtcblx0XHRcdC8vIGZhbGxiYWNrXG5cdFx0XHQvLyBhY2Nlc3MgZnJvbSBjYWxlbmRhd3IuIGRvbid0IGFjY2VzcyBmcm9tIHZpZXcuIGRvZXNuJ3QgdXBkYXRlIHdpdGggZHluYW1pYyBvcHRpb25zLlxuXHRcdFx0YnVzaW5lc3NIb3VycyA9IGNhbGVuZGFyLm9wdCgnYnVzaW5lc3NIb3VycycpO1xuXHRcdH1cblxuXHRcdGV2ZW50cyA9IGNhbGVuZGFyLmNvbXB1dGVCdXNpbmVzc0hvdXJFdmVudHMod2hvbGVEYXksIGJ1c2luZXNzSG91cnMpO1xuXG5cdFx0Ly8gSEFDSy4gRXZlbnR1YWxseSByZWZhY3RvciBidXNpbmVzcyBob3VycyBcImV2ZW50c1wiIHN5c3RlbS5cblx0XHQvLyBJZiBubyBldmVudHMgYXJlIGdpdmVuLCBidXQgYnVzaW5lc3NIb3VycyBpcyBhY3RpdmF0ZWQsIHRoaXMgbWVhbnMgdGhlIGVudGlyZSB2aXNpYmxlIHJhbmdlIHNob3VsZCBiZVxuXHRcdC8vIG1hcmtlZCBhcyAqbm90KiBidXNpbmVzcy1ob3VycywgdmlhIGludmVyc2UtYmFja2dyb3VuZCByZW5kZXJpbmcuXG5cdFx0aWYgKCFldmVudHMubGVuZ3RoICYmIGJ1c2luZXNzSG91cnMpIHtcblx0XHRcdGV2ZW50cyA9IFtcblx0XHRcdFx0JC5leHRlbmQoe30sIEJVU0lORVNTX0hPVVJfRVZFTlRfREVGQVVMVFMsIHtcblx0XHRcdFx0XHRzdGFydDogdGhpcy52aWV3LmFjdGl2ZVJhbmdlLmVuZCwgLy8gZ3VhcmFudGVlZCBvdXQtb2YtcmFuZ2Vcblx0XHRcdFx0XHRlbmQ6IHRoaXMudmlldy5hY3RpdmVSYW5nZS5lbmQsICAgLy8gXCJcblx0XHRcdFx0XHRkb3c6IG51bGxcblx0XHRcdFx0fSlcblx0XHRcdF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXG5cdC8qIEhhbmRsZXJzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBBdHRhY2hlcyBldmVudC1lbGVtZW50LXJlbGF0ZWQgaGFuZGxlcnMgZm9yICphbGwqIHJlbmRlcmVkIGV2ZW50IHNlZ21lbnRzIG9mIHRoZSB2aWV3LlxuXHRiaW5kU2VnSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYmluZFNlZ0hhbmRsZXJzVG9FbCh0aGlzLmVsKTtcblx0fSxcblxuXG5cdC8vIEF0dGFjaGVzIGV2ZW50LWVsZW1lbnQtcmVsYXRlZCBoYW5kbGVycyB0byBhbiBhcmJpdHJhcnkgY29udGFpbmVyIGVsZW1lbnQuIGxldmVyYWdlcyBidWJibGluZy5cblx0YmluZFNlZ0hhbmRsZXJzVG9FbDogZnVuY3Rpb24oZWwpIHtcblx0XHR0aGlzLmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVNlZ1RvdWNoU3RhcnQpO1xuXHRcdHRoaXMuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnbW91c2VlbnRlcicsIHRoaXMuaGFuZGxlU2VnTW91c2VvdmVyKTtcblx0XHR0aGlzLmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ21vdXNlbGVhdmUnLCB0aGlzLmhhbmRsZVNlZ01vdXNlb3V0KTtcblx0XHR0aGlzLmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlU2VnTW91c2Vkb3duKTtcblx0XHR0aGlzLmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ2NsaWNrJywgdGhpcy5oYW5kbGVTZWdDbGljayk7XG5cdH0sXG5cblxuXHQvLyBFeGVjdXRlcyBhIGhhbmRsZXIgZm9yIGFueSBhIHVzZXItaW50ZXJhY3Rpb24gb24gYSBzZWdtZW50LlxuXHQvLyBIYW5kbGVyIGdldHMgY2FsbGVkIHdpdGggKHNlZywgZXYpLCBhbmQgd2l0aCB0aGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIEdyaWRcblx0YmluZFNlZ0hhbmRsZXJUb0VsOiBmdW5jdGlvbihlbCwgbmFtZSwgaGFuZGxlcikge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHRlbC5vbihuYW1lLCB0aGlzLnNlZ1NlbGVjdG9yLCBmdW5jdGlvbihldikge1xuXHRcdFx0dmFyIHNlZyA9ICQodGhpcykuZGF0YSgnZmMtc2VnJyk7IC8vIGdyYWIgc2VnbWVudCBkYXRhLiBwdXQgdGhlcmUgYnkgVmlldzo6cmVuZGVyRXZlbnRzXG5cblx0XHRcdC8vIG9ubHkgY2FsbCB0aGUgaGFuZGxlcnMgaWYgdGhlcmUgaXMgbm90IGEgZHJhZy9yZXNpemUgaW4gcHJvZ3Jlc3Ncblx0XHRcdGlmIChzZWcgJiYgIV90aGlzLmlzRHJhZ2dpbmdTZWcgJiYgIV90aGlzLmlzUmVzaXppbmdTZWcpIHtcblx0XHRcdFx0cmV0dXJuIGhhbmRsZXIuY2FsbChfdGhpcywgc2VnLCBldik7IC8vIGNvbnRleHQgd2lsbCBiZSB0aGUgR3JpZFxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cblx0aGFuZGxlU2VnQ2xpY2s6IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHR2YXIgcmVzID0gdGhpcy52aWV3LnB1YmxpY2x5VHJpZ2dlcignZXZlbnRDbGljaycsIHNlZy5lbFswXSwgc2VnLmV2ZW50LCBldik7IC8vIGNhbiByZXR1cm4gYGZhbHNlYCB0byBjYW5jZWxcblx0XHRpZiAocmVzID09PSBmYWxzZSkge1xuXHRcdFx0ZXYucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBVcGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycyBmb3Igd2hlbiBhbiBldmVudCBlbGVtZW50IGlzIG1vdXNlZCBvdmVyXG5cdGhhbmRsZVNlZ01vdXNlb3ZlcjogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdGlmIChcblx0XHRcdCFHbG9iYWxFbWl0dGVyLmdldCgpLnNob3VsZElnbm9yZU1vdXNlKCkgJiZcblx0XHRcdCF0aGlzLm1vdXNlZE92ZXJTZWdcblx0XHQpIHtcblx0XHRcdHRoaXMubW91c2VkT3ZlclNlZyA9IHNlZztcblx0XHRcdGlmICh0aGlzLnZpZXcuaXNFdmVudFJlc2l6YWJsZShzZWcuZXZlbnQpKSB7XG5cdFx0XHRcdHNlZy5lbC5hZGRDbGFzcygnZmMtYWxsb3ctbW91c2UtcmVzaXplJyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnZpZXcucHVibGljbHlUcmlnZ2VyKCdldmVudE1vdXNlb3ZlcicsIHNlZy5lbFswXSwgc2VnLmV2ZW50LCBldik7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMgZm9yIHdoZW4gYW4gZXZlbnQgZWxlbWVudCBpcyBtb3VzZWQgb3V0LlxuXHQvLyBDYW4gYmUgZ2l2ZW4gbm8gYXJndW1lbnRzLCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgbW91c2VvdXQgdGhlIHNlZ21lbnQgdGhhdCB3YXMgcHJldmlvdXNseSBtb3VzZWQgb3Zlci5cblx0aGFuZGxlU2VnTW91c2VvdXQ6IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHRldiA9IGV2IHx8IHt9OyAvLyBpZiBnaXZlbiBubyBhcmdzLCBtYWtlIGEgbW9jayBtb3VzZSBldmVudFxuXG5cdFx0aWYgKHRoaXMubW91c2VkT3ZlclNlZykge1xuXHRcdFx0c2VnID0gc2VnIHx8IHRoaXMubW91c2VkT3ZlclNlZzsgLy8gaWYgZ2l2ZW4gbm8gYXJncywgdXNlIHRoZSBjdXJyZW50bHkgbW91c2VkLW92ZXIgc2VnbWVudFxuXHRcdFx0dGhpcy5tb3VzZWRPdmVyU2VnID0gbnVsbDtcblx0XHRcdGlmICh0aGlzLnZpZXcuaXNFdmVudFJlc2l6YWJsZShzZWcuZXZlbnQpKSB7XG5cdFx0XHRcdHNlZy5lbC5yZW1vdmVDbGFzcygnZmMtYWxsb3ctbW91c2UtcmVzaXplJyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnZpZXcucHVibGljbHlUcmlnZ2VyKCdldmVudE1vdXNlb3V0Jywgc2VnLmVsWzBdLCBzZWcuZXZlbnQsIGV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHRoYW5kbGVTZWdNb3VzZWRvd246IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHR2YXIgaXNSZXNpemluZyA9IHRoaXMuc3RhcnRTZWdSZXNpemUoc2VnLCBldiwgeyBkaXN0YW5jZTogNSB9KTtcblxuXHRcdGlmICghaXNSZXNpemluZyAmJiB0aGlzLnZpZXcuaXNFdmVudERyYWdnYWJsZShzZWcuZXZlbnQpKSB7XG5cdFx0XHR0aGlzLmJ1aWxkU2VnRHJhZ0xpc3RlbmVyKHNlZylcblx0XHRcdFx0LnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHtcblx0XHRcdFx0XHRkaXN0YW5jZTogNVxuXHRcdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblxuXHRoYW5kbGVTZWdUb3VjaFN0YXJ0OiBmdW5jdGlvbihzZWcsIGV2KSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGV2ZW50ID0gc2VnLmV2ZW50O1xuXHRcdHZhciBpc1NlbGVjdGVkID0gdmlldy5pc0V2ZW50U2VsZWN0ZWQoZXZlbnQpO1xuXHRcdHZhciBpc0RyYWdnYWJsZSA9IHZpZXcuaXNFdmVudERyYWdnYWJsZShldmVudCk7XG5cdFx0dmFyIGlzUmVzaXphYmxlID0gdmlldy5pc0V2ZW50UmVzaXphYmxlKGV2ZW50KTtcblx0XHR2YXIgaXNSZXNpemluZyA9IGZhbHNlO1xuXHRcdHZhciBkcmFnTGlzdGVuZXI7XG5cdFx0dmFyIGV2ZW50TG9uZ1ByZXNzRGVsYXk7XG5cblx0XHRpZiAoaXNTZWxlY3RlZCAmJiBpc1Jlc2l6YWJsZSkge1xuXHRcdFx0Ly8gb25seSBhbGxvdyByZXNpemluZyBvZiB0aGUgZXZlbnQgaXMgc2VsZWN0ZWRcblx0XHRcdGlzUmVzaXppbmcgPSB0aGlzLnN0YXJ0U2VnUmVzaXplKHNlZywgZXYpO1xuXHRcdH1cblxuXHRcdGlmICghaXNSZXNpemluZyAmJiAoaXNEcmFnZ2FibGUgfHwgaXNSZXNpemFibGUpKSB7IC8vIGFsbG93ZWQgdG8gYmUgc2VsZWN0ZWQ/XG5cblx0XHRcdGV2ZW50TG9uZ1ByZXNzRGVsYXkgPSB2aWV3Lm9wdCgnZXZlbnRMb25nUHJlc3NEZWxheScpO1xuXHRcdFx0aWYgKGV2ZW50TG9uZ1ByZXNzRGVsYXkgPT0gbnVsbCkge1xuXHRcdFx0XHRldmVudExvbmdQcmVzc0RlbGF5ID0gdmlldy5vcHQoJ2xvbmdQcmVzc0RlbGF5Jyk7IC8vIGZhbGxiYWNrXG5cdFx0XHR9XG5cblx0XHRcdGRyYWdMaXN0ZW5lciA9IGlzRHJhZ2dhYmxlID9cblx0XHRcdFx0dGhpcy5idWlsZFNlZ0RyYWdMaXN0ZW5lcihzZWcpIDpcblx0XHRcdFx0dGhpcy5idWlsZFNlZ1NlbGVjdExpc3RlbmVyKHNlZyk7IC8vIHNlZyBpc24ndCBkcmFnZ2FibGUsIGJ1dCBzdGlsbCBuZWVkcyB0byBiZSBzZWxlY3RlZFxuXG5cdFx0XHRkcmFnTGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldiwgeyAvLyB3b24ndCBzdGFydCBpZiBhbHJlYWR5IHN0YXJ0ZWRcblx0XHRcdFx0ZGVsYXk6IGlzU2VsZWN0ZWQgPyAwIDogZXZlbnRMb25nUHJlc3NEZWxheSAvLyBkbyBkZWxheSBpZiBub3QgYWxyZWFkeSBzZWxlY3RlZFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gcmV0dXJucyBib29sZWFuIHdoZXRoZXIgcmVzaXppbmcgYWN0dWFsbHkgc3RhcnRlZCBvciBub3QuXG5cdC8vIGFzc3VtZXMgdGhlIHNlZyBhbGxvd3MgcmVzaXppbmcuXG5cdC8vIGBkcmFnT3B0aW9uc2AgYXJlIG9wdGlvbmFsLlxuXHRzdGFydFNlZ1Jlc2l6ZTogZnVuY3Rpb24oc2VnLCBldiwgZHJhZ09wdGlvbnMpIHtcblx0XHRpZiAoJChldi50YXJnZXQpLmlzKCcuZmMtcmVzaXplcicpKSB7XG5cdFx0XHR0aGlzLmJ1aWxkU2VnUmVzaXplTGlzdGVuZXIoc2VnLCAkKGV2LnRhcmdldCkuaXMoJy5mYy1zdGFydC1yZXNpemVyJykpXG5cdFx0XHRcdC5zdGFydEludGVyYWN0aW9uKGV2LCBkcmFnT3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cblxuXHQvKiBFdmVudCBEcmFnZ2luZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQnVpbGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHRyYWNrIHVzZXItZHJhZ2dpbmcgb24gYW4gZXZlbnQgc2VnbWVudC5cblx0Ly8gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGFueSB0eXBlIG9mIEdyaWQuXG5cdC8vIEhhcyBzaWRlIGVmZmVjdCBvZiBzZXR0aW5nL3Vuc2V0dGluZyBgc2VnRHJhZ0xpc3RlbmVyYFxuXHRidWlsZFNlZ0RyYWdMaXN0ZW5lcjogZnVuY3Rpb24oc2VnKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgZWwgPSBzZWcuZWw7XG5cdFx0dmFyIGV2ZW50ID0gc2VnLmV2ZW50O1xuXHRcdHZhciBpc0RyYWdnaW5nO1xuXHRcdHZhciBtb3VzZUZvbGxvd2VyOyAvLyBBIGNsb25lIG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50IHRoYXQgd2lsbCBtb3ZlIHdpdGggdGhlIG1vdXNlXG5cdFx0dmFyIGRyb3BMb2NhdGlvbjsgLy8gem9uZWQgZXZlbnQgZGF0ZSBwcm9wZXJ0aWVzXG5cblx0XHRpZiAodGhpcy5zZWdEcmFnTGlzdGVuZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLnNlZ0RyYWdMaXN0ZW5lcjtcblx0XHR9XG5cblx0XHQvLyBUcmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciB0aGUgKnZpZXcncyogY29vcmRpbmF0ZSBtYXAuIEFsbG93cyBkcmFnZ2luZyBhbmQgZHJvcHBpbmcgYmV0d2VlbiBzdWJjb21wb25lbnRzXG5cdFx0Ly8gb2YgdGhlIHZpZXcuXG5cdFx0dmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuc2VnRHJhZ0xpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcih2aWV3LCB7XG5cdFx0XHRzY3JvbGw6IHZpZXcub3B0KCdkcmFnU2Nyb2xsJyksXG5cdFx0XHRzdWJqZWN0RWw6IGVsLFxuXHRcdFx0c3ViamVjdENlbnRlcjogdHJ1ZSxcblx0XHRcdGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdHNlZy5jb21wb25lbnQgPSBfdGhpczsgLy8gZm9yIHJlbmRlckRyYWdcblx0XHRcdFx0aXNEcmFnZ2luZyA9IGZhbHNlO1xuXHRcdFx0XHRtb3VzZUZvbGxvd2VyID0gbmV3IE1vdXNlRm9sbG93ZXIoc2VnLmVsLCB7XG5cdFx0XHRcdFx0YWRkaXRpb25hbENsYXNzOiAnZmMtZHJhZ2dpbmcnLFxuXHRcdFx0XHRcdHBhcmVudEVsOiB2aWV3LmVsLFxuXHRcdFx0XHRcdG9wYWNpdHk6IGRyYWdMaXN0ZW5lci5pc1RvdWNoID8gbnVsbCA6IHZpZXcub3B0KCdkcmFnT3BhY2l0eScpLFxuXHRcdFx0XHRcdHJldmVydER1cmF0aW9uOiB2aWV3Lm9wdCgnZHJhZ1JldmVydER1cmF0aW9uJyksXG5cdFx0XHRcdFx0ekluZGV4OiAyIC8vIG9uZSBhYm92ZSB0aGUgLmZjLXZpZXdcblx0XHRcdFx0fSk7XG5cdFx0XHRcdG1vdXNlRm9sbG93ZXIuaGlkZSgpOyAvLyBkb24ndCBzaG93IHVudGlsIHdlIGtub3cgdGhpcyBpcyBhIHJlYWwgZHJhZ1xuXHRcdFx0XHRtb3VzZUZvbGxvd2VyLnN0YXJ0KGV2KTtcblx0XHRcdH0sXG5cdFx0XHRkcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdGlmIChkcmFnTGlzdGVuZXIuaXNUb3VjaCAmJiAhdmlldy5pc0V2ZW50U2VsZWN0ZWQoZXZlbnQpKSB7XG5cdFx0XHRcdFx0Ly8gaWYgbm90IHByZXZpb3VzbHkgc2VsZWN0ZWQsIHdpbGwgZmlyZSBhZnRlciBhIGRlbGF5LiB0aGVuLCBzZWxlY3QgdGhlIGV2ZW50XG5cdFx0XHRcdFx0dmlldy5zZWxlY3RFdmVudChldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aXNEcmFnZ2luZyA9IHRydWU7XG5cdFx0XHRcdF90aGlzLmhhbmRsZVNlZ01vdXNlb3V0KHNlZywgZXYpOyAvLyBlbnN1cmUgYSBtb3VzZW91dCBvbiB0aGUgbWFuaXB1bGF0ZWQgZXZlbnQgaGFzIGJlZW4gcmVwb3J0ZWRcblx0XHRcdFx0X3RoaXMuc2VnRHJhZ1N0YXJ0KHNlZywgZXYpO1xuXHRcdFx0XHR2aWV3LmhpZGVFdmVudChldmVudCk7IC8vIGhpZGUgYWxsIGV2ZW50IHNlZ21lbnRzLiBvdXIgbW91c2VGb2xsb3dlciB3aWxsIHRha2Ugb3ZlclxuXHRcdFx0fSxcblx0XHRcdGhpdE92ZXI6IGZ1bmN0aW9uKGhpdCwgaXNPcmlnLCBvcmlnSGl0KSB7XG5cdFx0XHRcdHZhciBpc0FsbG93ZWQgPSB0cnVlO1xuXHRcdFx0XHR2YXIgb3JpZ0hpdFNwYW47XG5cdFx0XHRcdHZhciBoaXRTcGFuO1xuXHRcdFx0XHR2YXIgZHJhZ0hlbHBlckVscztcblxuXHRcdFx0XHQvLyBzdGFydGluZyBoaXQgY291bGQgYmUgZm9yY2VkIChEYXlHcmlkLmxpbWl0KVxuXHRcdFx0XHRpZiAoc2VnLmhpdCkge1xuXHRcdFx0XHRcdG9yaWdIaXQgPSBzZWcuaGl0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaGl0IG1pZ2h0IG5vdCBiZWxvbmcgdG8gdGhpcyBncmlkLCBzbyBxdWVyeSBvcmlnaW4gZ3JpZFxuXHRcdFx0XHRvcmlnSGl0U3BhbiA9IG9yaWdIaXQuY29tcG9uZW50LmdldFNhZmVIaXRTcGFuKG9yaWdIaXQpO1xuXHRcdFx0XHRoaXRTcGFuID0gaGl0LmNvbXBvbmVudC5nZXRTYWZlSGl0U3BhbihoaXQpO1xuXG5cdFx0XHRcdGlmIChvcmlnSGl0U3BhbiAmJiBoaXRTcGFuKSB7XG5cdFx0XHRcdFx0ZHJvcExvY2F0aW9uID0gX3RoaXMuY29tcHV0ZUV2ZW50RHJvcChvcmlnSGl0U3BhbiwgaGl0U3BhbiwgZXZlbnQpO1xuXHRcdFx0XHRcdGlzQWxsb3dlZCA9IGRyb3BMb2NhdGlvbiAmJiBfdGhpcy5pc0V2ZW50TG9jYXRpb25BbGxvd2VkKGRyb3BMb2NhdGlvbiwgZXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlzQWxsb3dlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFpc0FsbG93ZWQpIHtcblx0XHRcdFx0XHRkcm9wTG9jYXRpb24gPSBudWxsO1xuXHRcdFx0XHRcdGRpc2FibGVDdXJzb3IoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIGEgdmFsaWQgZHJvcCBsb2NhdGlvbiwgaGF2ZSB0aGUgc3ViY2xhc3MgcmVuZGVyIGEgdmlzdWFsIGluZGljYXRpb25cblx0XHRcdFx0aWYgKGRyb3BMb2NhdGlvbiAmJiAoZHJhZ0hlbHBlckVscyA9IHZpZXcucmVuZGVyRHJhZyhkcm9wTG9jYXRpb24sIHNlZykpKSB7XG5cblx0XHRcdFx0XHRkcmFnSGVscGVyRWxzLmFkZENsYXNzKCdmYy1kcmFnZ2luZycpO1xuXHRcdFx0XHRcdGlmICghZHJhZ0xpc3RlbmVyLmlzVG91Y2gpIHtcblx0XHRcdFx0XHRcdF90aGlzLmFwcGx5RHJhZ09wYWNpdHkoZHJhZ0hlbHBlckVscyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bW91c2VGb2xsb3dlci5oaWRlKCk7IC8vIGlmIHRoZSBzdWJjbGFzcyBpcyBhbHJlYWR5IHVzaW5nIGEgbW9jayBldmVudCBcImhlbHBlclwiLCBoaWRlIG91ciBvd25cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRtb3VzZUZvbGxvd2VyLnNob3coKTsgLy8gb3RoZXJ3aXNlLCBoYXZlIHRoZSBoZWxwZXIgZm9sbG93IHRoZSBtb3VzZSAobm8gc25hcHBpbmcpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNPcmlnKSB7XG5cdFx0XHRcdFx0ZHJvcExvY2F0aW9uID0gbnVsbDsgLy8gbmVlZHMgdG8gaGF2ZSBtb3ZlZCBoaXRzIHRvIGJlIGEgdmFsaWQgZHJvcFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aGl0T3V0OiBmdW5jdGlvbigpIHsgLy8gY2FsbGVkIGJlZm9yZSBtb3VzZSBtb3ZlcyB0byBhIGRpZmZlcmVudCBoaXQgT1IgbW92ZWQgb3V0IG9mIGFsbCBoaXRzXG5cdFx0XHRcdHZpZXcudW5yZW5kZXJEcmFnKCk7IC8vIHVucmVuZGVyIHdoYXRldmVyIHdhcyBkb25lIGluIHJlbmRlckRyYWdcblx0XHRcdFx0bW91c2VGb2xsb3dlci5zaG93KCk7IC8vIHNob3cgaW4gY2FzZSB3ZSBhcmUgbW92aW5nIG91dCBvZiBhbGwgaGl0c1xuXHRcdFx0XHRkcm9wTG9jYXRpb24gPSBudWxsO1xuXHRcdFx0fSxcblx0XHRcdGhpdERvbmU6IGZ1bmN0aW9uKCkgeyAvLyBDYWxsZWQgYWZ0ZXIgYSBoaXRPdXQgT1IgYmVmb3JlIGEgZHJhZ0VuZFxuXHRcdFx0XHRlbmFibGVDdXJzb3IoKTtcblx0XHRcdH0sXG5cdFx0XHRpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0ZGVsZXRlIHNlZy5jb21wb25lbnQ7IC8vIHByZXZlbnQgc2lkZSBlZmZlY3RzXG5cblx0XHRcdFx0Ly8gZG8gcmV2ZXJ0IGFuaW1hdGlvbiBpZiBoYXNuJ3QgY2hhbmdlZC4gY2FsbHMgYSBjYWxsYmFjayB3aGVuIGZpbmlzaGVkICh3aGV0aGVyIGFuaW1hdGlvbiBvciBub3QpXG5cdFx0XHRcdG1vdXNlRm9sbG93ZXIuc3RvcCghZHJvcExvY2F0aW9uLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoaXNEcmFnZ2luZykge1xuXHRcdFx0XHRcdFx0dmlldy51bnJlbmRlckRyYWcoKTtcblx0XHRcdFx0XHRcdF90aGlzLnNlZ0RyYWdTdG9wKHNlZywgZXYpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChkcm9wTG9jYXRpb24pIHtcblx0XHRcdFx0XHRcdC8vIG5vIG5lZWQgdG8gcmUtc2hvdyBvcmlnaW5hbCwgd2lsbCByZXJlbmRlciBhbGwgYW55d2F5cy4gZXNwIGltcG9ydGFudCBpZiBldmVudFJlbmRlcldhaXRcblx0XHRcdFx0XHRcdHZpZXcucmVwb3J0U2VnRHJvcChzZWcsIGRyb3BMb2NhdGlvbiwgX3RoaXMubGFyZ2VVbml0LCBlbCwgZXYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHZpZXcuc2hvd0V2ZW50KGV2ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRfdGhpcy5zZWdEcmFnTGlzdGVuZXIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGRyYWdMaXN0ZW5lcjtcblx0fSxcblxuXG5cdC8vIHNlZyBpc24ndCBkcmFnZ2FibGUsIGJ1dCBsZXQncyB1c2UgYSBnZW5lcmljIERyYWdMaXN0ZW5lclxuXHQvLyBzaW1wbHkgZm9yIHRoZSBkZWxheSwgc28gaXQgY2FuIGJlIHNlbGVjdGVkLlxuXHQvLyBIYXMgc2lkZSBlZmZlY3Qgb2Ygc2V0dGluZy91bnNldHRpbmcgYHNlZ0RyYWdMaXN0ZW5lcmBcblx0YnVpbGRTZWdTZWxlY3RMaXN0ZW5lcjogZnVuY3Rpb24oc2VnKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgZXZlbnQgPSBzZWcuZXZlbnQ7XG5cblx0XHRpZiAodGhpcy5zZWdEcmFnTGlzdGVuZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLnNlZ0RyYWdMaXN0ZW5lcjtcblx0XHR9XG5cblx0XHR2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5zZWdEcmFnTGlzdGVuZXIgPSBuZXcgRHJhZ0xpc3RlbmVyKHtcblx0XHRcdGRyYWdTdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0aWYgKGRyYWdMaXN0ZW5lci5pc1RvdWNoICYmICF2aWV3LmlzRXZlbnRTZWxlY3RlZChldmVudCkpIHtcblx0XHRcdFx0XHQvLyBpZiBub3QgcHJldmlvdXNseSBzZWxlY3RlZCwgd2lsbCBmaXJlIGFmdGVyIGEgZGVsYXkuIHRoZW4sIHNlbGVjdCB0aGUgZXZlbnRcblx0XHRcdFx0XHR2aWV3LnNlbGVjdEV2ZW50KGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbihldikge1xuXHRcdFx0XHRfdGhpcy5zZWdEcmFnTGlzdGVuZXIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGRyYWdMaXN0ZW5lcjtcblx0fSxcblxuXG5cdC8vIENhbGxlZCBiZWZvcmUgZXZlbnQgc2VnbWVudCBkcmFnZ2luZyBzdGFydHNcblx0c2VnRHJhZ1N0YXJ0OiBmdW5jdGlvbihzZWcsIGV2KSB7XG5cdFx0dGhpcy5pc0RyYWdnaW5nU2VnID0gdHJ1ZTtcblx0XHR0aGlzLnZpZXcucHVibGljbHlUcmlnZ2VyKCdldmVudERyYWdTdGFydCcsIHNlZy5lbFswXSwgc2VnLmV2ZW50LCBldiwge30pOyAvLyBsYXN0IGFyZ3VtZW50IGlzIGpxdWkgZHVtbXlcblx0fSxcblxuXG5cdC8vIENhbGxlZCBhZnRlciBldmVudCBzZWdtZW50IGRyYWdnaW5nIHN0b3BzXG5cdHNlZ0RyYWdTdG9wOiBmdW5jdGlvbihzZWcsIGV2KSB7XG5cdFx0dGhpcy5pc0RyYWdnaW5nU2VnID0gZmFsc2U7XG5cdFx0dGhpcy52aWV3LnB1YmxpY2x5VHJpZ2dlcignZXZlbnREcmFnU3RvcCcsIHNlZy5lbFswXSwgc2VnLmV2ZW50LCBldiwge30pOyAvLyBsYXN0IGFyZ3VtZW50IGlzIGpxdWkgZHVtbXlcblx0fSxcblxuXG5cdC8vIEdpdmVuIHRoZSBzcGFucyBhbiBldmVudCBkcmFnIGJlZ2FuLCBhbmQgdGhlIHNwYW4gZXZlbnQgd2FzIGRyb3BwZWQsIGNhbGN1bGF0ZXMgdGhlIG5ldyB6b25lZCBzdGFydC9lbmQvYWxsRGF5XG5cdC8vIHZhbHVlcyBmb3IgdGhlIGV2ZW50LiBTdWJjbGFzc2VzIG1heSBvdmVycmlkZSBhbmQgc2V0IGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBiZSB1c2VkIGJ5IHJlbmRlckRyYWcuXG5cdC8vIEEgZmFsc3kgcmV0dXJuZWQgdmFsdWUgaW5kaWNhdGVzIGFuIGludmFsaWQgZHJvcC5cblx0Ly8gRE9FUyBOT1QgY29uc2lkZXIgb3ZlcmxhcC9jb25zdHJhaW50LlxuXHRjb21wdXRlRXZlbnREcm9wOiBmdW5jdGlvbihzdGFydFNwYW4sIGVuZFNwYW4sIGV2ZW50KSB7XG5cdFx0dmFyIGNhbGVuZGFyID0gdGhpcy52aWV3LmNhbGVuZGFyO1xuXHRcdHZhciBkcmFnU3RhcnQgPSBzdGFydFNwYW4uc3RhcnQ7XG5cdFx0dmFyIGRyYWdFbmQgPSBlbmRTcGFuLnN0YXJ0O1xuXHRcdHZhciBkZWx0YTtcblx0XHR2YXIgZHJvcExvY2F0aW9uOyAvLyB6b25lZCBldmVudCBkYXRlIHByb3BlcnRpZXNcblxuXHRcdGlmIChkcmFnU3RhcnQuaGFzVGltZSgpID09PSBkcmFnRW5kLmhhc1RpbWUoKSkge1xuXHRcdFx0ZGVsdGEgPSB0aGlzLmRpZmZEYXRlcyhkcmFnRW5kLCBkcmFnU3RhcnQpO1xuXG5cdFx0XHQvLyBpZiBhbiBhbGwtZGF5IGV2ZW50IHdhcyBpbiBhIHRpbWVkIGFyZWEgYW5kIGl0IHdhcyBkcmFnZ2VkIHRvIGEgZGlmZmVyZW50IHRpbWUsXG5cdFx0XHQvLyBndWFyYW50ZWUgYW4gZW5kIGFuZCBhZGp1c3Qgc3RhcnQvZW5kIHRvIGhhdmUgdGltZXNcblx0XHRcdGlmIChldmVudC5hbGxEYXkgJiYgZHVyYXRpb25IYXNUaW1lKGRlbHRhKSkge1xuXHRcdFx0XHRkcm9wTG9jYXRpb24gPSB7XG5cdFx0XHRcdFx0c3RhcnQ6IGV2ZW50LnN0YXJ0LmNsb25lKCksXG5cdFx0XHRcdFx0ZW5kOiBjYWxlbmRhci5nZXRFdmVudEVuZChldmVudCksIC8vIHdpbGwgYmUgYW4gYW1iaWcgZGF5XG5cdFx0XHRcdFx0YWxsRGF5OiBmYWxzZSAvLyBmb3Igbm9ybWFsaXplRXZlbnRUaW1lc1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRjYWxlbmRhci5ub3JtYWxpemVFdmVudFRpbWVzKGRyb3BMb2NhdGlvbik7XG5cdFx0XHR9XG5cdFx0XHQvLyBvdGhld2lzZSwgd29yayBvZmYgZXhpc3RpbmcgdmFsdWVzXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZHJvcExvY2F0aW9uID0gcGx1Y2tFdmVudERhdGVQcm9wcyhldmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdGRyb3BMb2NhdGlvbi5zdGFydC5hZGQoZGVsdGEpO1xuXHRcdFx0aWYgKGRyb3BMb2NhdGlvbi5lbmQpIHtcblx0XHRcdFx0ZHJvcExvY2F0aW9uLmVuZC5hZGQoZGVsdGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIGlmIHN3aXRjaGluZyBmcm9tIGRheSA8LT4gdGltZWQsIHN0YXJ0IHNob3VsZCBiZSByZXNldCB0byB0aGUgZHJvcHBlZCBkYXRlLCBhbmQgdGhlIGVuZCBjbGVhcmVkXG5cdFx0XHRkcm9wTG9jYXRpb24gPSB7XG5cdFx0XHRcdHN0YXJ0OiBkcmFnRW5kLmNsb25lKCksXG5cdFx0XHRcdGVuZDogbnVsbCwgLy8gZW5kIHNob3VsZCBiZSBjbGVhcmVkXG5cdFx0XHRcdGFsbERheTogIWRyYWdFbmQuaGFzVGltZSgpXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiBkcm9wTG9jYXRpb247XG5cdH0sXG5cblxuXHQvLyBVdGlsaXR5IGZvciBhcHBseSBkcmFnT3BhY2l0eSB0byBhIGpRdWVyeSBzZXRcblx0YXBwbHlEcmFnT3BhY2l0eTogZnVuY3Rpb24oZWxzKSB7XG5cdFx0dmFyIG9wYWNpdHkgPSB0aGlzLnZpZXcub3B0KCdkcmFnT3BhY2l0eScpO1xuXG5cdFx0aWYgKG9wYWNpdHkgIT0gbnVsbCkge1xuXHRcdFx0ZWxzLmNzcygnb3BhY2l0eScsIG9wYWNpdHkpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8qIEV4dGVybmFsIEVsZW1lbnQgRHJhZ2dpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIENhbGxlZCB3aGVuIGEgalF1ZXJ5IFVJIGRyYWcgaXMgaW5pdGlhdGVkIGFueXdoZXJlIGluIHRoZSBET01cblx0ZXh0ZXJuYWxEcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2LCB1aSkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBlbDtcblx0XHR2YXIgYWNjZXB0O1xuXG5cdFx0aWYgKHZpZXcub3B0KCdkcm9wcGFibGUnKSkgeyAvLyBvbmx5IGxpc3RlbiBpZiB0aGlzIHNldHRpbmcgaXMgb25cblx0XHRcdGVsID0gJCgodWkgPyB1aS5pdGVtIDogbnVsbCkgfHwgZXYudGFyZ2V0KTtcblxuXHRcdFx0Ly8gVGVzdCB0aGF0IHRoZSBkcmFnZ2VkIGVsZW1lbnQgcGFzc2VzIHRoZSBkcm9wQWNjZXB0IHNlbGVjdG9yIG9yIGZpbHRlciBmdW5jdGlvbi5cblx0XHRcdC8vIEZZSSwgdGhlIGRlZmF1bHQgaXMgXCIqXCIgKG1hdGNoZXMgYWxsKVxuXHRcdFx0YWNjZXB0ID0gdmlldy5vcHQoJ2Ryb3BBY2NlcHQnKTtcblx0XHRcdGlmICgkLmlzRnVuY3Rpb24oYWNjZXB0KSA/IGFjY2VwdC5jYWxsKGVsWzBdLCBlbCkgOiBlbC5pcyhhY2NlcHQpKSB7XG5cdFx0XHRcdGlmICghdGhpcy5pc0RyYWdnaW5nRXh0ZXJuYWwpIHsgLy8gcHJldmVudCBkb3VibGUtbGlzdGVuaW5nIGlmIGZpcmVkIHR3aWNlXG5cdFx0XHRcdFx0dGhpcy5saXN0ZW5Ub0V4dGVybmFsRHJhZyhlbCwgZXYsIHVpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIGEgalF1ZXJ5IFVJIGRyYWcgc3RhcnRzIGFuZCBpdCBuZWVkcyB0byBiZSBtb25pdG9yZWQgZm9yIGRyb3BwaW5nXG5cdGxpc3RlblRvRXh0ZXJuYWxEcmFnOiBmdW5jdGlvbihlbCwgZXYsIHVpKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgbWV0YSA9IGdldERyYWdnZWRFbE1ldGEoZWwpOyAvLyBleHRyYSBkYXRhIGFib3V0IGV2ZW50IGRyb3AsIGluY2x1ZGluZyBwb3NzaWJsZSBldmVudCB0byBjcmVhdGVcblx0XHR2YXIgZHJvcExvY2F0aW9uOyAvLyBhIG51bGwgdmFsdWUgc2lnbmFscyBhbiB1bnN1Y2Nlc3NmdWwgZHJhZ1xuXG5cdFx0Ly8gbGlzdGVuZXIgdGhhdCB0cmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciBkYXRlLWFzc29jaWF0ZWQgcGl4ZWwgcmVnaW9uc1xuXHRcdHZhciBkcmFnTGlzdGVuZXIgPSBfdGhpcy5leHRlcm5hbERyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXIodGhpcywge1xuXHRcdFx0aW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF90aGlzLmlzRHJhZ2dpbmdFeHRlcm5hbCA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0aGl0T3ZlcjogZnVuY3Rpb24oaGl0KSB7XG5cdFx0XHRcdHZhciBpc0FsbG93ZWQgPSB0cnVlO1xuXHRcdFx0XHR2YXIgaGl0U3BhbiA9IGhpdC5jb21wb25lbnQuZ2V0U2FmZUhpdFNwYW4oaGl0KTsgLy8gaGl0IG1pZ2h0IG5vdCBiZWxvbmcgdG8gdGhpcyBncmlkXG5cblx0XHRcdFx0aWYgKGhpdFNwYW4pIHtcblx0XHRcdFx0XHRkcm9wTG9jYXRpb24gPSBfdGhpcy5jb21wdXRlRXh0ZXJuYWxEcm9wKGhpdFNwYW4sIG1ldGEpO1xuXHRcdFx0XHRcdGlzQWxsb3dlZCA9IGRyb3BMb2NhdGlvbiAmJiBfdGhpcy5pc0V4dGVybmFsTG9jYXRpb25BbGxvd2VkKGRyb3BMb2NhdGlvbiwgbWV0YS5ldmVudFByb3BzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpc0FsbG93ZWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghaXNBbGxvd2VkKSB7XG5cdFx0XHRcdFx0ZHJvcExvY2F0aW9uID0gbnVsbDtcblx0XHRcdFx0XHRkaXNhYmxlQ3Vyc29yKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZHJvcExvY2F0aW9uKSB7XG5cdFx0XHRcdFx0X3RoaXMucmVuZGVyRHJhZyhkcm9wTG9jYXRpb24pOyAvLyBjYWxsZWQgd2l0aG91dCBhIHNlZyBwYXJhbWV0ZXJcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhpdE91dDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRyb3BMb2NhdGlvbiA9IG51bGw7IC8vIHNpZ25hbCB1bnN1Y2Nlc3NmdWxcblx0XHRcdH0sXG5cdFx0XHRoaXREb25lOiBmdW5jdGlvbigpIHsgLy8gQ2FsbGVkIGFmdGVyIGEgaGl0T3V0IE9SIGJlZm9yZSBhIGRyYWdFbmRcblx0XHRcdFx0ZW5hYmxlQ3Vyc29yKCk7XG5cdFx0XHRcdF90aGlzLnVucmVuZGVyRHJhZygpO1xuXHRcdFx0fSxcblx0XHRcdGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbihldikge1xuXHRcdFx0XHRpZiAoZHJvcExvY2F0aW9uKSB7IC8vIGVsZW1lbnQgd2FzIGRyb3BwZWQgb24gYSB2YWxpZCBoaXRcblx0XHRcdFx0XHR2aWV3LnJlcG9ydEV4dGVybmFsRHJvcChtZXRhLCBkcm9wTG9jYXRpb24sIGVsLCBldiwgdWkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF90aGlzLmlzRHJhZ2dpbmdFeHRlcm5hbCA9IGZhbHNlO1xuXHRcdFx0XHRfdGhpcy5leHRlcm5hbERyYWdMaXN0ZW5lciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRkcmFnTGlzdGVuZXIuc3RhcnREcmFnKGV2KTsgLy8gc3RhcnQgbGlzdGVuaW5nIGltbWVkaWF0ZWx5XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIGhpdCB0byBiZSBkcm9wcGVkIHVwb24sIGFuZCBtaXNjIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBqcXVpIGRyYWcgKGd1YXJhbnRlZWQgdG8gYmUgYSBwbGFpbiBvYmplY3QpLFxuXHQvLyByZXR1cm5zIHRoZSB6b25lZCBzdGFydC9lbmQgZGF0ZXMgZm9yIHRoZSBldmVudCB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIHRoZSBoeXBvdGhldGljYWwgZHJvcC4gZW5kIG1pZ2h0IGJlIG51bGwuXG5cdC8vIFJldHVybmluZyBhIG51bGwgdmFsdWUgc2lnbmFscyBhbiBpbnZhbGlkIGRyb3AgaGl0LlxuXHQvLyBET0VTIE5PVCBjb25zaWRlciBvdmVybGFwL2NvbnN0cmFpbnQuXG5cdGNvbXB1dGVFeHRlcm5hbERyb3A6IGZ1bmN0aW9uKHNwYW4sIG1ldGEpIHtcblx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XG5cdFx0dmFyIGRyb3BMb2NhdGlvbiA9IHtcblx0XHRcdHN0YXJ0OiBjYWxlbmRhci5hcHBseVRpbWV6b25lKHNwYW4uc3RhcnQpLCAvLyBzaW11bGF0ZSBhIHpvbmVkIGV2ZW50IHN0YXJ0IGRhdGVcblx0XHRcdGVuZDogbnVsbFxuXHRcdH07XG5cblx0XHQvLyBpZiBkcm9wcGVkIG9uIGFuIGFsbC1kYXkgc3BhbiwgYW5kIGVsZW1lbnQncyBtZXRhZGF0YSBzcGVjaWZpZWQgYSB0aW1lLCBzZXQgaXRcblx0XHRpZiAobWV0YS5zdGFydFRpbWUgJiYgIWRyb3BMb2NhdGlvbi5zdGFydC5oYXNUaW1lKCkpIHtcblx0XHRcdGRyb3BMb2NhdGlvbi5zdGFydC50aW1lKG1ldGEuc3RhcnRUaW1lKTtcblx0XHR9XG5cblx0XHRpZiAobWV0YS5kdXJhdGlvbikge1xuXHRcdFx0ZHJvcExvY2F0aW9uLmVuZCA9IGRyb3BMb2NhdGlvbi5zdGFydC5jbG9uZSgpLmFkZChtZXRhLmR1cmF0aW9uKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZHJvcExvY2F0aW9uO1xuXHR9LFxuXG5cblxuXHQvKiBEcmFnIFJlbmRlcmluZyAoZm9yIGJvdGggZXZlbnRzIGFuZCBhbiBleHRlcm5hbCBlbGVtZW50cylcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBvciBleHRlcm5hbCBlbGVtZW50IGJlaW5nIGRyYWdnZWQuXG5cdC8vIGBkcm9wTG9jYXRpb25gIGNvbnRhaW5zIGh5cG90aGV0aWNhbCBzdGFydC9lbmQvYWxsRGF5IHZhbHVlcyB0aGUgZXZlbnQgd291bGQgaGF2ZSBpZiBkcm9wcGVkLiBlbmQgY2FuIGJlIG51bGwuXG5cdC8vIGBzZWdgIGlzIHRoZSBpbnRlcm5hbCBzZWdtZW50IG9iamVjdCB0aGF0IGlzIGJlaW5nIGRyYWdnZWQuIElmIGRyYWdnaW5nIGFuIGV4dGVybmFsIGVsZW1lbnQsIGBzZWdgIGlzIG51bGwuXG5cdC8vIEEgdHJ1dGh5IHJldHVybmVkIHZhbHVlIGluZGljYXRlcyB0aGlzIG1ldGhvZCBoYXMgcmVuZGVyZWQgYSBoZWxwZXIgZWxlbWVudC5cblx0Ly8gTXVzdCByZXR1cm4gZWxlbWVudHMgdXNlZCBmb3IgYW55IG1vY2sgZXZlbnRzLlxuXHRyZW5kZXJEcmFnOiBmdW5jdGlvbihkcm9wTG9jYXRpb24sIHNlZykge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IG9yIGV4dGVybmFsIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZFxuXHR1bnJlbmRlckRyYWc6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8qIFJlc2l6aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBDcmVhdGVzIGEgbGlzdGVuZXIgdGhhdCB0cmFja3MgdGhlIHVzZXIgYXMgdGhleSByZXNpemUgYW4gZXZlbnQgc2VnbWVudC5cblx0Ly8gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGFueSB0eXBlIG9mIEdyaWQuXG5cdGJ1aWxkU2VnUmVzaXplTGlzdGVuZXI6IGZ1bmN0aW9uKHNlZywgaXNTdGFydCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcblx0XHR2YXIgZWwgPSBzZWcuZWw7XG5cdFx0dmFyIGV2ZW50ID0gc2VnLmV2ZW50O1xuXHRcdHZhciBldmVudEVuZCA9IGNhbGVuZGFyLmdldEV2ZW50RW5kKGV2ZW50KTtcblx0XHR2YXIgaXNEcmFnZ2luZztcblx0XHR2YXIgcmVzaXplTG9jYXRpb247IC8vIHpvbmVkIGV2ZW50IGRhdGUgcHJvcGVydGllcy4gZmFsc3kgaWYgaW52YWxpZCByZXNpemVcblxuXHRcdC8vIFRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIHRoZSAqZ3JpZCdzKiBjb29yZGluYXRlIG1hcFxuXHRcdHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLnNlZ1Jlc2l6ZUxpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcih0aGlzLCB7XG5cdFx0XHRzY3JvbGw6IHZpZXcub3B0KCdkcmFnU2Nyb2xsJyksXG5cdFx0XHRzdWJqZWN0RWw6IGVsLFxuXHRcdFx0aW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlzRHJhZ2dpbmcgPSBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRkcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdGlzRHJhZ2dpbmcgPSB0cnVlO1xuXHRcdFx0XHRfdGhpcy5oYW5kbGVTZWdNb3VzZW91dChzZWcsIGV2KTsgLy8gZW5zdXJlIGEgbW91c2VvdXQgb24gdGhlIG1hbmlwdWxhdGVkIGV2ZW50IGhhcyBiZWVuIHJlcG9ydGVkXG5cdFx0XHRcdF90aGlzLnNlZ1Jlc2l6ZVN0YXJ0KHNlZywgZXYpO1xuXHRcdFx0fSxcblx0XHRcdGhpdE92ZXI6IGZ1bmN0aW9uKGhpdCwgaXNPcmlnLCBvcmlnSGl0KSB7XG5cdFx0XHRcdHZhciBpc0FsbG93ZWQgPSB0cnVlO1xuXHRcdFx0XHR2YXIgb3JpZ0hpdFNwYW4gPSBfdGhpcy5nZXRTYWZlSGl0U3BhbihvcmlnSGl0KTtcblx0XHRcdFx0dmFyIGhpdFNwYW4gPSBfdGhpcy5nZXRTYWZlSGl0U3BhbihoaXQpO1xuXG5cdFx0XHRcdGlmIChvcmlnSGl0U3BhbiAmJiBoaXRTcGFuKSB7XG5cdFx0XHRcdFx0cmVzaXplTG9jYXRpb24gPSBpc1N0YXJ0ID9cblx0XHRcdFx0XHRcdF90aGlzLmNvbXB1dGVFdmVudFN0YXJ0UmVzaXplKG9yaWdIaXRTcGFuLCBoaXRTcGFuLCBldmVudCkgOlxuXHRcdFx0XHRcdFx0X3RoaXMuY29tcHV0ZUV2ZW50RW5kUmVzaXplKG9yaWdIaXRTcGFuLCBoaXRTcGFuLCBldmVudCk7XG5cblx0XHRcdFx0XHRpc0FsbG93ZWQgPSByZXNpemVMb2NhdGlvbiAmJiBfdGhpcy5pc0V2ZW50TG9jYXRpb25BbGxvd2VkKHJlc2l6ZUxvY2F0aW9uLCBldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aXNBbGxvd2VkID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWlzQWxsb3dlZCkge1xuXHRcdFx0XHRcdHJlc2l6ZUxvY2F0aW9uID0gbnVsbDtcblx0XHRcdFx0XHRkaXNhYmxlQ3Vyc29yKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0cmVzaXplTG9jYXRpb24uc3RhcnQuaXNTYW1lKGV2ZW50LnN0YXJ0LmNsb25lKCkuc3RyaXBab25lKCkpICYmXG5cdFx0XHRcdFx0XHRyZXNpemVMb2NhdGlvbi5lbmQuaXNTYW1lKGV2ZW50RW5kLmNsb25lKCkuc3RyaXBab25lKCkpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHQvLyBubyBjaGFuZ2UuIChGWUksIGV2ZW50IGRhdGVzIG1pZ2h0IGhhdmUgem9uZXMpXG5cdFx0XHRcdFx0XHRyZXNpemVMb2NhdGlvbiA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHJlc2l6ZUxvY2F0aW9uKSB7XG5cdFx0XHRcdFx0dmlldy5oaWRlRXZlbnQoZXZlbnQpO1xuXHRcdFx0XHRcdF90aGlzLnJlbmRlckV2ZW50UmVzaXplKHJlc2l6ZUxvY2F0aW9uLCBzZWcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aGl0T3V0OiBmdW5jdGlvbigpIHsgLy8gY2FsbGVkIGJlZm9yZSBtb3VzZSBtb3ZlcyB0byBhIGRpZmZlcmVudCBoaXQgT1IgbW92ZWQgb3V0IG9mIGFsbCBoaXRzXG5cdFx0XHRcdHJlc2l6ZUxvY2F0aW9uID0gbnVsbDtcblx0XHRcdFx0dmlldy5zaG93RXZlbnQoZXZlbnQpOyAvLyBmb3Igd2hlbiBvdXQtb2YtYm91bmRzLiBzaG93IG9yaWdpbmFsXG5cdFx0XHR9LFxuXHRcdFx0aGl0RG9uZTogZnVuY3Rpb24oKSB7IC8vIHJlc2V0cyB0aGUgcmVuZGVyaW5nIHRvIHNob3cgdGhlIG9yaWdpbmFsIGV2ZW50XG5cdFx0XHRcdF90aGlzLnVucmVuZGVyRXZlbnRSZXNpemUoKTtcblx0XHRcdFx0ZW5hYmxlQ3Vyc29yKCk7XG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdGlmIChpc0RyYWdnaW5nKSB7XG5cdFx0XHRcdFx0X3RoaXMuc2VnUmVzaXplU3RvcChzZWcsIGV2KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyZXNpemVMb2NhdGlvbikgeyAvLyB2YWxpZCBkYXRlIHRvIHJlc2l6ZSB0bz9cblx0XHRcdFx0XHQvLyBubyBuZWVkIHRvIHJlLXNob3cgb3JpZ2luYWwsIHdpbGwgcmVyZW5kZXIgYWxsIGFueXdheXMuIGVzcCBpbXBvcnRhbnQgaWYgZXZlbnRSZW5kZXJXYWl0XG5cdFx0XHRcdFx0dmlldy5yZXBvcnRTZWdSZXNpemUoc2VnLCByZXNpemVMb2NhdGlvbiwgX3RoaXMubGFyZ2VVbml0LCBlbCwgZXYpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZpZXcuc2hvd0V2ZW50KGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdGhpcy5zZWdSZXNpemVMaXN0ZW5lciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZHJhZ0xpc3RlbmVyO1xuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIGJlZm9yZSBldmVudCBzZWdtZW50IHJlc2l6aW5nIHN0YXJ0c1xuXHRzZWdSZXNpemVTdGFydDogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdHRoaXMuaXNSZXNpemluZ1NlZyA9IHRydWU7XG5cdFx0dGhpcy52aWV3LnB1YmxpY2x5VHJpZ2dlcignZXZlbnRSZXNpemVTdGFydCcsIHNlZy5lbFswXSwgc2VnLmV2ZW50LCBldiwge30pOyAvLyBsYXN0IGFyZ3VtZW50IGlzIGpxdWkgZHVtbXlcblx0fSxcblxuXG5cdC8vIENhbGxlZCBhZnRlciBldmVudCBzZWdtZW50IHJlc2l6aW5nIHN0b3BzXG5cdHNlZ1Jlc2l6ZVN0b3A6IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHR0aGlzLmlzUmVzaXppbmdTZWcgPSBmYWxzZTtcblx0XHR0aGlzLnZpZXcucHVibGljbHlUcmlnZ2VyKCdldmVudFJlc2l6ZVN0b3AnLCBzZWcuZWxbMF0sIHNlZy5ldmVudCwgZXYsIHt9KTsgLy8gbGFzdCBhcmd1bWVudCBpcyBqcXVpIGR1bW15XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIG5ldyBkYXRlLWluZm9ybWF0aW9uIGZvciBhbiBldmVudCBzZWdtZW50IGJlaW5nIHJlc2l6ZWQgZnJvbSBpdHMgc3RhcnRcblx0Y29tcHV0ZUV2ZW50U3RhcnRSZXNpemU6IGZ1bmN0aW9uKHN0YXJ0U3BhbiwgZW5kU3BhbiwgZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5jb21wdXRlRXZlbnRSZXNpemUoJ3N0YXJ0Jywgc3RhcnRTcGFuLCBlbmRTcGFuLCBldmVudCk7XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIG5ldyBkYXRlLWluZm9ybWF0aW9uIGZvciBhbiBldmVudCBzZWdtZW50IGJlaW5nIHJlc2l6ZWQgZnJvbSBpdHMgZW5kXG5cdGNvbXB1dGVFdmVudEVuZFJlc2l6ZTogZnVuY3Rpb24oc3RhcnRTcGFuLCBlbmRTcGFuLCBldmVudCkge1xuXHRcdHJldHVybiB0aGlzLmNvbXB1dGVFdmVudFJlc2l6ZSgnZW5kJywgc3RhcnRTcGFuLCBlbmRTcGFuLCBldmVudCk7XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIG5ldyB6b25lZCBkYXRlIGluZm9ybWF0aW9uIGZvciBhbiBldmVudCBzZWdtZW50IGJlaW5nIHJlc2l6ZWQgZnJvbSBpdHMgc3RhcnQgT1IgZW5kXG5cdC8vIGB0eXBlYCBpcyBlaXRoZXIgJ3N0YXJ0JyBvciAnZW5kJy5cblx0Ly8gRE9FUyBOT1QgY29uc2lkZXIgb3ZlcmxhcC9jb25zdHJhaW50LlxuXHRjb21wdXRlRXZlbnRSZXNpemU6IGZ1bmN0aW9uKHR5cGUsIHN0YXJ0U3BhbiwgZW5kU3BhbiwgZXZlbnQpIHtcblx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XG5cdFx0dmFyIGRlbHRhID0gdGhpcy5kaWZmRGF0ZXMoZW5kU3Bhblt0eXBlXSwgc3RhcnRTcGFuW3R5cGVdKTtcblx0XHR2YXIgcmVzaXplTG9jYXRpb247IC8vIHpvbmVkIGV2ZW50IGRhdGUgcHJvcGVydGllc1xuXHRcdHZhciBkZWZhdWx0RHVyYXRpb247XG5cblx0XHQvLyBidWlsZCBvcmlnaW5hbCB2YWx1ZXMgdG8gd29yayBmcm9tLCBndWFyYW50ZWVpbmcgYSBzdGFydCBhbmQgZW5kXG5cdFx0cmVzaXplTG9jYXRpb24gPSB7XG5cdFx0XHRzdGFydDogZXZlbnQuc3RhcnQuY2xvbmUoKSxcblx0XHRcdGVuZDogY2FsZW5kYXIuZ2V0RXZlbnRFbmQoZXZlbnQpLFxuXHRcdFx0YWxsRGF5OiBldmVudC5hbGxEYXlcblx0XHR9O1xuXG5cdFx0Ly8gaWYgYW4gYWxsLWRheSBldmVudCB3YXMgaW4gYSB0aW1lZCBhcmVhIGFuZCB3YXMgcmVzaXplZCB0byBhIHRpbWUsIGFkanVzdCBzdGFydC9lbmQgdG8gaGF2ZSB0aW1lc1xuXHRcdGlmIChyZXNpemVMb2NhdGlvbi5hbGxEYXkgJiYgZHVyYXRpb25IYXNUaW1lKGRlbHRhKSkge1xuXHRcdFx0cmVzaXplTG9jYXRpb24uYWxsRGF5ID0gZmFsc2U7XG5cdFx0XHRjYWxlbmRhci5ub3JtYWxpemVFdmVudFRpbWVzKHJlc2l6ZUxvY2F0aW9uKTtcblx0XHR9XG5cblx0XHRyZXNpemVMb2NhdGlvblt0eXBlXS5hZGQoZGVsdGEpOyAvLyBhcHBseSBkZWx0YSB0byBzdGFydCBvciBlbmRcblxuXHRcdC8vIGlmIHRoZSBldmVudCB3YXMgY29tcHJlc3NlZCB0b28gc21hbGwsIGZpbmQgYSBuZXcgcmVhc29uYWJsZSBkdXJhdGlvbiBmb3IgaXRcblx0XHRpZiAoIXJlc2l6ZUxvY2F0aW9uLnN0YXJ0LmlzQmVmb3JlKHJlc2l6ZUxvY2F0aW9uLmVuZCkpIHtcblxuXHRcdFx0ZGVmYXVsdER1cmF0aW9uID1cblx0XHRcdFx0dGhpcy5taW5SZXNpemVEdXJhdGlvbiB8fCAvLyBUT0RPOiBoYWNrXG5cdFx0XHRcdChldmVudC5hbGxEYXkgP1xuXHRcdFx0XHRcdGNhbGVuZGFyLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIDpcblx0XHRcdFx0XHRjYWxlbmRhci5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcblxuXHRcdFx0aWYgKHR5cGUgPT0gJ3N0YXJ0JykgeyAvLyByZXNpemluZyB0aGUgc3RhcnQ/XG5cdFx0XHRcdHJlc2l6ZUxvY2F0aW9uLnN0YXJ0ID0gcmVzaXplTG9jYXRpb24uZW5kLmNsb25lKCkuc3VidHJhY3QoZGVmYXVsdER1cmF0aW9uKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgeyAvLyByZXNpemluZyB0aGUgZW5kP1xuXHRcdFx0XHRyZXNpemVMb2NhdGlvbi5lbmQgPSByZXNpemVMb2NhdGlvbi5zdGFydC5jbG9uZSgpLmFkZChkZWZhdWx0RHVyYXRpb24pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXNpemVMb2NhdGlvbjtcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkLlxuXHQvLyBgcmFuZ2VgIGhhcyB0aGUgdXBkYXRlZCBkYXRlcyBvZiB0aGUgZXZlbnQuIGBzZWdgIGlzIHRoZSBvcmlnaW5hbCBzZWdtZW50IG9iamVjdCBpbnZvbHZlZCBpbiB0aGUgZHJhZy5cblx0Ly8gTXVzdCByZXR1cm4gZWxlbWVudHMgdXNlZCBmb3IgYW55IG1vY2sgZXZlbnRzLlxuXHRyZW5kZXJFdmVudFJlc2l6ZTogZnVuY3Rpb24ocmFuZ2UsIHNlZykge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWQuXG5cdHVucmVuZGVyRXZlbnRSZXNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8qIFJlbmRlcmluZyBVdGlsc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ29tcHV0ZSB0aGUgdGV4dCB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgb24gYW4gZXZlbnQncyBlbGVtZW50LlxuXHQvLyBgcmFuZ2VgIGNhbiBiZSB0aGUgRXZlbnQgb2JqZWN0IGl0c2VsZiwgb3Igc29tZXRoaW5nIHJhbmdlLWxpa2UsIHdpdGggYXQgbGVhc3QgYSBgc3RhcnRgLlxuXHQvLyBJZiBldmVudCB0aW1lcyBhcmUgZGlzYWJsZWQsIG9yIHRoZSBldmVudCBoYXMgbm8gdGltZSwgd2lsbCByZXR1cm4gYSBibGFuayBzdHJpbmcuXG5cdC8vIElmIG5vdCBzcGVjaWZpZWQsIGZvcm1hdFN0ciB3aWxsIGRlZmF1bHQgdG8gdGhlIGV2ZW50VGltZUZvcm1hdCBzZXR0aW5nLFxuXHQvLyBhbmQgZGlzcGxheUVuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGRpc3BsYXlFdmVudEVuZCBzZXR0aW5nLlxuXHRnZXRFdmVudFRpbWVUZXh0OiBmdW5jdGlvbihyYW5nZSwgZm9ybWF0U3RyLCBkaXNwbGF5RW5kKSB7XG5cblx0XHRpZiAoZm9ybWF0U3RyID09IG51bGwpIHtcblx0XHRcdGZvcm1hdFN0ciA9IHRoaXMuZXZlbnRUaW1lRm9ybWF0O1xuXHRcdH1cblxuXHRcdGlmIChkaXNwbGF5RW5kID09IG51bGwpIHtcblx0XHRcdGRpc3BsYXlFbmQgPSB0aGlzLmRpc3BsYXlFdmVudEVuZDtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5kaXNwbGF5RXZlbnRUaW1lICYmIHJhbmdlLnN0YXJ0Lmhhc1RpbWUoKSkge1xuXHRcdFx0aWYgKGRpc3BsYXlFbmQgJiYgcmFuZ2UuZW5kKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZpZXcuZm9ybWF0UmFuZ2UocmFuZ2UsIGZvcm1hdFN0cik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHJhbmdlLnN0YXJ0LmZvcm1hdChmb3JtYXRTdHIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAnJztcblx0fSxcblxuXG5cdC8vIEdlbmVyaWMgdXRpbGl0eSBmb3IgZ2VuZXJhdGluZyB0aGUgSFRNTCBjbGFzc05hbWVzIGZvciBhbiBldmVudCBzZWdtZW50J3MgZWxlbWVudFxuXHRnZXRTZWdDbGFzc2VzOiBmdW5jdGlvbihzZWcsIGlzRHJhZ2dhYmxlLCBpc1Jlc2l6YWJsZSkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBjbGFzc2VzID0gW1xuXHRcdFx0J2ZjLWV2ZW50Jyxcblx0XHRcdHNlZy5pc1N0YXJ0ID8gJ2ZjLXN0YXJ0JyA6ICdmYy1ub3Qtc3RhcnQnLFxuXHRcdFx0c2VnLmlzRW5kID8gJ2ZjLWVuZCcgOiAnZmMtbm90LWVuZCdcblx0XHRdLmNvbmNhdCh0aGlzLmdldFNlZ0N1c3RvbUNsYXNzZXMoc2VnKSk7XG5cblx0XHRpZiAoaXNEcmFnZ2FibGUpIHtcblx0XHRcdGNsYXNzZXMucHVzaCgnZmMtZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHRcdGlmIChpc1Jlc2l6YWJsZSkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmYy1yZXNpemFibGUnKTtcblx0XHR9XG5cblx0XHQvLyBldmVudCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQ/IGF0dGFjaCBhIGNsYXNzTmFtZS5cblx0XHRpZiAodmlldy5pc0V2ZW50U2VsZWN0ZWQoc2VnLmV2ZW50KSkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmYy1zZWxlY3RlZCcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzO1xuXHR9LFxuXG5cblx0Ly8gTGlzdCBvZiBjbGFzc2VzIHRoYXQgd2VyZSBkZWZpbmVkIGJ5IHRoZSBjYWxsZXIgb2YgdGhlIEFQSSBpbiBzb21lIHdheVxuXHRnZXRTZWdDdXN0b21DbGFzc2VzOiBmdW5jdGlvbihzZWcpIHtcblx0XHR2YXIgZXZlbnQgPSBzZWcuZXZlbnQ7XG5cblx0XHRyZXR1cm4gW10uY29uY2F0KFxuXHRcdFx0ZXZlbnQuY2xhc3NOYW1lLCAvLyBndWFyYW50ZWVkIHRvIGJlIGFuIGFycmF5XG5cdFx0XHRldmVudC5zb3VyY2UgPyBldmVudC5zb3VyY2UuY2xhc3NOYW1lIDogW11cblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gVXRpbGl0eSBmb3IgZ2VuZXJhdGluZyBldmVudCBza2luLXJlbGF0ZWQgQ1NTIHByb3BlcnRpZXNcblx0Z2V0U2VnU2tpbkNzczogZnVuY3Rpb24oc2VnKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzogdGhpcy5nZXRTZWdCYWNrZ3JvdW5kQ29sb3Ioc2VnKSxcblx0XHRcdCdib3JkZXItY29sb3InOiB0aGlzLmdldFNlZ0JvcmRlckNvbG9yKHNlZyksXG5cdFx0XHRjb2xvcjogdGhpcy5nZXRTZWdUZXh0Q29sb3Ioc2VnKVxuXHRcdH07XG5cdH0sXG5cblxuXHQvLyBRdWVyaWVzIGZvciBjYWxsZXItc3BlY2lmaWVkIGNvbG9yLCB0aGVuIGZhbGxzIGJhY2sgdG8gZGVmYXVsdFxuXHRnZXRTZWdCYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHJldHVybiBzZWcuZXZlbnQuYmFja2dyb3VuZENvbG9yIHx8XG5cdFx0XHRzZWcuZXZlbnQuY29sb3IgfHxcblx0XHRcdHRoaXMuZ2V0U2VnRGVmYXVsdEJhY2tncm91bmRDb2xvcihzZWcpO1xuXHR9LFxuXG5cblx0Z2V0U2VnRGVmYXVsdEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24oc2VnKSB7XG5cdFx0dmFyIHNvdXJjZSA9IHNlZy5ldmVudC5zb3VyY2UgfHwge307XG5cblx0XHRyZXR1cm4gc291cmNlLmJhY2tncm91bmRDb2xvciB8fFxuXHRcdFx0c291cmNlLmNvbG9yIHx8XG5cdFx0XHR0aGlzLnZpZXcub3B0KCdldmVudEJhY2tncm91bmRDb2xvcicpIHx8XG5cdFx0XHR0aGlzLnZpZXcub3B0KCdldmVudENvbG9yJyk7XG5cdH0sXG5cblxuXHQvLyBRdWVyaWVzIGZvciBjYWxsZXItc3BlY2lmaWVkIGNvbG9yLCB0aGVuIGZhbGxzIGJhY2sgdG8gZGVmYXVsdFxuXHRnZXRTZWdCb3JkZXJDb2xvcjogZnVuY3Rpb24oc2VnKSB7XG5cdFx0cmV0dXJuIHNlZy5ldmVudC5ib3JkZXJDb2xvciB8fFxuXHRcdFx0c2VnLmV2ZW50LmNvbG9yIHx8XG5cdFx0XHR0aGlzLmdldFNlZ0RlZmF1bHRCb3JkZXJDb2xvcihzZWcpO1xuXHR9LFxuXG5cblx0Z2V0U2VnRGVmYXVsdEJvcmRlckNvbG9yOiBmdW5jdGlvbihzZWcpIHtcblx0XHR2YXIgc291cmNlID0gc2VnLmV2ZW50LnNvdXJjZSB8fCB7fTtcblxuXHRcdHJldHVybiBzb3VyY2UuYm9yZGVyQ29sb3IgfHxcblx0XHRcdHNvdXJjZS5jb2xvciB8fFxuXHRcdFx0dGhpcy52aWV3Lm9wdCgnZXZlbnRCb3JkZXJDb2xvcicpIHx8XG5cdFx0XHR0aGlzLnZpZXcub3B0KCdldmVudENvbG9yJyk7XG5cdH0sXG5cblxuXHQvLyBRdWVyaWVzIGZvciBjYWxsZXItc3BlY2lmaWVkIGNvbG9yLCB0aGVuIGZhbGxzIGJhY2sgdG8gZGVmYXVsdFxuXHRnZXRTZWdUZXh0Q29sb3I6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHJldHVybiBzZWcuZXZlbnQudGV4dENvbG9yIHx8XG5cdFx0XHR0aGlzLmdldFNlZ0RlZmF1bHRUZXh0Q29sb3Ioc2VnKTtcblx0fSxcblxuXG5cdGdldFNlZ0RlZmF1bHRUZXh0Q29sb3I6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHZhciBzb3VyY2UgPSBzZWcuZXZlbnQuc291cmNlIHx8IHt9O1xuXG5cdFx0cmV0dXJuIHNvdXJjZS50ZXh0Q29sb3IgfHxcblx0XHRcdHRoaXMudmlldy5vcHQoJ2V2ZW50VGV4dENvbG9yJyk7XG5cdH0sXG5cblxuXHQvKiBFdmVudCBMb2NhdGlvbiBWYWxpZGF0aW9uXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRpc0V2ZW50TG9jYXRpb25BbGxvd2VkOiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBldmVudCkge1xuXHRcdGlmICh0aGlzLmlzRXZlbnRMb2NhdGlvbkluUmFuZ2UoZXZlbnRMb2NhdGlvbikpIHtcblx0XHRcdHZhciBjYWxlbmRhciA9IHRoaXMudmlldy5jYWxlbmRhcjtcblx0XHRcdHZhciBldmVudFNwYW5zID0gdGhpcy5ldmVudFRvU3BhbnMoZXZlbnRMb2NhdGlvbik7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0aWYgKGV2ZW50U3BhbnMubGVuZ3RoKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBldmVudFNwYW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKCFjYWxlbmRhci5pc0V2ZW50U3BhbkFsbG93ZWQoZXZlbnRTcGFuc1tpXSwgZXZlbnQpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cblx0aXNFeHRlcm5hbExvY2F0aW9uQWxsb3dlZDogZnVuY3Rpb24oZXZlbnRMb2NhdGlvbiwgbWV0YVByb3BzKSB7IC8vIEZPUiB0aGUgZXh0ZXJuYWwgZWxlbWVudFxuXHRcdGlmICh0aGlzLmlzRXZlbnRMb2NhdGlvbkluUmFuZ2UoZXZlbnRMb2NhdGlvbikpIHtcblx0XHRcdHZhciBjYWxlbmRhciA9IHRoaXMudmlldy5jYWxlbmRhcjtcblx0XHRcdHZhciBldmVudFNwYW5zID0gdGhpcy5ldmVudFRvU3BhbnMoZXZlbnRMb2NhdGlvbik7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0aWYgKGV2ZW50U3BhbnMubGVuZ3RoKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBldmVudFNwYW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKCFjYWxlbmRhci5pc0V4dGVybmFsU3BhbkFsbG93ZWQoZXZlbnRTcGFuc1tpXSwgZXZlbnRMb2NhdGlvbiwgbWV0YVByb3BzKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXG5cdGlzRXZlbnRMb2NhdGlvbkluUmFuZ2U6IGZ1bmN0aW9uKGV2ZW50TG9jYXRpb24pIHtcblx0XHRyZXR1cm4gaXNSYW5nZVdpdGhpblJhbmdlKFxuXHRcdFx0dGhpcy5ldmVudFRvUmF3UmFuZ2UoZXZlbnRMb2NhdGlvbiksXG5cdFx0XHR0aGlzLnZpZXcudmFsaWRSYW5nZVxuXHRcdCk7XG5cdH0sXG5cblxuXHQvKiBDb252ZXJ0aW5nIGV2ZW50cyAtPiBldmVudFJhbmdlIC0+IGV2ZW50U3BhbiAtPiBldmVudFNlZ3Ncblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEdlbmVyYXRlcyBhbiBhcnJheSBvZiBzZWdtZW50cyBmb3IgdGhlIGdpdmVuIHNpbmdsZSBldmVudFxuXHQvLyBDYW4gYWNjZXB0IGFuIGV2ZW50IFwibG9jYXRpb25cIiBhcyB3ZWxsICh3aGljaCBvbmx5IGhhcyBzdGFydC9lbmQgYW5kIG5vIGFsbERheSlcblx0ZXZlbnRUb1NlZ3M6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIHRoaXMuZXZlbnRzVG9TZWdzKFsgZXZlbnQgXSk7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgc3BhbnMgKGFsd2F5cyB1bnpvbmVkKSBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuXHQvLyBEb2VzIG5vdCBkbyBhbnkgaW52ZXJ0aW5nIGZvciBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzLlxuXHQvLyBDYW4gYWNjZXB0IGFuIGV2ZW50IFwibG9jYXRpb25cIiBhcyB3ZWxsICh3aGljaCBvbmx5IGhhcyBzdGFydC9lbmQgYW5kIG5vIGFsbERheSlcblx0ZXZlbnRUb1NwYW5zOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBldmVudFJhbmdlID0gdGhpcy5ldmVudFRvUmFuZ2UoZXZlbnQpOyAvLyB7IHN0YXJ0LCBlbmQsIGlzU3RhcnQsIGlzRW5kIH1cblxuXHRcdGlmIChldmVudFJhbmdlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ldmVudFJhbmdlVG9TcGFucyhldmVudFJhbmdlLCBldmVudCk7XG5cdFx0fVxuXHRcdGVsc2UgeyAvLyBvdXQgb2YgdmlldydzIHZhbGlkIHJhbmdlXG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHR9LFxuXG5cblxuXHQvLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBldmVudCBvYmplY3RzIGludG8gYW4gYXJyYXkgb2YgZXZlbnQgc2VnbWVudCBvYmplY3RzLlxuXHQvLyBBIGN1c3RvbSBgc2VnU2xpY2VGdW5jYCBtYXkgYmUgZ2l2ZW4gZm9yIGFyYml0cmFyaWx5IHNsaWNpbmcgdXAgZXZlbnRzLlxuXHQvLyBEb2Vzbid0IGd1YXJhbnRlZSBhbiBvcmRlciBmb3IgdGhlIHJlc3VsdGluZyBhcnJheS5cblx0ZXZlbnRzVG9TZWdzOiBmdW5jdGlvbihhbGxFdmVudHMsIHNlZ1NsaWNlRnVuYykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIGV2ZW50c0J5SWQgPSBncm91cEV2ZW50c0J5SWQoYWxsRXZlbnRzKTtcblx0XHR2YXIgc2VncyA9IFtdO1xuXG5cdFx0JC5lYWNoKGV2ZW50c0J5SWQsIGZ1bmN0aW9uKGlkLCBldmVudHMpIHtcblx0XHRcdHZhciB2aXNpYmxlRXZlbnRzID0gW107XG5cdFx0XHR2YXIgZXZlbnRSYW5nZXMgPSBbXTtcblx0XHRcdHZhciBldmVudFJhbmdlOyAvLyB7IHN0YXJ0LCBlbmQsIGlzU3RhcnQsIGlzRW5kIH1cblx0XHRcdHZhciBpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGV2ZW50UmFuZ2UgPSBfdGhpcy5ldmVudFRvUmFuZ2UoZXZlbnRzW2ldKTsgLy8gbWlnaHQgYmUgbnVsbCBpZiBjb21wbGV0ZWx5IG91dCBvZiByYW5nZVxuXG5cdFx0XHRcdGlmIChldmVudFJhbmdlKSB7XG5cdFx0XHRcdFx0ZXZlbnRSYW5nZXMucHVzaChldmVudFJhbmdlKTtcblx0XHRcdFx0XHR2aXNpYmxlRXZlbnRzLnB1c2goZXZlbnRzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzICh1dGlsaXplIG9ubHkgdGhlIGZpcnN0IGV2ZW50IGluIGNhbGN1bGF0aW9ucylcblx0XHRcdGlmIChpc0ludmVyc2VCZ0V2ZW50KGV2ZW50c1swXSkpIHtcblx0XHRcdFx0ZXZlbnRSYW5nZXMgPSBfdGhpcy5pbnZlcnRSYW5nZXMoZXZlbnRSYW5nZXMpOyAvLyB3aWxsIGxvc2UgaXNTdGFydC9pc0VuZFxuXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBldmVudFJhbmdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHNlZ3MucHVzaC5hcHBseShzZWdzLCAvLyBhcHBlbmQgdG9cblx0XHRcdFx0XHRcdF90aGlzLmV2ZW50UmFuZ2VUb1NlZ3MoZXZlbnRSYW5nZXNbaV0sIGV2ZW50c1swXSwgc2VnU2xpY2VGdW5jKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIG5vcm1hbCBldmVudCByYW5nZXNcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRSYW5nZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRzZWdzLnB1c2guYXBwbHkoc2VncywgLy8gYXBwZW5kIHRvXG5cdFx0XHRcdFx0XHRfdGhpcy5ldmVudFJhbmdlVG9TZWdzKGV2ZW50UmFuZ2VzW2ldLCB2aXNpYmxlRXZlbnRzW2ldLCBzZWdTbGljZUZ1bmMpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIHVuem9uZWQgc3RhcnQvZW5kIGRhdGVzIGFuIGV2ZW50IGFwcGVhcnMgdG8gb2NjdXB5XG5cdC8vIENhbiBhY2NlcHQgYW4gZXZlbnQgXCJsb2NhdGlvblwiIGFzIHdlbGwgKHdoaWNoIG9ubHkgaGFzIHN0YXJ0L2VuZCBhbmQgbm8gYWxsRGF5KVxuXHQvLyByZXR1cm5zIHsgc3RhcnQsIGVuZCwgaXNTdGFydCwgaXNFbmQgfVxuXHQvLyBJZiB0aGUgZXZlbnQgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSBncmlkJ3MgdmFsaWQgcmFuZ2UsIHdpbGwgcmV0dXJuIHVuZGVmaW5lZC5cblx0ZXZlbnRUb1JhbmdlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiB0aGlzLnJlZmluZVJhd0V2ZW50UmFuZ2UoXG5cdFx0XHR0aGlzLmV2ZW50VG9SYXdSYW5nZShldmVudClcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gRW5zdXJlcyB0aGUgZ2l2ZW4gcmFuZ2UgaXMgd2l0aGluIHRoZSB2aWV3J3MgYWN0aXZlUmFuZ2UgYW5kIGlzIGNvcnJlY3RseSBsb2NhbGl6ZWQuXG5cdC8vIEFsd2F5cyByZXR1cm5zIGEgcmVzdWx0XG5cdHJlZmluZVJhd0V2ZW50UmFuZ2U6IGZ1bmN0aW9uKHJhd1JhbmdlKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcblx0XHR2YXIgcmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMocmF3UmFuZ2UsIHZpZXcuYWN0aXZlUmFuZ2UpO1xuXG5cdFx0aWYgKHJhbmdlKSB7IC8vIG90aGVyd2lzZSwgZXZlbnQgZG9lc24ndCBoYXZlIHZhbGlkIHJhbmdlXG5cblx0XHRcdC8vIGhhY2s6IGR5bmFtaWMgbG9jYWxlIGNoYW5nZSBmb3JnZXRzIHRvIHVwYXRlIHN0b3JlZCBldmVudCBsb2NhbGVkXG5cdFx0XHRjYWxlbmRhci5sb2NhbGl6ZU1vbWVudChyYW5nZS5zdGFydCk7XG5cdFx0XHRjYWxlbmRhci5sb2NhbGl6ZU1vbWVudChyYW5nZS5lbmQpO1xuXG5cdFx0XHRyZXR1cm4gcmFuZ2U7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gbm90IGNvbnN0cmFpbmVkIHRvIHZhbGlkIGRhdGVzXG5cdC8vIG5vdCBnaXZlbiBsb2NhbGl6ZU1vbWVudCBoYWNrXG5cdGV2ZW50VG9SYXdSYW5nZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XG5cdFx0dmFyIHN0YXJ0ID0gZXZlbnQuc3RhcnQuY2xvbmUoKS5zdHJpcFpvbmUoKTtcblx0XHR2YXIgZW5kID0gKFxuXHRcdFx0XHRldmVudC5lbmQgP1xuXHRcdFx0XHRcdGV2ZW50LmVuZC5jbG9uZSgpIDpcblx0XHRcdFx0XHQvLyBkZXJpdmUgdGhlIGVuZCBmcm9tIHRoZSBzdGFydCBhbmQgYWxsRGF5LiBjb21wdXRlIGFsbERheSBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQoXG5cdFx0XHRcdFx0XHRldmVudC5hbGxEYXkgIT0gbnVsbCA/XG5cdFx0XHRcdFx0XHRcdGV2ZW50LmFsbERheSA6XG5cdFx0XHRcdFx0XHRcdCFldmVudC5zdGFydC5oYXNUaW1lKCksXG5cdFx0XHRcdFx0XHRldmVudC5zdGFydFxuXHRcdFx0XHRcdClcblx0XHRcdCkuc3RyaXBab25lKCk7XG5cblx0XHRyZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhbiBldmVudCdzIHJhbmdlICh1bnpvbmVkIHN0YXJ0L2VuZCksIGFuZCB0aGUgZXZlbnQgaXRzZWxmLFxuXHQvLyBzbGljZSBpbnRvIHNlZ21lbnRzICh1c2luZyB0aGUgc2VnU2xpY2VGdW5jIGZ1bmN0aW9uIGlmIHNwZWNpZmllZClcblx0Ly8gZXZlbnRSYW5nZSAtIHsgc3RhcnQsIGVuZCwgaXNTdGFydCwgaXNFbmQgfVxuXHRldmVudFJhbmdlVG9TZWdzOiBmdW5jdGlvbihldmVudFJhbmdlLCBldmVudCwgc2VnU2xpY2VGdW5jKSB7XG5cdFx0dmFyIGV2ZW50U3BhbnMgPSB0aGlzLmV2ZW50UmFuZ2VUb1NwYW5zKGV2ZW50UmFuZ2UsIGV2ZW50KTtcblx0XHR2YXIgc2VncyA9IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGV2ZW50U3BhbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZ3MucHVzaC5hcHBseShzZWdzLCAvLyBhcHBlbmQgdG9cblx0XHRcdFx0dGhpcy5ldmVudFNwYW5Ub1NlZ3MoZXZlbnRTcGFuc1tpXSwgZXZlbnQsIHNlZ1NsaWNlRnVuYylcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhbiBldmVudCdzIHVuem9uZWQgZGF0ZSByYW5nZSwgcmV0dXJuIGFuIGFycmF5IG9mIGV2ZW50U3BhbiBvYmplY3RzLlxuXHQvLyBldmVudFNwYW4gLSB7IHN0YXJ0LCBlbmQsIGlzU3RhcnQsIGlzRW5kLCBvdGhlcnRoaW5ncy4uLiB9XG5cdC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlLlxuXHQvLyBTdWJjbGFzc2VzIGFyZSBvYmxpZ2F0ZWQgdG8gZm9yd2FyZCBldmVudFJhbmdlLmlzU3RhcnQvaXNFbmQgdG8gdGhlIHJlc3VsdGluZyBzcGFucy5cblx0ZXZlbnRSYW5nZVRvU3BhbnM6IGZ1bmN0aW9uKGV2ZW50UmFuZ2UsIGV2ZW50KSB7XG5cdFx0cmV0dXJuIFsgJC5leHRlbmQoe30sIGV2ZW50UmFuZ2UpIF07IC8vIGNvcHkgaW50byBhIHNpbmdsZS1pdGVtIGFycmF5XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhbiBldmVudCdzIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIGFuZCBvdGhlciBtaXNjIGRhdGEpLCBhbmQgdGhlIGV2ZW50IGl0c2VsZixcblx0Ly8gc2xpY2VzIGludG8gc2VnbWVudHMgYW5kIGF0dGFjaGVzIGV2ZW50LWRlcml2ZWQgcHJvcGVydGllcyB0byB0aGVtLlxuXHQvLyBldmVudFNwYW4gLSB7IHN0YXJ0LCBlbmQsIGlzU3RhcnQsIGlzRW5kLCBvdGhlcnRoaW5ncy4uLiB9XG5cdGV2ZW50U3BhblRvU2VnczogZnVuY3Rpb24oZXZlbnRTcGFuLCBldmVudCwgc2VnU2xpY2VGdW5jKSB7XG5cdFx0dmFyIHNlZ3MgPSBzZWdTbGljZUZ1bmMgPyBzZWdTbGljZUZ1bmMoZXZlbnRTcGFuKSA6IHRoaXMuc3BhblRvU2VncyhldmVudFNwYW4pO1xuXHRcdHZhciBpLCBzZWc7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnID0gc2Vnc1tpXTtcblxuXHRcdFx0Ly8gdGhlIGV2ZW50U3BhbidzIGlzU3RhcnQvaXNFbmQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBzZWcnc1xuXHRcdFx0aWYgKCFldmVudFNwYW4uaXNTdGFydCkge1xuXHRcdFx0XHRzZWcuaXNTdGFydCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFldmVudFNwYW4uaXNFbmQpIHtcblx0XHRcdFx0c2VnLmlzRW5kID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHNlZy5ldmVudCA9IGV2ZW50O1xuXHRcdFx0c2VnLmV2ZW50U3RhcnRNUyA9ICtldmVudFNwYW4uc3RhcnQ7IC8vIFRPRE86IG5vdCB0aGUgYmVzdCBuYW1lIGFmdGVyIG1ha2luZyBzcGFucyB1bnpvbmVkXG5cdFx0XHRzZWcuZXZlbnREdXJhdGlvbk1TID0gZXZlbnRTcGFuLmVuZCAtIGV2ZW50U3Bhbi5zdGFydDtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8vIFByb2R1Y2VzIGEgbmV3IGFycmF5IG9mIHJhbmdlIG9iamVjdHMgdGhhdCB3aWxsIGNvdmVyIGFsbCB0aGUgdGltZSBOT1QgY292ZXJlZCBieSB0aGUgZ2l2ZW4gcmFuZ2VzLlxuXHQvLyBTSURFIEVGRkVDVDogd2lsbCBtdXRhdGUgdGhlIGdpdmVuIGFycmF5IGFuZCB3aWxsIHVzZSBpdHMgZGF0ZSByZWZlcmVuY2VzLlxuXHRpbnZlcnRSYW5nZXM6IGZ1bmN0aW9uKHJhbmdlcykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciB2aWV3U3RhcnQgPSB2aWV3LmFjdGl2ZVJhbmdlLnN0YXJ0LmNsb25lKCk7IC8vIG5lZWQgYSBjb3B5XG5cdFx0dmFyIHZpZXdFbmQgPSB2aWV3LmFjdGl2ZVJhbmdlLmVuZC5jbG9uZSgpOyAvLyBuZWVkIGEgY29weVxuXHRcdHZhciBpbnZlcnNlUmFuZ2VzID0gW107XG5cdFx0dmFyIHN0YXJ0ID0gdmlld1N0YXJ0OyAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2Vcblx0XHR2YXIgaSwgcmFuZ2U7XG5cblx0XHQvLyByYW5nZXMgbmVlZCB0byBiZSBpbiBvcmRlci4gcmVxdWlyZWQgZm9yIG91ciBkYXRlLXdhbGtpbmcgYWxnb3JpdGhtXG5cdFx0cmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRyYW5nZSA9IHJhbmdlc1tpXTtcblxuXHRcdFx0Ly8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYmVmb3JlIHRoZSBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuXHRcdFx0aWYgKHJhbmdlLnN0YXJ0ID4gc3RhcnQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcblx0XHRcdFx0aW52ZXJzZVJhbmdlcy5wdXNoKHtcblx0XHRcdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRcdFx0ZW5kOiByYW5nZS5zdGFydFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJhbmdlLmVuZCA+IHN0YXJ0KSB7XG5cdFx0XHRcdHN0YXJ0ID0gcmFuZ2UuZW5kO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGFmdGVyIHRoZSBsYXN0IGV2ZW50IChpZiB0aGVyZSBpcyBhbnkpXG5cdFx0aWYgKHN0YXJ0IDwgdmlld0VuZCkgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxuXHRcdFx0aW52ZXJzZVJhbmdlcy5wdXNoKHtcblx0XHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0XHRlbmQ6IHZpZXdFbmRcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBpbnZlcnNlUmFuZ2VzO1xuXHR9LFxuXG5cblx0c29ydEV2ZW50U2VnczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHNlZ3Muc29ydChwcm94eSh0aGlzLCAnY29tcGFyZUV2ZW50U2VncycpKTtcblx0fSxcblxuXG5cdC8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGljaCBzZWdtZW50cyBzaG91bGQgdGFrZSB2aXN1YWwgcHJpb3JpdHlcblx0Y29tcGFyZUV2ZW50U2VnczogZnVuY3Rpb24oc2VnMSwgc2VnMikge1xuXHRcdHJldHVybiBzZWcxLmV2ZW50U3RhcnRNUyAtIHNlZzIuZXZlbnRTdGFydE1TIHx8IC8vIGVhcmxpZXIgZXZlbnRzIGdvIGZpcnN0XG5cdFx0XHRzZWcyLmV2ZW50RHVyYXRpb25NUyAtIHNlZzEuZXZlbnREdXJhdGlvbk1TIHx8IC8vIHRpZT8gbG9uZ2VyIGV2ZW50cyBnbyBmaXJzdFxuXHRcdFx0c2VnMi5ldmVudC5hbGxEYXkgLSBzZWcxLmV2ZW50LmFsbERheSB8fCAvLyB0aWU/IHB1dCBhbGwtZGF5IGV2ZW50cyBmaXJzdCAoYm9vbGVhbnMgY2FzdCB0byAwLzEpXG5cdFx0XHRjb21wYXJlQnlGaWVsZFNwZWNzKHNlZzEuZXZlbnQsIHNlZzIuZXZlbnQsIHRoaXMudmlldy5ldmVudE9yZGVyU3BlY3MpO1xuXHR9XG5cbn0pO1xuXG5cbi8qIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuZnVuY3Rpb24gcGx1Y2tFdmVudERhdGVQcm9wcyhldmVudCkge1xuXHRyZXR1cm4ge1xuXHRcdHN0YXJ0OiBldmVudC5zdGFydC5jbG9uZSgpLFxuXHRcdGVuZDogZXZlbnQuZW5kID8gZXZlbnQuZW5kLmNsb25lKCkgOiBudWxsLFxuXHRcdGFsbERheTogZXZlbnQuYWxsRGF5IC8vIGtlZXAgaXQgdGhlIHNhbWVcblx0fTtcbn1cbkZDLnBsdWNrRXZlbnREYXRlUHJvcHMgPSBwbHVja0V2ZW50RGF0ZVByb3BzO1xuXG5cbmZ1bmN0aW9uIGlzQmdFdmVudChldmVudCkgeyAvLyByZXR1cm5zIHRydWUgaWYgYmFja2dyb3VuZCBPUiBpbnZlcnNlLWJhY2tncm91bmRcblx0dmFyIHJlbmRlcmluZyA9IGdldEV2ZW50UmVuZGVyaW5nKGV2ZW50KTtcblx0cmV0dXJuIHJlbmRlcmluZyA9PT0gJ2JhY2tncm91bmQnIHx8IHJlbmRlcmluZyA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCc7XG59XG5GQy5pc0JnRXZlbnQgPSBpc0JnRXZlbnQ7IC8vIGV4cG9ydFxuXG5cbmZ1bmN0aW9uIGlzSW52ZXJzZUJnRXZlbnQoZXZlbnQpIHtcblx0cmV0dXJuIGdldEV2ZW50UmVuZGVyaW5nKGV2ZW50KSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCc7XG59XG5cblxuZnVuY3Rpb24gZ2V0RXZlbnRSZW5kZXJpbmcoZXZlbnQpIHtcblx0cmV0dXJuIGZpcnN0RGVmaW5lZCgoZXZlbnQuc291cmNlIHx8IHt9KS5yZW5kZXJpbmcsIGV2ZW50LnJlbmRlcmluZyk7XG59XG5cblxuZnVuY3Rpb24gZ3JvdXBFdmVudHNCeUlkKGV2ZW50cykge1xuXHR2YXIgZXZlbnRzQnlJZCA9IHt9O1xuXHR2YXIgaSwgZXZlbnQ7XG5cblx0Zm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGV2ZW50ID0gZXZlbnRzW2ldO1xuXHRcdChldmVudHNCeUlkW2V2ZW50Ll9pZF0gfHwgKGV2ZW50c0J5SWRbZXZlbnQuX2lkXSA9IFtdKSkucHVzaChldmVudCk7XG5cdH1cblxuXHRyZXR1cm4gZXZlbnRzQnlJZDtcbn1cblxuXG4vLyBBIGNtcCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgd2hpY2ggbm9uLWludmVydGVkIFwicmFuZ2VzXCIgKHNlZSBhYm92ZSkgaGFwcGVuIGVhcmxpZXJcbmZ1bmN0aW9uIGNvbXBhcmVSYW5nZXMocmFuZ2UxLCByYW5nZTIpIHtcblx0cmV0dXJuIHJhbmdlMS5zdGFydCAtIHJhbmdlMi5zdGFydDsgLy8gZWFybGllciByYW5nZXMgZ28gZmlyc3Rcbn1cblxuXG4vKiBFeHRlcm5hbC1EcmFnZ2luZy1FbGVtZW50IERhdGFcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vLyBSZXF1aXJlIGFsbCBIVE1MNSBkYXRhLSogYXR0cmlidXRlcyB1c2VkIGJ5IEZ1bGxDYWxlbmRhciB0byBoYXZlIHRoaXMgcHJlZml4LlxuLy8gQSB2YWx1ZSBvZiAnJyB3aWxsIHF1ZXJ5IGF0dHJpYnV0ZXMgbGlrZSBkYXRhLWV2ZW50LiBBIHZhbHVlIG9mICdmYycgd2lsbCBxdWVyeSBhdHRyaWJ1dGVzIGxpa2UgZGF0YS1mYy1ldmVudC5cbkZDLmRhdGFBdHRyUHJlZml4ID0gJyc7XG5cbi8vIEdpdmVuIGEgalF1ZXJ5IGVsZW1lbnQgdGhhdCBtaWdodCByZXByZXNlbnQgYSBkcmFnZ2VkIEZ1bGxDYWxlbmRhciBldmVudCwgcmV0dXJucyBhbiBpbnRlcm1lZGlhdGUgZGF0YSBzdHJ1Y3R1cmVcbi8vIHRvIGJlIHVzZWQgZm9yIEV2ZW50IE9iamVjdCBjcmVhdGlvbi5cbi8vIEEgZGVmaW5lZCBgLmV2ZW50UHJvcHNgLCBldmVuIHdoZW4gZW1wdHksIGluZGljYXRlcyB0aGF0IGFuIGV2ZW50IHNob3VsZCBiZSBjcmVhdGVkLlxuZnVuY3Rpb24gZ2V0RHJhZ2dlZEVsTWV0YShlbCkge1xuXHR2YXIgcHJlZml4ID0gRkMuZGF0YUF0dHJQcmVmaXg7XG5cdHZhciBldmVudFByb3BzOyAvLyBwcm9wZXJ0aWVzIGZvciBjcmVhdGluZyB0aGUgZXZlbnQsIG5vdCByZWxhdGVkIHRvIGRhdGUvdGltZVxuXHR2YXIgc3RhcnRUaW1lOyAvLyBhIER1cmF0aW9uXG5cdHZhciBkdXJhdGlvbjtcblx0dmFyIHN0aWNrO1xuXG5cdGlmIChwcmVmaXgpIHsgcHJlZml4ICs9ICctJzsgfVxuXHRldmVudFByb3BzID0gZWwuZGF0YShwcmVmaXggKyAnZXZlbnQnKSB8fCBudWxsO1xuXG5cdGlmIChldmVudFByb3BzKSB7XG5cdFx0aWYgKHR5cGVvZiBldmVudFByb3BzID09PSAnb2JqZWN0Jykge1xuXHRcdFx0ZXZlbnRQcm9wcyA9ICQuZXh0ZW5kKHt9LCBldmVudFByb3BzKTsgLy8gbWFrZSBhIGNvcHlcblx0XHR9XG5cdFx0ZWxzZSB7IC8vIHNvbWV0aGluZyBsaWtlIDEgb3IgdHJ1ZS4gc3RpbGwgc2lnbmFsIGV2ZW50IGNyZWF0aW9uXG5cdFx0XHRldmVudFByb3BzID0ge307XG5cdFx0fVxuXG5cdFx0Ly8gcGx1Y2sgc3BlY2lhbC1jYXNlZCBkYXRlL3RpbWUgcHJvcGVydGllc1xuXHRcdHN0YXJ0VGltZSA9IGV2ZW50UHJvcHMuc3RhcnQ7XG5cdFx0aWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7IHN0YXJ0VGltZSA9IGV2ZW50UHJvcHMudGltZTsgfSAvLyBhY2NlcHQgJ3RpbWUnIGFzIHdlbGxcblx0XHRkdXJhdGlvbiA9IGV2ZW50UHJvcHMuZHVyYXRpb247XG5cdFx0c3RpY2sgPSBldmVudFByb3BzLnN0aWNrO1xuXHRcdGRlbGV0ZSBldmVudFByb3BzLnN0YXJ0O1xuXHRcdGRlbGV0ZSBldmVudFByb3BzLnRpbWU7XG5cdFx0ZGVsZXRlIGV2ZW50UHJvcHMuZHVyYXRpb247XG5cdFx0ZGVsZXRlIGV2ZW50UHJvcHMuc3RpY2s7XG5cdH1cblxuXHQvLyBmYWxsYmFjayB0byBzdGFuZGFsb25lIGF0dHJpYnV0ZSB2YWx1ZXMgZm9yIGVhY2ggb2YgdGhlIGRhdGUvdGltZSBwcm9wZXJ0aWVzXG5cdGlmIChzdGFydFRpbWUgPT0gbnVsbCkgeyBzdGFydFRpbWUgPSBlbC5kYXRhKHByZWZpeCArICdzdGFydCcpOyB9XG5cdGlmIChzdGFydFRpbWUgPT0gbnVsbCkgeyBzdGFydFRpbWUgPSBlbC5kYXRhKHByZWZpeCArICd0aW1lJyk7IH0gLy8gYWNjZXB0ICd0aW1lJyBhcyB3ZWxsXG5cdGlmIChkdXJhdGlvbiA9PSBudWxsKSB7IGR1cmF0aW9uID0gZWwuZGF0YShwcmVmaXggKyAnZHVyYXRpb24nKTsgfVxuXHRpZiAoc3RpY2sgPT0gbnVsbCkgeyBzdGljayA9IGVsLmRhdGEocHJlZml4ICsgJ3N0aWNrJyk7IH1cblxuXHQvLyBtYXNzYWdlIGludG8gY29ycmVjdCBkYXRhIHR5cGVzXG5cdHN0YXJ0VGltZSA9IHN0YXJ0VGltZSAhPSBudWxsID8gbW9tZW50LmR1cmF0aW9uKHN0YXJ0VGltZSkgOiBudWxsO1xuXHRkdXJhdGlvbiA9IGR1cmF0aW9uICE9IG51bGwgPyBtb21lbnQuZHVyYXRpb24oZHVyYXRpb24pIDogbnVsbDtcblx0c3RpY2sgPSBCb29sZWFuKHN0aWNrKTtcblxuXHRyZXR1cm4geyBldmVudFByb3BzOiBldmVudFByb3BzLCBzdGFydFRpbWU6IHN0YXJ0VGltZSwgZHVyYXRpb246IGR1cmF0aW9uLCBzdGljazogc3RpY2sgfTtcbn1cblxuXG47O1xuXG4vKlxuQSBzZXQgb2YgcmVuZGVyaW5nIGFuZCBkYXRlLXJlbGF0ZWQgbWV0aG9kcyBmb3IgYSB2aXN1YWwgY29tcG9uZW50IGNvbXByaXNlZCBvZiBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjb2x1bW5zLlxuUHJlcmVxdWlzaXRlOiB0aGUgb2JqZWN0IGJlaW5nIG1peGVkIGludG8gbmVlZHMgdG8gYmUgYSAqR3JpZCpcbiovXG52YXIgRGF5VGFibGVNaXhpbiA9IEZDLkRheVRhYmxlTWl4aW4gPSB7XG5cblx0YnJlYWtPbldlZWtzOiBmYWxzZSwgLy8gc2hvdWxkIGNyZWF0ZSBhIG5ldyByb3cgZm9yIGVhY2ggd2Vlaz9cblx0ZGF5RGF0ZXM6IG51bGwsIC8vIHdob2xlLWRheSBkYXRlcyBmb3IgZWFjaCBjb2x1bW4uIGxlZnQgdG8gcmlnaHRcblx0ZGF5SW5kaWNlczogbnVsbCwgLy8gZm9yIGVhY2ggZGF5IGZyb20gc3RhcnQsIHRoZSBvZmZzZXRcblx0ZGF5c1BlclJvdzogbnVsbCxcblx0cm93Q250OiBudWxsLFxuXHRjb2xDbnQ6IG51bGwsXG5cdGNvbEhlYWRGb3JtYXQ6IG51bGwsXG5cblxuXHQvLyBQb3B1bGF0ZXMgaW50ZXJuYWwgdmFyaWFibGVzIHVzZWQgZm9yIGRhdGUgY2FsY3VsYXRpb24gYW5kIHJlbmRlcmluZ1xuXHR1cGRhdGVEYXlUYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGRhdGUgPSB0aGlzLnN0YXJ0LmNsb25lKCk7XG5cdFx0dmFyIGRheUluZGV4ID0gLTE7XG5cdFx0dmFyIGRheUluZGljZXMgPSBbXTtcblx0XHR2YXIgZGF5RGF0ZXMgPSBbXTtcblx0XHR2YXIgZGF5c1BlclJvdztcblx0XHR2YXIgZmlyc3REYXk7XG5cdFx0dmFyIHJvd0NudDtcblxuXHRcdHdoaWxlIChkYXRlLmlzQmVmb3JlKHRoaXMuZW5kKSkgeyAvLyBsb29wIGVhY2ggZGF5IGZyb20gc3RhcnQgdG8gZW5kXG5cdFx0XHRpZiAodmlldy5pc0hpZGRlbkRheShkYXRlKSkge1xuXHRcdFx0XHRkYXlJbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpOyAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRkYXlJbmRleCsrO1xuXHRcdFx0XHRkYXlJbmRpY2VzLnB1c2goZGF5SW5kZXgpO1xuXHRcdFx0XHRkYXlEYXRlcy5wdXNoKGRhdGUuY2xvbmUoKSk7XG5cdFx0XHR9XG5cdFx0XHRkYXRlLmFkZCgxLCAnZGF5cycpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmJyZWFrT25XZWVrcykge1xuXHRcdFx0Ly8gY291bnQgY29sdW1ucyB1bnRpbCB0aGUgZGF5LW9mLXdlZWsgcmVwZWF0c1xuXHRcdFx0Zmlyc3REYXkgPSBkYXlEYXRlc1swXS5kYXkoKTtcblx0XHRcdGZvciAoZGF5c1BlclJvdyA9IDE7IGRheXNQZXJSb3cgPCBkYXlEYXRlcy5sZW5ndGg7IGRheXNQZXJSb3crKykge1xuXHRcdFx0XHRpZiAoZGF5RGF0ZXNbZGF5c1BlclJvd10uZGF5KCkgPT0gZmlyc3REYXkpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cm93Q250ID0gTWF0aC5jZWlsKGRheURhdGVzLmxlbmd0aCAvIGRheXNQZXJSb3cpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJvd0NudCA9IDE7XG5cdFx0XHRkYXlzUGVyUm93ID0gZGF5RGF0ZXMubGVuZ3RoO1xuXHRcdH1cblxuXHRcdHRoaXMuZGF5RGF0ZXMgPSBkYXlEYXRlcztcblx0XHR0aGlzLmRheUluZGljZXMgPSBkYXlJbmRpY2VzO1xuXHRcdHRoaXMuZGF5c1BlclJvdyA9IGRheXNQZXJSb3c7XG5cdFx0dGhpcy5yb3dDbnQgPSByb3dDbnQ7XG5cblx0XHR0aGlzLnVwZGF0ZURheVRhYmxlQ29scygpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgYW5kIGFzc2lnbmVkIHRoZSBjb2xDbnQgcHJvcGVydHkgYW5kIHVwZGF0ZXMgYW55IG9wdGlvbnMgdGhhdCBtYXkgYmUgY29tcHV0ZWQgZnJvbSBpdFxuXHR1cGRhdGVEYXlUYWJsZUNvbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29sQ250ID0gdGhpcy5jb21wdXRlQ29sQ250KCk7XG5cdFx0dGhpcy5jb2xIZWFkRm9ybWF0ID0gdGhpcy52aWV3Lm9wdCgnY29sdW1uRm9ybWF0JykgfHwgdGhpcy5jb21wdXRlQ29sSGVhZEZvcm1hdCgpO1xuXHR9LFxuXG5cblx0Ly8gRGV0ZXJtaW5lcyBob3cgbWFueSBjb2x1bW5zIHRoZXJlIHNob3VsZCBiZSBpbiB0aGUgdGFibGVcblx0Y29tcHV0ZUNvbENudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF5c1BlclJvdztcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIHRoZSBhbWJpZ3VvdXNseS10aW1lZCBtb21lbnQgZm9yIHRoZSBnaXZlbiBjZWxsXG5cdGdldENlbGxEYXRlOiBmdW5jdGlvbihyb3csIGNvbCkge1xuXHRcdHJldHVybiB0aGlzLmRheURhdGVzW1xuXHRcdFx0XHR0aGlzLmdldENlbGxEYXlJbmRleChyb3csIGNvbClcblx0XHRcdF0uY2xvbmUoKTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIHRoZSBhbWJpZ3VvdXNseS10aW1lZCBkYXRlIHJhbmdlIGZvciB0aGUgZ2l2ZW4gY2VsbFxuXHRnZXRDZWxsUmFuZ2U6IGZ1bmN0aW9uKHJvdywgY29sKSB7XG5cdFx0dmFyIHN0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XG5cdFx0dmFyIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKDEsICdkYXlzJyk7XG5cblx0XHRyZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5IGNlbGxzLCBjaHJvbm9sb2dpY2FsbHksIGZyb20gdGhlIGZpcnN0IG9mIHRoZSBncmlkICgwLWJhc2VkKVxuXHRnZXRDZWxsRGF5SW5kZXg6IGZ1bmN0aW9uKHJvdywgY29sKSB7XG5cdFx0cmV0dXJuIHJvdyAqIHRoaXMuZGF5c1BlclJvdyArIHRoaXMuZ2V0Q29sRGF5SW5kZXgoY29sKTtcblx0fSxcblxuXG5cdC8vIFJldHVybnMgdGhlIG51bW5lciBvZiBkYXkgY2VsbHMsIGNocm9ub2xvZ2ljYWxseSwgZnJvbSB0aGUgZmlyc3QgY2VsbCBpbiAqYW55IGdpdmVuIHJvdypcblx0Z2V0Q29sRGF5SW5kZXg6IGZ1bmN0aW9uKGNvbCkge1xuXHRcdGlmICh0aGlzLmlzUlRMKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2xDbnQgLSAxIC0gY29sO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiBjb2w7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxuXHQvLyBJZiB0aGUgZGF0ZSBsaWVzIGJldHdlZW4gY2VsbHMgKGJlY2F1c2Ugb2YgaGlkZGVuRGF5cyksIHJldHVybnMgYSBmbG9hdGluZy1wb2ludCB2YWx1ZSBiZXR3ZWVuIG9mZnNldHMuXG5cdC8vIElmIGJlZm9yZSB0aGUgZmlyc3Qgb2Zmc2V0LCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyLlxuXHQvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXG5cdC8vIE9ubHkgd29ya3MgZm9yICpzdGFydCogZGF0ZXMgb2YgY2VsbHMuIFdpbGwgbm90IHdvcmsgZm9yIGV4Y2x1c2l2ZSBlbmQgZGF0ZXMgZm9yIGNlbGxzLlxuXHRnZXREYXRlRGF5SW5kZXg6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR2YXIgZGF5SW5kaWNlcyA9IHRoaXMuZGF5SW5kaWNlcztcblx0XHR2YXIgZGF5T2Zmc2V0ID0gZGF0ZS5kaWZmKHRoaXMuc3RhcnQsICdkYXlzJyk7XG5cblx0XHRpZiAoZGF5T2Zmc2V0IDwgMCkge1xuXHRcdFx0cmV0dXJuIGRheUluZGljZXNbMF0gLSAxO1xuXHRcdH1cblx0XHRlbHNlIGlmIChkYXlPZmZzZXQgPj0gZGF5SW5kaWNlcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBkYXlJbmRpY2VzW2RheUluZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiBkYXlJbmRpY2VzW2RheU9mZnNldF07XG5cdFx0fVxuXHR9LFxuXG5cblx0LyogT3B0aW9uc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ29tcHV0ZXMgYSBkZWZhdWx0IGNvbHVtbiBoZWFkZXIgZm9ybWF0dGluZyBzdHJpbmcgaWYgYGNvbEZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxuXHRjb21wdXRlQ29sSGVhZEZvcm1hdDogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gaWYgbW9yZSB0aGFuIG9uZSB3ZWVrIHJvdywgb3IgaWYgdGhlcmUgYXJlIGEgbG90IG9mIGNvbHVtbnMgd2l0aCBub3QgbXVjaCBzcGFjZSxcblx0XHQvLyBwdXQganVzdCB0aGUgZGF5IG51bWJlcnMgd2lsbCBiZSBpbiBlYWNoIGNlbGxcblx0XHRpZiAodGhpcy5yb3dDbnQgPiAxIHx8IHRoaXMuY29sQ250ID4gMTApIHtcblx0XHRcdHJldHVybiAnZGRkJzsgLy8gXCJTYXRcIlxuXHRcdH1cblx0XHQvLyBtdWx0aXBsZSBkYXlzLCBzbyBmdWxsIHNpbmdsZSBkYXRlIHN0cmluZyBXT04nVCBiZSBpbiB0aXRsZSB0ZXh0XG5cdFx0ZWxzZSBpZiAodGhpcy5jb2xDbnQgPiAxKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3Lm9wdCgnZGF5T2ZNb250aEZvcm1hdCcpOyAvLyBcIlNhdCAxMi8xMFwiXG5cdFx0fVxuXHRcdC8vIHNpbmdsZSBkYXksIHNvIGZ1bGwgc2luZ2xlIGRhdGUgc3RyaW5nIHdpbGwgcHJvYmFibHkgYmUgaW4gdGl0bGUgdGV4dFxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICdkZGRkJzsgLy8gXCJTYXR1cmRheVwiXG5cdFx0fVxuXHR9LFxuXG5cblx0LyogU2xpY2luZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gU2xpY2VzIHVwIGEgZGF0ZSByYW5nZSBpbnRvIGEgc2VnbWVudCBmb3IgZXZlcnkgd2Vlay1yb3cgaXQgaW50ZXJzZWN0cyB3aXRoXG5cdHNsaWNlUmFuZ2VCeVJvdzogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHR2YXIgZGF5c1BlclJvdyA9IHRoaXMuZGF5c1BlclJvdztcblx0XHR2YXIgbm9ybWFsUmFuZ2UgPSB0aGlzLnZpZXcuY29tcHV0ZURheVJhbmdlKHJhbmdlKTsgLy8gbWFrZSB3aG9sZS1kYXkgcmFuZ2UsIGNvbnNpZGVyaW5nIG5leHREYXlUaHJlc2hvbGRcblx0XHR2YXIgcmFuZ2VGaXJzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XG5cdFx0dmFyIHJhbmdlTGFzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLmVuZC5jbG9uZSgpLnN1YnRyYWN0KDEsICdkYXlzJykpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxuXHRcdHZhciBzZWdzID0gW107XG5cdFx0dmFyIHJvdztcblx0XHR2YXIgcm93Rmlyc3QsIHJvd0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIGN1cnJlbnQgcm93XG5cdFx0dmFyIHNlZ0ZpcnN0LCBzZWdMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBzZWdtZW50XG5cblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3crKykge1xuXHRcdFx0cm93Rmlyc3QgPSByb3cgKiBkYXlzUGVyUm93O1xuXHRcdFx0cm93TGFzdCA9IHJvd0ZpcnN0ICsgZGF5c1BlclJvdyAtIDE7XG5cblx0XHRcdC8vIGludGVyc2VjdCBzZWdtZW50J3Mgb2Zmc2V0IHJhbmdlIHdpdGggdGhlIHJvdydzXG5cdFx0XHRzZWdGaXJzdCA9IE1hdGgubWF4KHJhbmdlRmlyc3QsIHJvd0ZpcnN0KTtcblx0XHRcdHNlZ0xhc3QgPSBNYXRoLm1pbihyYW5nZUxhc3QsIHJvd0xhc3QpO1xuXG5cdFx0XHQvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXG5cdFx0XHRzZWdGaXJzdCA9IE1hdGguY2VpbChzZWdGaXJzdCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxuXHRcdFx0c2VnTGFzdCA9IE1hdGguZmxvb3Ioc2VnTGFzdCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcblxuXHRcdFx0aWYgKHNlZ0ZpcnN0IDw9IHNlZ0xhc3QpIHsgLy8gd2FzIHRoZXJlIGFueSBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgY3VycmVudCByb3c/XG5cdFx0XHRcdHNlZ3MucHVzaCh7XG5cdFx0XHRcdFx0cm93OiByb3csXG5cblx0XHRcdFx0XHQvLyBub3JtYWxpemUgdG8gc3RhcnQgb2Ygcm93XG5cdFx0XHRcdFx0Zmlyc3RSb3dEYXlJbmRleDogc2VnRmlyc3QgLSByb3dGaXJzdCxcblx0XHRcdFx0XHRsYXN0Um93RGF5SW5kZXg6IHNlZ0xhc3QgLSByb3dGaXJzdCxcblxuXHRcdFx0XHRcdC8vIG11c3QgYmUgbWF0Y2hpbmcgaW50ZWdlcnMgdG8gYmUgdGhlIHNlZ21lbnQncyBzdGFydC9lbmRcblx0XHRcdFx0XHRpc1N0YXJ0OiBzZWdGaXJzdCA9PT0gcmFuZ2VGaXJzdCxcblx0XHRcdFx0XHRpc0VuZDogc2VnTGFzdCA9PT0gcmFuZ2VMYXN0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0Ly8gU2xpY2VzIHVwIGEgZGF0ZSByYW5nZSBpbnRvIGEgc2VnbWVudCBmb3IgZXZlcnkgZGF5LWNlbGwgaXQgaW50ZXJzZWN0cyB3aXRoLlxuXHQvLyBUT0RPOiBtYWtlIG1vcmUgRFJZIHdpdGggc2xpY2VSYW5nZUJ5Um93IHNvbWVob3cuXG5cdHNsaWNlUmFuZ2VCeURheTogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHR2YXIgZGF5c1BlclJvdyA9IHRoaXMuZGF5c1BlclJvdztcblx0XHR2YXIgbm9ybWFsUmFuZ2UgPSB0aGlzLnZpZXcuY29tcHV0ZURheVJhbmdlKHJhbmdlKTsgLy8gbWFrZSB3aG9sZS1kYXkgcmFuZ2UsIGNvbnNpZGVyaW5nIG5leHREYXlUaHJlc2hvbGRcblx0XHR2YXIgcmFuZ2VGaXJzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XG5cdFx0dmFyIHJhbmdlTGFzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLmVuZC5jbG9uZSgpLnN1YnRyYWN0KDEsICdkYXlzJykpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxuXHRcdHZhciBzZWdzID0gW107XG5cdFx0dmFyIHJvdztcblx0XHR2YXIgcm93Rmlyc3QsIHJvd0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIGN1cnJlbnQgcm93XG5cdFx0dmFyIGk7XG5cdFx0dmFyIHNlZ0ZpcnN0LCBzZWdMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBzZWdtZW50XG5cblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3crKykge1xuXHRcdFx0cm93Rmlyc3QgPSByb3cgKiBkYXlzUGVyUm93O1xuXHRcdFx0cm93TGFzdCA9IHJvd0ZpcnN0ICsgZGF5c1BlclJvdyAtIDE7XG5cblx0XHRcdGZvciAoaSA9IHJvd0ZpcnN0OyBpIDw9IHJvd0xhc3Q7IGkrKykge1xuXG5cdFx0XHRcdC8vIGludGVyc2VjdCBzZWdtZW50J3Mgb2Zmc2V0IHJhbmdlIHdpdGggdGhlIHJvdydzXG5cdFx0XHRcdHNlZ0ZpcnN0ID0gTWF0aC5tYXgocmFuZ2VGaXJzdCwgaSk7XG5cdFx0XHRcdHNlZ0xhc3QgPSBNYXRoLm1pbihyYW5nZUxhc3QsIGkpO1xuXG5cdFx0XHRcdC8vIGRlYWwgd2l0aCBpbi1iZXR3ZWVuIGluZGljZXNcblx0XHRcdFx0c2VnRmlyc3QgPSBNYXRoLmNlaWwoc2VnRmlyc3QpOyAvLyBpbi1iZXR3ZWVuIHN0YXJ0cyByb3VuZCB0byBuZXh0IGNlbGxcblx0XHRcdFx0c2VnTGFzdCA9IE1hdGguZmxvb3Ioc2VnTGFzdCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcblxuXHRcdFx0XHRpZiAoc2VnRmlyc3QgPD0gc2VnTGFzdCkgeyAvLyB3YXMgdGhlcmUgYW55IGludGVyc2VjdGlvbiB3aXRoIHRoZSBjdXJyZW50IHJvdz9cblx0XHRcdFx0XHRzZWdzLnB1c2goe1xuXHRcdFx0XHRcdFx0cm93OiByb3csXG5cblx0XHRcdFx0XHRcdC8vIG5vcm1hbGl6ZSB0byBzdGFydCBvZiByb3dcblx0XHRcdFx0XHRcdGZpcnN0Um93RGF5SW5kZXg6IHNlZ0ZpcnN0IC0gcm93Rmlyc3QsXG5cdFx0XHRcdFx0XHRsYXN0Um93RGF5SW5kZXg6IHNlZ0xhc3QgLSByb3dGaXJzdCxcblxuXHRcdFx0XHRcdFx0Ly8gbXVzdCBiZSBtYXRjaGluZyBpbnRlZ2VycyB0byBiZSB0aGUgc2VnbWVudCdzIHN0YXJ0L2VuZFxuXHRcdFx0XHRcdFx0aXNTdGFydDogc2VnRmlyc3QgPT09IHJhbmdlRmlyc3QsXG5cdFx0XHRcdFx0XHRpc0VuZDogc2VnTGFzdCA9PT0gcmFuZ2VMYXN0XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8qIEhlYWRlciBSZW5kZXJpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckhlYWRIdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdHJldHVybiAnJyArXG5cdFx0XHQnPGRpdiBjbGFzcz1cImZjLXJvdyAnICsgdmlldy53aWRnZXRIZWFkZXJDbGFzcyArICdcIj4nICtcblx0XHRcdFx0Jzx0YWJsZT4nICtcblx0XHRcdFx0XHQnPHRoZWFkPicgK1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJIZWFkVHJIdG1sKCkgK1xuXHRcdFx0XHRcdCc8L3RoZWFkPicgK1xuXHRcdFx0XHQnPC90YWJsZT4nICtcblx0XHRcdCc8L2Rpdj4nO1xuXHR9LFxuXG5cblx0cmVuZGVySGVhZEludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7IC8vIGZhbGwgYmFjayB0byBnZW5lcmljXG5cdH0sXG5cblxuXHRyZW5kZXJIZWFkVHJIdG1sOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0Jzx0cj4nICtcblx0XHRcdFx0KHRoaXMuaXNSVEwgPyAnJyA6IHRoaXMucmVuZGVySGVhZEludHJvSHRtbCgpKSArXG5cdFx0XHRcdHRoaXMucmVuZGVySGVhZERhdGVDZWxsc0h0bWwoKSArXG5cdFx0XHRcdCh0aGlzLmlzUlRMID8gdGhpcy5yZW5kZXJIZWFkSW50cm9IdG1sKCkgOiAnJykgK1xuXHRcdFx0JzwvdHI+Jztcblx0fSxcblxuXG5cdHJlbmRlckhlYWREYXRlQ2VsbHNIdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaHRtbHMgPSBbXTtcblx0XHR2YXIgY29sLCBkYXRlO1xuXG5cdFx0Zm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcblx0XHRcdGRhdGUgPSB0aGlzLmdldENlbGxEYXRlKDAsIGNvbCk7XG5cdFx0XHRodG1scy5wdXNoKHRoaXMucmVuZGVySGVhZERhdGVDZWxsSHRtbChkYXRlKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGh0bWxzLmpvaW4oJycpO1xuXHR9LFxuXG5cblx0Ly8gVE9ETzogd2hlbiBpbnRlcm5hbEFwaVZlcnNpb24sIGFjY2VwdCBhbiBvYmplY3QgZm9yIEhUTUwgYXR0cmlidXRlc1xuXHQvLyAoY29sc3BhbiBzaG91bGQgYmUgbm8gZGlmZmVyZW50KVxuXHRyZW5kZXJIZWFkRGF0ZUNlbGxIdG1sOiBmdW5jdGlvbihkYXRlLCBjb2xzcGFuLCBvdGhlckF0dHJzKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGlzRGF0ZVZhbGlkID0gaXNEYXRlV2l0aGluUmFuZ2UoZGF0ZSwgdmlldy5hY3RpdmVSYW5nZSk7IC8vIFRPRE86IGNhbGxlZCB0b28gZnJlcXVlbnRseS4gY2FjaGUgc29tZWhvdy5cblx0XHR2YXIgY2xhc3NOYW1lcyA9IFtcblx0XHRcdCdmYy1kYXktaGVhZGVyJyxcblx0XHRcdHZpZXcud2lkZ2V0SGVhZGVyQ2xhc3Ncblx0XHRdO1xuXHRcdHZhciBpbm5lckh0bWwgPSBodG1sRXNjYXBlKGRhdGUuZm9ybWF0KHRoaXMuY29sSGVhZEZvcm1hdCkpO1xuXG5cdFx0Ly8gaWYgb25seSBvbmUgcm93IG9mIGRheXMsIHRoZSBjbGFzc05hbWVzIG9uIHRoZSBoZWFkZXIgY2FuIHJlcHJlc2VudCB0aGUgc3BlY2lmaWMgZGF5cyBiZW5lYXRoXG5cdFx0aWYgKHRoaXMucm93Q250ID09PSAxKSB7XG5cdFx0XHRjbGFzc05hbWVzID0gY2xhc3NOYW1lcy5jb25jYXQoXG5cdFx0XHRcdC8vIGluY2x1ZGVzIHRoZSBkYXktb2Ytd2VlayBjbGFzc1xuXHRcdFx0XHQvLyBub1RoZW1lSGlnaGxpZ2h0PXRydWUgKGRvbid0IGhpZ2hsaWdodCB0aGUgaGVhZGVyKVxuXHRcdFx0XHR0aGlzLmdldERheUNsYXNzZXMoZGF0ZSwgdHJ1ZSlcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Y2xhc3NOYW1lcy5wdXNoKCdmYy0nICsgZGF5SURzW2RhdGUuZGF5KCldKTsgLy8gb25seSBhZGQgdGhlIGRheS1vZi13ZWVrIGNsYXNzXG5cdFx0fVxuXG5cdFx0cmV0dXJuICcnICtcbiAgICAgICAgICAgICc8dGggY2xhc3M9XCInICsgY2xhc3NOYW1lcy5qb2luKCcgJykgKyAnXCInICtcblx0XHRcdFx0KChpc0RhdGVWYWxpZCAmJiB0aGlzLnJvd0NudCkgPT09IDEgP1xuXHRcdFx0XHRcdCcgZGF0YS1kYXRlPVwiJyArIGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykgKyAnXCInIDpcblx0XHRcdFx0XHQnJykgK1xuXHRcdFx0XHQoY29sc3BhbiA+IDEgP1xuXHRcdFx0XHRcdCcgY29sc3Bhbj1cIicgKyBjb2xzcGFuICsgJ1wiJyA6XG5cdFx0XHRcdFx0JycpICtcblx0XHRcdFx0KG90aGVyQXR0cnMgP1xuXHRcdFx0XHRcdCcgJyArIG90aGVyQXR0cnMgOlxuXHRcdFx0XHRcdCcnKSArXG5cdFx0XHRcdCc+JyArXG5cdFx0XHRcdChpc0RhdGVWYWxpZCA/XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgbWFrZSBhIGxpbmsgaWYgdGhlIGhlYWRpbmcgY291bGQgcmVwcmVzZW50IG11bHRpcGxlIGRheXMsIG9yIGlmIHRoZXJlJ3Mgb25seSBvbmUgZGF5IChmb3JjZU9mZilcblx0XHRcdFx0XHR2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoXG5cdFx0XHRcdFx0XHR7IGRhdGU6IGRhdGUsIGZvcmNlT2ZmOiB0aGlzLnJvd0NudCA+IDEgfHwgdGhpcy5jb2xDbnQgPT09IDEgfSxcblx0XHRcdFx0XHRcdGlubmVySHRtbFxuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdC8vIGlmIG5vdCB2YWxpZCwgZGlzcGxheSB0ZXh0LCBidXQgbm8gbGlua1xuXHRcdFx0XHRcdGlubmVySHRtbFxuXHRcdFx0XHQpICtcblx0XHRcdCc8L3RoPic7XG5cdH0sXG5cblxuXHQvKiBCYWNrZ3JvdW5kIFJlbmRlcmluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyQmdUckh0bWw6IGZ1bmN0aW9uKHJvdykge1xuXHRcdHJldHVybiAnJyArXG5cdFx0XHQnPHRyPicgK1xuXHRcdFx0XHQodGhpcy5pc1JUTCA/ICcnIDogdGhpcy5yZW5kZXJCZ0ludHJvSHRtbChyb3cpKSArXG5cdFx0XHRcdHRoaXMucmVuZGVyQmdDZWxsc0h0bWwocm93KSArXG5cdFx0XHRcdCh0aGlzLmlzUlRMID8gdGhpcy5yZW5kZXJCZ0ludHJvSHRtbChyb3cpIDogJycpICtcblx0XHRcdCc8L3RyPic7XG5cdH0sXG5cblxuXHRyZW5kZXJCZ0ludHJvSHRtbDogZnVuY3Rpb24ocm93KSB7XG5cdFx0cmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7IC8vIGZhbGwgYmFjayB0byBnZW5lcmljXG5cdH0sXG5cblxuXHRyZW5kZXJCZ0NlbGxzSHRtbDogZnVuY3Rpb24ocm93KSB7XG5cdFx0dmFyIGh0bWxzID0gW107XG5cdFx0dmFyIGNvbCwgZGF0ZTtcblxuXHRcdGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCsrKSB7XG5cdFx0XHRkYXRlID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XG5cdFx0XHRodG1scy5wdXNoKHRoaXMucmVuZGVyQmdDZWxsSHRtbChkYXRlKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGh0bWxzLmpvaW4oJycpO1xuXHR9LFxuXG5cblx0cmVuZGVyQmdDZWxsSHRtbDogZnVuY3Rpb24oZGF0ZSwgb3RoZXJBdHRycykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBpc0RhdGVWYWxpZCA9IGlzRGF0ZVdpdGhpblJhbmdlKGRhdGUsIHZpZXcuYWN0aXZlUmFuZ2UpOyAvLyBUT0RPOiBjYWxsZWQgdG9vIGZyZXF1ZW50bHkuIGNhY2hlIHNvbWVob3cuXG5cdFx0dmFyIGNsYXNzZXMgPSB0aGlzLmdldERheUNsYXNzZXMoZGF0ZSk7XG5cblx0XHRjbGFzc2VzLnVuc2hpZnQoJ2ZjLWRheScsIHZpZXcud2lkZ2V0Q29udGVudENsYXNzKTtcblxuXHRcdHJldHVybiAnPHRkIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXG5cdFx0XHQoaXNEYXRlVmFsaWQgP1xuXHRcdFx0XHQnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiJyA6IC8vIGlmIGRhdGUgaGFzIGEgdGltZSwgd29uJ3QgZm9ybWF0IGl0XG5cdFx0XHRcdCcnKSArXG5cdFx0XHQob3RoZXJBdHRycyA/XG5cdFx0XHRcdCcgJyArIG90aGVyQXR0cnMgOlxuXHRcdFx0XHQnJykgK1xuXHRcdFx0Jz48L3RkPic7XG5cdH0sXG5cblxuXHQvKiBHZW5lcmljXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIGRlZmF1bHQgSFRNTCBpbnRybyBmb3IgYW55IHJvdy4gVXNlciBjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuXHRyZW5kZXJJbnRyb0h0bWw6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cblx0Ly8gVE9ETzogYSBnZW5lcmljIG1ldGhvZCBmb3IgZGVhbGluZyB3aXRoIDx0cj4sIFJUTCwgaW50cm9cblx0Ly8gd2hlbiBpbmNyZW1lbnQgaW50ZXJuYWxBcGlWZXJzaW9uXG5cdC8vIHdyYXBUciAoc2NoZWR1bGVyKVxuXG5cblx0LyogVXRpbHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEFwcGxpZXMgdGhlIGdlbmVyaWMgXCJpbnRyb1wiIGFuZCBcIm91dHJvXCIgSFRNTCB0byB0aGUgZ2l2ZW4gY2VsbHMuXG5cdC8vIEludHJvIG1lYW5zIHRoZSBsZWZ0bW9zdCBjZWxsIHdoZW4gdGhlIGNhbGVuZGFyIGlzIExUUiBhbmQgdGhlIHJpZ2h0bW9zdCBjZWxsIHdoZW4gUlRMLiBWaWNlLXZlcnNhIGZvciBvdXRyby5cblx0Ym9va2VuZENlbGxzOiBmdW5jdGlvbih0ckVsKSB7XG5cdFx0dmFyIGludHJvSHRtbCA9IHRoaXMucmVuZGVySW50cm9IdG1sKCk7XG5cblx0XHRpZiAoaW50cm9IdG1sKSB7XG5cdFx0XHRpZiAodGhpcy5pc1JUTCkge1xuXHRcdFx0XHR0ckVsLmFwcGVuZChpbnRyb0h0bWwpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRyRWwucHJlcGVuZChpbnRyb0h0bWwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG59O1xuXG47O1xuXG4vKiBBIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgYSBncmlkIG9mIHdob2xlLWRheXMgdGhhdCBydW5zIGhvcml6b250YWxseS4gVGhlcmUgY2FuIGJlIG11bHRpcGxlIHJvd3MsIG9uZSBwZXIgd2Vlay5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG52YXIgRGF5R3JpZCA9IEZDLkRheUdyaWQgPSBHcmlkLmV4dGVuZChEYXlUYWJsZU1peGluLCB7XG5cblx0bnVtYmVyc1Zpc2libGU6IGZhbHNlLCAvLyBzaG91bGQgcmVuZGVyIGEgcm93IGZvciBkYXkvd2VlayBudW1iZXJzPyBzZXQgYnkgb3V0c2lkZSB2aWV3LiBUT0RPOiBtYWtlIGludGVybmFsXG5cdGJvdHRvbUNvb3JkUGFkZGluZzogMCwgLy8gaGFjayBmb3IgZXh0ZW5kaW5nIHRoZSBoaXQgYXJlYSBmb3IgdGhlIGxhc3Qgcm93IG9mIHRoZSBjb29yZGluYXRlIGdyaWRcblxuXHRyb3dFbHM6IG51bGwsIC8vIHNldCBvZiBmYWtlIHJvdyBlbGVtZW50c1xuXHRjZWxsRWxzOiBudWxsLCAvLyBzZXQgb2Ygd2hvbGUtZGF5IGVsZW1lbnRzIGNvbXByaXNpbmcgdGhlIHJvdydzIGJhY2tncm91bmRcblx0aGVscGVyRWxzOiBudWxsLCAvLyBzZXQgb2YgY2VsbCBza2VsZXRvbiBlbGVtZW50cyBmb3IgcmVuZGVyaW5nIHRoZSBtb2NrIGV2ZW50IFwiaGVscGVyXCJcblxuXHRyb3dDb29yZENhY2hlOiBudWxsLFxuXHRjb2xDb29yZENhY2hlOiBudWxsLFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgcm93cyBhbmQgY29sdW1ucyBpbnRvIHRoZSBjb21wb25lbnQncyBgdGhpcy5lbGAsIHdoaWNoIHNob3VsZCBhbHJlYWR5IGJlIGFzc2lnbmVkLlxuXHQvLyBpc1JpZ2lkIGRldGVybWlucyB3aGV0aGVyIHRoZSBpbmRpdmlkdWFsIHJvd3Mgc2hvdWxkIGlnbm9yZSB0aGUgY29udGVudHMgYW5kIGJlIGEgY29uc3RhbnQgaGVpZ2h0LlxuXHQvLyBSZWxpZXMgb24gdGhlIHZpZXcncyBjb2xDbnQgYW5kIHJvd0NudC4gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb21wb25lbnQgc2hvdWxkIHByb2JhYmx5IGJlIHNlbGYtc3VmZmljaWVudC5cblx0cmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKGlzUmlnaWQpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgcm93Q250ID0gdGhpcy5yb3dDbnQ7XG5cdFx0dmFyIGNvbENudCA9IHRoaXMuY29sQ250O1xuXHRcdHZhciBodG1sID0gJyc7XG5cdFx0dmFyIHJvdztcblx0XHR2YXIgY29sO1xuXG5cdFx0Zm9yIChyb3cgPSAwOyByb3cgPCByb3dDbnQ7IHJvdysrKSB7XG5cdFx0XHRodG1sICs9IHRoaXMucmVuZGVyRGF5Um93SHRtbChyb3csIGlzUmlnaWQpO1xuXHRcdH1cblx0XHR0aGlzLmVsLmh0bWwoaHRtbCk7XG5cblx0XHR0aGlzLnJvd0VscyA9IHRoaXMuZWwuZmluZCgnLmZjLXJvdycpO1xuXHRcdHRoaXMuY2VsbEVscyA9IHRoaXMuZWwuZmluZCgnLmZjLWRheSwgLmZjLWRpc2FibGVkLWRheScpO1xuXG5cdFx0dGhpcy5yb3dDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGUoe1xuXHRcdFx0ZWxzOiB0aGlzLnJvd0Vscyxcblx0XHRcdGlzVmVydGljYWw6IHRydWVcblx0XHR9KTtcblx0XHR0aGlzLmNvbENvb3JkQ2FjaGUgPSBuZXcgQ29vcmRDYWNoZSh7XG5cdFx0XHRlbHM6IHRoaXMuY2VsbEVscy5zbGljZSgwLCB0aGlzLmNvbENudCksIC8vIG9ubHkgdGhlIGZpcnN0IHJvd1xuXHRcdFx0aXNIb3Jpem9udGFsOiB0cnVlXG5cdFx0fSk7XG5cblx0XHQvLyB0cmlnZ2VyIGRheVJlbmRlciB3aXRoIGVhY2ggY2VsbCdzIGVsZW1lbnRcblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd0NudDsgcm93KyspIHtcblx0XHRcdGZvciAoY29sID0gMDsgY29sIDwgY29sQ250OyBjb2wrKykge1xuXHRcdFx0XHR2aWV3LnB1YmxpY2x5VHJpZ2dlcihcblx0XHRcdFx0XHQnZGF5UmVuZGVyJyxcblx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpLFxuXHRcdFx0XHRcdHRoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdHVucmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVtb3ZlU2VnUG9wb3ZlcigpO1xuXHR9LFxuXG5cblx0cmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ3MgPSB0aGlzLmJ1aWxkQnVzaW5lc3NIb3VyU2Vncyh0cnVlKTsgLy8gd2hvbGVEYXk9dHJ1ZVxuXHRcdHRoaXMucmVuZGVyRmlsbCgnYnVzaW5lc3NIb3VycycsIHNlZ3MsICdiZ2V2ZW50Jyk7XG5cdH0sXG5cblxuXHR1bnJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJGaWxsKCdidXNpbmVzc0hvdXJzJyk7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIGEgc2luZ2xlIHJvdywgd2hpY2ggaXMgYSBkaXYgdGhhdCB3cmFwcyBhIHRhYmxlLlxuXHQvLyBgcm93YCBpcyB0aGUgcm93IG51bWJlci5cblx0cmVuZGVyRGF5Um93SHRtbDogZnVuY3Rpb24ocm93LCBpc1JpZ2lkKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGNsYXNzZXMgPSBbICdmYy1yb3cnLCAnZmMtd2VlaycsIHZpZXcud2lkZ2V0Q29udGVudENsYXNzIF07XG5cblx0XHRpZiAoaXNSaWdpZCkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmYy1yaWdpZCcpO1xuXHRcdH1cblxuXHRcdHJldHVybiAnJyArXG5cdFx0XHQnPGRpdiBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIj4nICtcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1iZ1wiPicgK1xuXHRcdFx0XHRcdCc8dGFibGU+JyArXG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlckJnVHJIdG1sKHJvdykgK1xuXHRcdFx0XHRcdCc8L3RhYmxlPicgK1xuXHRcdFx0XHQnPC9kaXY+JyArXG5cdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtY29udGVudC1za2VsZXRvblwiPicgK1xuXHRcdFx0XHRcdCc8dGFibGU+JyArXG5cdFx0XHRcdFx0XHQodGhpcy5udW1iZXJzVmlzaWJsZSA/XG5cdFx0XHRcdFx0XHRcdCc8dGhlYWQ+JyArXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJOdW1iZXJUckh0bWwocm93KSArXG5cdFx0XHRcdFx0XHRcdCc8L3RoZWFkPicgOlxuXHRcdFx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdFx0XHQpICtcblx0XHRcdFx0XHQnPC90YWJsZT4nICtcblx0XHRcdFx0JzwvZGl2PicgK1xuXHRcdFx0JzwvZGl2Pic7XG5cdH0sXG5cblxuXHQvKiBHcmlkIE51bWJlciBSZW5kZXJpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlck51bWJlclRySHRtbDogZnVuY3Rpb24ocm93KSB7XG5cdFx0cmV0dXJuICcnICtcblx0XHRcdCc8dHI+JyArXG5cdFx0XHRcdCh0aGlzLmlzUlRMID8gJycgOiB0aGlzLnJlbmRlck51bWJlckludHJvSHRtbChyb3cpKSArXG5cdFx0XHRcdHRoaXMucmVuZGVyTnVtYmVyQ2VsbHNIdG1sKHJvdykgK1xuXHRcdFx0XHQodGhpcy5pc1JUTCA/IHRoaXMucmVuZGVyTnVtYmVySW50cm9IdG1sKHJvdykgOiAnJykgK1xuXHRcdFx0JzwvdHI+Jztcblx0fSxcblxuXG5cdHJlbmRlck51bWJlckludHJvSHRtbDogZnVuY3Rpb24ocm93KSB7XG5cdFx0cmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7XG5cdH0sXG5cblxuXHRyZW5kZXJOdW1iZXJDZWxsc0h0bWw6IGZ1bmN0aW9uKHJvdykge1xuXHRcdHZhciBodG1scyA9IFtdO1xuXHRcdHZhciBjb2wsIGRhdGU7XG5cblx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xuXHRcdFx0ZGF0ZSA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpO1xuXHRcdFx0aHRtbHMucHVzaCh0aGlzLnJlbmRlck51bWJlckNlbGxIdG1sKGRhdGUpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaHRtbHMuam9pbignJyk7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIHRoZSA8dGQ+cyBvZiB0aGUgXCJudW1iZXJcIiByb3cgaW4gdGhlIERheUdyaWQncyBjb250ZW50IHNrZWxldG9uLlxuXHQvLyBUaGUgbnVtYmVyIHJvdyB3aWxsIG9ubHkgZXhpc3QgaWYgZWl0aGVyIGRheSBudW1iZXJzIG9yIHdlZWsgbnVtYmVycyBhcmUgdHVybmVkIG9uLlxuXHRyZW5kZXJOdW1iZXJDZWxsSHRtbDogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBodG1sID0gJyc7XG5cdFx0dmFyIGlzRGF0ZVZhbGlkID0gaXNEYXRlV2l0aGluUmFuZ2UoZGF0ZSwgdmlldy5hY3RpdmVSYW5nZSk7IC8vIFRPRE86IGNhbGxlZCB0b28gZnJlcXVlbnRseS4gY2FjaGUgc29tZWhvdy5cblx0XHR2YXIgaXNEYXlOdW1iZXJWaXNpYmxlID0gdmlldy5kYXlOdW1iZXJzVmlzaWJsZSAmJiBpc0RhdGVWYWxpZDtcblx0XHR2YXIgY2xhc3Nlcztcblx0XHR2YXIgd2Vla0NhbGNGaXJzdERvVztcblxuXHRcdGlmICghaXNEYXlOdW1iZXJWaXNpYmxlICYmICF2aWV3LmNlbGxXZWVrTnVtYmVyc1Zpc2libGUpIHtcblx0XHRcdC8vIG5vIG51bWJlcnMgaW4gZGF5IGNlbGwgKHdlZWsgbnVtYmVyIG11c3QgYmUgYWxvbmcgdGhlIHNpZGUpXG5cdFx0XHRyZXR1cm4gJzx0ZC8+JzsgLy8gIHdpbGwgY3JlYXRlIGFuIGVtcHR5IHNwYWNlIGFib3ZlIGV2ZW50cyA6KFxuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSB0aGlzLmdldERheUNsYXNzZXMoZGF0ZSk7XG5cdFx0Y2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXktdG9wJyk7XG5cblx0XHRpZiAodmlldy5jZWxsV2Vla051bWJlcnNWaXNpYmxlKSB7XG5cdFx0XHQvLyBUbyBkZXRlcm1pbmUgdGhlIGRheSBvZiB3ZWVrIG51bWJlciBjaGFuZ2UgdW5kZXIgSVNPLCB3ZSBjYW5ub3Rcblx0XHRcdC8vIHJlbHkgb24gbW9tZW50LmpzIG1ldGhvZHMgc3VjaCBhcyBmaXJzdERheU9mV2VlaygpIG9yIHdlZWtkYXkoKSxcblx0XHRcdC8vIGJlY2F1c2UgdGhleSByZWx5IG9uIHRoZSBsb2NhbGUncyBkb3cgKHBvc3NpYmx5IG92ZXJyaWRkZW4gYnlcblx0XHRcdC8vIG91ciBmaXJzdERheSBvcHRpb24pLCB3aGljaCBtYXkgbm90IGJlIE1vbmRheS4gV2UgY2Fubm90IGNoYW5nZVxuXHRcdFx0Ly8gZG93LCBiZWNhdXNlIHRoYXQgd291bGQgYWZmZWN0IHRoZSBjYWxlbmRhciBzdGFydCBkYXkgYXMgd2VsbC5cblx0XHRcdGlmIChkYXRlLl9sb2NhbGUuX2Z1bGxDYWxlbmRhcl93ZWVrQ2FsYyA9PT0gJ0lTTycpIHtcblx0XHRcdFx0d2Vla0NhbGNGaXJzdERvVyA9IDE7ICAvLyBNb25kYXkgYnkgSVNPIDg2MDEgZGVmaW5pdGlvblxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHdlZWtDYWxjRmlyc3REb1cgPSBkYXRlLl9sb2NhbGUuZmlyc3REYXlPZldlZWsoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRodG1sICs9ICc8dGQgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcblx0XHRcdChpc0RhdGVWYWxpZCA/XG5cdFx0XHRcdCcgZGF0YS1kYXRlPVwiJyArIGRhdGUuZm9ybWF0KCkgKyAnXCInIDpcblx0XHRcdFx0Jydcblx0XHRcdFx0KSArXG5cdFx0XHQnPic7XG5cblx0XHRpZiAodmlldy5jZWxsV2Vla051bWJlcnNWaXNpYmxlICYmIChkYXRlLmRheSgpID09IHdlZWtDYWxjRmlyc3REb1cpKSB7XG5cdFx0XHRodG1sICs9IHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbChcblx0XHRcdFx0eyBkYXRlOiBkYXRlLCB0eXBlOiAnd2VlaycgfSxcblx0XHRcdFx0eyAnY2xhc3MnOiAnZmMtd2Vlay1udW1iZXInIH0sXG5cdFx0XHRcdGRhdGUuZm9ybWF0KCd3JykgLy8gaW5uZXIgSFRNTFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoaXNEYXlOdW1iZXJWaXNpYmxlKSB7XG5cdFx0XHRodG1sICs9IHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbChcblx0XHRcdFx0ZGF0ZSxcblx0XHRcdFx0eyAnY2xhc3MnOiAnZmMtZGF5LW51bWJlcicgfSxcblx0XHRcdFx0ZGF0ZS5kYXRlKCkgLy8gaW5uZXIgSFRNTFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRodG1sICs9ICc8L3RkPic7XG5cblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXG5cdC8qIE9wdGlvbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIENvbXB1dGVzIGEgZGVmYXVsdCBldmVudCB0aW1lIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGB0aW1lRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXG5cdGNvbXB1dGVFdmVudFRpbWVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXcub3B0KCdleHRyYVNtYWxsVGltZUZvcm1hdCcpOyAvLyBsaWtlIFwiNnBcIiBvciBcIjY6MzBwXCJcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGEgZGVmYXVsdCBgZGlzcGxheUV2ZW50RW5kYCB2YWx1ZSBpZiBvbmUgaXMgbm90IGV4cGxpY2x0eSBkZWZpbmVkXG5cdGNvbXB1dGVEaXNwbGF5RXZlbnRFbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbENudCA9PSAxOyAvLyB3ZSdsbCBsaWtlbHkgaGF2ZSBzcGFjZSBpZiB0aGVyZSdzIG9ubHkgb25lIGRheVxuXHR9LFxuXG5cblx0LyogRGF0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJhbmdlVXBkYXRlZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51cGRhdGVEYXlUYWJsZSgpO1xuXHR9LFxuXG5cblx0Ly8gU2xpY2VzIHVwIHRoZSBnaXZlbiBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCB3aXRoIG90aGVyIG1pc2MgZGF0YSkgaW50byBhbiBhcnJheSBvZiBzZWdtZW50c1xuXHRzcGFuVG9TZWdzOiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0dmFyIHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2VCeVJvdyhzcGFuKTtcblx0XHR2YXIgaSwgc2VnO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZyA9IHNlZ3NbaV07XG5cdFx0XHRpZiAodGhpcy5pc1JUTCkge1xuXHRcdFx0XHRzZWcubGVmdENvbCA9IHRoaXMuZGF5c1BlclJvdyAtIDEgLSBzZWcubGFzdFJvd0RheUluZGV4O1xuXHRcdFx0XHRzZWcucmlnaHRDb2wgPSB0aGlzLmRheXNQZXJSb3cgLSAxIC0gc2VnLmZpcnN0Um93RGF5SW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2VnLmxlZnRDb2wgPSBzZWcuZmlyc3RSb3dEYXlJbmRleDtcblx0XHRcdFx0c2VnLnJpZ2h0Q29sID0gc2VnLmxhc3RSb3dEYXlJbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8qIEhpdCBTeXN0ZW1cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHByZXBhcmVIaXRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNvbENvb3JkQ2FjaGUuYnVpbGQoKTtcblx0XHR0aGlzLnJvd0Nvb3JkQ2FjaGUuYnVpbGQoKTtcblx0XHR0aGlzLnJvd0Nvb3JkQ2FjaGUuYm90dG9tc1t0aGlzLnJvd0NudCAtIDFdICs9IHRoaXMuYm90dG9tQ29vcmRQYWRkaW5nOyAvLyBoYWNrXG5cdH0sXG5cblxuXHRyZWxlYXNlSGl0czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jb2xDb29yZENhY2hlLmNsZWFyKCk7XG5cdFx0dGhpcy5yb3dDb29yZENhY2hlLmNsZWFyKCk7XG5cdH0sXG5cblxuXHRxdWVyeUhpdDogZnVuY3Rpb24obGVmdE9mZnNldCwgdG9wT2Zmc2V0KSB7XG5cdFx0aWYgKHRoaXMuY29sQ29vcmRDYWNoZS5pc0xlZnRJbkJvdW5kcyhsZWZ0T2Zmc2V0KSAmJiB0aGlzLnJvd0Nvb3JkQ2FjaGUuaXNUb3BJbkJvdW5kcyh0b3BPZmZzZXQpKSB7XG5cdFx0XHR2YXIgY29sID0gdGhpcy5jb2xDb29yZENhY2hlLmdldEhvcml6b250YWxJbmRleChsZWZ0T2Zmc2V0KTtcblx0XHRcdHZhciByb3cgPSB0aGlzLnJvd0Nvb3JkQ2FjaGUuZ2V0VmVydGljYWxJbmRleCh0b3BPZmZzZXQpO1xuXG5cdFx0XHRpZiAocm93ICE9IG51bGwgJiYgY29sICE9IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0Q2VsbEhpdChyb3csIGNvbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Z2V0SGl0U3BhbjogZnVuY3Rpb24oaGl0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2VsbFJhbmdlKGhpdC5yb3csIGhpdC5jb2wpO1xuXHR9LFxuXG5cblx0Z2V0SGl0RWw6IGZ1bmN0aW9uKGhpdCkge1xuXHRcdHJldHVybiB0aGlzLmdldENlbGxFbChoaXQucm93LCBoaXQuY29sKTtcblx0fSxcblxuXG5cdC8qIENlbGwgU3lzdGVtXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdC8vIEZZSTogdGhlIGZpcnN0IGNvbHVtbiBpcyB0aGUgbGVmdG1vc3QgY29sdW1uLCByZWdhcmRsZXNzIG9mIGRhdGVcblxuXG5cdGdldENlbGxIaXQ6IGZ1bmN0aW9uKHJvdywgY29sKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJvdzogcm93LFxuXHRcdFx0Y29sOiBjb2wsXG5cdFx0XHRjb21wb25lbnQ6IHRoaXMsIC8vIG5lZWRlZCB1bmZvcnR1bmF0ZWx5IDooXG5cdFx0XHRsZWZ0OiB0aGlzLmNvbENvb3JkQ2FjaGUuZ2V0TGVmdE9mZnNldChjb2wpLFxuXHRcdFx0cmlnaHQ6IHRoaXMuY29sQ29vcmRDYWNoZS5nZXRSaWdodE9mZnNldChjb2wpLFxuXHRcdFx0dG9wOiB0aGlzLnJvd0Nvb3JkQ2FjaGUuZ2V0VG9wT2Zmc2V0KHJvdyksXG5cdFx0XHRib3R0b206IHRoaXMucm93Q29vcmRDYWNoZS5nZXRCb3R0b21PZmZzZXQocm93KVxuXHRcdH07XG5cdH0sXG5cblxuXHRnZXRDZWxsRWw6IGZ1bmN0aW9uKHJvdywgY29sKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2VsbEVscy5lcShyb3cgKiB0aGlzLmNvbENudCArIGNvbCk7XG5cdH0sXG5cblxuXHQvKiBFdmVudCBEcmFnIFZpc3VhbGl6YXRpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0Ly8gVE9ETzogbW92ZSB0byBEYXlHcmlkLmV2ZW50LCBzaW1pbGFyIHRvIHdoYXQgd2UgZGlkIHdpdGggR3JpZCdzIGRyYWcgbWV0aG9kc1xuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IG9yIGV4dGVybmFsIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZC5cblx0Ly8gYGV2ZW50TG9jYXRpb25gIGhhcyB6b25lZCBzdGFydCBhbmQgZW5kIChvcHRpb25hbClcblx0cmVuZGVyRHJhZzogZnVuY3Rpb24oZXZlbnRMb2NhdGlvbiwgc2VnKSB7XG5cdFx0dmFyIGV2ZW50U3BhbnMgPSB0aGlzLmV2ZW50VG9TcGFucyhldmVudExvY2F0aW9uKTtcblx0XHR2YXIgaTtcblxuXHRcdC8vIGFsd2F5cyByZW5kZXIgYSBoaWdobGlnaHQgdW5kZXJuZWF0aFxuXHRcdGZvciAoaSA9IDA7IGkgPCBldmVudFNwYW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLnJlbmRlckhpZ2hsaWdodChldmVudFNwYW5zW2ldKTtcblx0XHR9XG5cblx0XHQvLyBpZiBhIHNlZ21lbnQgZnJvbSB0aGUgc2FtZSBjYWxlbmRhciBidXQgYW5vdGhlciBjb21wb25lbnQgaXMgYmVpbmcgZHJhZ2dlZCwgcmVuZGVyIGEgaGVscGVyIGV2ZW50XG5cdFx0aWYgKHNlZyAmJiBzZWcuY29tcG9uZW50ICE9PSB0aGlzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXJFdmVudExvY2F0aW9uSGVscGVyKGV2ZW50TG9jYXRpb24sIHNlZyk7IC8vIHJldHVybnMgbW9jayBldmVudCBlbGVtZW50c1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYSBob3ZlcmluZyBldmVudFxuXHR1bnJlbmRlckRyYWc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIaWdobGlnaHQoKTtcblx0XHR0aGlzLnVucmVuZGVySGVscGVyKCk7XG5cdH0sXG5cblxuXHQvKiBFdmVudCBSZXNpemUgVmlzdWFsaXphdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcblx0cmVuZGVyRXZlbnRSZXNpemU6IGZ1bmN0aW9uKGV2ZW50TG9jYXRpb24sIHNlZykge1xuXHRcdHZhciBldmVudFNwYW5zID0gdGhpcy5ldmVudFRvU3BhbnMoZXZlbnRMb2NhdGlvbik7XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRTcGFucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5yZW5kZXJIaWdobGlnaHQoZXZlbnRTcGFuc1tpXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucmVuZGVyRXZlbnRMb2NhdGlvbkhlbHBlcihldmVudExvY2F0aW9uLCBzZWcpOyAvLyByZXR1cm5zIG1vY2sgZXZlbnQgZWxlbWVudHNcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcblx0dW5yZW5kZXJFdmVudFJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xuXHRcdHRoaXMudW5yZW5kZXJIZWxwZXIoKTtcblx0fSxcblxuXG5cdC8qIEV2ZW50IEhlbHBlclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIG1vY2sgXCJoZWxwZXJcIiBldmVudC4gYHNvdXJjZVNlZ2AgaXMgdGhlIGFzc29jaWF0ZWQgaW50ZXJuYWwgc2VnbWVudCBvYmplY3QuIEl0IGNhbiBiZSBudWxsLlxuXHRyZW5kZXJIZWxwZXI6IGZ1bmN0aW9uKGV2ZW50LCBzb3VyY2VTZWcpIHtcblx0XHR2YXIgaGVscGVyTm9kZXMgPSBbXTtcblx0XHR2YXIgc2VncyA9IHRoaXMuZXZlbnRUb1NlZ3MoZXZlbnQpO1xuXHRcdHZhciByb3dTdHJ1Y3RzO1xuXG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmdTZWdFbHMoc2Vncyk7IC8vIGFzc2lnbnMgZWFjaCBzZWcncyBlbCBhbmQgcmV0dXJucyBhIHN1YnNldCBvZiBzZWdzIHRoYXQgd2VyZSByZW5kZXJlZFxuXHRcdHJvd1N0cnVjdHMgPSB0aGlzLnJlbmRlclNlZ1Jvd3Moc2Vncyk7XG5cblx0XHQvLyBpbmplY3QgZWFjaCBuZXcgZXZlbnQgc2tlbGV0b24gaW50byBlYWNoIGFzc29jaWF0ZWQgcm93XG5cdFx0dGhpcy5yb3dFbHMuZWFjaChmdW5jdGlvbihyb3csIHJvd05vZGUpIHtcblx0XHRcdHZhciByb3dFbCA9ICQocm93Tm9kZSk7IC8vIHRoZSAuZmMtcm93XG5cdFx0XHR2YXIgc2tlbGV0b25FbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1oZWxwZXItc2tlbGV0b25cIj48dGFibGUvPjwvZGl2PicpOyAvLyB3aWxsIGJlIGFic29sdXRlbHkgcG9zaXRpb25lZFxuXHRcdFx0dmFyIHNrZWxldG9uVG9wO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBvcmlnaW5hbCBzZWdtZW50LCBtYXRjaCB0aGUgdG9wIHBvc2l0aW9uLiBPdGhlcndpc2UsIHB1dCBpdCBhdCB0aGUgcm93J3MgdG9wIGxldmVsXG5cdFx0XHRpZiAoc291cmNlU2VnICYmIHNvdXJjZVNlZy5yb3cgPT09IHJvdykge1xuXHRcdFx0XHRza2VsZXRvblRvcCA9IHNvdXJjZVNlZy5lbC5wb3NpdGlvbigpLnRvcDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRza2VsZXRvblRvcCA9IHJvd0VsLmZpbmQoJy5mYy1jb250ZW50LXNrZWxldG9uIHRib2R5JykucG9zaXRpb24oKS50b3A7XG5cdFx0XHR9XG5cblx0XHRcdHNrZWxldG9uRWwuY3NzKCd0b3AnLCBza2VsZXRvblRvcClcblx0XHRcdFx0LmZpbmQoJ3RhYmxlJylcblx0XHRcdFx0XHQuYXBwZW5kKHJvd1N0cnVjdHNbcm93XS50Ym9keUVsKTtcblxuXHRcdFx0cm93RWwuYXBwZW5kKHNrZWxldG9uRWwpO1xuXHRcdFx0aGVscGVyTm9kZXMucHVzaChza2VsZXRvbkVsWzBdKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiAoIC8vIG11c3QgcmV0dXJuIHRoZSBlbGVtZW50cyByZW5kZXJlZFxuXHRcdFx0dGhpcy5oZWxwZXJFbHMgPSAkKGhlbHBlck5vZGVzKSAvLyBhcnJheSAtPiBqUXVlcnkgc2V0XG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYSBtb2NrIGhlbHBlciBldmVudFxuXHR1bnJlbmRlckhlbHBlcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaGVscGVyRWxzKSB7XG5cdFx0XHR0aGlzLmhlbHBlckVscy5yZW1vdmUoKTtcblx0XHRcdHRoaXMuaGVscGVyRWxzID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBGaWxsIFN5c3RlbSAoaGlnaGxpZ2h0LCBiYWNrZ3JvdW5kIGV2ZW50cywgYnVzaW5lc3MgaG91cnMpXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRmaWxsU2VnVGFnOiAndGQnLCAvLyBvdmVycmlkZSB0aGUgZGVmYXVsdCB0YWcgbmFtZVxuXG5cblx0Ly8gUmVuZGVycyBhIHNldCBvZiByZWN0YW5nbGVzIG92ZXIgdGhlIGdpdmVuIHNlZ21lbnRzIG9mIGRheXMuXG5cdC8vIE9ubHkgcmV0dXJucyBzZWdtZW50cyB0aGF0IHN1Y2Nlc3NmdWxseSByZW5kZXJlZC5cblx0cmVuZGVyRmlsbDogZnVuY3Rpb24odHlwZSwgc2VncywgY2xhc3NOYW1lKSB7XG5cdFx0dmFyIG5vZGVzID0gW107XG5cdFx0dmFyIGksIHNlZztcblx0XHR2YXIgc2tlbGV0b25FbDtcblxuXHRcdHNlZ3MgPSB0aGlzLnJlbmRlckZpbGxTZWdFbHModHlwZSwgc2Vncyk7IC8vIGFzc2lnbmVzIGAuZWxgIHRvIGVhY2ggc2VnLiByZXR1cm5zIHN1Y2Nlc3NmdWxseSByZW5kZXJlZCBzZWdzXG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnID0gc2Vnc1tpXTtcblx0XHRcdHNrZWxldG9uRWwgPSB0aGlzLnJlbmRlckZpbGxSb3codHlwZSwgc2VnLCBjbGFzc05hbWUpO1xuXHRcdFx0dGhpcy5yb3dFbHMuZXEoc2VnLnJvdykuYXBwZW5kKHNrZWxldG9uRWwpO1xuXHRcdFx0bm9kZXMucHVzaChza2VsZXRvbkVsWzBdKTtcblx0XHR9XG5cblx0XHR0aGlzLmVsc0J5RmlsbFt0eXBlXSA9ICQobm9kZXMpO1xuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgbmVlZGVkIGZvciBvbmUgcm93IG9mIGEgZmlsbC4gUmVxdWlyZXMgdGhlIHNlZydzIGVsIHRvIGJlIHJlbmRlcmVkLlxuXHRyZW5kZXJGaWxsUm93OiBmdW5jdGlvbih0eXBlLCBzZWcsIGNsYXNzTmFtZSkge1xuXHRcdHZhciBjb2xDbnQgPSB0aGlzLmNvbENudDtcblx0XHR2YXIgc3RhcnRDb2wgPSBzZWcubGVmdENvbDtcblx0XHR2YXIgZW5kQ29sID0gc2VnLnJpZ2h0Q29sICsgMTtcblx0XHR2YXIgc2tlbGV0b25FbDtcblx0XHR2YXIgdHJFbDtcblxuXHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRza2VsZXRvbkVsID0gJChcblx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtJyArIGNsYXNzTmFtZSArICctc2tlbGV0b25cIj4nICtcblx0XHRcdFx0Jzx0YWJsZT48dHIvPjwvdGFibGU+JyArXG5cdFx0XHQnPC9kaXY+J1xuXHRcdCk7XG5cdFx0dHJFbCA9IHNrZWxldG9uRWwuZmluZCgndHInKTtcblxuXHRcdGlmIChzdGFydENvbCA+IDApIHtcblx0XHRcdHRyRWwuYXBwZW5kKCc8dGQgY29sc3Bhbj1cIicgKyBzdGFydENvbCArICdcIi8+Jyk7XG5cdFx0fVxuXG5cdFx0dHJFbC5hcHBlbmQoXG5cdFx0XHRzZWcuZWwuYXR0cignY29sc3BhbicsIGVuZENvbCAtIHN0YXJ0Q29sKVxuXHRcdCk7XG5cblx0XHRpZiAoZW5kQ29sIDwgY29sQ250KSB7XG5cdFx0XHR0ckVsLmFwcGVuZCgnPHRkIGNvbHNwYW49XCInICsgKGNvbENudCAtIGVuZENvbCkgKyAnXCIvPicpO1xuXHRcdH1cblxuXHRcdHRoaXMuYm9va2VuZENlbGxzKHRyRWwpO1xuXG5cdFx0cmV0dXJuIHNrZWxldG9uRWw7XG5cdH1cblxufSk7XG5cbjs7XG5cbi8qIEV2ZW50LXJlbmRlcmluZyBtZXRob2RzIGZvciB0aGUgRGF5R3JpZCBjbGFzc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbkRheUdyaWQubWl4aW4oe1xuXG5cdHJvd1N0cnVjdHM6IG51bGwsIC8vIGFuIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggaG9sZGluZyBpbmZvcm1hdGlvbiBhYm91dCBhIHJvdydzIGZvcmVncm91bmQgZXZlbnQtcmVuZGVyaW5nXG5cblxuXHQvLyBVbnJlbmRlcnMgYWxsIGV2ZW50cyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcblx0dW5yZW5kZXJFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVtb3ZlU2VnUG9wb3ZlcigpOyAvLyByZW1vdmVzIHRoZSBcIm1vcmUuLlwiIGV2ZW50cyBwb3BvdmVyXG5cdFx0R3JpZC5wcm90b3R5cGUudW5yZW5kZXJFdmVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gY2FsbHMgdGhlIHN1cGVyLW1ldGhvZFxuXHR9LFxuXG5cblx0Ly8gUmV0cmlldmVzIGFsbCByZW5kZXJlZCBzZWdtZW50IG9iamVjdHMgY3VycmVudGx5IHJlbmRlcmVkIG9uIHRoZSBncmlkXG5cdGdldEV2ZW50U2VnczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEdyaWQucHJvdG90eXBlLmdldEV2ZW50U2Vncy5jYWxsKHRoaXMpIC8vIGdldCB0aGUgc2VnbWVudHMgZnJvbSB0aGUgc3VwZXItbWV0aG9kXG5cdFx0XHQuY29uY2F0KHRoaXMucG9wb3ZlclNlZ3MgfHwgW10pOyAvLyBhcHBlbmQgdGhlIHNlZ21lbnRzIGZyb20gdGhlIFwibW9yZS4uLlwiIHBvcG92ZXJcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIGdpdmVuIGJhY2tncm91bmQgZXZlbnQgc2VnbWVudHMgb250byB0aGUgZ3JpZFxuXHRyZW5kZXJCZ1NlZ3M6IGZ1bmN0aW9uKHNlZ3MpIHtcblxuXHRcdC8vIGRvbid0IHJlbmRlciB0aW1lZCBiYWNrZ3JvdW5kIGV2ZW50c1xuXHRcdHZhciBhbGxEYXlTZWdzID0gJC5ncmVwKHNlZ3MsIGZ1bmN0aW9uKHNlZykge1xuXHRcdFx0cmV0dXJuIHNlZy5ldmVudC5hbGxEYXk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gR3JpZC5wcm90b3R5cGUucmVuZGVyQmdTZWdzLmNhbGwodGhpcywgYWxsRGF5U2Vncyk7IC8vIGNhbGwgdGhlIHN1cGVyLW1ldGhvZFxuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgZ2l2ZW4gZm9yZWdyb3VuZCBldmVudCBzZWdtZW50cyBvbnRvIHRoZSBncmlkXG5cdHJlbmRlckZnU2VnczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciByb3dTdHJ1Y3RzO1xuXG5cdFx0Ly8gcmVuZGVyIGFuIGAuZWxgIG9uIGVhY2ggc2VnXG5cdFx0Ly8gcmV0dXJucyBhIHN1YnNldCBvZiB0aGUgc2Vncy4gc2VncyB0aGF0IHdlcmUgYWN0dWFsbHkgcmVuZGVyZWRcblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ0VscyhzZWdzKTtcblxuXHRcdHJvd1N0cnVjdHMgPSB0aGlzLnJvd1N0cnVjdHMgPSB0aGlzLnJlbmRlclNlZ1Jvd3Moc2Vncyk7XG5cblx0XHQvLyBhcHBlbmQgdG8gZWFjaCByb3cncyBjb250ZW50IHNrZWxldG9uXG5cdFx0dGhpcy5yb3dFbHMuZWFjaChmdW5jdGlvbihpLCByb3dOb2RlKSB7XG5cdFx0XHQkKHJvd05vZGUpLmZpbmQoJy5mYy1jb250ZW50LXNrZWxldG9uID4gdGFibGUnKS5hcHBlbmQoXG5cdFx0XHRcdHJvd1N0cnVjdHNbaV0udGJvZHlFbFxuXHRcdFx0KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBzZWdzOyAvLyByZXR1cm4gb25seSB0aGUgc2VncyB0aGF0IHdlcmUgYWN0dWFsbHkgcmVuZGVyZWRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbGwgY3VycmVudGx5IHJlbmRlcmVkIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudHNcblx0dW5yZW5kZXJGZ1NlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByb3dTdHJ1Y3RzID0gdGhpcy5yb3dTdHJ1Y3RzIHx8IFtdO1xuXHRcdHZhciByb3dTdHJ1Y3Q7XG5cblx0XHR3aGlsZSAoKHJvd1N0cnVjdCA9IHJvd1N0cnVjdHMucG9wKCkpKSB7XG5cdFx0XHRyb3dTdHJ1Y3QudGJvZHlFbC5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLnJvd1N0cnVjdHMgPSBudWxsO1xuXHR9LFxuXG5cblx0Ly8gVXNlcyB0aGUgZ2l2ZW4gZXZlbnRzIGFycmF5IHRvIGdlbmVyYXRlIDx0Ym9keT4gZWxlbWVudHMgdGhhdCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gZWFjaCByb3cncyBjb250ZW50IHNrZWxldG9uLlxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHJvd1N0cnVjdCBvYmplY3RzIChzZWUgdGhlIGJvdHRvbSBvZiBgcmVuZGVyU2VnUm93YCkuXG5cdC8vIFBSRUNPTkRJVElPTjogZWFjaCBzZWdtZW50IHNob3VkIGFscmVhZHkgaGF2ZSBhIHJlbmRlcmVkIGFuZCBhc3NpZ25lZCBgLmVsYFxuXHRyZW5kZXJTZWdSb3dzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dmFyIHJvd1N0cnVjdHMgPSBbXTtcblx0XHR2YXIgc2VnUm93cztcblx0XHR2YXIgcm93O1xuXG5cdFx0c2VnUm93cyA9IHRoaXMuZ3JvdXBTZWdSb3dzKHNlZ3MpOyAvLyBncm91cCBpbnRvIG5lc3RlZCBhcnJheXNcblxuXHRcdC8vIGl0ZXJhdGUgZWFjaCByb3cgb2Ygc2VnbWVudCBncm91cGluZ3Ncblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IHNlZ1Jvd3MubGVuZ3RoOyByb3crKykge1xuXHRcdFx0cm93U3RydWN0cy5wdXNoKFxuXHRcdFx0XHR0aGlzLnJlbmRlclNlZ1Jvdyhyb3csIHNlZ1Jvd3Nbcm93XSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJvd1N0cnVjdHM7XG5cdH0sXG5cblxuXHQvLyBCdWlsZHMgdGhlIEhUTUwgdG8gYmUgdXNlZCBmb3IgdGhlIGRlZmF1bHQgZWxlbWVudCBmb3IgYW4gaW5kaXZpZHVhbCBzZWdtZW50XG5cdGZnU2VnSHRtbDogZnVuY3Rpb24oc2VnLCBkaXNhYmxlUmVzaXppbmcpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgZXZlbnQgPSBzZWcuZXZlbnQ7XG5cdFx0dmFyIGlzRHJhZ2dhYmxlID0gdmlldy5pc0V2ZW50RHJhZ2dhYmxlKGV2ZW50KTtcblx0XHR2YXIgaXNSZXNpemFibGVGcm9tU3RhcnQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIGV2ZW50LmFsbERheSAmJlxuXHRcdFx0c2VnLmlzU3RhcnQgJiYgdmlldy5pc0V2ZW50UmVzaXphYmxlRnJvbVN0YXJ0KGV2ZW50KTtcblx0XHR2YXIgaXNSZXNpemFibGVGcm9tRW5kID0gIWRpc2FibGVSZXNpemluZyAmJiBldmVudC5hbGxEYXkgJiZcblx0XHRcdHNlZy5pc0VuZCAmJiB2aWV3LmlzRXZlbnRSZXNpemFibGVGcm9tRW5kKGV2ZW50KTtcblx0XHR2YXIgY2xhc3NlcyA9IHRoaXMuZ2V0U2VnQ2xhc3NlcyhzZWcsIGlzRHJhZ2dhYmxlLCBpc1Jlc2l6YWJsZUZyb21TdGFydCB8fCBpc1Jlc2l6YWJsZUZyb21FbmQpO1xuXHRcdHZhciBza2luQ3NzID0gY3NzVG9TdHIodGhpcy5nZXRTZWdTa2luQ3NzKHNlZykpO1xuXHRcdHZhciB0aW1lSHRtbCA9ICcnO1xuXHRcdHZhciB0aW1lVGV4dDtcblx0XHR2YXIgdGl0bGVIdG1sO1xuXG5cdFx0Y2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXktZ3JpZC1ldmVudCcsICdmYy1oLWV2ZW50Jyk7XG5cblx0XHQvLyBPbmx5IGRpc3BsYXkgYSB0aW1lZCBldmVudHMgdGltZSBpZiBpdCBpcyB0aGUgc3RhcnRpbmcgc2VnbWVudFxuXHRcdGlmIChzZWcuaXNTdGFydCkge1xuXHRcdFx0dGltZVRleHQgPSB0aGlzLmdldEV2ZW50VGltZVRleHQoZXZlbnQpO1xuXHRcdFx0aWYgKHRpbWVUZXh0KSB7XG5cdFx0XHRcdHRpbWVIdG1sID0gJzxzcGFuIGNsYXNzPVwiZmMtdGltZVwiPicgKyBodG1sRXNjYXBlKHRpbWVUZXh0KSArICc8L3NwYW4+Jztcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aXRsZUh0bWwgPVxuXHRcdFx0JzxzcGFuIGNsYXNzPVwiZmMtdGl0bGVcIj4nICtcblx0XHRcdFx0KGh0bWxFc2NhcGUoZXZlbnQudGl0bGUgfHwgJycpIHx8ICcmbmJzcDsnKSArIC8vIHdlIGFsd2F5cyB3YW50IG9uZSBsaW5lIG9mIGhlaWdodFxuXHRcdFx0Jzwvc3Bhbj4nO1xuXHRcdFxuXHRcdHJldHVybiAnPGEgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcblx0XHRcdFx0KGV2ZW50LnVybCA/XG5cdFx0XHRcdFx0JyBocmVmPVwiJyArIGh0bWxFc2NhcGUoZXZlbnQudXJsKSArICdcIicgOlxuXHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0KSArXG5cdFx0XHRcdChza2luQ3NzID9cblx0XHRcdFx0XHQnIHN0eWxlPVwiJyArIHNraW5Dc3MgKyAnXCInIDpcblx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdCkgK1xuXHRcdFx0Jz4nICtcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1jb250ZW50XCI+JyArXG5cdFx0XHRcdFx0KHRoaXMuaXNSVEwgP1xuXHRcdFx0XHRcdFx0dGl0bGVIdG1sICsgJyAnICsgdGltZUh0bWwgOiAvLyBwdXQgYSBuYXR1cmFsIHNwYWNlIGluIGJldHdlZW5cblx0XHRcdFx0XHRcdHRpbWVIdG1sICsgJyAnICsgdGl0bGVIdG1sICAgLy9cblx0XHRcdFx0XHRcdCkgK1xuXHRcdFx0XHQnPC9kaXY+JyArXG5cdFx0XHRcdChpc1Jlc2l6YWJsZUZyb21TdGFydCA/XG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLXN0YXJ0LXJlc2l6ZXJcIiAvPicgOlxuXHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0KSArXG5cdFx0XHRcdChpc1Jlc2l6YWJsZUZyb21FbmQgP1xuXHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1lbmQtcmVzaXplclwiIC8+JyA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0XHQpICtcblx0XHRcdCc8L2E+Jztcblx0fSxcblxuXG5cdC8vIEdpdmVuIGEgcm93ICMgYW5kIGFuIGFycmF5IG9mIHNlZ21lbnRzIGFsbCBpbiB0aGUgc2FtZSByb3csIHJlbmRlciBhIDx0Ym9keT4gZWxlbWVudCwgYSBza2VsZXRvbiB0aGF0IGNvbnRhaW5zXG5cdC8vIHRoZSBzZWdtZW50cy4gUmV0dXJucyBvYmplY3Qgd2l0aCBhIGJ1bmNoIG9mIGludGVybmFsIGRhdGEgYWJvdXQgaG93IHRoZSByZW5kZXIgd2FzIGNhbGN1bGF0ZWQuXG5cdC8vIE5PVEU6IG1vZGlmaWVzIHJvd1NlZ3Ncblx0cmVuZGVyU2VnUm93OiBmdW5jdGlvbihyb3csIHJvd1NlZ3MpIHtcblx0XHR2YXIgY29sQ250ID0gdGhpcy5jb2xDbnQ7XG5cdFx0dmFyIHNlZ0xldmVscyA9IHRoaXMuYnVpbGRTZWdMZXZlbHMocm93U2Vncyk7IC8vIGdyb3VwIGludG8gc3ViLWFycmF5cyBvZiBsZXZlbHNcblx0XHR2YXIgbGV2ZWxDbnQgPSBNYXRoLm1heCgxLCBzZWdMZXZlbHMubGVuZ3RoKTsgLy8gZW5zdXJlIGF0IGxlYXN0IG9uZSBsZXZlbFxuXHRcdHZhciB0Ym9keSA9ICQoJzx0Ym9keS8+Jyk7XG5cdFx0dmFyIHNlZ01hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIHdoaWNoIHNlZ21lbnRzIGFyZSByZW5kZXJlZCBpbnRvIHdoaWNoIGxldmVsK2NvbCBjZWxsc1xuXHRcdHZhciBjZWxsTWF0cml4ID0gW107IC8vIGxvb2t1cCBmb3IgYWxsIDx0ZD4gZWxlbWVudHMgb2YgdGhlIGxldmVsK2NvbCBtYXRyaXhcblx0XHR2YXIgbG9uZUNlbGxNYXRyaXggPSBbXTsgLy8gbG9va3VwIGZvciA8dGQ+IGVsZW1lbnRzIHRoYXQgb25seSB0YWtlIHVwIGEgc2luZ2xlIGNvbHVtblxuXHRcdHZhciBpLCBsZXZlbFNlZ3M7XG5cdFx0dmFyIGNvbDtcblx0XHR2YXIgdHI7XG5cdFx0dmFyIGosIHNlZztcblx0XHR2YXIgdGQ7XG5cblx0XHQvLyBwb3B1bGF0ZXMgZW1wdHkgY2VsbHMgZnJvbSB0aGUgY3VycmVudCBjb2x1bW4gKGBjb2xgKSB0byBgZW5kQ29sYFxuXHRcdGZ1bmN0aW9uIGVtcHR5Q2VsbHNVbnRpbChlbmRDb2wpIHtcblx0XHRcdHdoaWxlIChjb2wgPCBlbmRDb2wpIHtcblx0XHRcdFx0Ly8gdHJ5IHRvIGdyYWIgYSBjZWxsIGZyb20gdGhlIGxldmVsIGFib3ZlIGFuZCBleHRlbmQgaXRzIHJvd3NwYW4uIG90aGVyd2lzZSwgY3JlYXRlIGEgZnJlc2ggY2VsbFxuXHRcdFx0XHR0ZCA9IChsb25lQ2VsbE1hdHJpeFtpIC0gMV0gfHwgW10pW2NvbF07XG5cdFx0XHRcdGlmICh0ZCkge1xuXHRcdFx0XHRcdHRkLmF0dHIoXG5cdFx0XHRcdFx0XHQncm93c3BhbicsXG5cdFx0XHRcdFx0XHRwYXJzZUludCh0ZC5hdHRyKCdyb3dzcGFuJykgfHwgMSwgMTApICsgMVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGQgPSAkKCc8dGQvPicpO1xuXHRcdFx0XHRcdHRyLmFwcGVuZCh0ZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XG5cdFx0XHRcdGxvbmVDZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcblx0XHRcdFx0Y29sKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxldmVsQ250OyBpKyspIHsgLy8gaXRlcmF0ZSB0aHJvdWdoIGFsbCBsZXZlbHNcblx0XHRcdGxldmVsU2VncyA9IHNlZ0xldmVsc1tpXTtcblx0XHRcdGNvbCA9IDA7XG5cdFx0XHR0ciA9ICQoJzx0ci8+Jyk7XG5cblx0XHRcdHNlZ01hdHJpeC5wdXNoKFtdKTtcblx0XHRcdGNlbGxNYXRyaXgucHVzaChbXSk7XG5cdFx0XHRsb25lQ2VsbE1hdHJpeC5wdXNoKFtdKTtcblxuXHRcdFx0Ly8gbGV2ZWxDbnQgbWlnaHQgYmUgMSBldmVuIHRob3VnaCB0aGVyZSBhcmUgbm8gYWN0dWFsIGxldmVscy4gcHJvdGVjdCBhZ2FpbnN0IHRoaXMuXG5cdFx0XHQvLyB0aGlzIHNpbmdsZSBlbXB0eSByb3cgaXMgdXNlZnVsIGZvciBzdHlsaW5nLlxuXHRcdFx0aWYgKGxldmVsU2Vncykge1xuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbGV2ZWxTZWdzLmxlbmd0aDsgaisrKSB7IC8vIGl0ZXJhdGUgdGhyb3VnaCBzZWdtZW50cyBpbiBsZXZlbFxuXHRcdFx0XHRcdHNlZyA9IGxldmVsU2Vnc1tqXTtcblxuXHRcdFx0XHRcdGVtcHR5Q2VsbHNVbnRpbChzZWcubGVmdENvbCk7XG5cblx0XHRcdFx0XHQvLyBjcmVhdGUgYSBjb250YWluZXIgdGhhdCBvY2N1cGllcyBvciBtb3JlIGNvbHVtbnMuIGFwcGVuZCB0aGUgZXZlbnQgZWxlbWVudC5cblx0XHRcdFx0XHR0ZCA9ICQoJzx0ZCBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiLz4nKS5hcHBlbmQoc2VnLmVsKTtcblx0XHRcdFx0XHRpZiAoc2VnLmxlZnRDb2wgIT0gc2VnLnJpZ2h0Q29sKSB7XG5cdFx0XHRcdFx0XHR0ZC5hdHRyKCdjb2xzcGFuJywgc2VnLnJpZ2h0Q29sIC0gc2VnLmxlZnRDb2wgKyAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7IC8vIGEgc2luZ2xlLWNvbHVtbiBzZWdtZW50XG5cdFx0XHRcdFx0XHRsb25lQ2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0d2hpbGUgKGNvbCA8PSBzZWcucmlnaHRDb2wpIHtcblx0XHRcdFx0XHRcdGNlbGxNYXRyaXhbaV1bY29sXSA9IHRkO1xuXHRcdFx0XHRcdFx0c2VnTWF0cml4W2ldW2NvbF0gPSBzZWc7XG5cdFx0XHRcdFx0XHRjb2wrKztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ci5hcHBlbmQodGQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGVtcHR5Q2VsbHNVbnRpbChjb2xDbnQpOyAvLyBmaW5pc2ggb2ZmIHRoZSByb3dcblx0XHRcdHRoaXMuYm9va2VuZENlbGxzKHRyKTtcblx0XHRcdHRib2R5LmFwcGVuZCh0cik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgLy8gYSBcInJvd1N0cnVjdFwiXG5cdFx0XHRyb3c6IHJvdywgLy8gdGhlIHJvdyBudW1iZXJcblx0XHRcdHRib2R5RWw6IHRib2R5LFxuXHRcdFx0Y2VsbE1hdHJpeDogY2VsbE1hdHJpeCxcblx0XHRcdHNlZ01hdHJpeDogc2VnTWF0cml4LFxuXHRcdFx0c2VnTGV2ZWxzOiBzZWdMZXZlbHMsXG5cdFx0XHRzZWdzOiByb3dTZWdzXG5cdFx0fTtcblx0fSxcblxuXG5cdC8vIFN0YWNrcyBhIGZsYXQgYXJyYXkgb2Ygc2VnbWVudHMsIHdoaWNoIGFyZSBhbGwgYXNzdW1lZCB0byBiZSBpbiB0aGUgc2FtZSByb3csIGludG8gc3ViYXJyYXlzIG9mIHZlcnRpY2FsIGxldmVscy5cblx0Ly8gTk9URTogbW9kaWZpZXMgc2Vnc1xuXHRidWlsZFNlZ0xldmVsczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciBsZXZlbHMgPSBbXTtcblx0XHR2YXIgaSwgc2VnO1xuXHRcdHZhciBqO1xuXG5cdFx0Ly8gR2l2ZSBwcmVmZXJlbmNlIHRvIGVsZW1lbnRzIHdpdGggY2VydGFpbiBjcml0ZXJpYSwgc28gdGhleSBoYXZlXG5cdFx0Ly8gYSBjaGFuY2UgdG8gYmUgY2xvc2VyIHRvIHRoZSB0b3AuXG5cdFx0dGhpcy5zb3J0RXZlbnRTZWdzKHNlZ3MpO1xuXHRcdFxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWcgPSBzZWdzW2ldO1xuXG5cdFx0XHQvLyBsb29wIHRocm91Z2ggbGV2ZWxzLCBzdGFydGluZyB3aXRoIHRoZSB0b3Btb3N0LCB1bnRpbCB0aGUgc2VnbWVudCBkb2Vzbid0IGNvbGxpZGUgd2l0aCBvdGhlciBzZWdtZW50c1xuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRpZiAoIWlzRGF5U2VnQ29sbGlzaW9uKHNlZywgbGV2ZWxzW2pdKSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBgamAgbm93IGhvbGRzIHRoZSBkZXNpcmVkIHN1YnJvdyBpbmRleFxuXHRcdFx0c2VnLmxldmVsID0gajtcblxuXHRcdFx0Ly8gY3JlYXRlIG5ldyBsZXZlbCBhcnJheSBpZiBuZWVkZWQgYW5kIGFwcGVuZCBzZWdtZW50XG5cdFx0XHQobGV2ZWxzW2pdIHx8IChsZXZlbHNbal0gPSBbXSkpLnB1c2goc2VnKTtcblx0XHR9XG5cblx0XHQvLyBvcmRlciBzZWdtZW50cyBsZWZ0LXRvLXJpZ2h0LiB2ZXJ5IGltcG9ydGFudCBpZiBjYWxlbmRhciBpcyBSVExcblx0XHRmb3IgKGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRsZXZlbHNbal0uc29ydChjb21wYXJlRGF5U2VnQ29scyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxldmVscztcblx0fSxcblxuXG5cdC8vIEdpdmVuIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgcmV0dXJuIGFuIGFycmF5IG9mIHN1Yi1hcnJheXMsIGdyb3VwZWQgYnkgZWFjaCBzZWdtZW50J3Mgcm93XG5cdGdyb3VwU2VnUm93czogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciBzZWdSb3dzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5yb3dDbnQ7IGkrKykge1xuXHRcdFx0c2VnUm93cy5wdXNoKFtdKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnUm93c1tzZWdzW2ldLnJvd10ucHVzaChzZWdzW2ldKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2VnUm93cztcblx0fVxuXG59KTtcblxuXG4vLyBDb21wdXRlcyB3aGV0aGVyIHR3byBzZWdtZW50cycgY29sdW1ucyBjb2xsaWRlLiBUaGV5IGFyZSBhc3N1bWVkIHRvIGJlIGluIHRoZSBzYW1lIHJvdy5cbmZ1bmN0aW9uIGlzRGF5U2VnQ29sbGlzaW9uKHNlZywgb3RoZXJTZWdzKSB7XG5cdHZhciBpLCBvdGhlclNlZztcblxuXHRmb3IgKGkgPSAwOyBpIDwgb3RoZXJTZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0b3RoZXJTZWcgPSBvdGhlclNlZ3NbaV07XG5cblx0XHRpZiAoXG5cdFx0XHRvdGhlclNlZy5sZWZ0Q29sIDw9IHNlZy5yaWdodENvbCAmJlxuXHRcdFx0b3RoZXJTZWcucmlnaHRDb2wgPj0gc2VnLmxlZnRDb2xcblx0XHQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuXG4vLyBBIGNtcCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgdGhlIGxlZnRtb3N0IGV2ZW50XG5mdW5jdGlvbiBjb21wYXJlRGF5U2VnQ29scyhhLCBiKSB7XG5cdHJldHVybiBhLmxlZnRDb2wgLSBiLmxlZnRDb2w7XG59XG5cbjs7XG5cbi8qIE1ldGhvZHMgcmVsYXRlIHRvIGxpbWl0aW5nIHRoZSBudW1iZXIgZXZlbnRzIGZvciBhIGdpdmVuIGRheSBvbiBhIERheUdyaWRcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gTk9URTogYWxsIHRoZSBzZWdzIGJlaW5nIHBhc3NlZCBhcm91bmQgaW4gaGVyZSBhcmUgZm9yZWdyb3VuZCBzZWdzXG5cbkRheUdyaWQubWl4aW4oe1xuXG5cdHNlZ1BvcG92ZXI6IG51bGwsIC8vIHRoZSBQb3BvdmVyIHRoYXQgaG9sZHMgZXZlbnRzIHRoYXQgY2FuJ3QgZml0IGluIGEgY2VsbC4gbnVsbCB3aGVuIG5vdCB2aXNpYmxlXG5cdHBvcG92ZXJTZWdzOiBudWxsLCAvLyBhbiBhcnJheSBvZiBzZWdtZW50IG9iamVjdHMgdGhhdCB0aGUgc2VnUG9wb3ZlciBob2xkcy4gbnVsbCB3aGVuIG5vdCB2aXNpYmxlXG5cblxuXHRyZW1vdmVTZWdQb3BvdmVyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5zZWdQb3BvdmVyKSB7XG5cdFx0XHR0aGlzLnNlZ1BvcG92ZXIuaGlkZSgpOyAvLyBpbiBoYW5kbGVyLCB3aWxsIGNhbGwgc2VnUG9wb3ZlcidzIHJlbW92ZUVsZW1lbnRcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBMaW1pdHMgdGhlIG51bWJlciBvZiBcImxldmVsc1wiICh2ZXJ0aWNhbGx5IHN0YWNraW5nIGxheWVycyBvZiBldmVudHMpIGZvciBlYWNoIHJvdyBvZiB0aGUgZ3JpZC5cblx0Ly8gYGxldmVsTGltaXRgIGNhbiBiZSBmYWxzZSAoZG9uJ3QgbGltaXQpLCBhIG51bWJlciwgb3IgdHJ1ZSAoc2hvdWxkIGJlIGNvbXB1dGVkKS5cblx0bGltaXRSb3dzOiBmdW5jdGlvbihsZXZlbExpbWl0KSB7XG5cdFx0dmFyIHJvd1N0cnVjdHMgPSB0aGlzLnJvd1N0cnVjdHMgfHwgW107XG5cdFx0dmFyIHJvdzsgLy8gcm93ICNcblx0XHR2YXIgcm93TGV2ZWxMaW1pdDtcblxuXHRcdGZvciAocm93ID0gMDsgcm93IDwgcm93U3RydWN0cy5sZW5ndGg7IHJvdysrKSB7XG5cdFx0XHR0aGlzLnVubGltaXRSb3cocm93KTtcblxuXHRcdFx0aWYgKCFsZXZlbExpbWl0KSB7XG5cdFx0XHRcdHJvd0xldmVsTGltaXQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBsZXZlbExpbWl0ID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRyb3dMZXZlbExpbWl0ID0gbGV2ZWxMaW1pdDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyb3dMZXZlbExpbWl0ID0gdGhpcy5jb21wdXRlUm93TGV2ZWxMaW1pdChyb3cpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocm93TGV2ZWxMaW1pdCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5saW1pdFJvdyhyb3csIHJvd0xldmVsTGltaXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIHRoZSBudW1iZXIgb2YgbGV2ZWxzIGEgcm93IHdpbGwgYWNjb21vZGF0ZSB3aXRob3V0IGdvaW5nIG91dHNpZGUgaXRzIGJvdW5kcy5cblx0Ly8gQXNzdW1lcyB0aGUgcm93IGlzIFwicmlnaWRcIiAobWFpbnRhaW5zIGEgY29uc3RhbnQgaGVpZ2h0IHJlZ2FyZGxlc3Mgb2Ygd2hhdCBpcyBpbnNpZGUpLlxuXHQvLyBgcm93YCBpcyB0aGUgcm93IG51bWJlci5cblx0Y29tcHV0ZVJvd0xldmVsTGltaXQ6IGZ1bmN0aW9uKHJvdykge1xuXHRcdHZhciByb3dFbCA9IHRoaXMucm93RWxzLmVxKHJvdyk7IC8vIHRoZSBjb250YWluaW5nIFwiZmFrZVwiIHJvdyBkaXZcblx0XHR2YXIgcm93SGVpZ2h0ID0gcm93RWwuaGVpZ2h0KCk7IC8vIFRPRE86IGNhY2hlIHNvbWVob3c/XG5cdFx0dmFyIHRyRWxzID0gdGhpcy5yb3dTdHJ1Y3RzW3Jvd10udGJvZHlFbC5jaGlsZHJlbigpO1xuXHRcdHZhciBpLCB0ckVsO1xuXHRcdHZhciB0ckhlaWdodDtcblxuXHRcdGZ1bmN0aW9uIGl0ZXJJbm5lckhlaWdodHMoaSwgY2hpbGROb2RlKSB7XG5cdFx0XHR0ckhlaWdodCA9IE1hdGgubWF4KHRySGVpZ2h0LCAkKGNoaWxkTm9kZSkub3V0ZXJIZWlnaHQoKSk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV2ZWFsIG9uZSBsZXZlbCA8dHI+IGF0IGEgdGltZSBhbmQgc3RvcCB3aGVuIHdlIGZpbmQgb25lIG91dCBvZiBib3VuZHNcblx0XHRmb3IgKGkgPSAwOyBpIDwgdHJFbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRyRWwgPSB0ckVscy5lcShpKS5yZW1vdmVDbGFzcygnZmMtbGltaXRlZCcpOyAvLyByZXNldCB0byBvcmlnaW5hbCBzdGF0ZSAocmV2ZWFsKVxuXG5cdFx0XHQvLyB3aXRoIHJvd3NwYW5zPjEgYW5kIElFOCwgdHJFbC5vdXRlckhlaWdodCgpIHdvdWxkIHJldHVybiB0aGUgaGVpZ2h0IG9mIHRoZSBsYXJnZXN0IGNlbGwsXG5cdFx0XHQvLyBzbyBpbnN0ZWFkLCBmaW5kIHRoZSB0YWxsZXN0IGlubmVyIGNvbnRlbnQgZWxlbWVudC5cblx0XHRcdHRySGVpZ2h0ID0gMDtcblx0XHRcdHRyRWwuZmluZCgnPiB0ZCA+IDpmaXJzdC1jaGlsZCcpLmVhY2goaXRlcklubmVySGVpZ2h0cyk7XG5cblx0XHRcdGlmICh0ckVsLnBvc2l0aW9uKCkudG9wICsgdHJIZWlnaHQgPiByb3dIZWlnaHQpIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBzaG91bGQgbm90IGxpbWl0IGF0IGFsbFxuXHR9LFxuXG5cblx0Ly8gTGltaXRzIHRoZSBnaXZlbiBncmlkIHJvdyB0byB0aGUgbWF4aW11bSBudW1iZXIgb2YgbGV2ZWxzIGFuZCBpbmplY3RzIFwibW9yZVwiIGxpbmtzIGlmIG5lY2Vzc2FyeS5cblx0Ly8gYHJvd2AgaXMgdGhlIHJvdyBudW1iZXIuXG5cdC8vIGBsZXZlbExpbWl0YCBpcyBhIG51bWJlciBmb3IgdGhlIG1heGltdW0gKGluY2x1c2l2ZSkgbnVtYmVyIG9mIGxldmVscyBhbGxvd2VkLlxuXHRsaW1pdFJvdzogZnVuY3Rpb24ocm93LCBsZXZlbExpbWl0KSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgcm93U3RydWN0ID0gdGhpcy5yb3dTdHJ1Y3RzW3Jvd107XG5cdFx0dmFyIG1vcmVOb2RlcyA9IFtdOyAvLyBhcnJheSBvZiBcIm1vcmVcIiA8YT4gbGlua3MgYW5kIDx0ZD4gRE9NIG5vZGVzXG5cdFx0dmFyIGNvbCA9IDA7IC8vIGNvbCAjLCBsZWZ0LXRvLXJpZ2h0IChub3QgY2hyb25vbG9naWNhbGx5KVxuXHRcdHZhciBsZXZlbFNlZ3M7IC8vIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cyBpbiB0aGUgbGFzdCBhbGxvd2FibGUgbGV2ZWwsIG9yZGVyZWQgbGVmdC10by1yaWdodFxuXHRcdHZhciBjZWxsTWF0cml4OyAvLyBhIG1hdHJpeCAoYnkgbGV2ZWwsIHRoZW4gY29sdW1uKSBvZiBhbGwgPHRkPiBqUXVlcnkgZWxlbWVudHMgaW4gdGhlIHJvd1xuXHRcdHZhciBsaW1pdGVkTm9kZXM7IC8vIGFycmF5IG9mIHRlbXBvcmFyaWx5IGhpZGRlbiBsZXZlbCA8dHI+IGFuZCBzZWdtZW50IDx0ZD4gRE9NIG5vZGVzXG5cdFx0dmFyIGksIHNlZztcblx0XHR2YXIgc2Vnc0JlbG93OyAvLyBhcnJheSBvZiBzZWdtZW50IG9iamVjdHMgYmVsb3cgYHNlZ2AgaW4gdGhlIGN1cnJlbnQgYGNvbGBcblx0XHR2YXIgdG90YWxTZWdzQmVsb3c7IC8vIHRvdGFsIG51bWJlciBvZiBzZWdtZW50cyBiZWxvdyBgc2VnYCBpbiBhbnkgb2YgdGhlIGNvbHVtbnMgYHNlZ2Agb2NjdXBpZXNcblx0XHR2YXIgY29sU2Vnc0JlbG93OyAvLyBhcnJheSBvZiBzZWdtZW50IGFycmF5cywgYmVsb3cgc2VnLCBvbmUgZm9yIGVhY2ggY29sdW1uIChvZmZzZXQgZnJvbSBzZWdzJ3MgZmlyc3QgY29sdW1uKVxuXHRcdHZhciB0ZCwgcm93c3Bhbjtcblx0XHR2YXIgc2VnTW9yZU5vZGVzOyAvLyBhcnJheSBvZiBcIm1vcmVcIiA8dGQ+IGNlbGxzIHRoYXQgd2lsbCBzdGFuZC1pbiBmb3IgdGhlIGN1cnJlbnQgc2VnJ3MgY2VsbFxuXHRcdHZhciBqO1xuXHRcdHZhciBtb3JlVGQsIG1vcmVXcmFwLCBtb3JlTGluaztcblxuXHRcdC8vIEl0ZXJhdGVzIHRocm91Z2ggZW1wdHkgbGV2ZWwgY2VsbHMgYW5kIHBsYWNlcyBcIm1vcmVcIiBsaW5rcyBpbnNpZGUgaWYgbmVlZCBiZVxuXHRcdGZ1bmN0aW9uIGVtcHR5Q2VsbHNVbnRpbChlbmRDb2wpIHsgLy8gZ29lcyBmcm9tIGN1cnJlbnQgYGNvbGAgdG8gYGVuZENvbGBcblx0XHRcdHdoaWxlIChjb2wgPCBlbmRDb2wpIHtcblx0XHRcdFx0c2Vnc0JlbG93ID0gX3RoaXMuZ2V0Q2VsbFNlZ3Mocm93LCBjb2wsIGxldmVsTGltaXQpO1xuXHRcdFx0XHRpZiAoc2Vnc0JlbG93Lmxlbmd0aCkge1xuXHRcdFx0XHRcdHRkID0gY2VsbE1hdHJpeFtsZXZlbExpbWl0IC0gMV1bY29sXTtcblx0XHRcdFx0XHRtb3JlTGluayA9IF90aGlzLnJlbmRlck1vcmVMaW5rKHJvdywgY29sLCBzZWdzQmVsb3cpO1xuXHRcdFx0XHRcdG1vcmVXcmFwID0gJCgnPGRpdi8+JykuYXBwZW5kKG1vcmVMaW5rKTtcblx0XHRcdFx0XHR0ZC5hcHBlbmQobW9yZVdyYXApO1xuXHRcdFx0XHRcdG1vcmVOb2Rlcy5wdXNoKG1vcmVXcmFwWzBdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb2wrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobGV2ZWxMaW1pdCAmJiBsZXZlbExpbWl0IDwgcm93U3RydWN0LnNlZ0xldmVscy5sZW5ndGgpIHsgLy8gaXMgaXQgYWN0dWFsbHkgb3ZlciB0aGUgbGltaXQ/XG5cdFx0XHRsZXZlbFNlZ3MgPSByb3dTdHJ1Y3Quc2VnTGV2ZWxzW2xldmVsTGltaXQgLSAxXTtcblx0XHRcdGNlbGxNYXRyaXggPSByb3dTdHJ1Y3QuY2VsbE1hdHJpeDtcblxuXHRcdFx0bGltaXRlZE5vZGVzID0gcm93U3RydWN0LnRib2R5RWwuY2hpbGRyZW4oKS5zbGljZShsZXZlbExpbWl0KSAvLyBnZXQgbGV2ZWwgPHRyPiBlbGVtZW50cyBwYXN0IHRoZSBsaW1pdFxuXHRcdFx0XHQuYWRkQ2xhc3MoJ2ZjLWxpbWl0ZWQnKS5nZXQoKTsgLy8gaGlkZSBlbGVtZW50cyBhbmQgZ2V0IGEgc2ltcGxlIERPTS1ub2RlcyBhcnJheVxuXG5cdFx0XHQvLyBpdGVyYXRlIHRob3VnaCBzZWdtZW50cyBpbiB0aGUgbGFzdCBhbGxvd2FibGUgbGV2ZWxcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZXZlbFNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0c2VnID0gbGV2ZWxTZWdzW2ldO1xuXHRcdFx0XHRlbXB0eUNlbGxzVW50aWwoc2VnLmxlZnRDb2wpOyAvLyBwcm9jZXNzIGVtcHR5IGNlbGxzIGJlZm9yZSB0aGUgc2VnbWVudFxuXG5cdFx0XHRcdC8vIGRldGVybWluZSAqYWxsKiBzZWdtZW50cyBiZWxvdyBgc2VnYCB0aGF0IG9jY3VweSB0aGUgc2FtZSBjb2x1bW5zXG5cdFx0XHRcdGNvbFNlZ3NCZWxvdyA9IFtdO1xuXHRcdFx0XHR0b3RhbFNlZ3NCZWxvdyA9IDA7XG5cdFx0XHRcdHdoaWxlIChjb2wgPD0gc2VnLnJpZ2h0Q29sKSB7XG5cdFx0XHRcdFx0c2Vnc0JlbG93ID0gdGhpcy5nZXRDZWxsU2Vncyhyb3csIGNvbCwgbGV2ZWxMaW1pdCk7XG5cdFx0XHRcdFx0Y29sU2Vnc0JlbG93LnB1c2goc2Vnc0JlbG93KTtcblx0XHRcdFx0XHR0b3RhbFNlZ3NCZWxvdyArPSBzZWdzQmVsb3cubGVuZ3RoO1xuXHRcdFx0XHRcdGNvbCsrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRvdGFsU2Vnc0JlbG93KSB7IC8vIGRvIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGlzIHNlZ21lbnQgd2l0aCBvbmUgb3IgbWFueSBcIm1vcmVcIiBsaW5rcz9cblx0XHRcdFx0XHR0ZCA9IGNlbGxNYXRyaXhbbGV2ZWxMaW1pdCAtIDFdW3NlZy5sZWZ0Q29sXTsgLy8gdGhlIHNlZ21lbnQncyBwYXJlbnQgY2VsbFxuXHRcdFx0XHRcdHJvd3NwYW4gPSB0ZC5hdHRyKCdyb3dzcGFuJykgfHwgMTtcblx0XHRcdFx0XHRzZWdNb3JlTm9kZXMgPSBbXTtcblxuXHRcdFx0XHRcdC8vIG1ha2UgYSByZXBsYWNlbWVudCA8dGQ+IGZvciBlYWNoIGNvbHVtbiB0aGUgc2VnbWVudCBvY2N1cGllcy4gd2lsbCBiZSBvbmUgZm9yIGVhY2ggY29sc3BhblxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBjb2xTZWdzQmVsb3cubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdG1vcmVUZCA9ICQoJzx0ZCBjbGFzcz1cImZjLW1vcmUtY2VsbFwiLz4nKS5hdHRyKCdyb3dzcGFuJywgcm93c3Bhbik7XG5cdFx0XHRcdFx0XHRzZWdzQmVsb3cgPSBjb2xTZWdzQmVsb3dbal07XG5cdFx0XHRcdFx0XHRtb3JlTGluayA9IHRoaXMucmVuZGVyTW9yZUxpbmsoXG5cdFx0XHRcdFx0XHRcdHJvdyxcblx0XHRcdFx0XHRcdFx0c2VnLmxlZnRDb2wgKyBqLFxuXHRcdFx0XHRcdFx0XHRbIHNlZyBdLmNvbmNhdChzZWdzQmVsb3cpIC8vIGNvdW50IHNlZyBhcyBoaWRkZW4gdG9vXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0bW9yZVdyYXAgPSAkKCc8ZGl2Lz4nKS5hcHBlbmQobW9yZUxpbmspO1xuXHRcdFx0XHRcdFx0bW9yZVRkLmFwcGVuZChtb3JlV3JhcCk7XG5cdFx0XHRcdFx0XHRzZWdNb3JlTm9kZXMucHVzaChtb3JlVGRbMF0pO1xuXHRcdFx0XHRcdFx0bW9yZU5vZGVzLnB1c2gobW9yZVRkWzBdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZC5hZGRDbGFzcygnZmMtbGltaXRlZCcpLmFmdGVyKCQoc2VnTW9yZU5vZGVzKSk7IC8vIGhpZGUgb3JpZ2luYWwgPHRkPiBhbmQgaW5qZWN0IHJlcGxhY2VtZW50c1xuXHRcdFx0XHRcdGxpbWl0ZWROb2Rlcy5wdXNoKHRkWzBdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRlbXB0eUNlbGxzVW50aWwodGhpcy5jb2xDbnQpOyAvLyBmaW5pc2ggb2ZmIHRoZSBsZXZlbFxuXHRcdFx0cm93U3RydWN0Lm1vcmVFbHMgPSAkKG1vcmVOb2Rlcyk7IC8vIGZvciBlYXN5IHVuZG9pbmcgbGF0ZXJcblx0XHRcdHJvd1N0cnVjdC5saW1pdGVkRWxzID0gJChsaW1pdGVkTm9kZXMpOyAvLyBmb3IgZWFzeSB1bmRvaW5nIGxhdGVyXG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmV2ZWFscyBhbGwgbGV2ZWxzIGFuZCByZW1vdmVzIGFsbCBcIm1vcmVcIi1yZWxhdGVkIGVsZW1lbnRzIGZvciBhIGdyaWQncyByb3cuXG5cdC8vIGByb3dgIGlzIGEgcm93IG51bWJlci5cblx0dW5saW1pdFJvdzogZnVuY3Rpb24ocm93KSB7XG5cdFx0dmFyIHJvd1N0cnVjdCA9IHRoaXMucm93U3RydWN0c1tyb3ddO1xuXG5cdFx0aWYgKHJvd1N0cnVjdC5tb3JlRWxzKSB7XG5cdFx0XHRyb3dTdHJ1Y3QubW9yZUVscy5yZW1vdmUoKTtcblx0XHRcdHJvd1N0cnVjdC5tb3JlRWxzID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAocm93U3RydWN0LmxpbWl0ZWRFbHMpIHtcblx0XHRcdHJvd1N0cnVjdC5saW1pdGVkRWxzLnJlbW92ZUNsYXNzKCdmYy1saW1pdGVkJyk7XG5cdFx0XHRyb3dTdHJ1Y3QubGltaXRlZEVscyA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyBhbiA8YT4gZWxlbWVudCB0aGF0IHJlcHJlc2VudHMgaGlkZGVuIGV2ZW50IGVsZW1lbnQgZm9yIGEgY2VsbC5cblx0Ly8gUmVzcG9uc2libGUgZm9yIGF0dGFjaGluZyBjbGljayBoYW5kbGVyIGFzIHdlbGwuXG5cdHJlbmRlck1vcmVMaW5rOiBmdW5jdGlvbihyb3csIGNvbCwgaGlkZGVuU2Vncykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRyZXR1cm4gJCgnPGEgY2xhc3M9XCJmYy1tb3JlXCIvPicpXG5cdFx0XHQudGV4dChcblx0XHRcdFx0dGhpcy5nZXRNb3JlTGlua1RleHQoaGlkZGVuU2Vncy5sZW5ndGgpXG5cdFx0XHQpXG5cdFx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0dmFyIGNsaWNrT3B0aW9uID0gdmlldy5vcHQoJ2V2ZW50TGltaXRDbGljaycpO1xuXHRcdFx0XHR2YXIgZGF0ZSA9IF90aGlzLmdldENlbGxEYXRlKHJvdywgY29sKTtcblx0XHRcdFx0dmFyIG1vcmVFbCA9ICQodGhpcyk7XG5cdFx0XHRcdHZhciBkYXlFbCA9IF90aGlzLmdldENlbGxFbChyb3csIGNvbCk7XG5cdFx0XHRcdHZhciBhbGxTZWdzID0gX3RoaXMuZ2V0Q2VsbFNlZ3Mocm93LCBjb2wpO1xuXG5cdFx0XHRcdC8vIHJlc2NvcGUgdGhlIHNlZ21lbnRzIHRvIGJlIHdpdGhpbiB0aGUgY2VsbCdzIGRhdGVcblx0XHRcdFx0dmFyIHJlc2xpY2VkQWxsU2VncyA9IF90aGlzLnJlc2xpY2VEYXlTZWdzKGFsbFNlZ3MsIGRhdGUpO1xuXHRcdFx0XHR2YXIgcmVzbGljZWRIaWRkZW5TZWdzID0gX3RoaXMucmVzbGljZURheVNlZ3MoaGlkZGVuU2VncywgZGF0ZSk7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBjbGlja09wdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdC8vIHRoZSByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgYW4gYXRvbWljIG9wdGlvblxuXHRcdFx0XHRcdGNsaWNrT3B0aW9uID0gdmlldy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50TGltaXRDbGljaycsIG51bGwsIHtcblx0XHRcdFx0XHRcdGRhdGU6IGRhdGUsXG5cdFx0XHRcdFx0XHRkYXlFbDogZGF5RWwsXG5cdFx0XHRcdFx0XHRtb3JlRWw6IG1vcmVFbCxcblx0XHRcdFx0XHRcdHNlZ3M6IHJlc2xpY2VkQWxsU2Vncyxcblx0XHRcdFx0XHRcdGhpZGRlblNlZ3M6IHJlc2xpY2VkSGlkZGVuU2Vnc1xuXHRcdFx0XHRcdH0sIGV2KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjbGlja09wdGlvbiA9PT0gJ3BvcG92ZXInKSB7XG5cdFx0XHRcdFx0X3RoaXMuc2hvd1NlZ1BvcG92ZXIocm93LCBjb2wsIG1vcmVFbCwgcmVzbGljZWRBbGxTZWdzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgY2xpY2tPcHRpb24gPT09ICdzdHJpbmcnKSB7IC8vIGEgdmlldyBuYW1lXG5cdFx0XHRcdFx0dmlldy5jYWxlbmRhci56b29tVG8oZGF0ZSwgY2xpY2tPcHRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fSxcblxuXG5cdC8vIFJldmVhbHMgdGhlIHBvcG92ZXIgdGhhdCBkaXNwbGF5cyBhbGwgZXZlbnRzIHdpdGhpbiBhIGNlbGxcblx0c2hvd1NlZ1BvcG92ZXI6IGZ1bmN0aW9uKHJvdywgY29sLCBtb3JlTGluaywgc2Vncykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIG1vcmVXcmFwID0gbW9yZUxpbmsucGFyZW50KCk7IC8vIHRoZSA8ZGl2PiB3cmFwcGVyIGFyb3VuZCB0aGUgPGE+XG5cdFx0dmFyIHRvcEVsOyAvLyB0aGUgZWxlbWVudCB3ZSB3YW50IHRvIG1hdGNoIHRoZSB0b3AgY29vcmRpbmF0ZSBvZlxuXHRcdHZhciBvcHRpb25zO1xuXG5cdFx0aWYgKHRoaXMucm93Q250ID09IDEpIHtcblx0XHRcdHRvcEVsID0gdmlldy5lbDsgLy8gd2lsbCBjYXVzZSB0aGUgcG9wb3ZlciB0byBjb3ZlciBhbnkgc29ydCBvZiBoZWFkZXJcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0b3BFbCA9IHRoaXMucm93RWxzLmVxKHJvdyk7IC8vIHdpbGwgYWxpZ24gd2l0aCB0b3Agb2Ygcm93XG5cdFx0fVxuXG5cdFx0b3B0aW9ucyA9IHtcblx0XHRcdGNsYXNzTmFtZTogJ2ZjLW1vcmUtcG9wb3ZlcicsXG5cdFx0XHRjb250ZW50OiB0aGlzLnJlbmRlclNlZ1BvcG92ZXJDb250ZW50KHJvdywgY29sLCBzZWdzKSxcblx0XHRcdHBhcmVudEVsOiB0aGlzLnZpZXcuZWwsIC8vIGF0dGFjaCB0byByb290IG9mIHZpZXcuIGd1YXJhbnRlZXMgb3V0c2lkZSBvZiBzY3JvbGxiYXJzLlxuXHRcdFx0dG9wOiB0b3BFbC5vZmZzZXQoKS50b3AsXG5cdFx0XHRhdXRvSGlkZTogdHJ1ZSwgLy8gd2hlbiB0aGUgdXNlciBjbGlja3MgZWxzZXdoZXJlLCBoaWRlIHRoZSBwb3BvdmVyXG5cdFx0XHR2aWV3cG9ydENvbnN0cmFpbjogdmlldy5vcHQoJ3BvcG92ZXJWaWV3cG9ydENvbnN0cmFpbicpLFxuXHRcdFx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIGtpbGwgZXZlcnl0aGluZyB3aGVuIHRoZSBwb3BvdmVyIGlzIGhpZGRlblxuXHRcdFx0XHQvLyBub3RpZnkgZXZlbnRzIHRvIGJlIHJlbW92ZWRcblx0XHRcdFx0aWYgKF90aGlzLnBvcG92ZXJTZWdzKSB7XG5cdFx0XHRcdFx0dmFyIHNlZztcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLnBvcG92ZXJTZWdzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0XHRzZWcgPSBfdGhpcy5wb3BvdmVyU2Vnc1tpXTtcblx0XHRcdFx0XHRcdHZpZXcucHVibGljbHlUcmlnZ2VyKCdldmVudERlc3Ryb3knLCBzZWcuZXZlbnQsIHNlZy5ldmVudCwgc2VnLmVsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0X3RoaXMuc2VnUG9wb3Zlci5yZW1vdmVFbGVtZW50KCk7XG5cdFx0XHRcdF90aGlzLnNlZ1BvcG92ZXIgPSBudWxsO1xuXHRcdFx0XHRfdGhpcy5wb3BvdmVyU2VncyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIERldGVybWluZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG5cdFx0Ly8gV2UgdXNlIHRoZSBtb3JlV3JhcCBpbnN0ZWFkIG9mIHRoZSA8dGQ+IHRvIGF2b2lkIGJvcmRlciBjb25mdXNpb24uXG5cdFx0aWYgKHRoaXMuaXNSVEwpIHtcblx0XHRcdG9wdGlvbnMucmlnaHQgPSBtb3JlV3JhcC5vZmZzZXQoKS5sZWZ0ICsgbW9yZVdyYXAub3V0ZXJXaWR0aCgpICsgMTsgLy8gKzEgdG8gYmUgb3ZlciBjZWxsIGJvcmRlclxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG9wdGlvbnMubGVmdCA9IG1vcmVXcmFwLm9mZnNldCgpLmxlZnQgLSAxOyAvLyAtMSB0byBiZSBvdmVyIGNlbGwgYm9yZGVyXG5cdFx0fVxuXG5cdFx0dGhpcy5zZWdQb3BvdmVyID0gbmV3IFBvcG92ZXIob3B0aW9ucyk7XG5cdFx0dGhpcy5zZWdQb3BvdmVyLnNob3coKTtcblxuXHRcdC8vIHRoZSBwb3BvdmVyIGRvZXNuJ3QgbGl2ZSB3aXRoaW4gdGhlIGdyaWQncyBjb250YWluZXIgZWxlbWVudCwgYW5kIHRodXMgd29uJ3QgZ2V0IHRoZSBldmVudFxuXHRcdC8vIGRlbGVnYXRlZC1oYW5kbGVycyBmb3IgZnJlZS4gYXR0YWNoIGV2ZW50LXJlbGF0ZWQgaGFuZGxlcnMgdG8gdGhlIHBvcG92ZXIuXG5cdFx0dGhpcy5iaW5kU2VnSGFuZGxlcnNUb0VsKHRoaXMuc2VnUG9wb3Zlci5lbCk7XG5cdH0sXG5cblxuXHQvLyBCdWlsZHMgdGhlIGlubmVyIERPTSBjb250ZW50cyBvZiB0aGUgc2VnbWVudCBwb3BvdmVyXG5cdHJlbmRlclNlZ1BvcG92ZXJDb250ZW50OiBmdW5jdGlvbihyb3csIGNvbCwgc2Vncykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBpc1RoZW1lID0gdmlldy5vcHQoJ3RoZW1lJyk7XG5cdFx0dmFyIHRpdGxlID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCkuZm9ybWF0KHZpZXcub3B0KCdkYXlQb3BvdmVyRm9ybWF0JykpO1xuXHRcdHZhciBjb250ZW50ID0gJChcblx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtaGVhZGVyICcgKyB2aWV3LndpZGdldEhlYWRlckNsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJmYy1jbG9zZSAnICtcblx0XHRcdFx0XHQoaXNUaGVtZSA/ICd1aS1pY29uIHVpLWljb24tY2xvc2V0aGljaycgOiAnZmMtaWNvbiBmYy1pY29uLXgnKSArXG5cdFx0XHRcdCdcIj48L3NwYW4+JyArXG5cdFx0XHRcdCc8c3BhbiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXG5cdFx0XHRcdFx0aHRtbEVzY2FwZSh0aXRsZSkgK1xuXHRcdFx0XHQnPC9zcGFuPicgK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWNsZWFyXCIvPicgK1xuXHRcdFx0JzwvZGl2PicgK1xuXHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1ib2R5ICcgKyB2aWV3LndpZGdldENvbnRlbnRDbGFzcyArICdcIj4nICtcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXJcIj48L2Rpdj4nICtcblx0XHRcdCc8L2Rpdj4nXG5cdFx0KTtcblx0XHR2YXIgc2VnQ29udGFpbmVyID0gY29udGVudC5maW5kKCcuZmMtZXZlbnQtY29udGFpbmVyJyk7XG5cdFx0dmFyIGk7XG5cblx0XHQvLyByZW5kZXIgZWFjaCBzZWcncyBgZWxgIGFuZCBvbmx5IHJldHVybiB0aGUgdmlzaWJsZSBzZWdzXG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmdTZWdFbHMoc2VncywgdHJ1ZSk7IC8vIGRpc2FibGVSZXNpemluZz10cnVlXG5cdFx0dGhpcy5wb3BvdmVyU2VncyA9IHNlZ3M7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXG5cdFx0XHQvLyBiZWNhdXNlIHNlZ21lbnRzIGluIHRoZSBwb3BvdmVyIGFyZSBub3QgcGFydCBvZiBhIGdyaWQgY29vcmRpbmF0ZSBzeXN0ZW0sIHByb3ZpZGUgYSBoaW50IHRvIGFueVxuXHRcdFx0Ly8gZ3JpZHMgdGhhdCB3YW50IHRvIGRvIGRyYWctbi1kcm9wIGFib3V0IHdoaWNoIGNlbGwgaXQgY2FtZSBmcm9tXG5cdFx0XHR0aGlzLmhpdHNOZWVkZWQoKTtcblx0XHRcdHNlZ3NbaV0uaGl0ID0gdGhpcy5nZXRDZWxsSGl0KHJvdywgY29sKTtcblx0XHRcdHRoaXMuaGl0c05vdE5lZWRlZCgpO1xuXG5cdFx0XHRzZWdDb250YWluZXIuYXBwZW5kKHNlZ3NbaV0uZWwpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb250ZW50O1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gdGhlIGV2ZW50cyB3aXRoaW4gYW4gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzLCByZXNsaWNlIHRoZW0gdG8gYmUgaW4gYSBzaW5nbGUgZGF5XG5cdHJlc2xpY2VEYXlTZWdzOiBmdW5jdGlvbihzZWdzLCBkYXlEYXRlKSB7XG5cblx0XHQvLyBidWlsZCBhbiBhcnJheSBvZiB0aGUgb3JpZ2luYWwgZXZlbnRzXG5cdFx0dmFyIGV2ZW50cyA9ICQubWFwKHNlZ3MsIGZ1bmN0aW9uKHNlZykge1xuXHRcdFx0cmV0dXJuIHNlZy5ldmVudDtcblx0XHR9KTtcblxuXHRcdHZhciBkYXlTdGFydCA9IGRheURhdGUuY2xvbmUoKTtcblx0XHR2YXIgZGF5RW5kID0gZGF5U3RhcnQuY2xvbmUoKS5hZGQoMSwgJ2RheXMnKTtcblx0XHR2YXIgZGF5UmFuZ2UgPSB7IHN0YXJ0OiBkYXlTdGFydCwgZW5kOiBkYXlFbmQgfTtcblxuXHRcdC8vIHNsaWNlIHRoZSBldmVudHMgd2l0aCBhIGN1c3RvbSBzbGljaW5nIGZ1bmN0aW9uXG5cdFx0c2VncyA9IHRoaXMuZXZlbnRzVG9TZWdzKFxuXHRcdFx0ZXZlbnRzLFxuXHRcdFx0ZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHRcdFx0dmFyIHNlZyA9IGludGVyc2VjdFJhbmdlcyhyYW5nZSwgZGF5UmFuZ2UpOyAvLyB1bmRlZmluZCBpZiBubyBpbnRlcnNlY3Rpb25cblx0XHRcdFx0cmV0dXJuIHNlZyA/IFsgc2VnIF0gOiBbXTsgLy8gbXVzdCByZXR1cm4gYW4gYXJyYXkgb2Ygc2VnbWVudHNcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0Ly8gZm9yY2UgYW4gb3JkZXIgYmVjYXVzZSBldmVudHNUb1NlZ3MgZG9lc24ndCBndWFyYW50ZWUgb25lXG5cdFx0dGhpcy5zb3J0RXZlbnRTZWdzKHNlZ3MpO1xuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgaW5zaWRlIGEgXCJtb3JlXCIgbGluaywgZ2l2ZW4gdGhlIG51bWJlciBvZiBldmVudHMgaXQgcmVwcmVzZW50c1xuXHRnZXRNb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG51bSkge1xuXHRcdHZhciBvcHQgPSB0aGlzLnZpZXcub3B0KCdldmVudExpbWl0VGV4dCcpO1xuXG5cdFx0aWYgKHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBvcHQobnVtKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gJysnICsgbnVtICsgJyAnICsgb3B0O1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJldHVybnMgc2VnbWVudHMgd2l0aGluIGEgZ2l2ZW4gY2VsbC5cblx0Ly8gSWYgYHN0YXJ0TGV2ZWxgIGlzIHNwZWNpZmllZCwgcmV0dXJucyBvbmx5IGV2ZW50cyBpbmNsdWRpbmcgYW5kIGJlbG93IHRoYXQgbGV2ZWwuIE90aGVyd2lzZSByZXR1cm5zIGFsbCBzZWdzLlxuXHRnZXRDZWxsU2VnczogZnVuY3Rpb24ocm93LCBjb2wsIHN0YXJ0TGV2ZWwpIHtcblx0XHR2YXIgc2VnTWF0cml4ID0gdGhpcy5yb3dTdHJ1Y3RzW3Jvd10uc2VnTWF0cml4O1xuXHRcdHZhciBsZXZlbCA9IHN0YXJ0TGV2ZWwgfHwgMDtcblx0XHR2YXIgc2VncyA9IFtdO1xuXHRcdHZhciBzZWc7XG5cblx0XHR3aGlsZSAobGV2ZWwgPCBzZWdNYXRyaXgubGVuZ3RoKSB7XG5cdFx0XHRzZWcgPSBzZWdNYXRyaXhbbGV2ZWxdW2NvbF07XG5cdFx0XHRpZiAoc2VnKSB7XG5cdFx0XHRcdHNlZ3MucHVzaChzZWcpO1xuXHRcdFx0fVxuXHRcdFx0bGV2ZWwrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fVxuXG59KTtcblxuOztcblxuLyogQSBjb21wb25lbnQgdGhhdCByZW5kZXJzIG9uZSBvciBtb3JlIGNvbHVtbnMgb2YgdmVydGljYWwgdGltZSBzbG90c1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBXZSBtaXhpbiBEYXlUYWJsZSwgZXZlbiB0aG91Z2ggdGhlcmUgaXMgb25seSBhIHNpbmdsZSByb3cgb2YgZGF5c1xuXG52YXIgVGltZUdyaWQgPSBGQy5UaW1lR3JpZCA9IEdyaWQuZXh0ZW5kKERheVRhYmxlTWl4aW4sIHtcblxuXHRzbG90RHVyYXRpb246IG51bGwsIC8vIGR1cmF0aW9uIG9mIGEgXCJzbG90XCIsIGEgZGlzdGluY3QgdGltZSBzZWdtZW50IG9uIGdpdmVuIGRheSwgdmlzdWFsaXplZCBieSBsaW5lc1xuXHRzbmFwRHVyYXRpb246IG51bGwsIC8vIGdyYW51bGFyaXR5IG9mIHRpbWUgZm9yIGRyYWdnaW5nIGFuZCBzZWxlY3Rpbmdcblx0c25hcHNQZXJTbG90OiBudWxsLFxuXHRsYWJlbEZvcm1hdDogbnVsbCwgLy8gZm9ybWF0dGluZyBzdHJpbmcgZm9yIHRpbWVzIHJ1bm5pbmcgYWxvbmcgdmVydGljYWwgYXhpc1xuXHRsYWJlbEludGVydmFsOiBudWxsLCAvLyBkdXJhdGlvbiBvZiBob3cgb2Z0ZW4gYSBsYWJlbCBzaG91bGQgYmUgZGlzcGxheWVkIGZvciBhIHNsb3RcblxuXHRjb2xFbHM6IG51bGwsIC8vIGNlbGxzIGVsZW1lbnRzIGluIHRoZSBkYXktcm93IGJhY2tncm91bmRcblx0c2xhdENvbnRhaW5lckVsOiBudWxsLCAvLyBkaXYgdGhhdCB3cmFwcyBhbGwgdGhlIHNsYXQgcm93c1xuXHRzbGF0RWxzOiBudWxsLCAvLyBlbGVtZW50cyBydW5uaW5nIGhvcml6b250YWxseSBhY3Jvc3MgYWxsIGNvbHVtbnNcblx0bm93SW5kaWNhdG9yRWxzOiBudWxsLFxuXG5cdGNvbENvb3JkQ2FjaGU6IG51bGwsXG5cdHNsYXRDb29yZENhY2hlOiBudWxsLFxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdEdyaWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gY2FsbCB0aGUgc3VwZXItY29uc3RydWN0b3JcblxuXHRcdHRoaXMucHJvY2Vzc09wdGlvbnMoKTtcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIHRpbWUgZ3JpZCBpbnRvIGB0aGlzLmVsYCwgd2hpY2ggc2hvdWxkIGFscmVhZHkgYmUgYXNzaWduZWQuXG5cdC8vIFJlbGllcyBvbiB0aGUgdmlldydzIGNvbENudC4gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb21wb25lbnQgc2hvdWxkIHByb2JhYmx5IGJlIHNlbGYtc3VmZmljaWVudC5cblx0cmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWwuaHRtbCh0aGlzLnJlbmRlckh0bWwoKSk7XG5cdFx0dGhpcy5jb2xFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1kYXksIC5mYy1kaXNhYmxlZC1kYXknKTtcblx0XHR0aGlzLnNsYXRDb250YWluZXJFbCA9IHRoaXMuZWwuZmluZCgnLmZjLXNsYXRzJyk7XG5cdFx0dGhpcy5zbGF0RWxzID0gdGhpcy5zbGF0Q29udGFpbmVyRWwuZmluZCgndHInKTtcblxuXHRcdHRoaXMuY29sQ29vcmRDYWNoZSA9IG5ldyBDb29yZENhY2hlKHtcblx0XHRcdGVsczogdGhpcy5jb2xFbHMsXG5cdFx0XHRpc0hvcml6b250YWw6IHRydWVcblx0XHR9KTtcblx0XHR0aGlzLnNsYXRDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGUoe1xuXHRcdFx0ZWxzOiB0aGlzLnNsYXRFbHMsXG5cdFx0XHRpc1ZlcnRpY2FsOiB0cnVlXG5cdFx0fSk7XG5cblx0XHR0aGlzLnJlbmRlckNvbnRlbnRTa2VsZXRvbigpO1xuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgYmFzaWMgSFRNTCBza2VsZXRvbiBmb3IgdGhlIGdyaWRcblx0cmVuZGVySHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICcnICtcblx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtYmdcIj4nICtcblx0XHRcdFx0Jzx0YWJsZT4nICtcblx0XHRcdFx0XHR0aGlzLnJlbmRlckJnVHJIdG1sKDApICsgLy8gcm93PTBcblx0XHRcdFx0JzwvdGFibGU+JyArXG5cdFx0XHQnPC9kaXY+JyArXG5cdFx0XHQnPGRpdiBjbGFzcz1cImZjLXNsYXRzXCI+JyArXG5cdFx0XHRcdCc8dGFibGU+JyArXG5cdFx0XHRcdFx0dGhpcy5yZW5kZXJTbGF0Um93SHRtbCgpICtcblx0XHRcdFx0JzwvdGFibGU+JyArXG5cdFx0XHQnPC9kaXY+Jztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIGhvcml6b250YWwgXCJzbGF0c1wiIHRoYXQgcnVuIHdpZHRoLXdpc2UuIEhhcyBhIHRpbWUgYXhpcyBvbiBhIHNpZGUuIERlcGVuZHMgb24gUlRMLlxuXHRyZW5kZXJTbGF0Um93SHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGlzUlRMID0gdGhpcy5pc1JUTDtcblx0XHR2YXIgaHRtbCA9ICcnO1xuXHRcdHZhciBzbG90VGltZSA9IG1vbWVudC5kdXJhdGlvbigrdGhpcy52aWV3Lm1pblRpbWUpOyAvLyB3aXNoIHRoZXJlIHdhcyAuY2xvbmUoKSBmb3IgZHVyYXRpb25zXG5cdFx0dmFyIHNsb3REYXRlOyAvLyB3aWxsIGJlIG9uIHRoZSB2aWV3J3MgZmlyc3QgZGF5LCBidXQgd2Ugb25seSBjYXJlIGFib3V0IGl0cyB0aW1lXG5cdFx0dmFyIGlzTGFiZWxlZDtcblx0XHR2YXIgYXhpc0h0bWw7XG5cblx0XHQvLyBDYWxjdWxhdGUgdGhlIHRpbWUgZm9yIGVhY2ggc2xvdFxuXHRcdHdoaWxlIChzbG90VGltZSA8IHRoaXMudmlldy5tYXhUaW1lKSB7XG5cdFx0XHRzbG90RGF0ZSA9IHRoaXMuc3RhcnQuY2xvbmUoKS50aW1lKHNsb3RUaW1lKTtcblx0XHRcdGlzTGFiZWxlZCA9IGlzSW50KGRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbihzbG90VGltZSwgdGhpcy5sYWJlbEludGVydmFsKSk7XG5cblx0XHRcdGF4aXNIdG1sID1cblx0XHRcdFx0Jzx0ZCBjbGFzcz1cImZjLWF4aXMgZmMtdGltZSAnICsgdmlldy53aWRnZXRDb250ZW50Q2xhc3MgKyAnXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz4nICtcblx0XHRcdFx0XHQoaXNMYWJlbGVkID9cblx0XHRcdFx0XHRcdCc8c3Bhbj4nICsgLy8gZm9yIG1hdGNoQ2VsbFdpZHRoc1xuXHRcdFx0XHRcdFx0XHRodG1sRXNjYXBlKHNsb3REYXRlLmZvcm1hdCh0aGlzLmxhYmVsRm9ybWF0KSkgK1xuXHRcdFx0XHRcdFx0Jzwvc3Bhbj4nIDpcblx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHQpICtcblx0XHRcdFx0JzwvdGQ+JztcblxuXHRcdFx0aHRtbCArPVxuXHRcdFx0XHQnPHRyIGRhdGEtdGltZT1cIicgKyBzbG90RGF0ZS5mb3JtYXQoJ0hIOm1tOnNzJykgKyAnXCInICtcblx0XHRcdFx0XHQoaXNMYWJlbGVkID8gJycgOiAnIGNsYXNzPVwiZmMtbWlub3JcIicpICtcblx0XHRcdFx0XHQnPicgK1xuXHRcdFx0XHRcdCghaXNSVEwgPyBheGlzSHRtbCA6ICcnKSArXG5cdFx0XHRcdFx0Jzx0ZCBjbGFzcz1cIicgKyB2aWV3LndpZGdldENvbnRlbnRDbGFzcyArICdcIi8+JyArXG5cdFx0XHRcdFx0KGlzUlRMID8gYXhpc0h0bWwgOiAnJykgK1xuXHRcdFx0XHRcIjwvdHI+XCI7XG5cblx0XHRcdHNsb3RUaW1lLmFkZCh0aGlzLnNsb3REdXJhdGlvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblxuXHQvKiBPcHRpb25zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBQYXJzZXMgdmFyaW91cyBvcHRpb25zIGludG8gcHJvcGVydGllcyBvZiB0aGlzIG9iamVjdFxuXHRwcm9jZXNzT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIHNsb3REdXJhdGlvbiA9IHZpZXcub3B0KCdzbG90RHVyYXRpb24nKTtcblx0XHR2YXIgc25hcER1cmF0aW9uID0gdmlldy5vcHQoJ3NuYXBEdXJhdGlvbicpO1xuXHRcdHZhciBpbnB1dDtcblxuXHRcdHNsb3REdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihzbG90RHVyYXRpb24pO1xuXHRcdHNuYXBEdXJhdGlvbiA9IHNuYXBEdXJhdGlvbiA/IG1vbWVudC5kdXJhdGlvbihzbmFwRHVyYXRpb24pIDogc2xvdER1cmF0aW9uO1xuXG5cdFx0dGhpcy5zbG90RHVyYXRpb24gPSBzbG90RHVyYXRpb247XG5cdFx0dGhpcy5zbmFwRHVyYXRpb24gPSBzbmFwRHVyYXRpb247XG5cdFx0dGhpcy5zbmFwc1BlclNsb3QgPSBzbG90RHVyYXRpb24gLyBzbmFwRHVyYXRpb247IC8vIFRPRE86IGVuc3VyZSBhbiBpbnRlZ2VyIG11bHRpcGxlP1xuXG5cdFx0dGhpcy5taW5SZXNpemVEdXJhdGlvbiA9IHNuYXBEdXJhdGlvbjsgLy8gaGFja1xuXG5cdFx0Ly8gbWlnaHQgYmUgYW4gYXJyYXkgdmFsdWUgKGZvciBUaW1lbGluZVZpZXcpLlxuXHRcdC8vIGlmIHNvLCBnZXR0aW5nIHRoZSBtb3N0IGdyYW51bGFyIGVudHJ5ICh0aGUgbGFzdCBvbmUgcHJvYmFibHkpLlxuXHRcdGlucHV0ID0gdmlldy5vcHQoJ3Nsb3RMYWJlbEZvcm1hdCcpO1xuXHRcdGlmICgkLmlzQXJyYXkoaW5wdXQpKSB7XG5cdFx0XHRpbnB1dCA9IGlucHV0W2lucHV0Lmxlbmd0aCAtIDFdO1xuXHRcdH1cblxuXHRcdHRoaXMubGFiZWxGb3JtYXQgPVxuXHRcdFx0aW5wdXQgfHxcblx0XHRcdHZpZXcub3B0KCdzbWFsbFRpbWVGb3JtYXQnKTsgLy8gdGhlIGNvbXB1dGVkIGRlZmF1bHRcblxuXHRcdGlucHV0ID0gdmlldy5vcHQoJ3Nsb3RMYWJlbEludGVydmFsJyk7XG5cdFx0dGhpcy5sYWJlbEludGVydmFsID0gaW5wdXQgP1xuXHRcdFx0bW9tZW50LmR1cmF0aW9uKGlucHV0KSA6XG5cdFx0XHR0aGlzLmNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbik7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyBhbiBhdXRvbWF0aWMgdmFsdWUgZm9yIHNsb3RMYWJlbEludGVydmFsXG5cdGNvbXB1dGVMYWJlbEludGVydmFsOiBmdW5jdGlvbihzbG90RHVyYXRpb24pIHtcblx0XHR2YXIgaTtcblx0XHR2YXIgbGFiZWxJbnRlcnZhbDtcblx0XHR2YXIgc2xvdHNQZXJMYWJlbDtcblxuXHRcdC8vIGZpbmQgdGhlIHNtYWxsZXN0IHN0b2NrIGxhYmVsIGludGVydmFsIHRoYXQgcmVzdWx0cyBpbiBtb3JlIHRoYW4gb25lIHNsb3RzLXBlci1sYWJlbFxuXHRcdGZvciAoaSA9IEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRsYWJlbEludGVydmFsID0gbW9tZW50LmR1cmF0aW9uKEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TW2ldKTtcblx0XHRcdHNsb3RzUGVyTGFiZWwgPSBkaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24obGFiZWxJbnRlcnZhbCwgc2xvdER1cmF0aW9uKTtcblx0XHRcdGlmIChpc0ludChzbG90c1BlckxhYmVsKSAmJiBzbG90c1BlckxhYmVsID4gMSkge1xuXHRcdFx0XHRyZXR1cm4gbGFiZWxJbnRlcnZhbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKHNsb3REdXJhdGlvbik7IC8vIGZhbGwgYmFjay4gY2xvbmVcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGEgZGVmYXVsdCBldmVudCB0aW1lIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGB0aW1lRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXG5cdGNvbXB1dGVFdmVudFRpbWVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXcub3B0KCdub01lcmlkaWVtVGltZUZvcm1hdCcpOyAvLyBsaWtlIFwiNjozMFwiIChubyBBTS9QTSlcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGEgZGVmYXVsdCBgZGlzcGxheUV2ZW50RW5kYCB2YWx1ZSBpZiBvbmUgaXMgbm90IGV4cGxpY2x0eSBkZWZpbmVkXG5cdGNvbXB1dGVEaXNwbGF5RXZlbnRFbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cblx0LyogSGl0IFN5c3RlbVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cHJlcGFyZUhpdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29sQ29vcmRDYWNoZS5idWlsZCgpO1xuXHRcdHRoaXMuc2xhdENvb3JkQ2FjaGUuYnVpbGQoKTtcblx0fSxcblxuXG5cdHJlbGVhc2VIaXRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNvbENvb3JkQ2FjaGUuY2xlYXIoKTtcblx0XHQvLyBOT1RFOiBkb24ndCBjbGVhciBzbGF0Q29vcmRDYWNoZSBiZWNhdXNlIHdlIHJlbHkgb24gaXQgZm9yIGNvbXB1dGVUaW1lVG9wXG5cdH0sXG5cblxuXHRxdWVyeUhpdDogZnVuY3Rpb24obGVmdE9mZnNldCwgdG9wT2Zmc2V0KSB7XG5cdFx0dmFyIHNuYXBzUGVyU2xvdCA9IHRoaXMuc25hcHNQZXJTbG90O1xuXHRcdHZhciBjb2xDb29yZENhY2hlID0gdGhpcy5jb2xDb29yZENhY2hlO1xuXHRcdHZhciBzbGF0Q29vcmRDYWNoZSA9IHRoaXMuc2xhdENvb3JkQ2FjaGU7XG5cblx0XHRpZiAoY29sQ29vcmRDYWNoZS5pc0xlZnRJbkJvdW5kcyhsZWZ0T2Zmc2V0KSAmJiBzbGF0Q29vcmRDYWNoZS5pc1RvcEluQm91bmRzKHRvcE9mZnNldCkpIHtcblx0XHRcdHZhciBjb2xJbmRleCA9IGNvbENvb3JkQ2FjaGUuZ2V0SG9yaXpvbnRhbEluZGV4KGxlZnRPZmZzZXQpO1xuXHRcdFx0dmFyIHNsYXRJbmRleCA9IHNsYXRDb29yZENhY2hlLmdldFZlcnRpY2FsSW5kZXgodG9wT2Zmc2V0KTtcblxuXHRcdFx0aWYgKGNvbEluZGV4ICE9IG51bGwgJiYgc2xhdEluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIHNsYXRUb3AgPSBzbGF0Q29vcmRDYWNoZS5nZXRUb3BPZmZzZXQoc2xhdEluZGV4KTtcblx0XHRcdFx0dmFyIHNsYXRIZWlnaHQgPSBzbGF0Q29vcmRDYWNoZS5nZXRIZWlnaHQoc2xhdEluZGV4KTtcblx0XHRcdFx0dmFyIHBhcnRpYWwgPSAodG9wT2Zmc2V0IC0gc2xhdFRvcCkgLyBzbGF0SGVpZ2h0OyAvLyBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG5cdFx0XHRcdHZhciBsb2NhbFNuYXBJbmRleCA9IE1hdGguZmxvb3IocGFydGlhbCAqIHNuYXBzUGVyU2xvdCk7IC8vIHRoZSBzbmFwICMgcmVsYXRpdmUgdG8gc3RhcnQgb2Ygc2xhdFxuXHRcdFx0XHR2YXIgc25hcEluZGV4ID0gc2xhdEluZGV4ICogc25hcHNQZXJTbG90ICsgbG9jYWxTbmFwSW5kZXg7XG5cdFx0XHRcdHZhciBzbmFwVG9wID0gc2xhdFRvcCArIChsb2NhbFNuYXBJbmRleCAvIHNuYXBzUGVyU2xvdCkgKiBzbGF0SGVpZ2h0O1xuXHRcdFx0XHR2YXIgc25hcEJvdHRvbSA9IHNsYXRUb3AgKyAoKGxvY2FsU25hcEluZGV4ICsgMSkgLyBzbmFwc1BlclNsb3QpICogc2xhdEhlaWdodDtcblxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGNvbDogY29sSW5kZXgsXG5cdFx0XHRcdFx0c25hcDogc25hcEluZGV4LFxuXHRcdFx0XHRcdGNvbXBvbmVudDogdGhpcywgLy8gbmVlZGVkIHVuZm9ydHVuYXRlbHkgOihcblx0XHRcdFx0XHRsZWZ0OiBjb2xDb29yZENhY2hlLmdldExlZnRPZmZzZXQoY29sSW5kZXgpLFxuXHRcdFx0XHRcdHJpZ2h0OiBjb2xDb29yZENhY2hlLmdldFJpZ2h0T2Zmc2V0KGNvbEluZGV4KSxcblx0XHRcdFx0XHR0b3A6IHNuYXBUb3AsXG5cdFx0XHRcdFx0Ym90dG9tOiBzbmFwQm90dG9tXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Z2V0SGl0U3BhbjogZnVuY3Rpb24oaGl0KSB7XG5cdFx0dmFyIHN0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZSgwLCBoaXQuY29sKTsgLy8gcm93PTBcblx0XHR2YXIgdGltZSA9IHRoaXMuY29tcHV0ZVNuYXBUaW1lKGhpdC5zbmFwKTsgLy8gcGFzcyBpbiB0aGUgc25hcC1pbmRleFxuXHRcdHZhciBlbmQ7XG5cblx0XHRzdGFydC50aW1lKHRpbWUpO1xuXHRcdGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKHRoaXMuc25hcER1cmF0aW9uKTtcblxuXHRcdHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcblx0fSxcblxuXG5cdGdldEhpdEVsOiBmdW5jdGlvbihoaXQpIHtcblx0XHRyZXR1cm4gdGhpcy5jb2xFbHMuZXEoaGl0LmNvbCk7XG5cdH0sXG5cblxuXHQvKiBEYXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmFuZ2VVcGRhdGVkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVwZGF0ZURheVRhYmxlKCk7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIHJvdyBudW1iZXIgb2YgdGhlIGdyaWQsIHJlcHJlc2VudGluZyBhIFwic25hcFwiLCByZXR1cm5zIGEgdGltZSAoRHVyYXRpb24pIGZyb20gaXRzIHN0YXJ0LW9mLWRheVxuXHRjb21wdXRlU25hcFRpbWU6IGZ1bmN0aW9uKHNuYXBJbmRleCkge1xuXHRcdHJldHVybiBtb21lbnQuZHVyYXRpb24odGhpcy52aWV3Lm1pblRpbWUgKyB0aGlzLnNuYXBEdXJhdGlvbiAqIHNuYXBJbmRleCk7XG5cdH0sXG5cblxuXHQvLyBTbGljZXMgdXAgdGhlIGdpdmVuIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIHdpdGggb3RoZXIgbWlzYyBkYXRhKSBpbnRvIGFuIGFycmF5IG9mIHNlZ21lbnRzXG5cdHNwYW5Ub1NlZ3M6IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHR2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZUJ5VGltZXMoc3Bhbik7XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuaXNSVEwpIHtcblx0XHRcdFx0c2Vnc1tpXS5jb2wgPSB0aGlzLmRheXNQZXJSb3cgLSAxIC0gc2Vnc1tpXS5kYXlJbmRleDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzZWdzW2ldLmNvbCA9IHNlZ3NbaV0uZGF5SW5kZXg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblxuXHRzbGljZVJhbmdlQnlUaW1lczogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHR2YXIgc2VncyA9IFtdO1xuXHRcdHZhciBzZWc7XG5cdFx0dmFyIGRheUluZGV4O1xuXHRcdHZhciBkYXlEYXRlO1xuXHRcdHZhciBkYXlSYW5nZTtcblxuXHRcdGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IHRoaXMuZGF5c1BlclJvdzsgZGF5SW5kZXgrKykge1xuXHRcdFx0ZGF5RGF0ZSA9IHRoaXMuZGF5RGF0ZXNbZGF5SW5kZXhdLmNsb25lKCkudGltZSgwKTsgLy8gVE9ETzogYmV0dGVyIEFQSSBmb3IgdGhpcz9cblx0XHRcdGRheVJhbmdlID0ge1xuXHRcdFx0XHRzdGFydDogZGF5RGF0ZS5jbG9uZSgpLmFkZCh0aGlzLnZpZXcubWluVGltZSksIC8vIGRvbid0IHVzZSAudGltZSgpIGJlY2F1c2UgaXQgc3V4IHdpdGggbmVnYXRpdmVzXG5cdFx0XHRcdGVuZDogZGF5RGF0ZS5jbG9uZSgpLmFkZCh0aGlzLnZpZXcubWF4VGltZSlcblx0XHRcdH07XG5cdFx0XHRzZWcgPSBpbnRlcnNlY3RSYW5nZXMocmFuZ2UsIGRheVJhbmdlKTsgLy8gYm90aCB3aWxsIGJlIGFtYmlnIHRpbWV6b25lXG5cdFx0XHRpZiAoc2VnKSB7XG5cdFx0XHRcdHNlZy5kYXlJbmRleCA9IGRheUluZGV4O1xuXHRcdFx0XHRzZWdzLnB1c2goc2VnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8qIENvb3JkaW5hdGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHR1cGRhdGVTaXplOiBmdW5jdGlvbihpc1Jlc2l6ZSkgeyAvLyBOT1QgYSBzdGFuZGFyZCBHcmlkIG1ldGhvZFxuXHRcdHRoaXMuc2xhdENvb3JkQ2FjaGUuYnVpbGQoKTtcblxuXHRcdGlmIChpc1Jlc2l6ZSkge1xuXHRcdFx0dGhpcy51cGRhdGVTZWdWZXJ0aWNhbHMoXG5cdFx0XHRcdFtdLmNvbmNhdCh0aGlzLmZnU2VncyB8fCBbXSwgdGhpcy5iZ1NlZ3MgfHwgW10sIHRoaXMuYnVzaW5lc3NTZWdzIHx8IFtdKVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblxuXHRnZXRUb3RhbFNsYXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnNsYXRDb250YWluZXJFbC5vdXRlckhlaWdodCgpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cblx0Ly8gQSBgc3RhcnRPZkRheURhdGVgIG11c3QgYmUgZ2l2ZW4gZm9yIGF2b2lkaW5nIGFtYmlndWl0eSBvdmVyIGhvdyB0byB0cmVhdCBtaWRuaWdodC5cblx0Y29tcHV0ZURhdGVUb3A6IGZ1bmN0aW9uKGRhdGUsIHN0YXJ0T2ZEYXlEYXRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29tcHV0ZVRpbWVUb3AoXG5cdFx0XHRtb21lbnQuZHVyYXRpb24oXG5cdFx0XHRcdGRhdGUgLSBzdGFydE9mRGF5RGF0ZS5jbG9uZSgpLnN0cmlwVGltZSgpXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIHRoZSB0b3AgY29vcmRpbmF0ZSwgcmVsYXRpdmUgdG8gdGhlIGJvdW5kcyBvZiB0aGUgZ3JpZCwgb2YgdGhlIGdpdmVuIHRpbWUgKGEgRHVyYXRpb24pLlxuXHRjb21wdXRlVGltZVRvcDogZnVuY3Rpb24odGltZSkge1xuXHRcdHZhciBsZW4gPSB0aGlzLnNsYXRFbHMubGVuZ3RoO1xuXHRcdHZhciBzbGF0Q292ZXJhZ2UgPSAodGltZSAtIHRoaXMudmlldy5taW5UaW1lKSAvIHRoaXMuc2xvdER1cmF0aW9uOyAvLyBmbG9hdGluZy1wb2ludCB2YWx1ZSBvZiAjIG9mIHNsb3RzIGNvdmVyZWRcblx0XHR2YXIgc2xhdEluZGV4O1xuXHRcdHZhciBzbGF0UmVtYWluZGVyO1xuXG5cdFx0Ly8gY29tcHV0ZSBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBmb3IgaG93IG1hbnkgc2xhdHMgc2hvdWxkIGJlIHByb2dyZXNzZWQgdGhyb3VnaC5cblx0XHQvLyBmcm9tIDAgdG8gbnVtYmVyIG9mIHNsYXRzIChpbmNsdXNpdmUpXG5cdFx0Ly8gY29uc3RyYWluZWQgYmVjYXVzZSBtaW5UaW1lL21heFRpbWUgbWlnaHQgYmUgY3VzdG9taXplZC5cblx0XHRzbGF0Q292ZXJhZ2UgPSBNYXRoLm1heCgwLCBzbGF0Q292ZXJhZ2UpO1xuXHRcdHNsYXRDb3ZlcmFnZSA9IE1hdGgubWluKGxlbiwgc2xhdENvdmVyYWdlKTtcblxuXHRcdC8vIGFuIGludGVnZXIgaW5kZXggb2YgdGhlIGZ1cnRoZXN0IHdob2xlIHNsYXRcblx0XHQvLyBmcm9tIDAgdG8gbnVtYmVyIHNsYXRzICgqZXhjbHVzaXZlKiwgc28gbGVuLTEpXG5cdFx0c2xhdEluZGV4ID0gTWF0aC5mbG9vcihzbGF0Q292ZXJhZ2UpO1xuXHRcdHNsYXRJbmRleCA9IE1hdGgubWluKHNsYXRJbmRleCwgbGVuIC0gMSk7XG5cblx0XHQvLyBob3cgbXVjaCBmdXJ0aGVyIHRocm91Z2ggdGhlIHNsYXRJbmRleCBzbGF0IChmcm9tIDAuMC0xLjApIG11c3QgYmUgY292ZXJlZCBpbiBhZGRpdGlvbi5cblx0XHQvLyBjb3VsZCBiZSAxLjAgaWYgc2xhdENvdmVyYWdlIGlzIGNvdmVyaW5nICphbGwqIHRoZSBzbG90c1xuXHRcdHNsYXRSZW1haW5kZXIgPSBzbGF0Q292ZXJhZ2UgLSBzbGF0SW5kZXg7XG5cblx0XHRyZXR1cm4gdGhpcy5zbGF0Q29vcmRDYWNoZS5nZXRUb3BQb3NpdGlvbihzbGF0SW5kZXgpICtcblx0XHRcdHRoaXMuc2xhdENvb3JkQ2FjaGUuZ2V0SGVpZ2h0KHNsYXRJbmRleCkgKiBzbGF0UmVtYWluZGVyO1xuXHR9LFxuXG5cblxuXHQvKiBFdmVudCBEcmFnIFZpc3VhbGl6YXRpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyBkcmFnZ2VkIG92ZXIgdGhlIHNwZWNpZmllZCBkYXRlKHMpLlxuXHQvLyBBIHJldHVybmVkIHZhbHVlIG9mIGB0cnVlYCBzaWduYWxzIHRoYXQgYSBtb2NrIFwiaGVscGVyXCIgZXZlbnQgaGFzIGJlZW4gcmVuZGVyZWQuXG5cdHJlbmRlckRyYWc6IGZ1bmN0aW9uKGV2ZW50TG9jYXRpb24sIHNlZykge1xuXHRcdHZhciBldmVudFNwYW5zO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKHNlZykgeyAvLyBpZiB0aGVyZSBpcyBldmVudCBpbmZvcm1hdGlvbiBmb3IgdGhpcyBkcmFnLCByZW5kZXIgYSBoZWxwZXIgZXZlbnRcblxuXHRcdFx0Ly8gcmV0dXJucyBtb2NrIGV2ZW50IGVsZW1lbnRzXG5cdFx0XHQvLyBzaWduYWwgdGhhdCBhIGhlbHBlciBoYXMgYmVlbiByZW5kZXJlZFxuXHRcdFx0cmV0dXJuIHRoaXMucmVuZGVyRXZlbnRMb2NhdGlvbkhlbHBlcihldmVudExvY2F0aW9uLCBzZWcpO1xuXHRcdH1cblx0XHRlbHNlIHsgLy8gb3RoZXJ3aXNlLCBqdXN0IHJlbmRlciBhIGhpZ2hsaWdodFxuXHRcdFx0ZXZlbnRTcGFucyA9IHRoaXMuZXZlbnRUb1NwYW5zKGV2ZW50TG9jYXRpb24pO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRTcGFucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLnJlbmRlckhpZ2hsaWdodChldmVudFNwYW5zW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIGRyYWdnZWRcblx0dW5yZW5kZXJEcmFnOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVySGVscGVyKCk7XG5cdFx0dGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xuXHR9LFxuXG5cblx0LyogRXZlbnQgUmVzaXplIFZpc3VhbGl6YXRpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkXG5cdHJlbmRlckV2ZW50UmVzaXplOiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBzZWcpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJFdmVudExvY2F0aW9uSGVscGVyKGV2ZW50TG9jYXRpb24sIHNlZyk7IC8vIHJldHVybnMgbW9jayBldmVudCBlbGVtZW50c1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkXG5cdHVucmVuZGVyRXZlbnRSZXNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIZWxwZXIoKTtcblx0fSxcblxuXG5cdC8qIEV2ZW50IEhlbHBlclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIG1vY2sgXCJoZWxwZXJcIiBldmVudC4gYHNvdXJjZVNlZ2AgaXMgdGhlIG9yaWdpbmFsIHNlZ21lbnQgb2JqZWN0IGFuZCBtaWdodCBiZSBudWxsIChhbiBleHRlcm5hbCBkcmFnKVxuXHRyZW5kZXJIZWxwZXI6IGZ1bmN0aW9uKGV2ZW50LCBzb3VyY2VTZWcpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJIZWxwZXJTZWdzKHRoaXMuZXZlbnRUb1NlZ3MoZXZlbnQpLCBzb3VyY2VTZWcpOyAvLyByZXR1cm5zIG1vY2sgZXZlbnQgZWxlbWVudHNcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbnkgbW9jayBoZWxwZXIgZXZlbnRcblx0dW5yZW5kZXJIZWxwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIZWxwZXJTZWdzKCk7XG5cdH0sXG5cblxuXHQvKiBCdXNpbmVzcyBIb3Vyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW5kZXJCdXNpbmVzc1NlZ3MoXG5cdFx0XHR0aGlzLmJ1aWxkQnVzaW5lc3NIb3VyU2VncygpXG5cdFx0KTtcblx0fSxcblxuXG5cdHVucmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckJ1c2luZXNzU2VncygpO1xuXHR9LFxuXG5cblx0LyogTm93IEluZGljYXRvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Z2V0Tm93SW5kaWNhdG9yVW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdtaW51dGUnOyAvLyB3aWxsIHJlZnJlc2ggb24gdGhlIG1pbnV0ZVxuXHR9LFxuXG5cblx0cmVuZGVyTm93SW5kaWNhdG9yOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0Ly8gc2VnIHN5c3RlbSBtaWdodCBiZSBvdmVya2lsbCwgYnV0IGl0IGhhbmRsZXMgc2NlbmFyaW8gd2hlcmUgbGluZSBuZWVkcyB0byBiZSByZW5kZXJlZFxuXHRcdC8vICBtb3JlIHRoYW4gb25jZSBiZWNhdXNlIG9mIGNvbHVtbnMgd2l0aCB0aGUgc2FtZSBkYXRlIChyZXNvdXJjZXMgY29sdW1ucyBmb3IgZXhhbXBsZSlcblx0XHR2YXIgc2VncyA9IHRoaXMuc3BhblRvU2Vncyh7IHN0YXJ0OiBkYXRlLCBlbmQ6IGRhdGUgfSk7XG5cdFx0dmFyIHRvcCA9IHRoaXMuY29tcHV0ZURhdGVUb3AoZGF0ZSwgZGF0ZSk7XG5cdFx0dmFyIG5vZGVzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHQvLyByZW5kZXIgbGluZXMgd2l0aGluIHRoZSBjb2x1bW5zXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdG5vZGVzLnB1c2goJCgnPGRpdiBjbGFzcz1cImZjLW5vdy1pbmRpY2F0b3IgZmMtbm93LWluZGljYXRvci1saW5lXCI+PC9kaXY+Jylcblx0XHRcdFx0LmNzcygndG9wJywgdG9wKVxuXHRcdFx0XHQuYXBwZW5kVG8odGhpcy5jb2xDb250YWluZXJFbHMuZXEoc2Vnc1tpXS5jb2wpKVswXSk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVuZGVyIGFuIGFycm93IG92ZXIgdGhlIGF4aXNcblx0XHRpZiAoc2Vncy5sZW5ndGggPiAwKSB7IC8vIGlzIHRoZSBjdXJyZW50IHRpbWUgaW4gdmlldz9cblx0XHRcdG5vZGVzLnB1c2goJCgnPGRpdiBjbGFzcz1cImZjLW5vdy1pbmRpY2F0b3IgZmMtbm93LWluZGljYXRvci1hcnJvd1wiPjwvZGl2PicpXG5cdFx0XHRcdC5jc3MoJ3RvcCcsIHRvcClcblx0XHRcdFx0LmFwcGVuZFRvKHRoaXMuZWwuZmluZCgnLmZjLWNvbnRlbnQtc2tlbGV0b24nKSlbMF0pO1xuXHRcdH1cblxuXHRcdHRoaXMubm93SW5kaWNhdG9yRWxzID0gJChub2Rlcyk7XG5cdH0sXG5cblxuXHR1bnJlbmRlck5vd0luZGljYXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMubm93SW5kaWNhdG9yRWxzKSB7XG5cdFx0XHR0aGlzLm5vd0luZGljYXRvckVscy5yZW1vdmUoKTtcblx0XHRcdHRoaXMubm93SW5kaWNhdG9yRWxzID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBTZWxlY3Rpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvbi4gT3ZlcnJpZGVzIHRoZSBkZWZhdWx0LCB3aGljaCB3YXMgdG8gc2ltcGx5IHJlbmRlciBhIGhpZ2hsaWdodC5cblx0cmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0aWYgKHRoaXMudmlldy5vcHQoJ3NlbGVjdEhlbHBlcicpKSB7IC8vIHRoaXMgc2V0dGluZyBzaWduYWxzIHRoYXQgYSBtb2NrIGhlbHBlciBldmVudCBzaG91bGQgYmUgcmVuZGVyZWRcblxuXHRcdFx0Ly8gbm9ybWFsbHkgYWNjZXBzIGFuIGV2ZW50TG9jYXRpb24sIHNwYW4gaGFzIGEgc3RhcnQvZW5kLCB3aGljaCBpcyBnb29kIGVub3VnaFxuXHRcdFx0dGhpcy5yZW5kZXJFdmVudExvY2F0aW9uSGVscGVyKHNwYW4pO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0KHNwYW4pO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYSBzZWxlY3Rpb25cblx0dW5yZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIZWxwZXIoKTtcblx0XHR0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XG5cdH0sXG5cblxuXHQvKiBIaWdobGlnaHRcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckhpZ2hsaWdodDogZnVuY3Rpb24oc3Bhbikge1xuXHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0U2Vncyh0aGlzLnNwYW5Ub1NlZ3Moc3BhbikpO1xuXHR9LFxuXG5cblx0dW5yZW5kZXJIaWdobGlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIaWdobGlnaHRTZWdzKCk7XG5cdH1cblxufSk7XG5cbjs7XG5cbi8qIE1ldGhvZHMgZm9yIHJlbmRlcmluZyBTRUdNRU5UUywgcGllY2VzIG9mIGNvbnRlbnQgdGhhdCBsaXZlIG9uIHRoZSB2aWV3XG4gKCB0aGlzIGZpbGUgaXMgbm8gbG9uZ2VyIGp1c3QgZm9yIGV2ZW50cyApXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuVGltZUdyaWQubWl4aW4oe1xuXG5cdGNvbENvbnRhaW5lckVsczogbnVsbCwgLy8gY29udGFpbmVycyBmb3IgZWFjaCBjb2x1bW5cblxuXHQvLyBpbm5lci1jb250YWluZXJzIGZvciBlYWNoIGNvbHVtbiB3aGVyZSBkaWZmZXJlbnQgdHlwZXMgb2Ygc2VncyBsaXZlXG5cdGZnQ29udGFpbmVyRWxzOiBudWxsLFxuXHRiZ0NvbnRhaW5lckVsczogbnVsbCxcblx0aGVscGVyQ29udGFpbmVyRWxzOiBudWxsLFxuXHRoaWdobGlnaHRDb250YWluZXJFbHM6IG51bGwsXG5cdGJ1c2luZXNzQ29udGFpbmVyRWxzOiBudWxsLFxuXG5cdC8vIGFycmF5cyBvZiBkaWZmZXJlbnQgdHlwZXMgb2YgZGlzcGxheWVkIHNlZ21lbnRzXG5cdGZnU2VnczogbnVsbCxcblx0YmdTZWdzOiBudWxsLFxuXHRoZWxwZXJTZWdzOiBudWxsLFxuXHRoaWdobGlnaHRTZWdzOiBudWxsLFxuXHRidXNpbmVzc1NlZ3M6IG51bGwsXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBET00gdGhhdCB0aGUgdmlldydzIGNvbnRlbnQgd2lsbCBsaXZlIGluXG5cdHJlbmRlckNvbnRlbnRTa2VsZXRvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNlbGxIdG1sID0gJyc7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIHNrZWxldG9uRWw7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5jb2xDbnQ7IGkrKykge1xuXHRcdFx0Y2VsbEh0bWwgKz1cblx0XHRcdFx0Jzx0ZD4nICtcblx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtY29sXCI+JyArXG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lciBmYy1oZWxwZXItY29udGFpbmVyXCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiPjwvZGl2PicgK1xuXHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1oaWdobGlnaHQtY29udGFpbmVyXCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWJnZXZlbnQtY29udGFpbmVyXCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWJ1c2luZXNzLWNvbnRhaW5lclwiPjwvZGl2PicgK1xuXHRcdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdFx0JzwvdGQ+Jztcblx0XHR9XG5cblx0XHRza2VsZXRvbkVsID0gJChcblx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtY29udGVudC1za2VsZXRvblwiPicgK1xuXHRcdFx0XHQnPHRhYmxlPicgK1xuXHRcdFx0XHRcdCc8dHI+JyArIGNlbGxIdG1sICsgJzwvdHI+JyArXG5cdFx0XHRcdCc8L3RhYmxlPicgK1xuXHRcdFx0JzwvZGl2Pidcblx0XHQpO1xuXG5cdFx0dGhpcy5jb2xDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1jb250ZW50LWNvbCcpO1xuXHRcdHRoaXMuaGVscGVyQ29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtaGVscGVyLWNvbnRhaW5lcicpO1xuXHRcdHRoaXMuZmdDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1ldmVudC1jb250YWluZXI6bm90KC5mYy1oZWxwZXItY29udGFpbmVyKScpO1xuXHRcdHRoaXMuYmdDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1iZ2V2ZW50LWNvbnRhaW5lcicpO1xuXHRcdHRoaXMuaGlnaGxpZ2h0Q29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtaGlnaGxpZ2h0LWNvbnRhaW5lcicpO1xuXHRcdHRoaXMuYnVzaW5lc3NDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1idXNpbmVzcy1jb250YWluZXInKTtcblxuXHRcdHRoaXMuYm9va2VuZENlbGxzKHNrZWxldG9uRWwuZmluZCgndHInKSk7IC8vIFRPRE86IGRvIHRoaXMgb24gc3RyaW5nIGxldmVsXG5cdFx0dGhpcy5lbC5hcHBlbmQoc2tlbGV0b25FbCk7XG5cdH0sXG5cblxuXHQvKiBGb3JlZ3JvdW5kIEV2ZW50c1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyRmdTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmdTZWdzSW50b0NvbnRhaW5lcnMoc2VncywgdGhpcy5mZ0NvbnRhaW5lckVscyk7XG5cdFx0dGhpcy5mZ1NlZ3MgPSBzZWdzO1xuXHRcdHJldHVybiBzZWdzOyAvLyBuZWVkZWQgZm9yIEdyaWQ6OnJlbmRlckV2ZW50c1xuXHR9LFxuXG5cblx0dW5yZW5kZXJGZ1NlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJOYW1lZFNlZ3MoJ2ZnU2VncycpO1xuXHR9LFxuXG5cblx0LyogRm9yZWdyb3VuZCBIZWxwZXIgRXZlbnRzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJIZWxwZXJTZWdzOiBmdW5jdGlvbihzZWdzLCBzb3VyY2VTZWcpIHtcblx0XHR2YXIgaGVscGVyRWxzID0gW107XG5cdFx0dmFyIGksIHNlZztcblx0XHR2YXIgc291cmNlRWw7XG5cblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ3NJbnRvQ29udGFpbmVycyhzZWdzLCB0aGlzLmhlbHBlckNvbnRhaW5lckVscyk7XG5cblx0XHQvLyBUcnkgdG8gbWFrZSB0aGUgc2VnbWVudCB0aGF0IGlzIGluIHRoZSBzYW1lIHJvdyBhcyBzb3VyY2VTZWcgbG9vayB0aGUgc2FtZVxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWcgPSBzZWdzW2ldO1xuXHRcdFx0aWYgKHNvdXJjZVNlZyAmJiBzb3VyY2VTZWcuY29sID09PSBzZWcuY29sKSB7XG5cdFx0XHRcdHNvdXJjZUVsID0gc291cmNlU2VnLmVsO1xuXHRcdFx0XHRzZWcuZWwuY3NzKHtcblx0XHRcdFx0XHRsZWZ0OiBzb3VyY2VFbC5jc3MoJ2xlZnQnKSxcblx0XHRcdFx0XHRyaWdodDogc291cmNlRWwuY3NzKCdyaWdodCcpLFxuXHRcdFx0XHRcdCdtYXJnaW4tbGVmdCc6IHNvdXJjZUVsLmNzcygnbWFyZ2luLWxlZnQnKSxcblx0XHRcdFx0XHQnbWFyZ2luLXJpZ2h0Jzogc291cmNlRWwuY3NzKCdtYXJnaW4tcmlnaHQnKVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGhlbHBlckVscy5wdXNoKHNlZy5lbFswXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5oZWxwZXJTZWdzID0gc2VncztcblxuXHRcdHJldHVybiAkKGhlbHBlckVscyk7IC8vIG11c3QgcmV0dXJuIHJlbmRlcmVkIGhlbHBlcnNcblx0fSxcblxuXG5cdHVucmVuZGVySGVscGVyU2VnczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlck5hbWVkU2VncygnaGVscGVyU2VncycpO1xuXHR9LFxuXG5cblx0LyogQmFja2dyb3VuZCBFdmVudHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckJnU2VnczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHNlZ3MgPSB0aGlzLnJlbmRlckZpbGxTZWdFbHMoJ2JnRXZlbnQnLCBzZWdzKTsgLy8gVE9ETzogb2xkIGZpbGwgc3lzdGVtXG5cdFx0dGhpcy51cGRhdGVTZWdWZXJ0aWNhbHMoc2Vncyk7XG5cdFx0dGhpcy5hdHRhY2hTZWdzQnlDb2wodGhpcy5ncm91cFNlZ3NCeUNvbChzZWdzKSwgdGhpcy5iZ0NvbnRhaW5lckVscyk7XG5cdFx0dGhpcy5iZ1NlZ3MgPSBzZWdzO1xuXHRcdHJldHVybiBzZWdzOyAvLyBuZWVkZWQgZm9yIEdyaWQ6OnJlbmRlckV2ZW50c1xuXHR9LFxuXG5cblx0dW5yZW5kZXJCZ1NlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJOYW1lZFNlZ3MoJ2JnU2VncycpO1xuXHR9LFxuXG5cblx0LyogSGlnaGxpZ2h0XG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJIaWdobGlnaHRTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmlsbFNlZ0VscygnaGlnaGxpZ2h0Jywgc2Vncyk7IC8vIFRPRE86IG9sZCBmaWxsIHN5c3RlbVxuXHRcdHRoaXMudXBkYXRlU2VnVmVydGljYWxzKHNlZ3MpO1xuXHRcdHRoaXMuYXR0YWNoU2Vnc0J5Q29sKHRoaXMuZ3JvdXBTZWdzQnlDb2woc2VncyksIHRoaXMuaGlnaGxpZ2h0Q29udGFpbmVyRWxzKTtcblx0XHR0aGlzLmhpZ2hsaWdodFNlZ3MgPSBzZWdzO1xuXHR9LFxuXG5cblx0dW5yZW5kZXJIaWdobGlnaHRTZWdzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVyTmFtZWRTZWdzKCdoaWdobGlnaHRTZWdzJyk7XG5cdH0sXG5cblxuXHQvKiBCdXNpbmVzcyBIb3Vyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyQnVzaW5lc3NTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmlsbFNlZ0VscygnYnVzaW5lc3NIb3VycycsIHNlZ3MpOyAvLyBUT0RPOiBvbGQgZmlsbCBzeXN0ZW1cblx0XHR0aGlzLnVwZGF0ZVNlZ1ZlcnRpY2FscyhzZWdzKTtcblx0XHR0aGlzLmF0dGFjaFNlZ3NCeUNvbCh0aGlzLmdyb3VwU2Vnc0J5Q29sKHNlZ3MpLCB0aGlzLmJ1c2luZXNzQ29udGFpbmVyRWxzKTtcblx0XHR0aGlzLmJ1c2luZXNzU2VncyA9IHNlZ3M7XG5cdH0sXG5cblxuXHR1bnJlbmRlckJ1c2luZXNzU2VnczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlck5hbWVkU2VncygnYnVzaW5lc3NTZWdzJyk7XG5cdH0sXG5cblxuXHQvKiBTZWcgUmVuZGVyaW5nIFV0aWxzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBHaXZlbiBhIGZsYXQgYXJyYXkgb2Ygc2VnbWVudHMsIHJldHVybiBhbiBhcnJheSBvZiBzdWItYXJyYXlzLCBncm91cGVkIGJ5IGVhY2ggc2VnbWVudCdzIGNvbFxuXHRncm91cFNlZ3NCeUNvbDogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciBzZWdzQnlDb2wgPSBbXTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbENudDsgaSsrKSB7XG5cdFx0XHRzZWdzQnlDb2wucHVzaChbXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZ3NCeUNvbFtzZWdzW2ldLmNvbF0ucHVzaChzZWdzW2ldKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vnc0J5Q29sO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gc2VnbWVudHMgZ3JvdXBlZCBieSBjb2x1bW4sIGluc2VydCB0aGUgc2VnbWVudHMnIGVsZW1lbnRzIGludG8gYSBwYXJhbGxlbCBhcnJheSBvZiBjb250YWluZXJcblx0Ly8gZWxlbWVudHMsIGVhY2ggbGl2aW5nIHdpdGhpbiBhIGNvbHVtbi5cblx0YXR0YWNoU2Vnc0J5Q29sOiBmdW5jdGlvbihzZWdzQnlDb2wsIGNvbnRhaW5lckVscykge1xuXHRcdHZhciBjb2w7XG5cdFx0dmFyIHNlZ3M7XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykgeyAvLyBpdGVyYXRlIGVhY2ggY29sdW1uIGdyb3VwaW5nXG5cdFx0XHRzZWdzID0gc2Vnc0J5Q29sW2NvbF07XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnRhaW5lckVscy5lcShjb2wpLmFwcGVuZChzZWdzW2ldLmVsKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHaXZlbiB0aGUgbmFtZSBvZiBhIHByb3BlcnR5IG9mIGB0aGlzYCBvYmplY3QsIGFzc3VtZWQgdG8gYmUgYW4gYXJyYXkgb2Ygc2VnbWVudHMsXG5cdC8vIGxvb3BzIHRocm91Z2ggZWFjaCBzZWdtZW50IGFuZCByZW1vdmVzIGZyb20gRE9NLiBXaWxsIG51bGwtb3V0IHRoZSBwcm9wZXJ0eSBhZnRlcndhcmRzLlxuXHR1bnJlbmRlck5hbWVkU2VnczogZnVuY3Rpb24ocHJvcE5hbWUpIHtcblx0XHR2YXIgc2VncyA9IHRoaXNbcHJvcE5hbWVdO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKHNlZ3MpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNlZ3NbaV0uZWwucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzW3Byb3BOYW1lXSA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cblxuXHQvKiBGb3JlZ3JvdW5kIEV2ZW50IFJlbmRlcmluZyBVdGlsc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gR2l2ZW4gYW4gYXJyYXkgb2YgZm9yZWdyb3VuZCBzZWdtZW50cywgcmVuZGVyIGEgRE9NIGVsZW1lbnQgZm9yIGVhY2gsIGNvbXB1dGVzIHBvc2l0aW9uLFxuXHQvLyBhbmQgYXR0YWNoZXMgdG8gdGhlIGNvbHVtbiBpbm5lci1jb250YWluZXIgZWxlbWVudHMuXG5cdHJlbmRlckZnU2Vnc0ludG9Db250YWluZXJzOiBmdW5jdGlvbihzZWdzLCBjb250YWluZXJFbHMpIHtcblx0XHR2YXIgc2Vnc0J5Q29sO1xuXHRcdHZhciBjb2w7XG5cblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ0VscyhzZWdzKTsgLy8gd2lsbCBjYWxsIGZnU2VnSHRtbFxuXHRcdHNlZ3NCeUNvbCA9IHRoaXMuZ3JvdXBTZWdzQnlDb2woc2Vncyk7XG5cblx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xuXHRcdFx0dGhpcy51cGRhdGVGZ1NlZ0Nvb3JkcyhzZWdzQnlDb2xbY29sXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5hdHRhY2hTZWdzQnlDb2woc2Vnc0J5Q29sLCBjb250YWluZXJFbHMpO1xuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSBldmVudCBzZWdtZW50J3MgZGVmYXVsdCByZW5kZXJpbmdcblx0ZmdTZWdIdG1sOiBmdW5jdGlvbihzZWcsIGRpc2FibGVSZXNpemluZykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBldmVudCA9IHNlZy5ldmVudDtcblx0XHR2YXIgaXNEcmFnZ2FibGUgPSB2aWV3LmlzRXZlbnREcmFnZ2FibGUoZXZlbnQpO1xuXHRcdHZhciBpc1Jlc2l6YWJsZUZyb21TdGFydCA9ICFkaXNhYmxlUmVzaXppbmcgJiYgc2VnLmlzU3RhcnQgJiYgdmlldy5pc0V2ZW50UmVzaXphYmxlRnJvbVN0YXJ0KGV2ZW50KTtcblx0XHR2YXIgaXNSZXNpemFibGVGcm9tRW5kID0gIWRpc2FibGVSZXNpemluZyAmJiBzZWcuaXNFbmQgJiYgdmlldy5pc0V2ZW50UmVzaXphYmxlRnJvbUVuZChldmVudCk7XG5cdFx0dmFyIGNsYXNzZXMgPSB0aGlzLmdldFNlZ0NsYXNzZXMoc2VnLCBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGVGcm9tU3RhcnQgfHwgaXNSZXNpemFibGVGcm9tRW5kKTtcblx0XHR2YXIgc2tpbkNzcyA9IGNzc1RvU3RyKHRoaXMuZ2V0U2VnU2tpbkNzcyhzZWcpKTtcblx0XHR2YXIgdGltZVRleHQ7XG5cdFx0dmFyIGZ1bGxUaW1lVGV4dDsgLy8gbW9yZSB2ZXJib3NlIHRpbWUgdGV4dC4gZm9yIHRoZSBwcmludCBzdHlsZXNoZWV0XG5cdFx0dmFyIHN0YXJ0VGltZVRleHQ7IC8vIGp1c3QgdGhlIHN0YXJ0IHRpbWUgdGV4dFxuXG5cdFx0Y2xhc3Nlcy51bnNoaWZ0KCdmYy10aW1lLWdyaWQtZXZlbnQnLCAnZmMtdi1ldmVudCcpO1xuXG5cdFx0aWYgKHZpZXcuaXNNdWx0aURheUV2ZW50KGV2ZW50KSkgeyAvLyBpZiB0aGUgZXZlbnQgYXBwZWFycyB0byBzcGFuIG1vcmUgdGhhbiBvbmUgZGF5Li4uXG5cdFx0XHQvLyBEb24ndCBkaXNwbGF5IHRpbWUgdGV4dCBvbiBzZWdtZW50cyB0aGF0IHJ1biBlbnRpcmVseSB0aHJvdWdoIGEgZGF5LlxuXHRcdFx0Ly8gVGhhdCB3b3VsZCBhcHBlYXIgYXMgbWlkbmlnaHQtbWlkbmlnaHQgYW5kIHdvdWxkIGxvb2sgZHVtYi5cblx0XHRcdC8vIE90aGVyd2lzZSwgZGlzcGxheSB0aGUgdGltZSB0ZXh0IGZvciB0aGUgKnNlZ21lbnQncyogdGltZXMgKGxpa2UgNnBtLW1pZG5pZ2h0IG9yIG1pZG5pZ2h0LTEwYW0pXG5cdFx0XHRpZiAoc2VnLmlzU3RhcnQgfHwgc2VnLmlzRW5kKSB7XG5cdFx0XHRcdHRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KHNlZyk7XG5cdFx0XHRcdGZ1bGxUaW1lVGV4dCA9IHRoaXMuZ2V0RXZlbnRUaW1lVGV4dChzZWcsICdMVCcpO1xuXHRcdFx0XHRzdGFydFRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KHNlZywgbnVsbCwgZmFsc2UpOyAvLyBkaXNwbGF5RW5kPWZhbHNlXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIERpc3BsYXkgdGhlIG5vcm1hbCB0aW1lIHRleHQgZm9yIHRoZSAqZXZlbnQncyogdGltZXNcblx0XHRcdHRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KGV2ZW50KTtcblx0XHRcdGZ1bGxUaW1lVGV4dCA9IHRoaXMuZ2V0RXZlbnRUaW1lVGV4dChldmVudCwgJ0xUJyk7XG5cdFx0XHRzdGFydFRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KGV2ZW50LCBudWxsLCBmYWxzZSk7IC8vIGRpc3BsYXlFbmQ9ZmFsc2Vcblx0XHR9XG5cblx0XHRyZXR1cm4gJzxhIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXG5cdFx0XHQoZXZlbnQudXJsID9cblx0XHRcdFx0JyBocmVmPVwiJyArIGh0bWxFc2NhcGUoZXZlbnQudXJsKSArICdcIicgOlxuXHRcdFx0XHQnJ1xuXHRcdFx0XHQpICtcblx0XHRcdChza2luQ3NzID9cblx0XHRcdFx0JyBzdHlsZT1cIicgKyBza2luQ3NzICsgJ1wiJyA6XG5cdFx0XHRcdCcnXG5cdFx0XHRcdCkgK1xuXHRcdFx0Jz4nICtcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1jb250ZW50XCI+JyArXG5cdFx0XHRcdFx0KHRpbWVUZXh0ID9cblx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtdGltZVwiJyArXG5cdFx0XHRcdFx0XHQnIGRhdGEtc3RhcnQ9XCInICsgaHRtbEVzY2FwZShzdGFydFRpbWVUZXh0KSArICdcIicgK1xuXHRcdFx0XHRcdFx0JyBkYXRhLWZ1bGw9XCInICsgaHRtbEVzY2FwZShmdWxsVGltZVRleHQpICsgJ1wiJyArXG5cdFx0XHRcdFx0XHQnPicgK1xuXHRcdFx0XHRcdFx0XHQnPHNwYW4+JyArIGh0bWxFc2NhcGUodGltZVRleHQpICsgJzwvc3Bhbj4nICtcblx0XHRcdFx0XHRcdCc8L2Rpdj4nIDpcblx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHQpICtcblx0XHRcdFx0XHQoZXZlbnQudGl0bGUgP1xuXHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy10aXRsZVwiPicgK1xuXHRcdFx0XHRcdFx0XHRodG1sRXNjYXBlKGV2ZW50LnRpdGxlKSArXG5cdFx0XHRcdFx0XHQnPC9kaXY+JyA6XG5cdFx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdFx0KSArXG5cdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1iZ1wiLz4nICtcblx0XHRcdFx0LyogVE9ETzogd3JpdGUgQ1NTIGZvciB0aGlzXG5cdFx0XHRcdChpc1Jlc2l6YWJsZUZyb21TdGFydCA/XG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLXN0YXJ0LXJlc2l6ZXJcIiAvPicgOlxuXHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0KSArXG5cdFx0XHRcdCovXG5cdFx0XHRcdChpc1Jlc2l6YWJsZUZyb21FbmQgP1xuXHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1lbmQtcmVzaXplclwiIC8+JyA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0XHQpICtcblx0XHRcdCc8L2E+Jztcblx0fSxcblxuXG5cdC8qIFNlZyBQb3NpdGlvbiBVdGlsc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVmcmVzaGVzIHRoZSBDU1MgdG9wL2JvdHRvbSBjb29yZGluYXRlcyBmb3IgZWFjaCBzZWdtZW50IGVsZW1lbnQuXG5cdC8vIFdvcmtzIHdoZW4gY2FsbGVkIGFmdGVyIGluaXRpYWwgcmVuZGVyLCBhZnRlciBhIHdpbmRvdyByZXNpemUvem9vbSBmb3IgZXhhbXBsZS5cblx0dXBkYXRlU2VnVmVydGljYWxzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dGhpcy5jb21wdXRlU2VnVmVydGljYWxzKHNlZ3MpO1xuXHRcdHRoaXMuYXNzaWduU2VnVmVydGljYWxzKHNlZ3MpO1xuXHR9LFxuXG5cblx0Ly8gRm9yIGVhY2ggc2VnbWVudCBpbiBhbiBhcnJheSwgY29tcHV0ZXMgYW5kIGFzc2lnbnMgaXRzIHRvcCBhbmQgYm90dG9tIHByb3BlcnRpZXNcblx0Y29tcHV0ZVNlZ1ZlcnRpY2FsczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciBpLCBzZWc7XG5cdFx0dmFyIGRheURhdGU7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnID0gc2Vnc1tpXTtcblx0XHRcdGRheURhdGUgPSB0aGlzLmRheURhdGVzW3NlZy5kYXlJbmRleF07XG5cblx0XHRcdHNlZy50b3AgPSB0aGlzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydCwgZGF5RGF0ZSk7XG5cdFx0XHRzZWcuYm90dG9tID0gdGhpcy5jb21wdXRlRGF0ZVRvcChzZWcuZW5kLCBkYXlEYXRlKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBzZWdtZW50cyB0aGF0IGFscmVhZHkgaGF2ZSB0aGVpciB0b3AvYm90dG9tIHByb3BlcnRpZXMgY29tcHV0ZWQsIGFwcGxpZXMgdGhvc2UgdmFsdWVzIHRvXG5cdC8vIHRoZSBzZWdtZW50cycgZWxlbWVudHMuXG5cdGFzc2lnblNlZ1ZlcnRpY2FsczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciBpLCBzZWc7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnID0gc2Vnc1tpXTtcblx0XHRcdHNlZy5lbC5jc3ModGhpcy5nZW5lcmF0ZVNlZ1ZlcnRpY2FsQ3NzKHNlZykpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyBhbiBvYmplY3Qgd2l0aCBDU1MgcHJvcGVydGllcyBmb3IgdGhlIHRvcC9ib3R0b20gY29vcmRpbmF0ZXMgb2YgYSBzZWdtZW50IGVsZW1lbnRcblx0Z2VuZXJhdGVTZWdWZXJ0aWNhbENzczogZnVuY3Rpb24oc2VnKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogc2VnLnRvcCxcblx0XHRcdGJvdHRvbTogLXNlZy5ib3R0b20gLy8gZmxpcHBlZCBiZWNhdXNlIG5lZWRzIHRvIGJlIHNwYWNlIGJleW9uZCBib3R0b20gZWRnZSBvZiBldmVudCBjb250YWluZXJcblx0XHR9O1xuXHR9LFxuXG5cblx0LyogRm9yZWdyb3VuZCBFdmVudCBQb3NpdGlvbmluZyBVdGlsc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gR2l2ZW4gc2VnbWVudHMgdGhhdCBhcmUgYXNzdW1lZCB0byBhbGwgbGl2ZSBpbiB0aGUgKnNhbWUgY29sdW1uKixcblx0Ly8gY29tcHV0ZSB0aGVpciB2ZXJpY2FsL2hvcml6b250YWwgY29vcmRpbmF0ZXMgYW5kIGFzc2lnbiB0byB0aGVpciBlbGVtZW50cy5cblx0dXBkYXRlRmdTZWdDb29yZHM6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR0aGlzLmNvbXB1dGVTZWdWZXJ0aWNhbHMoc2Vncyk7IC8vIGhvcml6b250YWxzIHJlbGllcyBvbiB0aGlzXG5cdFx0dGhpcy5jb21wdXRlRmdTZWdIb3Jpem9udGFscyhzZWdzKTsgLy8gY29tcHV0ZSBob3Jpem9udGFsIGNvb3JkaW5hdGVzLCB6LWluZGV4J3MsIGFuZCByZW9yZGVyIHRoZSBhcnJheVxuXHRcdHRoaXMuYXNzaWduU2VnVmVydGljYWxzKHNlZ3MpO1xuXHRcdHRoaXMuYXNzaWduRmdTZWdIb3Jpem9udGFscyhzZWdzKTtcblx0fSxcblxuXG5cdC8vIEdpdmVuIGFuIGFycmF5IG9mIHNlZ21lbnRzIHRoYXQgYXJlIGFsbCBpbiB0aGUgc2FtZSBjb2x1bW4sIHNldHMgdGhlIGJhY2t3YXJkQ29vcmQgYW5kIGZvcndhcmRDb29yZCBvbiBlYWNoLlxuXHQvLyBOT1RFOiBBbHNvIHJlb3JkZXJzIHRoZSBnaXZlbiBhcnJheSBieSBkYXRlIVxuXHRjb21wdXRlRmdTZWdIb3Jpem9udGFsczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciBsZXZlbHM7XG5cdFx0dmFyIGxldmVsMDtcblx0XHR2YXIgaTtcblxuXHRcdHRoaXMuc29ydEV2ZW50U2VncyhzZWdzKTsgLy8gb3JkZXIgYnkgY2VydGFpbiBjcml0ZXJpYVxuXHRcdGxldmVscyA9IGJ1aWxkU2xvdFNlZ0xldmVscyhzZWdzKTtcblx0XHRjb21wdXRlRm9yd2FyZFNsb3RTZWdzKGxldmVscyk7XG5cblx0XHRpZiAoKGxldmVsMCA9IGxldmVsc1swXSkpIHtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxldmVsMC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb21wdXRlU2xvdFNlZ1ByZXNzdXJlcyhsZXZlbDBbaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGV2ZWwwLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuY29tcHV0ZUZnU2VnRm9yd2FyZEJhY2sobGV2ZWwwW2ldLCAwLCAwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxjdWxhdGUgc2VnLmZvcndhcmRDb29yZCBhbmQgc2VnLmJhY2t3YXJkQ29vcmQgZm9yIHRoZSBzZWdtZW50LCB3aGVyZSBib3RoIHZhbHVlcyByYW5nZVxuXHQvLyBmcm9tIDAgdG8gMS4gSWYgdGhlIGNhbGVuZGFyIGlzIGxlZnQtdG8tcmlnaHQsIHRoZSBzZWcuYmFja3dhcmRDb29yZCBtYXBzIHRvIFwibGVmdFwiIGFuZFxuXHQvLyBzZWcuZm9yd2FyZENvb3JkIG1hcHMgdG8gXCJyaWdodFwiICh2aWEgcGVyY2VudGFnZSkuIFZpY2UtdmVyc2EgaWYgdGhlIGNhbGVuZGFyIGlzIHJpZ2h0LXRvLWxlZnQuXG5cdC8vXG5cdC8vIFRoZSBzZWdtZW50IG1pZ2h0IGJlIHBhcnQgb2YgYSBcInNlcmllc1wiLCB3aGljaCBtZWFucyBjb25zZWN1dGl2ZSBzZWdtZW50cyB3aXRoIHRoZSBzYW1lIHByZXNzdXJlXG5cdC8vIHdobydzIHdpZHRoIGlzIHVua25vd24gdW50aWwgYW4gZWRnZSBoYXMgYmVlbiBoaXQuIGBzZXJpZXNCYWNrd2FyZFByZXNzdXJlYCBpcyB0aGUgbnVtYmVyIG9mXG5cdC8vIHNlZ21lbnRzIGJlaGluZCB0aGlzIG9uZSBpbiB0aGUgY3VycmVudCBzZXJpZXMsIGFuZCBgc2VyaWVzQmFja3dhcmRDb29yZGAgaXMgdGhlIHN0YXJ0aW5nXG5cdC8vIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHNlZ21lbnQgaW4gdGhlIHNlcmllcy5cblx0Y29tcHV0ZUZnU2VnRm9yd2FyZEJhY2s6IGZ1bmN0aW9uKHNlZywgc2VyaWVzQmFja3dhcmRQcmVzc3VyZSwgc2VyaWVzQmFja3dhcmRDb29yZCkge1xuXHRcdHZhciBmb3J3YXJkU2VncyA9IHNlZy5mb3J3YXJkU2Vncztcblx0XHR2YXIgaTtcblxuXHRcdGlmIChzZWcuZm9yd2FyZENvb3JkID09PSB1bmRlZmluZWQpIHsgLy8gbm90IGFscmVhZHkgY29tcHV0ZWRcblxuXHRcdFx0aWYgKCFmb3J3YXJkU2Vncy5sZW5ndGgpIHtcblxuXHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gZm9yd2FyZCBzZWdtZW50cywgdGhpcyBzZWdtZW50IHNob3VsZCBidXR0IHVwIGFnYWluc3QgdGhlIGVkZ2Vcblx0XHRcdFx0c2VnLmZvcndhcmRDb29yZCA9IDE7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblxuXHRcdFx0XHQvLyBzb3J0IGhpZ2hlc3QgcHJlc3N1cmUgZmlyc3Rcblx0XHRcdFx0dGhpcy5zb3J0Rm9yd2FyZFNlZ3MoZm9yd2FyZFNlZ3MpO1xuXG5cdFx0XHRcdC8vIHRoaXMgc2VnbWVudCdzIGZvcndhcmRDb29yZCB3aWxsIGJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgYmFja3dhcmRDb29yZCBvZiB0aGVcblx0XHRcdFx0Ly8gaGlnaGVzdC1wcmVzc3VyZSBmb3J3YXJkIHNlZ21lbnQuXG5cdFx0XHRcdHRoaXMuY29tcHV0ZUZnU2VnRm9yd2FyZEJhY2soZm9yd2FyZFNlZ3NbMF0sIHNlcmllc0JhY2t3YXJkUHJlc3N1cmUgKyAxLCBzZXJpZXNCYWNrd2FyZENvb3JkKTtcblx0XHRcdFx0c2VnLmZvcndhcmRDb29yZCA9IGZvcndhcmRTZWdzWzBdLmJhY2t3YXJkQ29vcmQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSB0aGUgYmFja3dhcmRDb29yZCBmcm9tIHRoZSBmb3J3YXJkQ29vcmQuIGNvbnNpZGVyIHRoZSBzZXJpZXNcblx0XHRcdHNlZy5iYWNrd2FyZENvb3JkID0gc2VnLmZvcndhcmRDb29yZCAtXG5cdFx0XHRcdChzZWcuZm9yd2FyZENvb3JkIC0gc2VyaWVzQmFja3dhcmRDb29yZCkgLyAvLyBhdmFpbGFibGUgd2lkdGggZm9yIHNlcmllc1xuXHRcdFx0XHQoc2VyaWVzQmFja3dhcmRQcmVzc3VyZSArIDEpOyAvLyAjIG9mIHNlZ21lbnRzIGluIHRoZSBzZXJpZXNcblxuXHRcdFx0Ly8gdXNlIHRoaXMgc2VnbWVudCdzIGNvb3JkaW5hdGVzIHRvIGNvbXB1dGVkIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGVzcy1wcmVzc3VyaXplZFxuXHRcdFx0Ly8gZm9yd2FyZCBzZWdtZW50c1xuXHRcdFx0Zm9yIChpPTA7IGk8Zm9yd2FyZFNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5jb21wdXRlRmdTZWdGb3J3YXJkQmFjayhmb3J3YXJkU2Vnc1tpXSwgMCwgc2VnLmZvcndhcmRDb29yZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0c29ydEZvcndhcmRTZWdzOiBmdW5jdGlvbihmb3J3YXJkU2Vncykge1xuXHRcdGZvcndhcmRTZWdzLnNvcnQocHJveHkodGhpcywgJ2NvbXBhcmVGb3J3YXJkU2VncycpKTtcblx0fSxcblxuXG5cdC8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGljaCBmb3J3YXJkIHNlZ21lbnQgdG8gcmVseSBvbiBtb3JlIHdoZW4gY29tcHV0aW5nIGNvb3JkaW5hdGVzLlxuXHRjb21wYXJlRm9yd2FyZFNlZ3M6IGZ1bmN0aW9uKHNlZzEsIHNlZzIpIHtcblx0XHQvLyBwdXQgaGlnaGVyLXByZXNzdXJlIGZpcnN0XG5cdFx0cmV0dXJuIHNlZzIuZm9yd2FyZFByZXNzdXJlIC0gc2VnMS5mb3J3YXJkUHJlc3N1cmUgfHxcblx0XHRcdC8vIHB1dCBzZWdtZW50cyB0aGF0IGFyZSBjbG9zZXIgdG8gaW5pdGlhbCBlZGdlIGZpcnN0IChhbmQgZmF2b3Igb25lcyB3aXRoIG5vIGNvb3JkcyB5ZXQpXG5cdFx0XHQoc2VnMS5iYWNrd2FyZENvb3JkIHx8IDApIC0gKHNlZzIuYmFja3dhcmRDb29yZCB8fCAwKSB8fFxuXHRcdFx0Ly8gZG8gbm9ybWFsIHNvcnRpbmcuLi5cblx0XHRcdHRoaXMuY29tcGFyZUV2ZW50U2VncyhzZWcxLCBzZWcyKTtcblx0fSxcblxuXG5cdC8vIEdpdmVuIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudHMgdGhhdCBoYXZlIGFscmVhZHkgaGFkIHRoZWlyIHBvc2l0aW9uIGNvb3JkaW5hdGVzIGNvbXB1dGVkLFxuXHQvLyBhc3NpZ25zIHBvc2l0aW9uLXJlbGF0ZWQgQ1NTIHZhbHVlcyB0byB0aGVpciBlbGVtZW50cy5cblx0YXNzaWduRmdTZWdIb3Jpem9udGFsczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciBpLCBzZWc7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnID0gc2Vnc1tpXTtcblx0XHRcdHNlZy5lbC5jc3ModGhpcy5nZW5lcmF0ZUZnU2VnSG9yaXpvbnRhbENzcyhzZWcpKTtcblxuXHRcdFx0Ly8gaWYgdGhlIGhlaWdodCBpcyBzaG9ydCwgYWRkIGEgY2xhc3NOYW1lIGZvciBhbHRlcm5hdGUgc3R5bGluZ1xuXHRcdFx0aWYgKHNlZy5ib3R0b20gLSBzZWcudG9wIDwgMzApIHtcblx0XHRcdFx0c2VnLmVsLmFkZENsYXNzKCdmYy1zaG9ydCcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyBhbiBvYmplY3Qgd2l0aCBDU1MgcHJvcGVydGllcy92YWx1ZXMgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBhbiBldmVudCBzZWdtZW50IGVsZW1lbnQuXG5cdC8vIENvbnRhaW5zIGltcG9ydGFudCBwb3NpdGlvbmluZy1yZWxhdGVkIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBhbnkgZXZlbnQgZWxlbWVudCwgY3VzdG9taXplZCBvciBub3QuXG5cdGdlbmVyYXRlRmdTZWdIb3Jpem9udGFsQ3NzOiBmdW5jdGlvbihzZWcpIHtcblx0XHR2YXIgc2hvdWxkT3ZlcmxhcCA9IHRoaXMudmlldy5vcHQoJ3Nsb3RFdmVudE92ZXJsYXAnKTtcblx0XHR2YXIgYmFja3dhcmRDb29yZCA9IHNlZy5iYWNrd2FyZENvb3JkOyAvLyB0aGUgbGVmdCBzaWRlIGlmIExUUi4gdGhlIHJpZ2h0IHNpZGUgaWYgUlRMLiBmbG9hdGluZy1wb2ludFxuXHRcdHZhciBmb3J3YXJkQ29vcmQgPSBzZWcuZm9yd2FyZENvb3JkOyAvLyB0aGUgcmlnaHQgc2lkZSBpZiBMVFIuIHRoZSBsZWZ0IHNpZGUgaWYgUlRMLiBmbG9hdGluZy1wb2ludFxuXHRcdHZhciBwcm9wcyA9IHRoaXMuZ2VuZXJhdGVTZWdWZXJ0aWNhbENzcyhzZWcpOyAvLyBnZXQgdG9wL2JvdHRvbSBmaXJzdFxuXHRcdHZhciBsZWZ0OyAvLyBhbW91bnQgb2Ygc3BhY2UgZnJvbSBsZWZ0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXG5cdFx0dmFyIHJpZ2h0OyAvLyBhbW91bnQgb2Ygc3BhY2UgZnJvbSByaWdodCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxuXG5cdFx0aWYgKHNob3VsZE92ZXJsYXApIHtcblx0XHRcdC8vIGRvdWJsZSB0aGUgd2lkdGgsIGJ1dCBkb24ndCBnbyBiZXlvbmQgdGhlIG1heGltdW0gZm9yd2FyZCBjb29yZGluYXRlICgxLjApXG5cdFx0XHRmb3J3YXJkQ29vcmQgPSBNYXRoLm1pbigxLCBiYWNrd2FyZENvb3JkICsgKGZvcndhcmRDb29yZCAtIGJhY2t3YXJkQ29vcmQpICogMik7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaXNSVEwpIHtcblx0XHRcdGxlZnQgPSAxIC0gZm9yd2FyZENvb3JkO1xuXHRcdFx0cmlnaHQgPSBiYWNrd2FyZENvb3JkO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGxlZnQgPSBiYWNrd2FyZENvb3JkO1xuXHRcdFx0cmlnaHQgPSAxIC0gZm9yd2FyZENvb3JkO1xuXHRcdH1cblxuXHRcdHByb3BzLnpJbmRleCA9IHNlZy5sZXZlbCArIDE7IC8vIGNvbnZlcnQgZnJvbSAwLWJhc2UgdG8gMS1iYXNlZFxuXHRcdHByb3BzLmxlZnQgPSBsZWZ0ICogMTAwICsgJyUnO1xuXHRcdHByb3BzLnJpZ2h0ID0gcmlnaHQgKiAxMDAgKyAnJSc7XG5cblx0XHRpZiAoc2hvdWxkT3ZlcmxhcCAmJiBzZWcuZm9yd2FyZFByZXNzdXJlKSB7XG5cdFx0XHQvLyBhZGQgcGFkZGluZyB0byB0aGUgZWRnZSBzbyB0aGF0IGZvcndhcmQgc3RhY2tlZCBldmVudHMgZG9uJ3QgY292ZXIgdGhlIHJlc2l6ZXIncyBpY29uXG5cdFx0XHRwcm9wc1t0aGlzLmlzUlRMID8gJ21hcmdpbkxlZnQnIDogJ21hcmdpblJpZ2h0J10gPSAxMCAqIDI7IC8vIDEwIGlzIGEgZ3Vlc3N0aW1hdGUgb2YgdGhlIGljb24ncyB3aWR0aFxuXHRcdH1cblxuXHRcdHJldHVybiBwcm9wcztcblx0fVxuXG59KTtcblxuXG4vLyBCdWlsZHMgYW4gYXJyYXkgb2Ygc2VnbWVudHMgXCJsZXZlbHNcIi4gVGhlIGZpcnN0IGxldmVsIHdpbGwgYmUgdGhlIGxlZnRtb3N0IHRpZXIgb2Ygc2VnbWVudHMgaWYgdGhlIGNhbGVuZGFyIGlzXG4vLyBsZWZ0LXRvLXJpZ2h0LCBvciB0aGUgcmlnaHRtb3N0IGlmIHRoZSBjYWxlbmRhciBpcyByaWdodC10by1sZWZ0LiBBc3N1bWVzIHRoZSBzZWdtZW50cyBhcmUgYWxyZWFkeSBvcmRlcmVkIGJ5IGRhdGUuXG5mdW5jdGlvbiBidWlsZFNsb3RTZWdMZXZlbHMoc2Vncykge1xuXHR2YXIgbGV2ZWxzID0gW107XG5cdHZhciBpLCBzZWc7XG5cdHZhciBqO1xuXG5cdGZvciAoaT0wOyBpPHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRzZWcgPSBzZWdzW2ldO1xuXG5cdFx0Ly8gZ28gdGhyb3VnaCBhbGwgdGhlIGxldmVscyBhbmQgc3RvcCBvbiB0aGUgZmlyc3QgbGV2ZWwgd2hlcmUgdGhlcmUgYXJlIG5vIGNvbGxpc2lvbnNcblx0XHRmb3IgKGo9MDsgajxsZXZlbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdGlmICghY29tcHV0ZVNsb3RTZWdDb2xsaXNpb25zKHNlZywgbGV2ZWxzW2pdKS5sZW5ndGgpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VnLmxldmVsID0gajtcblxuXHRcdChsZXZlbHNbal0gfHwgKGxldmVsc1tqXSA9IFtdKSkucHVzaChzZWcpO1xuXHR9XG5cblx0cmV0dXJuIGxldmVscztcbn1cblxuXG4vLyBGb3IgZXZlcnkgc2VnbWVudCwgZmlndXJlIG91dCB0aGUgb3RoZXIgc2VnbWVudHMgdGhhdCBhcmUgaW4gc3Vic2VxdWVudFxuLy8gbGV2ZWxzIHRoYXQgYWxzbyBvY2N1cHkgdGhlIHNhbWUgdmVydGljYWwgc3BhY2UuIEFjY3VtdWxhdGUgaW4gc2VnLmZvcndhcmRTZWdzXG5mdW5jdGlvbiBjb21wdXRlRm9yd2FyZFNsb3RTZWdzKGxldmVscykge1xuXHR2YXIgaSwgbGV2ZWw7XG5cdHZhciBqLCBzZWc7XG5cdHZhciBrO1xuXG5cdGZvciAoaT0wOyBpPGxldmVscy5sZW5ndGg7IGkrKykge1xuXHRcdGxldmVsID0gbGV2ZWxzW2ldO1xuXG5cdFx0Zm9yIChqPTA7IGo8bGV2ZWwubGVuZ3RoOyBqKyspIHtcblx0XHRcdHNlZyA9IGxldmVsW2pdO1xuXG5cdFx0XHRzZWcuZm9yd2FyZFNlZ3MgPSBbXTtcblx0XHRcdGZvciAoaz1pKzE7IGs8bGV2ZWxzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdGNvbXB1dGVTbG90U2VnQ29sbGlzaW9ucyhzZWcsIGxldmVsc1trXSwgc2VnLmZvcndhcmRTZWdzKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuXG4vLyBGaWd1cmUgb3V0IHdoaWNoIHBhdGggZm9yd2FyZCAodmlhIHNlZy5mb3J3YXJkU2VncykgcmVzdWx0cyBpbiB0aGUgbG9uZ2VzdCBwYXRoIHVudGlsXG4vLyB0aGUgZnVydGhlc3QgZWRnZSBpcyByZWFjaGVkLiBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGF0aCB3aWxsIGJlIHNlZy5mb3J3YXJkUHJlc3N1cmVcbmZ1bmN0aW9uIGNvbXB1dGVTbG90U2VnUHJlc3N1cmVzKHNlZykge1xuXHR2YXIgZm9yd2FyZFNlZ3MgPSBzZWcuZm9yd2FyZFNlZ3M7XG5cdHZhciBmb3J3YXJkUHJlc3N1cmUgPSAwO1xuXHR2YXIgaSwgZm9yd2FyZFNlZztcblxuXHRpZiAoc2VnLmZvcndhcmRQcmVzc3VyZSA9PT0gdW5kZWZpbmVkKSB7IC8vIG5vdCBhbHJlYWR5IGNvbXB1dGVkXG5cblx0XHRmb3IgKGk9MDsgaTxmb3J3YXJkU2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Zm9yd2FyZFNlZyA9IGZvcndhcmRTZWdzW2ldO1xuXG5cdFx0XHQvLyBmaWd1cmUgb3V0IHRoZSBjaGlsZCdzIG1heGltdW0gZm9yd2FyZCBwYXRoXG5cdFx0XHRjb21wdXRlU2xvdFNlZ1ByZXNzdXJlcyhmb3J3YXJkU2VnKTtcblxuXHRcdFx0Ly8gZWl0aGVyIHVzZSB0aGUgZXhpc3RpbmcgbWF4aW11bSwgb3IgdXNlIHRoZSBjaGlsZCdzIGZvcndhcmQgcHJlc3N1cmVcblx0XHRcdC8vIHBsdXMgb25lIChmb3IgdGhlIGZvcndhcmRTZWcgaXRzZWxmKVxuXHRcdFx0Zm9yd2FyZFByZXNzdXJlID0gTWF0aC5tYXgoXG5cdFx0XHRcdGZvcndhcmRQcmVzc3VyZSxcblx0XHRcdFx0MSArIGZvcndhcmRTZWcuZm9yd2FyZFByZXNzdXJlXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHNlZy5mb3J3YXJkUHJlc3N1cmUgPSBmb3J3YXJkUHJlc3N1cmU7XG5cdH1cbn1cblxuXG4vLyBGaW5kIGFsbCB0aGUgc2VnbWVudHMgaW4gYG90aGVyU2Vnc2AgdGhhdCB2ZXJ0aWNhbGx5IGNvbGxpZGUgd2l0aCBgc2VnYC5cbi8vIEFwcGVuZCBpbnRvIGFuIG9wdGlvbmFsbHktc3VwcGxpZWQgYHJlc3VsdHNgIGFycmF5IGFuZCByZXR1cm4uXG5mdW5jdGlvbiBjb21wdXRlU2xvdFNlZ0NvbGxpc2lvbnMoc2VnLCBvdGhlclNlZ3MsIHJlc3VsdHMpIHtcblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Zm9yICh2YXIgaT0wOyBpPG90aGVyU2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdGlmIChpc1Nsb3RTZWdDb2xsaXNpb24oc2VnLCBvdGhlclNlZ3NbaV0pKSB7XG5cdFx0XHRyZXN1bHRzLnB1c2gob3RoZXJTZWdzW2ldKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuXG4vLyBEbyB0aGVzZSBzZWdtZW50cyBvY2N1cHkgdGhlIHNhbWUgdmVydGljYWwgc3BhY2U/XG5mdW5jdGlvbiBpc1Nsb3RTZWdDb2xsaXNpb24oc2VnMSwgc2VnMikge1xuXHRyZXR1cm4gc2VnMS5ib3R0b20gPiBzZWcyLnRvcCAmJiBzZWcxLnRvcCA8IHNlZzIuYm90dG9tO1xufVxuXG47O1xuXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmcm9tIHdoaWNoIG90aGVyIHZpZXdzIGluaGVyaXQgZnJvbVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbnZhciBWaWV3ID0gRkMuVmlldyA9IE1vZGVsLmV4dGVuZCh7XG5cblx0dHlwZTogbnVsbCwgLy8gc3ViY2xhc3MnIHZpZXcgbmFtZSAoc3RyaW5nKVxuXHRuYW1lOiBudWxsLCAvLyBkZXByZWNhdGVkLiB1c2UgYHR5cGVgIGluc3RlYWRcblx0dGl0bGU6IG51bGwsIC8vIHRoZSB0ZXh0IHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gdGhlIGhlYWRlcidzIHRpdGxlXG5cblx0Y2FsZW5kYXI6IG51bGwsIC8vIG93bmVyIENhbGVuZGFyIG9iamVjdFxuXHR2aWV3U3BlYzogbnVsbCxcblx0b3B0aW9uczogbnVsbCwgLy8gaGFzaCBjb250YWluaW5nIGFsbCBvcHRpb25zLiBhbHJlYWR5IG1lcmdlZCB3aXRoIHZpZXctc3BlY2lmaWMtb3B0aW9uc1xuXHRlbDogbnVsbCwgLy8gdGhlIHZpZXcncyBjb250YWluaW5nIGVsZW1lbnQuIHNldCBieSBDYWxlbmRhclxuXG5cdHJlbmRlclF1ZXVlOiBudWxsLFxuXHRiYXRjaFJlbmRlckRlcHRoOiAwLFxuXHRpc0RhdGVzUmVuZGVyZWQ6IGZhbHNlLFxuXHRpc0V2ZW50c1JlbmRlcmVkOiBmYWxzZSxcblx0aXNCYXNlUmVuZGVyZWQ6IGZhbHNlLCAvLyByZWxhdGVkIHRvIHZpZXdSZW5kZXIvdmlld0Rlc3Ryb3kgdHJpZ2dlcnNcblxuXHRxdWV1ZWRTY3JvbGw6IG51bGwsXG5cblx0aXNSVEw6IGZhbHNlLFxuXHRpc1NlbGVjdGVkOiBmYWxzZSwgLy8gYm9vbGVhbiB3aGV0aGVyIGEgcmFuZ2Ugb2YgdGltZSBpcyB1c2VyLXNlbGVjdGVkIG9yIG5vdFxuXHRzZWxlY3RlZEV2ZW50OiBudWxsLFxuXG5cdGV2ZW50T3JkZXJTcGVjczogbnVsbCwgLy8gY3JpdGVyaWEgZm9yIG9yZGVyaW5nIGV2ZW50cyB3aGVuIHRoZXkgaGF2ZSBzYW1lIGRhdGUvdGltZVxuXG5cdC8vIGNsYXNzTmFtZXMgc3R5bGVkIGJ5IGpxdWkgdGhlbWVzXG5cdHdpZGdldEhlYWRlckNsYXNzOiBudWxsLFxuXHR3aWRnZXRDb250ZW50Q2xhc3M6IG51bGwsXG5cdGhpZ2hsaWdodFN0YXRlQ2xhc3M6IG51bGwsXG5cblx0Ly8gZm9yIGRhdGUgdXRpbHMsIGNvbXB1dGVkIGZyb20gb3B0aW9uc1xuXHRuZXh0RGF5VGhyZXNob2xkOiBudWxsLFxuXHRpc0hpZGRlbkRheUhhc2g6IG51bGwsXG5cblx0Ly8gbm93IGluZGljYXRvclxuXHRpc05vd0luZGljYXRvclJlbmRlcmVkOiBudWxsLFxuXHRpbml0aWFsTm93RGF0ZTogbnVsbCwgLy8gcmVzdWx0IGZpcnN0IGdldE5vdyBjYWxsXG5cdGluaXRpYWxOb3dRdWVyaWVkTXM6IG51bGwsIC8vIG1zIHRpbWUgdGhlIGdldE5vdyB3YXMgY2FsbGVkXG5cdG5vd0luZGljYXRvclRpbWVvdXRJRDogbnVsbCwgLy8gZm9yIHJlZnJlc2ggdGltaW5nIG9mIG5vdyBpbmRpY2F0b3Jcblx0bm93SW5kaWNhdG9ySW50ZXJ2YWxJRDogbnVsbCwgLy8gXCJcblxuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbihjYWxlbmRhciwgdmlld1NwZWMpIHtcblx0XHRNb2RlbC5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcblxuXHRcdHRoaXMuY2FsZW5kYXIgPSBjYWxlbmRhcjtcblx0XHR0aGlzLnZpZXdTcGVjID0gdmlld1NwZWM7XG5cblx0XHQvLyBzaG9ydGN1dHNcblx0XHR0aGlzLnR5cGUgPSB2aWV3U3BlYy50eXBlO1xuXHRcdHRoaXMub3B0aW9ucyA9IHZpZXdTcGVjLm9wdGlvbnM7XG5cblx0XHQvLyAubmFtZSBpcyBkZXByZWNhdGVkXG5cdFx0dGhpcy5uYW1lID0gdGhpcy50eXBlO1xuXG5cdFx0dGhpcy5uZXh0RGF5VGhyZXNob2xkID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCduZXh0RGF5VGhyZXNob2xkJykpO1xuXHRcdHRoaXMuaW5pdFRoZW1pbmdQcm9wcygpO1xuXHRcdHRoaXMuaW5pdEhpZGRlbkRheXMoKTtcblx0XHR0aGlzLmlzUlRMID0gdGhpcy5vcHQoJ2lzUlRMJyk7XG5cblx0XHR0aGlzLmV2ZW50T3JkZXJTcGVjcyA9IHBhcnNlRmllbGRTcGVjcyh0aGlzLm9wdCgnZXZlbnRPcmRlcicpKTtcblxuXHRcdHRoaXMucmVuZGVyUXVldWUgPSB0aGlzLmJ1aWxkUmVuZGVyUXVldWUoKTtcblx0XHR0aGlzLmluaXRBdXRvQmF0Y2hSZW5kZXIoKTtcblxuXHRcdHRoaXMuaW5pdGlhbGl6ZSgpO1xuXHR9LFxuXG5cblx0YnVpbGRSZW5kZXJRdWV1ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgcmVuZGVyUXVldWUgPSBuZXcgUmVuZGVyUXVldWUoe1xuXHRcdFx0ZXZlbnQ6IHRoaXMub3B0KCdldmVudFJlbmRlcldhaXQnKVxuXHRcdH0pO1xuXG5cdFx0cmVuZGVyUXVldWUub24oJ3N0YXJ0JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRfdGhpcy5mcmVlemVIZWlnaHQoKTtcblx0XHRcdF90aGlzLmFkZFNjcm9sbChfdGhpcy5xdWVyeVNjcm9sbCgpKTtcblx0XHR9KTtcblxuXHRcdHJlbmRlclF1ZXVlLm9uKCdzdG9wJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRfdGhpcy50aGF3SGVpZ2h0KCk7XG5cdFx0XHRfdGhpcy5wb3BTY3JvbGwoKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiByZW5kZXJRdWV1ZTtcblx0fSxcblxuXG5cdGluaXRBdXRvQmF0Y2hSZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHR0aGlzLm9uKCdiZWZvcmU6Y2hhbmdlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRfdGhpcy5zdGFydEJhdGNoUmVuZGVyKCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcblx0XHRcdF90aGlzLnN0b3BCYXRjaFJlbmRlcigpO1xuXHRcdH0pO1xuXHR9LFxuXG5cblx0c3RhcnRCYXRjaFJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCEodGhpcy5iYXRjaFJlbmRlckRlcHRoKyspKSB7XG5cdFx0XHR0aGlzLnJlbmRlclF1ZXVlLnBhdXNlKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0c3RvcEJhdGNoUmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoISgtLXRoaXMuYmF0Y2hSZW5kZXJEZXB0aCkpIHtcblx0XHRcdHRoaXMucmVuZGVyUXVldWUucmVzdW1lKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQSBnb29kIHBsYWNlIGZvciBzdWJjbGFzc2VzIHRvIGluaXRpYWxpemUgbWVtYmVyIHZhcmlhYmxlc1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFJldHJpZXZlcyBhbiBvcHRpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuXHRvcHQ6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zW25hbWVdO1xuXHR9LFxuXG5cblx0Ly8gVHJpZ2dlcnMgaGFuZGxlcnMgdGhhdCBhcmUgdmlldy1yZWxhdGVkLiBNb2RpZmllcyBhcmdzIGJlZm9yZSBwYXNzaW5nIHRvIGNhbGVuZGFyLlxuXHRwdWJsaWNseVRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUsIHRoaXNPYmopIHsgLy8gYXJndW1lbnRzIGJleW9uZCB0aGlzT2JqIGFyZSBwYXNzZWQgYWxvbmdcblx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xuXG5cdFx0cmV0dXJuIGNhbGVuZGFyLnB1YmxpY2x5VHJpZ2dlci5hcHBseShcblx0XHRcdGNhbGVuZGFyLFxuXHRcdFx0W25hbWUsIHRoaXNPYmogfHwgdGhpc10uY29uY2F0KFxuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLCAvLyBhcmd1bWVudHMgYmV5b25kIHRoaXNPYmpcblx0XHRcdFx0WyB0aGlzIF0gLy8gYWx3YXlzIG1ha2UgdGhlIGxhc3QgYXJndW1lbnQgYSByZWZlcmVuY2UgdG8gdGhlIHZpZXcuIFRPRE86IGRlcHJlY2F0ZVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblxuXHQvKiBUaXRsZSBhbmQgRGF0ZSBGb3JtYXR0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBTZXRzIHRoZSB2aWV3J3MgdGl0bGUgcHJvcGVydHkgdG8gdGhlIG1vc3QgdXBkYXRlZCBjb21wdXRlZCB2YWx1ZVxuXHR1cGRhdGVUaXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aXRsZSA9IHRoaXMuY29tcHV0ZVRpdGxlKCk7XG5cdFx0dGhpcy5jYWxlbmRhci5zZXRUb29sYmFyc1RpdGxlKHRoaXMudGl0bGUpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgd2hhdCB0aGUgdGl0bGUgYXQgdGhlIHRvcCBvZiB0aGUgY2FsZW5kYXIgc2hvdWxkIGJlIGZvciB0aGlzIHZpZXdcblx0Y29tcHV0ZVRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmFuZ2U7XG5cblx0XHQvLyBmb3Igdmlld3MgdGhhdCBzcGFuIGEgbGFyZ2UgdW5pdCBvZiB0aW1lLCBzaG93IHRoZSBwcm9wZXIgaW50ZXJ2YWwsIGlnbm9yaW5nIHN0cmF5IGRheXMgYmVmb3JlIGFuZCBhZnRlclxuXHRcdGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QodGhpcy5jdXJyZW50UmFuZ2VVbml0KSkge1xuXHRcdFx0cmFuZ2UgPSB0aGlzLmN1cnJlbnRSYW5nZTtcblx0XHR9XG5cdFx0ZWxzZSB7IC8vIGZvciBkYXkgdW5pdHMgb3Igc21hbGxlciwgdXNlIHRoZSBhY3R1YWwgZGF5IHJhbmdlXG5cdFx0XHRyYW5nZSA9IHRoaXMuYWN0aXZlUmFuZ2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZm9ybWF0UmFuZ2UoXG5cdFx0XHR7XG5cdFx0XHRcdC8vIGluIGNhc2UgY3VycmVudFJhbmdlIGhhcyBhIHRpbWUsIG1ha2Ugc3VyZSB0aW1lem9uZSBpcyBjb3JyZWN0XG5cdFx0XHRcdHN0YXJ0OiB0aGlzLmNhbGVuZGFyLmFwcGx5VGltZXpvbmUocmFuZ2Uuc3RhcnQpLFxuXHRcdFx0XHRlbmQ6IHRoaXMuY2FsZW5kYXIuYXBwbHlUaW1lem9uZShyYW5nZS5lbmQpXG5cdFx0XHR9LFxuXHRcdFx0dGhpcy5vcHQoJ3RpdGxlRm9ybWF0JykgfHwgdGhpcy5jb21wdXRlVGl0bGVGb3JtYXQoKSxcblx0XHRcdHRoaXMub3B0KCd0aXRsZVJhbmdlU2VwYXJhdG9yJylcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxuXHQvLyBBdHRlbXB0cyB0byBjb21wdXRlIHRoZSBtb3N0IGFwcHJvcHJpYXRlIGZvcm1hdCBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgd2l0aCBgdGl0bGVGb3JtYXRgLlxuXHRjb21wdXRlVGl0bGVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmN1cnJlbnRSYW5nZVVuaXQgPT0gJ3llYXInKSB7XG5cdFx0XHRyZXR1cm4gJ1lZWVknO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLmN1cnJlbnRSYW5nZVVuaXQgPT0gJ21vbnRoJykge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0KCdtb250aFllYXJGb3JtYXQnKTsgLy8gbGlrZSBcIlNlcHRlbWJlciAyMDE0XCJcblx0XHR9XG5cdFx0ZWxzZSBpZiAodGhpcy5jdXJyZW50UmFuZ2VBcygnZGF5cycpID4gMSkge1xuXHRcdFx0cmV0dXJuICdsbCc7IC8vIG11bHRpLWRheSByYW5nZS4gc2hvcnRlciwgbGlrZSBcIlNlcCA5IC0gMTAgMjAxNFwiXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICdMTCc7IC8vIG9uZSBkYXkuIGxvbmdlciwgbGlrZSBcIlNlcHRlbWJlciA5IDIwMTRcIlxuXHRcdH1cblx0fSxcblxuXG5cdC8vIFV0aWxpdHkgZm9yIGZvcm1hdHRpbmcgYSByYW5nZS4gQWNjZXB0cyBhIHJhbmdlIG9iamVjdCwgZm9ybWF0dGluZyBzdHJpbmcsIGFuZCBvcHRpb25hbCBzZXBhcmF0b3IuXG5cdC8vIERpc3BsYXlzIGFsbC1kYXkgcmFuZ2VzIG5hdHVyYWxseSwgd2l0aCBhbiBpbmNsdXNpdmUgZW5kLiBUYWtlcyB0aGUgY3VycmVudCBpc1JUTCBpbnRvIGFjY291bnQuXG5cdC8vIFRoZSB0aW1lem9uZXMgb2YgdGhlIGRhdGVzIHdpdGhpbiBgcmFuZ2VgIHdpbGwgYmUgcmVzcGVjdGVkLlxuXHRmb3JtYXRSYW5nZTogZnVuY3Rpb24ocmFuZ2UsIGZvcm1hdFN0ciwgc2VwYXJhdG9yKSB7XG5cdFx0dmFyIGVuZCA9IHJhbmdlLmVuZDtcblxuXHRcdGlmICghZW5kLmhhc1RpbWUoKSkgeyAvLyBhbGwtZGF5P1xuXHRcdFx0ZW5kID0gZW5kLmNsb25lKCkuc3VidHJhY3QoMSk7IC8vIGNvbnZlcnQgdG8gaW5jbHVzaXZlLiBsYXN0IG1zIG9mIHByZXZpb3VzIGRheVxuXHRcdH1cblxuXHRcdHJldHVybiBmb3JtYXRSYW5nZShyYW5nZS5zdGFydCwgZW5kLCBmb3JtYXRTdHIsIHNlcGFyYXRvciwgdGhpcy5vcHQoJ2lzUlRMJykpO1xuXHR9LFxuXG5cblx0Z2V0QWxsRGF5SHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0KCdhbGxEYXlIdG1sJykgfHwgaHRtbEVzY2FwZSh0aGlzLm9wdCgnYWxsRGF5VGV4dCcpKTtcblx0fSxcblxuXG5cdC8qIE5hdmlnYXRpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEdlbmVyYXRlcyBIVE1MIGZvciBhbiBhbmNob3IgdG8gYW5vdGhlciB2aWV3IGludG8gdGhlIGNhbGVuZGFyLlxuXHQvLyBXaWxsIGVpdGhlciBnZW5lcmF0ZSBhbiA8YT4gdGFnIG9yIGEgbm9uLWNsaWNrYWJsZSA8c3Bhbj4gdGFnLCBkZXBlbmRpbmcgb24gZW5hYmxlZCBzZXR0aW5ncy5cblx0Ly8gYGdvdG9PcHRpb25zYCBjYW4gZWl0aGVyIGJlIGEgbW9tZW50IGlucHV0LCBvciBhbiBvYmplY3Qgd2l0aCB0aGUgZm9ybTpcblx0Ly8geyBkYXRlLCB0eXBlLCBmb3JjZU9mZiB9XG5cdC8vIGB0eXBlYCBpcyBhIHZpZXctdHlwZSBsaWtlIFwiZGF5XCIgb3IgXCJ3ZWVrXCIuIGRlZmF1bHQgdmFsdWUgaXMgXCJkYXlcIi5cblx0Ly8gYGF0dHJzYCBhbmQgYGlubmVySHRtbGAgYXJlIHVzZSB0byBnZW5lcmF0ZSB0aGUgcmVzdCBvZiB0aGUgSFRNTCB0YWcuXG5cdGJ1aWxkR290b0FuY2hvckh0bWw6IGZ1bmN0aW9uKGdvdG9PcHRpb25zLCBhdHRycywgaW5uZXJIdG1sKSB7XG5cdFx0dmFyIGRhdGUsIHR5cGUsIGZvcmNlT2ZmO1xuXHRcdHZhciBmaW5hbE9wdGlvbnM7XG5cblx0XHRpZiAoJC5pc1BsYWluT2JqZWN0KGdvdG9PcHRpb25zKSkge1xuXHRcdFx0ZGF0ZSA9IGdvdG9PcHRpb25zLmRhdGU7XG5cdFx0XHR0eXBlID0gZ290b09wdGlvbnMudHlwZTtcblx0XHRcdGZvcmNlT2ZmID0gZ290b09wdGlvbnMuZm9yY2VPZmY7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZGF0ZSA9IGdvdG9PcHRpb25zOyAvLyBhIHNpbmdsZSBtb21lbnQgaW5wdXRcblx0XHR9XG5cdFx0ZGF0ZSA9IEZDLm1vbWVudChkYXRlKTsgLy8gaWYgYSBzdHJpbmcsIHBhcnNlIGl0XG5cblx0XHRmaW5hbE9wdGlvbnMgPSB7IC8vIGZvciBzZXJpYWxpemF0aW9uIGludG8gdGhlIGxpbmtcblx0XHRcdGRhdGU6IGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREJyksXG5cdFx0XHR0eXBlOiB0eXBlIHx8ICdkYXknXG5cdFx0fTtcblxuXHRcdGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpbm5lckh0bWwgPSBhdHRycztcblx0XHRcdGF0dHJzID0gbnVsbDtcblx0XHR9XG5cblx0XHRhdHRycyA9IGF0dHJzID8gJyAnICsgYXR0cnNUb1N0cihhdHRycykgOiAnJzsgLy8gd2lsbCBoYXZlIGEgbGVhZGluZyBzcGFjZVxuXHRcdGlubmVySHRtbCA9IGlubmVySHRtbCB8fCAnJztcblxuXHRcdGlmICghZm9yY2VPZmYgJiYgdGhpcy5vcHQoJ25hdkxpbmtzJykpIHtcblx0XHRcdHJldHVybiAnPGEnICsgYXR0cnMgK1xuXHRcdFx0XHQnIGRhdGEtZ290bz1cIicgKyBodG1sRXNjYXBlKEpTT04uc3RyaW5naWZ5KGZpbmFsT3B0aW9ucykpICsgJ1wiPicgK1xuXHRcdFx0XHRpbm5lckh0bWwgK1xuXHRcdFx0XHQnPC9hPic7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICc8c3BhbicgKyBhdHRycyArICc+JyArXG5cdFx0XHRcdGlubmVySHRtbCArXG5cdFx0XHRcdCc8L3NwYW4+Jztcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJpbmcgTm9uLWRhdGUtcmVsYXRlZCBDb250ZW50XG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHQvLyBTZXRzIHRoZSBjb250YWluZXIgZWxlbWVudCB0aGF0IHRoZSB2aWV3IHNob3VsZCByZW5kZXIgaW5zaWRlIG9mLCBkb2VzIGdsb2JhbCBET00tcmVsYXRlZCBpbml0aWFsaXphdGlvbnMsXG5cdC8vIGFuZCByZW5kZXJzIGFsbCB0aGUgbm9uLWRhdGUtcmVsYXRlZCBjb250ZW50IGluc2lkZS5cblx0c2V0RWxlbWVudDogZnVuY3Rpb24oZWwpIHtcblx0XHR0aGlzLmVsID0gZWw7XG5cdFx0dGhpcy5iaW5kR2xvYmFsSGFuZGxlcnMoKTtcblx0XHR0aGlzLmJpbmRCYXNlUmVuZGVySGFuZGxlcnMoKTtcblx0XHR0aGlzLnJlbmRlclNrZWxldG9uKCk7XG5cdH0sXG5cblxuXHQvLyBSZW1vdmVzIHRoZSB2aWV3J3MgY29udGFpbmVyIGVsZW1lbnQgZnJvbSB0aGUgRE9NLCBjbGVhcmluZyBhbnkgY29udGVudCBiZWZvcmVoYW5kLlxuXHQvLyBVbmRvZXMgYW55IG90aGVyIERPTS1yZWxhdGVkIGF0dGFjaG1lbnRzLlxuXHRyZW1vdmVFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVuc2V0RGF0ZSgpO1xuXHRcdHRoaXMudW5yZW5kZXJTa2VsZXRvbigpO1xuXG5cdFx0dGhpcy51bmJpbmRHbG9iYWxIYW5kbGVycygpO1xuXHRcdHRoaXMudW5iaW5kQmFzZVJlbmRlckhhbmRsZXJzKCk7XG5cblx0XHR0aGlzLmVsLnJlbW92ZSgpO1xuXHRcdC8vIE5PVEU6IGRvbid0IG51bGwtb3V0IHRoaXMuZWwgaW4gY2FzZSB0aGUgVmlldyB3YXMgZGVzdHJveWVkIHdpdGhpbiBhbiBBUEkgY2FsbGJhY2suXG5cdFx0Ly8gV2UgZG9uJ3QgbnVsbC1vdXQgdGhlIFZpZXcncyBvdGhlciBqUXVlcnkgZWxlbWVudCByZWZlcmVuY2VzIHVwb24gZGVzdHJveSxcblx0XHQvLyAgc28gd2Ugc2hvdWxkbid0IGtpbGwgdGhpcy5lbCBlaXRoZXIuXG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBiYXNpYyBzdHJ1Y3R1cmUgb2YgdGhlIHZpZXcgYmVmb3JlIGFueSBjb250ZW50IGlzIHJlbmRlcmVkXG5cdHJlbmRlclNrZWxldG9uOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyB0aGUgYmFzaWMgc3RydWN0dXJlIG9mIHRoZSB2aWV3XG5cdHVucmVuZGVyU2tlbGV0b246IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gRGF0ZSBTZXR0aW5nL1Vuc2V0dGluZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0c2V0RGF0ZTogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdHZhciBjdXJyZW50RGF0ZVByb2ZpbGUgPSB0aGlzLmdldCgnZGF0ZVByb2ZpbGUnKTtcblx0XHR2YXIgbmV3RGF0ZVByb2ZpbGUgPSB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGUoZGF0ZSwgbnVsbCwgdHJ1ZSk7IC8vIGZvcmNlVG9WYWxpZD10cnVlXG5cblx0XHRpZiAoXG5cdFx0XHQhY3VycmVudERhdGVQcm9maWxlIHx8XG5cdFx0XHQhaXNSYW5nZXNFcXVhbChjdXJyZW50RGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIG5ld0RhdGVQcm9maWxlLmFjdGl2ZVJhbmdlKVxuXHRcdCkge1xuXHRcdFx0dGhpcy5zZXQoJ2RhdGVQcm9maWxlJywgbmV3RGF0ZVByb2ZpbGUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXdEYXRlUHJvZmlsZS5kYXRlO1xuXHR9LFxuXG5cblx0dW5zZXREYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVuc2V0KCdkYXRlUHJvZmlsZScpO1xuXHR9LFxuXG5cblx0Ly8gRGF0ZSBSZW5kZXJpbmdcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdHJlcXVlc3REYXRlUmVuZGVyOiBmdW5jdGlvbihkYXRlUHJvZmlsZSkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHR0aGlzLnJlbmRlclF1ZXVlLnF1ZXVlKGZ1bmN0aW9uKCkge1xuXHRcdFx0X3RoaXMuZXhlY3V0ZURhdGVSZW5kZXIoZGF0ZVByb2ZpbGUpO1xuXHRcdH0sICdkYXRlJywgJ2luaXQnKTtcblx0fSxcblxuXG5cdHJlcXVlc3REYXRlVW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHR0aGlzLnJlbmRlclF1ZXVlLnF1ZXVlKGZ1bmN0aW9uKCkge1xuXHRcdFx0X3RoaXMuZXhlY3V0ZURhdGVVbnJlbmRlcigpO1xuXHRcdH0sICdkYXRlJywgJ2Rlc3Ryb3knKTtcblx0fSxcblxuXG5cdC8vIEV2ZW50IERhdGFcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdGZldGNoSW5pdGlhbEV2ZW50czogZnVuY3Rpb24oZGF0ZVByb2ZpbGUpIHtcblx0XHRyZXR1cm4gdGhpcy5jYWxlbmRhci5yZXF1ZXN0RXZlbnRzKFxuXHRcdFx0ZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2Uuc3RhcnQsXG5cdFx0XHRkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5lbmRcblx0XHQpO1xuXHR9LFxuXG5cblx0YmluZEV2ZW50Q2hhbmdlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLmNhbGVuZGFyLCAnZXZlbnRzUmVzZXQnLCB0aGlzLnJlc2V0RXZlbnRzKTtcblx0fSxcblxuXG5cdHVuYmluZEV2ZW50Q2hhbmdlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8odGhpcy5jYWxlbmRhciwgJ2V2ZW50c1Jlc2V0Jyk7XG5cdH0sXG5cblxuXHRzZXRFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdHRoaXMuc2V0KCdjdXJyZW50RXZlbnRzJywgZXZlbnRzKTtcblx0XHR0aGlzLnNldCgnaGFzRXZlbnRzJywgdHJ1ZSk7XG5cdH0sXG5cblxuXHR1bnNldEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnNldCgnY3VycmVudEV2ZW50cycpO1xuXHRcdHRoaXMudW5zZXQoJ2hhc0V2ZW50cycpO1xuXHR9LFxuXG5cblx0cmVzZXRFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdHRoaXMuc3RhcnRCYXRjaFJlbmRlcigpO1xuXHRcdHRoaXMudW5zZXRFdmVudHMoKTtcblx0XHR0aGlzLnNldEV2ZW50cyhldmVudHMpO1xuXHRcdHRoaXMuc3RvcEJhdGNoUmVuZGVyKCk7XG5cdH0sXG5cblxuXHQvLyBFdmVudCBSZW5kZXJpbmdcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdHJlcXVlc3RFdmVudHNSZW5kZXI6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHR0aGlzLnJlbmRlclF1ZXVlLnF1ZXVlKGZ1bmN0aW9uKCkge1xuXHRcdFx0X3RoaXMuZXhlY3V0ZUV2ZW50c1JlbmRlcihldmVudHMpO1xuXHRcdH0sICdldmVudCcsICdpbml0Jyk7XG5cdH0sXG5cblxuXHRyZXF1ZXN0RXZlbnRzVW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHR0aGlzLnJlbmRlclF1ZXVlLnF1ZXVlKGZ1bmN0aW9uKCkge1xuXHRcdFx0X3RoaXMuZXhlY3V0ZUV2ZW50c1VucmVuZGVyKCk7XG5cdFx0fSwgJ2V2ZW50JywgJ2Rlc3Ryb3knKTtcblx0fSxcblxuXG5cdC8vIERhdGUgSGlnaC1sZXZlbCBSZW5kZXJpbmdcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdC8vIGlmIGRhdGVQcm9maWxlIG5vdCBzcGVjaWZpZWQsIHVzZXMgY3VycmVudFxuXHRleGVjdXRlRGF0ZVJlbmRlcjogZnVuY3Rpb24oZGF0ZVByb2ZpbGUsIHNraXBTY3JvbGwpIHtcblxuXHRcdHRoaXMuc2V0RGF0ZVByb2ZpbGVGb3JSZW5kZXJpbmcoZGF0ZVByb2ZpbGUpO1xuXHRcdHRoaXMudXBkYXRlVGl0bGUoKTtcblx0XHR0aGlzLmNhbGVuZGFyLnVwZGF0ZVRvb2xiYXJCdXR0b25zKCk7XG5cblx0XHRpZiAodGhpcy5yZW5kZXIpIHtcblx0XHRcdHRoaXMucmVuZGVyKCk7IC8vIFRPRE86IGRlcHJlY2F0ZVxuXHRcdH1cblxuXHRcdHRoaXMucmVuZGVyRGF0ZXMoKTtcblx0XHR0aGlzLnVwZGF0ZVNpemUoKTtcblx0XHR0aGlzLnJlbmRlckJ1c2luZXNzSG91cnMoKTsgLy8gbWlnaHQgbmVlZCBjb29yZGluYXRlcywgc28gc2hvdWxkIGdvIGFmdGVyIHVwZGF0ZVNpemUoKVxuXHRcdHRoaXMuc3RhcnROb3dJbmRpY2F0b3IoKTtcblxuXHRcdGlmICghc2tpcFNjcm9sbCkge1xuXHRcdFx0dGhpcy5hZGRTY3JvbGwodGhpcy5jb21wdXRlSW5pdGlhbERhdGVTY3JvbGwoKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5pc0RhdGVzUmVuZGVyZWQgPSB0cnVlO1xuXHRcdHRoaXMudHJpZ2dlcignZGF0ZXNSZW5kZXJlZCcpO1xuXHR9LFxuXG5cblx0ZXhlY3V0ZURhdGVVbnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cblx0XHR0aGlzLnVuc2VsZWN0KCk7XG5cdFx0dGhpcy5zdG9wTm93SW5kaWNhdG9yKCk7XG5cblx0XHR0aGlzLnRyaWdnZXIoJ2JlZm9yZTpkYXRlc1VucmVuZGVyZWQnKTtcblxuXHRcdHRoaXMudW5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cdFx0dGhpcy51bnJlbmRlckRhdGVzKCk7XG5cblx0XHRpZiAodGhpcy5kZXN0cm95KSB7XG5cdFx0XHR0aGlzLmRlc3Ryb3koKTsgLy8gVE9ETzogZGVwcmVjYXRlXG5cdFx0fVxuXG5cdFx0dGhpcy5pc0RhdGVzUmVuZGVyZWQgPSBmYWxzZTtcblx0fSxcblxuXG5cdC8vIERhdGUgTG93LWxldmVsIFJlbmRlcmluZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gZGF0ZS1jZWxsIGNvbnRlbnQgb25seVxuXHRyZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBkYXRlLWNlbGwgY29udGVudCBvbmx5XG5cdHVucmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG5cdH0sXG5cblxuXHQvLyBEZXRlcm1pbmcgd2hlbiB0aGUgXCJtZWF0XCIgb2YgdGhlIHZpZXcgaXMgcmVuZGVyZWQgKGFrYSB0aGUgYmFzZSlcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdGJpbmRCYXNlUmVuZGVySGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHR0aGlzLm9uKCdkYXRlc1JlbmRlcmVkLmJhc2VIYW5kbGVyJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRfdGhpcy5vbkJhc2VSZW5kZXIoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMub24oJ2JlZm9yZTpkYXRlc1VucmVuZGVyZWQuYmFzZUhhbmRsZXInLCBmdW5jdGlvbigpIHtcblx0XHRcdF90aGlzLm9uQmVmb3JlQmFzZVVucmVuZGVyKCk7XG5cdFx0fSk7XG5cdH0sXG5cblxuXHR1bmJpbmRCYXNlUmVuZGVySGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMub2ZmKCcuYmFzZUhhbmRsZXInKTtcblx0fSxcblxuXG5cdG9uQmFzZVJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5hcHBseVNjcmVlblN0YXRlKCk7XG5cdFx0dGhpcy5wdWJsaWNseVRyaWdnZXIoJ3ZpZXdSZW5kZXInLCB0aGlzLCB0aGlzLCB0aGlzLmVsKTtcblx0fSxcblxuXG5cdG9uQmVmb3JlQmFzZVVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmFwcGx5U2NyZWVuU3RhdGUoKTtcblx0XHR0aGlzLnB1YmxpY2x5VHJpZ2dlcigndmlld0Rlc3Ryb3knLCB0aGlzLCB0aGlzLCB0aGlzLmVsKTtcblx0fSxcblxuXG5cdC8vIE1pc2MgdmlldyByZW5kZXJpbmcgdXRpbHNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdC8vIEJpbmRzIERPTSBoYW5kbGVycyB0byBlbGVtZW50cyB0aGF0IHJlc2lkZSBvdXRzaWRlIHRoZSB2aWV3IGNvbnRhaW5lciwgc3VjaCBhcyB0aGUgZG9jdW1lbnRcblx0YmluZEdsb2JhbEhhbmRsZXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmxpc3RlblRvKEdsb2JhbEVtaXR0ZXIuZ2V0KCksIHtcblx0XHRcdHRvdWNoc3RhcnQ6IHRoaXMucHJvY2Vzc1Vuc2VsZWN0LFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLmhhbmRsZURvY3VtZW50TW91c2Vkb3duXG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvLyBVbmJpbmRzIERPTSBoYW5kbGVycyBmcm9tIGVsZW1lbnRzIHRoYXQgcmVzaWRlIG91dHNpZGUgdGhlIHZpZXcgY29udGFpbmVyXG5cdHVuYmluZEdsb2JhbEhhbmRsZXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3BMaXN0ZW5pbmdUbyhHbG9iYWxFbWl0dGVyLmdldCgpKTtcblx0fSxcblxuXG5cdC8vIEluaXRpYWxpemVzIGludGVybmFsIHZhcmlhYmxlcyByZWxhdGVkIHRvIHRoZW1pbmdcblx0aW5pdFRoZW1pbmdQcm9wczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRtID0gdGhpcy5vcHQoJ3RoZW1lJykgPyAndWknIDogJ2ZjJztcblxuXHRcdHRoaXMud2lkZ2V0SGVhZGVyQ2xhc3MgPSB0bSArICctd2lkZ2V0LWhlYWRlcic7XG5cdFx0dGhpcy53aWRnZXRDb250ZW50Q2xhc3MgPSB0bSArICctd2lkZ2V0LWNvbnRlbnQnO1xuXHRcdHRoaXMuaGlnaGxpZ2h0U3RhdGVDbGFzcyA9IHRtICsgJy1zdGF0ZS1oaWdobGlnaHQnO1xuXHR9LFxuXG5cblx0LyogQnVzaW5lc3MgSG91cnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYnVzaW5lc3MtaG91cnMgb250byB0aGUgdmlldy4gQXNzdW1lcyB1cGRhdGVTaXplIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkLlxuXHRyZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBwcmV2aW91c2x5LXJlbmRlcmVkIGJ1c2luZXNzLWhvdXJzXG5cdHVucmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvKiBOb3cgSW5kaWNhdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBJbW1lZGlhdGVseSByZW5kZXIgdGhlIGN1cnJlbnQgdGltZSBpbmRpY2F0b3IgYW5kIGJlZ2lucyByZS1yZW5kZXJpbmcgaXQgYXQgYW4gaW50ZXJ2YWwsXG5cdC8vIHdoaWNoIGlzIGRlZmluZWQgYnkgdGhpcy5nZXROb3dJbmRpY2F0b3JVbml0KCkuXG5cdC8vIFRPRE86IHNvbWVob3cgZG8gdGhpcyBmb3IgdGhlIGN1cnJlbnQgd2hvbGUgZGF5J3MgYmFja2dyb3VuZCB0b29cblx0c3RhcnROb3dJbmRpY2F0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHVuaXQ7XG5cdFx0dmFyIHVwZGF0ZTtcblx0XHR2YXIgZGVsYXk7IC8vIG1zIHdhaXQgdmFsdWVcblxuXHRcdGlmICh0aGlzLm9wdCgnbm93SW5kaWNhdG9yJykpIHtcblx0XHRcdHVuaXQgPSB0aGlzLmdldE5vd0luZGljYXRvclVuaXQoKTtcblx0XHRcdGlmICh1bml0KSB7XG5cdFx0XHRcdHVwZGF0ZSA9IHByb3h5KHRoaXMsICd1cGRhdGVOb3dJbmRpY2F0b3InKTsgLy8gYmluZCB0byBgdGhpc2BcblxuXHRcdFx0XHR0aGlzLmluaXRpYWxOb3dEYXRlID0gdGhpcy5jYWxlbmRhci5nZXROb3coKTtcblx0XHRcdFx0dGhpcy5pbml0aWFsTm93UXVlcmllZE1zID0gK25ldyBEYXRlKCk7XG5cdFx0XHRcdHRoaXMucmVuZGVyTm93SW5kaWNhdG9yKHRoaXMuaW5pdGlhbE5vd0RhdGUpO1xuXHRcdFx0XHR0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIHdhaXQgdW50aWwgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBpbnRlcnZhbFxuXHRcdFx0XHRkZWxheSA9IHRoaXMuaW5pdGlhbE5vd0RhdGUuY2xvbmUoKS5zdGFydE9mKHVuaXQpLmFkZCgxLCB1bml0KSAtIHRoaXMuaW5pdGlhbE5vd0RhdGU7XG5cdFx0XHRcdHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRfdGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBudWxsO1xuXHRcdFx0XHRcdHVwZGF0ZSgpO1xuXHRcdFx0XHRcdGRlbGF5ID0gK21vbWVudC5kdXJhdGlvbigxLCB1bml0KTtcblx0XHRcdFx0XHRkZWxheSA9IE1hdGgubWF4KDEwMCwgZGVsYXkpOyAvLyBwcmV2ZW50IHRvbyBmcmVxdWVudFxuXHRcdFx0XHRcdF90aGlzLm5vd0luZGljYXRvckludGVydmFsSUQgPSBzZXRJbnRlcnZhbCh1cGRhdGUsIGRlbGF5KTsgLy8gdXBkYXRlIGV2ZXJ5IGludGVydmFsXG5cdFx0XHRcdH0sIGRlbGF5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyByZXJlbmRlcnMgdGhlIG5vdyBpbmRpY2F0b3IsIGNvbXB1dGluZyB0aGUgbmV3IGN1cnJlbnQgdGltZSBmcm9tIHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGhhcyBwYXNzZWRcblx0Ly8gc2luY2UgdGhlIGluaXRpYWwgZ2V0Tm93IGNhbGwuXG5cdHVwZGF0ZU5vd0luZGljYXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaXNOb3dJbmRpY2F0b3JSZW5kZXJlZCkge1xuXHRcdFx0dGhpcy51bnJlbmRlck5vd0luZGljYXRvcigpO1xuXHRcdFx0dGhpcy5yZW5kZXJOb3dJbmRpY2F0b3IoXG5cdFx0XHRcdHRoaXMuaW5pdGlhbE5vd0RhdGUuY2xvbmUoKS5hZGQobmV3IERhdGUoKSAtIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcykgLy8gYWRkIG1zXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEltbWVkaWF0ZWx5IHVucmVuZGVycyB0aGUgdmlldydzIGN1cnJlbnQgdGltZSBpbmRpY2F0b3IgYW5kIHN0b3BzIGFueSByZS1yZW5kZXJpbmcgdGltZXJzLlxuXHQvLyBXb24ndCBjYXVzZSBzaWRlIGVmZmVjdHMgaWYgaW5kaWNhdG9yIGlzbid0IHJlbmRlcmVkLlxuXHRzdG9wTm93SW5kaWNhdG9yOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkKSB7XG5cblx0XHRcdGlmICh0aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQpO1xuXHRcdFx0XHR0aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLm5vd0luZGljYXRvckludGVydmFsSUQpO1xuXHRcdFx0XHR0aGlzLm5vd0luZGljYXRvckludGVydmFsSUQgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnVucmVuZGVyTm93SW5kaWNhdG9yKCk7XG5cdFx0XHR0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHVuaXQsIGxpa2UgJ3NlY29uZCcgb3IgJ21pbnV0ZScgdGhhdCBkZWZpbmVkIGhvdyBvZnRlbiB0aGUgY3VycmVudCB0aW1lIGluZGljYXRvclxuXHQvLyBzaG91bGQgYmUgcmVmcmVzaGVkLiBJZiBzb21ldGhpbmcgZmFsc3kgaXMgcmV0dXJuZWQsIG5vIHRpbWUgaW5kaWNhdG9yIGlzIHJlbmRlcmVkIGF0IGFsbC5cblx0Z2V0Tm93SW5kaWNhdG9yVW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIGEgY3VycmVudCB0aW1lIGluZGljYXRvciBhdCB0aGUgZ2l2ZW4gZGF0ZXRpbWVcblx0cmVuZGVyTm93SW5kaWNhdG9yOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBVbmRvZXMgdGhlIHJlbmRlcmluZyBhY3Rpb25zIGZyb20gcmVuZGVyTm93SW5kaWNhdG9yXG5cdHVucmVuZGVyTm93SW5kaWNhdG9yOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8qIERpbWVuc2lvbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlZnJlc2hlcyBhbnl0aGluZyBkZXBlbmRhbnQgdXBvbiBzaXppbmcgb2YgdGhlIGNvbnRhaW5lciBlbGVtZW50IG9mIHRoZSBncmlkXG5cdHVwZGF0ZVNpemU6IGZ1bmN0aW9uKGlzUmVzaXplKSB7XG5cdFx0dmFyIHNjcm9sbDtcblxuXHRcdGlmIChpc1Jlc2l6ZSkge1xuXHRcdFx0c2Nyb2xsID0gdGhpcy5xdWVyeVNjcm9sbCgpO1xuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlSGVpZ2h0KGlzUmVzaXplKTtcblx0XHR0aGlzLnVwZGF0ZVdpZHRoKGlzUmVzaXplKTtcblx0XHR0aGlzLnVwZGF0ZU5vd0luZGljYXRvcigpO1xuXG5cdFx0aWYgKGlzUmVzaXplKSB7XG5cdFx0XHR0aGlzLmFwcGx5U2Nyb2xsKHNjcm9sbCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmVmcmVzaGVzIHRoZSBob3Jpem9udGFsIGRpbWVuc2lvbnMgb2YgdGhlIGNhbGVuZGFyXG5cdHVwZGF0ZVdpZHRoOiBmdW5jdGlvbihpc1Jlc2l6ZSkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gUmVmcmVzaGVzIHRoZSB2ZXJ0aWNhbCBkaW1lbnNpb25zIG9mIHRoZSBjYWxlbmRhclxuXHR1cGRhdGVIZWlnaHQ6IGZ1bmN0aW9uKGlzUmVzaXplKSB7XG5cdFx0dmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjsgLy8gd2UgcG9sbCB0aGUgY2FsZW5kYXIgZm9yIGhlaWdodCBpbmZvcm1hdGlvblxuXG5cdFx0dGhpcy5zZXRIZWlnaHQoXG5cdFx0XHRjYWxlbmRhci5nZXRTdWdnZXN0ZWRWaWV3SGVpZ2h0KCksXG5cdFx0XHRjYWxlbmRhci5pc0hlaWdodEF1dG8oKVxuXHRcdCk7XG5cdH0sXG5cblxuXHQvLyBVcGRhdGVzIHRoZSB2ZXJ0aWNhbCBkaW1lbnNpb25zIG9mIHRoZSBjYWxlbmRhciB0byB0aGUgc3BlY2lmaWVkIGhlaWdodC5cblx0Ly8gaWYgYGlzQXV0b2AgaXMgc2V0IHRvIHRydWUsIGhlaWdodCBiZWNvbWVzIG1lcmVseSBhIHN1Z2dlc3Rpb24gYW5kIHRoZSB2aWV3IHNob3VsZCB1c2UgaXRzIFwibmF0dXJhbFwiIGhlaWdodC5cblx0c2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQsIGlzQXV0bykge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogU2Nyb2xsZXJcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdGFkZEZvcmNlZFNjcm9sbDogZnVuY3Rpb24oc2Nyb2xsKSB7XG5cdFx0dGhpcy5hZGRTY3JvbGwoXG5cdFx0XHQkLmV4dGVuZChzY3JvbGwsIHsgaXNGb3JjZWQ6IHRydWUgfSlcblx0XHQpO1xuXHR9LFxuXG5cblx0YWRkU2Nyb2xsOiBmdW5jdGlvbihzY3JvbGwpIHtcblx0XHR2YXIgcXVldWVkU2Nyb2xsID0gdGhpcy5xdWV1ZWRTY3JvbGwgfHwgKHRoaXMucXVldWVkU2Nyb2xsID0ge30pO1xuXG5cdFx0aWYgKCFxdWV1ZWRTY3JvbGwuaXNGb3JjZWQpIHtcblx0XHRcdCQuZXh0ZW5kKHF1ZXVlZFNjcm9sbCwgc2Nyb2xsKTtcblx0XHR9XG5cdH0sXG5cblxuXHRwb3BTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYXBwbHlRdWV1ZWRTY3JvbGwoKTtcblx0XHR0aGlzLnF1ZXVlZFNjcm9sbCA9IG51bGw7XG5cdH0sXG5cblxuXHRhcHBseVF1ZXVlZFNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMucXVldWVkU2Nyb2xsKSB7XG5cdFx0XHR0aGlzLmFwcGx5U2Nyb2xsKHRoaXMucXVldWVkU2Nyb2xsKTtcblx0XHR9XG5cdH0sXG5cblxuXHRxdWVyeVNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjcm9sbCA9IHt9O1xuXG5cdFx0aWYgKHRoaXMuaXNEYXRlc1JlbmRlcmVkKSB7XG5cdFx0XHQkLmV4dGVuZChzY3JvbGwsIHRoaXMucXVlcnlEYXRlU2Nyb2xsKCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzY3JvbGw7XG5cdH0sXG5cblxuXHRhcHBseVNjcm9sbDogZnVuY3Rpb24oc2Nyb2xsKSB7XG5cdFx0aWYgKHRoaXMuaXNEYXRlc1JlbmRlcmVkKSB7XG5cdFx0XHR0aGlzLmFwcGx5RGF0ZVNjcm9sbChzY3JvbGwpO1xuXHRcdH1cblx0fSxcblxuXG5cdGNvbXB1dGVJbml0aWFsRGF0ZVNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHt9OyAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHRxdWVyeURhdGVTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7fTsgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0YXBwbHlEYXRlU2Nyb2xsOiBmdW5jdGlvbihzY3JvbGwpIHtcblx0XHQ7IC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8qIEhlaWdodCBGcmVlemluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0ZnJlZXplSGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNhbGVuZGFyLmZyZWV6ZUNvbnRlbnRIZWlnaHQoKTtcblx0fSxcblxuXG5cdHRoYXdIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY2FsZW5kYXIudGhhd0NvbnRlbnRIZWlnaHQoKTtcblx0fSxcblxuXG5cdC8vIEV2ZW50IEhpZ2gtbGV2ZWwgUmVuZGVyaW5nXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRleGVjdXRlRXZlbnRzUmVuZGVyOiBmdW5jdGlvbihldmVudHMpIHtcblx0XHR0aGlzLnJlbmRlckV2ZW50cyhldmVudHMpO1xuXHRcdHRoaXMuaXNFdmVudHNSZW5kZXJlZCA9IHRydWU7XG5cblx0XHR0aGlzLm9uRXZlbnRzUmVuZGVyKCk7XG5cdH0sXG5cblxuXHRleGVjdXRlRXZlbnRzVW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMub25CZWZvcmVFdmVudHNVbnJlbmRlcigpO1xuXG5cdFx0aWYgKHRoaXMuZGVzdHJveUV2ZW50cykge1xuXHRcdFx0dGhpcy5kZXN0cm95RXZlbnRzKCk7IC8vIFRPRE86IGRlcHJlY2F0ZVxuXHRcdH1cblxuXHRcdHRoaXMudW5yZW5kZXJFdmVudHMoKTtcblx0XHR0aGlzLmlzRXZlbnRzUmVuZGVyZWQgPSBmYWxzZTtcblx0fSxcblxuXG5cdC8vIEV2ZW50IFJlbmRlcmluZyBUcmlnZ2Vyc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gU2lnbmFscyB0aGF0IGFsbCBldmVudHMgaGF2ZSBiZWVuIHJlbmRlcmVkXG5cdG9uRXZlbnRzUmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmFwcGx5U2NyZWVuU3RhdGUoKTtcblxuXHRcdHRoaXMucmVuZGVyZWRFdmVudFNlZ0VhY2goZnVuY3Rpb24oc2VnKSB7XG5cdFx0XHR0aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnRBZnRlclJlbmRlcicsIHNlZy5ldmVudCwgc2VnLmV2ZW50LCBzZWcuZWwpO1xuXHRcdH0pO1xuXHRcdHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudEFmdGVyQWxsUmVuZGVyJyk7XG5cdH0sXG5cblxuXHQvLyBTaWduYWxzIHRoYXQgYWxsIGV2ZW50IGVsZW1lbnRzIGFyZSBhYm91dCB0byBiZSByZW1vdmVkXG5cdG9uQmVmb3JlRXZlbnRzVW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYXBwbHlTY3JlZW5TdGF0ZSgpO1xuXG5cdFx0dGhpcy5yZW5kZXJlZEV2ZW50U2VnRWFjaChmdW5jdGlvbihzZWcpIHtcblx0XHRcdHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudERlc3Ryb3knLCBzZWcuZXZlbnQsIHNlZy5ldmVudCwgc2VnLmVsKTtcblx0XHR9KTtcblx0fSxcblxuXG5cdGFwcGx5U2NyZWVuU3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGhhd0hlaWdodCgpO1xuXHRcdHRoaXMuZnJlZXplSGVpZ2h0KCk7XG5cdFx0dGhpcy5hcHBseVF1ZXVlZFNjcm9sbCgpO1xuXHR9LFxuXG5cblx0Ly8gRXZlbnQgTG93LWxldmVsIFJlbmRlcmluZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gUmVuZGVycyB0aGUgZXZlbnRzIG9udG8gdGhlIHZpZXcuXG5cdHJlbmRlckV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBSZW1vdmVzIGV2ZW50IGVsZW1lbnRzIGZyb20gdGhlIHZpZXcuXG5cdHVucmVuZGVyRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIEV2ZW50IFJlbmRlcmluZyBVdGlsc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gR2l2ZW4gYW4gZXZlbnQgYW5kIHRoZSBkZWZhdWx0IGVsZW1lbnQgdXNlZCBmb3IgcmVuZGVyaW5nLCByZXR1cm5zIHRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGFjdHVhbGx5IGJlIHVzZWQuXG5cdC8vIEJhc2ljYWxseSBydW5zIGV2ZW50cyBhbmQgZWxlbWVudHMgdGhyb3VnaCB0aGUgZXZlbnRSZW5kZXIgaG9vay5cblx0cmVzb2x2ZUV2ZW50RWw6IGZ1bmN0aW9uKGV2ZW50LCBlbCkge1xuXHRcdHZhciBjdXN0b20gPSB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnRSZW5kZXInLCBldmVudCwgZXZlbnQsIGVsKTtcblxuXHRcdGlmIChjdXN0b20gPT09IGZhbHNlKSB7IC8vIG1lYW5zIGRvbid0IHJlbmRlciBhdCBhbGxcblx0XHRcdGVsID0gbnVsbDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY3VzdG9tICYmIGN1c3RvbSAhPT0gdHJ1ZSkge1xuXHRcdFx0ZWwgPSAkKGN1c3RvbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsO1xuXHR9LFxuXG5cblx0Ly8gSGlkZXMgYWxsIHJlbmRlcmVkIGV2ZW50IHNlZ21lbnRzIGxpbmtlZCB0byB0aGUgZ2l2ZW4gZXZlbnRcblx0c2hvd0V2ZW50OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHRoaXMucmVuZGVyZWRFdmVudFNlZ0VhY2goZnVuY3Rpb24oc2VnKSB7XG5cdFx0XHRzZWcuZWwuY3NzKCd2aXNpYmlsaXR5JywgJycpO1xuXHRcdH0sIGV2ZW50KTtcblx0fSxcblxuXG5cdC8vIFNob3dzIGFsbCByZW5kZXJlZCBldmVudCBzZWdtZW50cyBsaW5rZWQgdG8gdGhlIGdpdmVuIGV2ZW50XG5cdGhpZGVFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR0aGlzLnJlbmRlcmVkRXZlbnRTZWdFYWNoKGZ1bmN0aW9uKHNlZykge1xuXHRcdFx0c2VnLmVsLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcblx0XHR9LCBldmVudCk7XG5cdH0sXG5cblxuXHQvLyBJdGVyYXRlcyB0aHJvdWdoIGV2ZW50IHNlZ21lbnRzIHRoYXQgaGF2ZSBiZWVuIHJlbmRlcmVkIChoYXZlIGFuIGVsKS4gR29lcyB0aHJvdWdoIGFsbCBieSBkZWZhdWx0LlxuXHQvLyBJZiB0aGUgb3B0aW9uYWwgYGV2ZW50YCBhcmd1bWVudCBpcyBzcGVjaWZpZWQsIG9ubHkgaXRlcmF0ZXMgdGhyb3VnaCBzZWdtZW50cyBsaW5rZWQgdG8gdGhhdCBldmVudC5cblx0Ly8gVGhlIGB0aGlzYCB2YWx1ZSBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSB0aGUgdmlldy5cblx0cmVuZGVyZWRFdmVudFNlZ0VhY2g6IGZ1bmN0aW9uKGZ1bmMsIGV2ZW50KSB7XG5cdFx0dmFyIHNlZ3MgPSB0aGlzLmdldEV2ZW50U2VncygpO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICghZXZlbnQgfHwgc2Vnc1tpXS5ldmVudC5faWQgPT09IGV2ZW50Ll9pZCkge1xuXHRcdFx0XHRpZiAoc2Vnc1tpXS5lbCkge1xuXHRcdFx0XHRcdGZ1bmMuY2FsbCh0aGlzLCBzZWdzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJldHJpZXZlcyBhbGwgdGhlIHJlbmRlcmVkIHNlZ21lbnQgb2JqZWN0cyBmb3IgdGhlIHZpZXdcblx0Z2V0RXZlbnRTZWdzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdFx0cmV0dXJuIFtdO1xuXHR9LFxuXG5cblx0LyogRXZlbnQgRHJhZy1uLURyb3Bcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIENvbXB1dGVzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhbGxvd2VkIHRvIGJlIGRyYWdnZWQgYnkgdGhlIHVzZXJcblx0aXNFdmVudERyYWdnYWJsZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0V2ZW50U3RhcnRFZGl0YWJsZShldmVudCk7XG5cdH0sXG5cblxuXHRpc0V2ZW50U3RhcnRFZGl0YWJsZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gZmlyc3REZWZpbmVkKFxuXHRcdFx0ZXZlbnQuc3RhcnRFZGl0YWJsZSxcblx0XHRcdChldmVudC5zb3VyY2UgfHwge30pLnN0YXJ0RWRpdGFibGUsXG5cdFx0XHR0aGlzLm9wdCgnZXZlbnRTdGFydEVkaXRhYmxlJyksXG5cdFx0XHR0aGlzLmlzRXZlbnRHZW5lcmFsbHlFZGl0YWJsZShldmVudClcblx0XHQpO1xuXHR9LFxuXG5cblx0aXNFdmVudEdlbmVyYWxseUVkaXRhYmxlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiBmaXJzdERlZmluZWQoXG5cdFx0XHRldmVudC5lZGl0YWJsZSxcblx0XHRcdChldmVudC5zb3VyY2UgfHwge30pLmVkaXRhYmxlLFxuXHRcdFx0dGhpcy5vcHQoJ2VkaXRhYmxlJylcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gTXVzdCBiZSBjYWxsZWQgd2hlbiBhbiBldmVudCBpbiB0aGUgdmlldyBpcyBkcm9wcGVkIG9udG8gbmV3IGxvY2F0aW9uLlxuXHQvLyBgZHJvcExvY2F0aW9uYCBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHpvbmVkIHN0YXJ0L2VuZC9hbGxEYXkgdmFsdWVzIGZvciB0aGUgZXZlbnQuXG5cdHJlcG9ydFNlZ0Ryb3A6IGZ1bmN0aW9uKHNlZywgZHJvcExvY2F0aW9uLCBsYXJnZVVuaXQsIGVsLCBldikge1xuXHRcdHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XG5cdFx0dmFyIG11dGF0ZVJlc3VsdCA9IGNhbGVuZGFyLm11dGF0ZVNlZyhzZWcsIGRyb3BMb2NhdGlvbiwgbGFyZ2VVbml0KTtcblx0XHR2YXIgdW5kb0Z1bmMgPSBmdW5jdGlvbigpIHtcblx0XHRcdG11dGF0ZVJlc3VsdC51bmRvKCk7XG5cdFx0XHRjYWxlbmRhci5yZXBvcnRFdmVudENoYW5nZSgpO1xuXHRcdH07XG5cblx0XHR0aGlzLnRyaWdnZXJFdmVudERyb3Aoc2VnLmV2ZW50LCBtdXRhdGVSZXN1bHQuZGF0ZURlbHRhLCB1bmRvRnVuYywgZWwsIGV2KTtcblx0XHRjYWxlbmRhci5yZXBvcnRFdmVudENoYW5nZSgpOyAvLyB3aWxsIHJlcmVuZGVyIGV2ZW50c1xuXHR9LFxuXG5cblx0Ly8gVHJpZ2dlcnMgZXZlbnQtZHJvcCBoYW5kbGVycyB0aGF0IGhhdmUgc3Vic2NyaWJlZCB2aWEgdGhlIEFQSVxuXHR0cmlnZ2VyRXZlbnREcm9wOiBmdW5jdGlvbihldmVudCwgZGF0ZURlbHRhLCB1bmRvRnVuYywgZWwsIGV2KSB7XG5cdFx0dGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RHJvcCcsIGVsWzBdLCBldmVudCwgZGF0ZURlbHRhLCB1bmRvRnVuYywgZXYsIHt9KTsgLy8ge30gPSBqcXVpIGR1bW15XG5cdH0sXG5cblxuXHQvKiBFeHRlcm5hbCBFbGVtZW50IERyYWctbi1Ecm9wXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBNdXN0IGJlIGNhbGxlZCB3aGVuIGFuIGV4dGVybmFsIGVsZW1lbnQsIHZpYSBqUXVlcnkgVUksIGhhcyBiZWVuIGRyb3BwZWQgb250byB0aGUgY2FsZW5kYXIuXG5cdC8vIGBtZXRhYCBpcyB0aGUgcGFyc2VkIGRhdGEgdGhhdCBoYXMgYmVlbiBlbWJlZGRlZCBpbnRvIHRoZSBkcmFnZ2luZyBldmVudC5cblx0Ly8gYGRyb3BMb2NhdGlvbmAgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIG5ldyB6b25lZCBzdGFydC9lbmQvYWxsRGF5IHZhbHVlcyBmb3IgdGhlIGV2ZW50LlxuXHRyZXBvcnRFeHRlcm5hbERyb3A6IGZ1bmN0aW9uKG1ldGEsIGRyb3BMb2NhdGlvbiwgZWwsIGV2LCB1aSkge1xuXHRcdHZhciBldmVudFByb3BzID0gbWV0YS5ldmVudFByb3BzO1xuXHRcdHZhciBldmVudElucHV0O1xuXHRcdHZhciBldmVudDtcblxuXHRcdC8vIFRyeSB0byBidWlsZCBhbiBldmVudCBvYmplY3QgYW5kIHJlbmRlciBpdC4gVE9ETzogZGVjb3VwbGUgdGhlIHR3b1xuXHRcdGlmIChldmVudFByb3BzKSB7XG5cdFx0XHRldmVudElucHV0ID0gJC5leHRlbmQoe30sIGV2ZW50UHJvcHMsIGRyb3BMb2NhdGlvbik7XG5cdFx0XHRldmVudCA9IHRoaXMuY2FsZW5kYXIucmVuZGVyRXZlbnQoZXZlbnRJbnB1dCwgbWV0YS5zdGljaylbMF07IC8vIHJlbmRlckV2ZW50IHJldHVybnMgYW4gYXJyYXlcblx0XHR9XG5cblx0XHR0aGlzLnRyaWdnZXJFeHRlcm5hbERyb3AoZXZlbnQsIGRyb3BMb2NhdGlvbiwgZWwsIGV2LCB1aSk7XG5cdH0sXG5cblxuXHQvLyBUcmlnZ2VycyBleHRlcm5hbC1kcm9wIGhhbmRsZXJzIHRoYXQgaGF2ZSBzdWJzY3JpYmVkIHZpYSB0aGUgQVBJXG5cdHRyaWdnZXJFeHRlcm5hbERyb3A6IGZ1bmN0aW9uKGV2ZW50LCBkcm9wTG9jYXRpb24sIGVsLCBldiwgdWkpIHtcblxuXHRcdC8vIHRyaWdnZXIgJ2Ryb3AnIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBlbGVtZW50IHJlcHJlc2VudHMgYW4gZXZlbnRcblx0XHR0aGlzLnB1YmxpY2x5VHJpZ2dlcignZHJvcCcsIGVsWzBdLCBkcm9wTG9jYXRpb24uc3RhcnQsIGV2LCB1aSk7XG5cblx0XHRpZiAoZXZlbnQpIHtcblx0XHRcdHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudFJlY2VpdmUnLCBudWxsLCBldmVudCk7IC8vIHNpZ25hbCBhbiBleHRlcm5hbCBldmVudCBsYW5kZWRcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBEcmFnLW4tRHJvcCBSZW5kZXJpbmcgKGZvciBib3RoIGV2ZW50cyBhbmQgZXh0ZXJuYWwgZWxlbWVudHMpXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYSBldmVudCBvciBleHRlcm5hbC1lbGVtZW50IGRyYWcgb3ZlciB0aGUgZ2l2ZW4gZHJvcCB6b25lLlxuXHQvLyBJZiBhbiBleHRlcm5hbC1lbGVtZW50LCBzZWcgd2lsbCBiZSBgbnVsbGAuXG5cdC8vIE11c3QgcmV0dXJuIGVsZW1lbnRzIHVzZWQgZm9yIGFueSBtb2NrIGV2ZW50cy5cblx0cmVuZGVyRHJhZzogZnVuY3Rpb24oZHJvcExvY2F0aW9uLCBzZWcpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBvciBleHRlcm5hbC1lbGVtZW50IGJlaW5nIGRyYWdnZWQuXG5cdHVucmVuZGVyRHJhZzogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogRXZlbnQgUmVzaXppbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIENvbXB1dGVzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhbGxvd2VkIHRvIGJlIHJlc2l6ZWQgZnJvbSBpdHMgc3RhcnRpbmcgZWRnZVxuXHRpc0V2ZW50UmVzaXphYmxlRnJvbVN0YXJ0OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiB0aGlzLm9wdCgnZXZlbnRSZXNpemFibGVGcm9tU3RhcnQnKSAmJiB0aGlzLmlzRXZlbnRSZXNpemFibGUoZXZlbnQpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgcmVzaXplZCBmcm9tIGl0cyBlbmRpbmcgZWRnZVxuXHRpc0V2ZW50UmVzaXphYmxlRnJvbUVuZDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0V2ZW50UmVzaXphYmxlKGV2ZW50KTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhbGxvd2VkIHRvIGJlIHJlc2l6ZWQgYnkgdGhlIHVzZXIgYXQgYWxsXG5cdGlzRXZlbnRSZXNpemFibGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCB7fTtcblxuXHRcdHJldHVybiBmaXJzdERlZmluZWQoXG5cdFx0XHRldmVudC5kdXJhdGlvbkVkaXRhYmxlLFxuXHRcdFx0c291cmNlLmR1cmF0aW9uRWRpdGFibGUsXG5cdFx0XHR0aGlzLm9wdCgnZXZlbnREdXJhdGlvbkVkaXRhYmxlJyksXG5cdFx0XHRldmVudC5lZGl0YWJsZSxcblx0XHRcdHNvdXJjZS5lZGl0YWJsZSxcblx0XHRcdHRoaXMub3B0KCdlZGl0YWJsZScpXG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIE11c3QgYmUgY2FsbGVkIHdoZW4gYW4gZXZlbnQgaW4gdGhlIHZpZXcgaGFzIGJlZW4gcmVzaXplZCB0byBhIG5ldyBsZW5ndGhcblx0cmVwb3J0U2VnUmVzaXplOiBmdW5jdGlvbihzZWcsIHJlc2l6ZUxvY2F0aW9uLCBsYXJnZVVuaXQsIGVsLCBldikge1xuXHRcdHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XG5cdFx0dmFyIG11dGF0ZVJlc3VsdCA9IGNhbGVuZGFyLm11dGF0ZVNlZyhzZWcsIHJlc2l6ZUxvY2F0aW9uLCBsYXJnZVVuaXQpO1xuXHRcdHZhciB1bmRvRnVuYyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0bXV0YXRlUmVzdWx0LnVuZG8oKTtcblx0XHRcdGNhbGVuZGFyLnJlcG9ydEV2ZW50Q2hhbmdlKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMudHJpZ2dlckV2ZW50UmVzaXplKHNlZy5ldmVudCwgbXV0YXRlUmVzdWx0LmR1cmF0aW9uRGVsdGEsIHVuZG9GdW5jLCBlbCwgZXYpO1xuXHRcdGNhbGVuZGFyLnJlcG9ydEV2ZW50Q2hhbmdlKCk7IC8vIHdpbGwgcmVyZW5kZXIgZXZlbnRzXG5cdH0sXG5cblxuXHQvLyBUcmlnZ2VycyBldmVudC1yZXNpemUgaGFuZGxlcnMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdmlhIHRoZSBBUElcblx0dHJpZ2dlckV2ZW50UmVzaXplOiBmdW5jdGlvbihldmVudCwgZHVyYXRpb25EZWx0YSwgdW5kb0Z1bmMsIGVsLCBldikge1xuXHRcdHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudFJlc2l6ZScsIGVsWzBdLCBldmVudCwgZHVyYXRpb25EZWx0YSwgdW5kb0Z1bmMsIGV2LCB7fSk7IC8vIHt9ID0ganF1aSBkdW1teVxuXHR9LFxuXG5cblx0LyogU2VsZWN0aW9uICh0aW1lIHJhbmdlKVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gU2VsZWN0cyBhIGRhdGUgc3BhbiBvbiB0aGUgdmlldy4gYHN0YXJ0YCBhbmQgYGVuZGAgYXJlIGJvdGggTW9tZW50cy5cblx0Ly8gYGV2YCBpcyB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50IHRoYXQgYmVnaW4gdGhlIGludGVyYWN0aW9uLlxuXHRzZWxlY3Q6IGZ1bmN0aW9uKHNwYW4sIGV2KSB7XG5cdFx0dGhpcy51bnNlbGVjdChldik7XG5cdFx0dGhpcy5yZW5kZXJTZWxlY3Rpb24oc3Bhbik7XG5cdFx0dGhpcy5yZXBvcnRTZWxlY3Rpb24oc3BhbiwgZXYpO1xuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIHRoZSBzZWxlY3Rpb25cblx0cmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiBhIG5ldyBzZWxlY3Rpb24gaXMgbWFkZS4gVXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMuXG5cdHJlcG9ydFNlbGVjdGlvbjogZnVuY3Rpb24oc3BhbiwgZXYpIHtcblx0XHR0aGlzLmlzU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdHRoaXMudHJpZ2dlclNlbGVjdChzcGFuLCBldik7XG5cdH0sXG5cblxuXHQvLyBUcmlnZ2VycyBoYW5kbGVycyB0byAnc2VsZWN0J1xuXHR0cmlnZ2VyU2VsZWN0OiBmdW5jdGlvbihzcGFuLCBldikge1xuXHRcdHRoaXMucHVibGljbHlUcmlnZ2VyKFxuXHRcdFx0J3NlbGVjdCcsXG5cdFx0XHRudWxsLFxuXHRcdFx0dGhpcy5jYWxlbmRhci5hcHBseVRpbWV6b25lKHNwYW4uc3RhcnQpLCAvLyBjb252ZXJ0IHRvIGNhbGVuZGFyJ3MgdHogZm9yIGV4dGVybmFsIEFQSVxuXHRcdFx0dGhpcy5jYWxlbmRhci5hcHBseVRpbWV6b25lKHNwYW4uZW5kKSwgLy8gXCJcblx0XHRcdGV2XG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIFVuZG9lcyBhIHNlbGVjdGlvbi4gdXBkYXRlcyBpbiB0aGUgaW50ZXJuYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGhhbmRsZXJzLlxuXHQvLyBgZXZgIGlzIHRoZSBuYXRpdmUgbW91c2UgZXZlbnQgdGhhdCBiZWdhbiB0aGUgaW50ZXJhY3Rpb24uXG5cdHVuc2VsZWN0OiBmdW5jdGlvbihldikge1xuXHRcdGlmICh0aGlzLmlzU2VsZWN0ZWQpIHtcblx0XHRcdHRoaXMuaXNTZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0aWYgKHRoaXMuZGVzdHJveVNlbGVjdGlvbikge1xuXHRcdFx0XHR0aGlzLmRlc3Ryb3lTZWxlY3Rpb24oKTsgLy8gVE9ETzogZGVwcmVjYXRlXG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVucmVuZGVyU2VsZWN0aW9uKCk7XG5cdFx0XHR0aGlzLnB1YmxpY2x5VHJpZ2dlcigndW5zZWxlY3QnLCBudWxsLCBldik7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2Ygc2VsZWN0aW9uXG5cdHVucmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8qIEV2ZW50IFNlbGVjdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0c2VsZWN0RXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLnNlbGVjdGVkRXZlbnQgfHwgdGhpcy5zZWxlY3RlZEV2ZW50ICE9PSBldmVudCkge1xuXHRcdFx0dGhpcy51bnNlbGVjdEV2ZW50KCk7XG5cdFx0XHR0aGlzLnJlbmRlcmVkRXZlbnRTZWdFYWNoKGZ1bmN0aW9uKHNlZykge1xuXHRcdFx0XHRzZWcuZWwuYWRkQ2xhc3MoJ2ZjLXNlbGVjdGVkJyk7XG5cdFx0XHR9LCBldmVudCk7XG5cdFx0XHR0aGlzLnNlbGVjdGVkRXZlbnQgPSBldmVudDtcblx0XHR9XG5cdH0sXG5cblxuXHR1bnNlbGVjdEV2ZW50OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5zZWxlY3RlZEV2ZW50KSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVkRXZlbnRTZWdFYWNoKGZ1bmN0aW9uKHNlZykge1xuXHRcdFx0XHRzZWcuZWwucmVtb3ZlQ2xhc3MoJ2ZjLXNlbGVjdGVkJyk7XG5cdFx0XHR9LCB0aGlzLnNlbGVjdGVkRXZlbnQpO1xuXHRcdFx0dGhpcy5zZWxlY3RlZEV2ZW50ID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblxuXHRpc0V2ZW50U2VsZWN0ZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Ly8gZXZlbnQgcmVmZXJlbmNlcyBtaWdodCBjaGFuZ2Ugb24gcmVmZXRjaEV2ZW50cygpLCB3aGlsZSBzZWxlY3RlZEV2ZW50IGRvZXNuJ3QsXG5cdFx0Ly8gc28gY29tcGFyZSBJRHNcblx0XHRyZXR1cm4gdGhpcy5zZWxlY3RlZEV2ZW50ICYmIHRoaXMuc2VsZWN0ZWRFdmVudC5faWQgPT09IGV2ZW50Ll9pZDtcblx0fSxcblxuXG5cdC8qIE1vdXNlIC8gVG91Y2ggVW5zZWxlY3RpbmcgKHRpbWUgcmFuZ2UgJiBldmVudCB1bnNlbGVjdGlvbilcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0Ly8gVE9ETzogbW92ZSBjb25zaXN0ZW50bHkgdG8gZG93bi9zdGFydCBvciB1cC9lbmQ/XG5cdC8vIFRPRE86IGRvbid0IGtpbGwgcHJldmlvdXMgc2VsZWN0aW9uIGlmIHRvdWNoIHNjcm9sbGluZ1xuXG5cblx0aGFuZGxlRG9jdW1lbnRNb3VzZWRvd246IGZ1bmN0aW9uKGV2KSB7XG5cdFx0aWYgKGlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2KSkge1xuXHRcdFx0dGhpcy5wcm9jZXNzVW5zZWxlY3QoZXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdHByb2Nlc3NVbnNlbGVjdDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnByb2Nlc3NSYW5nZVVuc2VsZWN0KGV2KTtcblx0XHR0aGlzLnByb2Nlc3NFdmVudFVuc2VsZWN0KGV2KTtcblx0fSxcblxuXG5cdHByb2Nlc3NSYW5nZVVuc2VsZWN0OiBmdW5jdGlvbihldikge1xuXHRcdHZhciBpZ25vcmU7XG5cblx0XHQvLyBpcyB0aGVyZSBhIHRpbWUtcmFuZ2Ugc2VsZWN0aW9uP1xuXHRcdGlmICh0aGlzLmlzU2VsZWN0ZWQgJiYgdGhpcy5vcHQoJ3Vuc2VsZWN0QXV0bycpKSB7XG5cdFx0XHQvLyBvbmx5IHVuc2VsZWN0IGlmIHRoZSBjbGlja2VkIGVsZW1lbnQgaXMgbm90IGlkZW50aWNhbCB0byBvciBpbnNpZGUgb2YgYW4gJ3Vuc2VsZWN0Q2FuY2VsJyBlbGVtZW50XG5cdFx0XHRpZ25vcmUgPSB0aGlzLm9wdCgndW5zZWxlY3RDYW5jZWwnKTtcblx0XHRcdGlmICghaWdub3JlIHx8ICEkKGV2LnRhcmdldCkuY2xvc2VzdChpZ25vcmUpLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLnVuc2VsZWN0KGV2KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHRwcm9jZXNzRXZlbnRVbnNlbGVjdDogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAodGhpcy5zZWxlY3RlZEV2ZW50KSB7XG5cdFx0XHRpZiAoISQoZXYudGFyZ2V0KS5jbG9zZXN0KCcuZmMtc2VsZWN0ZWQnKS5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy51bnNlbGVjdEV2ZW50KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0LyogRGF5IENsaWNrXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBUcmlnZ2VycyBoYW5kbGVycyB0byAnZGF5Q2xpY2snXG5cdC8vIFNwYW4gaGFzIHN0YXJ0L2VuZCBvZiB0aGUgY2xpY2tlZCBhcmVhLiBPbmx5IHRoZSBzdGFydCBpcyB1c2VmdWwuXG5cdHRyaWdnZXJEYXlDbGljazogZnVuY3Rpb24oc3BhbiwgZGF5RWwsIGV2KSB7XG5cdFx0dGhpcy5wdWJsaWNseVRyaWdnZXIoXG5cdFx0XHQnZGF5Q2xpY2snLFxuXHRcdFx0ZGF5RWwsXG5cdFx0XHR0aGlzLmNhbGVuZGFyLmFwcGx5VGltZXpvbmUoc3Bhbi5zdGFydCksIC8vIGNvbnZlcnQgdG8gY2FsZW5kYXIncyB0aW1lem9uZSBmb3IgZXh0ZXJuYWwgQVBJXG5cdFx0XHRldlxuXHRcdCk7XG5cdH0sXG5cblxuXHQvKiBEYXRlIFV0aWxzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZXR1cm5zIHRoZSBkYXRlIHJhbmdlIG9mIHRoZSBmdWxsIGRheXMgdGhlIGdpdmVuIHJhbmdlIHZpc3VhbGx5IGFwcGVhcnMgdG8gb2NjdXB5LlxuXHQvLyBSZXR1cm5zIGEgbmV3IHJhbmdlIG9iamVjdC5cblx0Y29tcHV0ZURheVJhbmdlOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdHZhciBzdGFydERheSA9IHJhbmdlLnN0YXJ0LmNsb25lKCkuc3RyaXBUaW1lKCk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2Ugc3RhcnRzXG5cdFx0dmFyIGVuZCA9IHJhbmdlLmVuZDtcblx0XHR2YXIgZW5kRGF5ID0gbnVsbDtcblx0XHR2YXIgZW5kVGltZU1TO1xuXG5cdFx0aWYgKGVuZCkge1xuXHRcdFx0ZW5kRGF5ID0gZW5kLmNsb25lKCkuc3RyaXBUaW1lKCk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2UgZXhjbHVzaXZlbHkgZW5kc1xuXHRcdFx0ZW5kVGltZU1TID0gK2VuZC50aW1lKCk7IC8vICMgb2YgbWlsbGlzZWNvbmRzIGludG8gYGVuZERheWBcblxuXHRcdFx0Ly8gSWYgdGhlIGVuZCB0aW1lIGlzIGFjdHVhbGx5IGluY2x1c2l2ZWx5IHBhcnQgb2YgdGhlIG5leHQgZGF5IGFuZCBpcyBlcXVhbCB0byBvclxuXHRcdFx0Ly8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBsZWF2aW5nIGl0IGFzIGluY2x1c2l2ZSB3aWxsIGNhdXNlIGl0IHRvIGV4Y2x1ZGUgYGVuZERheWAuXG5cdFx0XHRpZiAoZW5kVGltZU1TICYmIGVuZFRpbWVNUyA+PSB0aGlzLm5leHREYXlUaHJlc2hvbGQpIHtcblx0XHRcdFx0ZW5kRGF5LmFkZCgxLCAnZGF5cycpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIG5vIGVuZCB3YXMgc3BlY2lmaWVkLCBvciBpZiBpdCBpcyB3aXRoaW4gYHN0YXJ0RGF5YCBidXQgbm90IHBhc3QgbmV4dERheVRocmVzaG9sZCxcblx0XHQvLyBhc3NpZ24gdGhlIGRlZmF1bHQgZHVyYXRpb24gb2Ygb25lIGRheS5cblx0XHRpZiAoIWVuZCB8fCBlbmREYXkgPD0gc3RhcnREYXkpIHtcblx0XHRcdGVuZERheSA9IHN0YXJ0RGF5LmNsb25lKCkuYWRkKDEsICdkYXlzJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9O1xuXHR9LFxuXG5cblx0Ly8gRG9lcyB0aGUgZ2l2ZW4gZXZlbnQgdmlzdWFsbHkgYXBwZWFyIHRvIG9jY3VweSBtb3JlIHRoYW4gb25lIGRheT9cblx0aXNNdWx0aURheUV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciByYW5nZSA9IHRoaXMuY29tcHV0ZURheVJhbmdlKGV2ZW50KTsgLy8gZXZlbnQgaXMgcmFuZ2UtaXNoXG5cblx0XHRyZXR1cm4gcmFuZ2UuZW5kLmRpZmYocmFuZ2Uuc3RhcnQsICdkYXlzJykgPiAxO1xuXHR9XG5cbn0pO1xuXG5cblZpZXcud2F0Y2goJ2Rpc3BsYXlpbmdEYXRlcycsIFsgJ2RhdGVQcm9maWxlJyBdLCBmdW5jdGlvbihkZXBzKSB7XG5cdHRoaXMucmVxdWVzdERhdGVSZW5kZXIoZGVwcy5kYXRlUHJvZmlsZSk7XG59LCBmdW5jdGlvbigpIHtcblx0dGhpcy5yZXF1ZXN0RGF0ZVVucmVuZGVyKCk7XG59KTtcblxuXG5WaWV3LndhdGNoKCdpbml0aWFsRXZlbnRzJywgWyAnZGF0ZVByb2ZpbGUnIF0sIGZ1bmN0aW9uKGRlcHMpIHtcblx0cmV0dXJuIHRoaXMuZmV0Y2hJbml0aWFsRXZlbnRzKGRlcHMuZGF0ZVByb2ZpbGUpO1xufSk7XG5cblxuVmlldy53YXRjaCgnYmluZGluZ0V2ZW50cycsIFsgJ2luaXRpYWxFdmVudHMnIF0sIGZ1bmN0aW9uKGRlcHMpIHtcblx0dGhpcy5zZXRFdmVudHMoZGVwcy5pbml0aWFsRXZlbnRzKTtcblx0dGhpcy5iaW5kRXZlbnRDaGFuZ2VzKCk7XG59LCBmdW5jdGlvbigpIHtcblx0dGhpcy51bmJpbmRFdmVudENoYW5nZXMoKTtcblx0dGhpcy51bnNldEV2ZW50cygpO1xufSk7XG5cblxuVmlldy53YXRjaCgnZGlzcGxheWluZ0V2ZW50cycsIFsgJ2Rpc3BsYXlpbmdEYXRlcycsICdoYXNFdmVudHMnIF0sIGZ1bmN0aW9uKCkge1xuXHR0aGlzLnJlcXVlc3RFdmVudHNSZW5kZXIodGhpcy5nZXQoJ2N1cnJlbnRFdmVudHMnKSk7IC8vIGlmIHRoZXJlIHdlcmUgZXZlbnQgbXV0YXRpb25zIGFmdGVyIGluaXRpYWxFdmVudHNcbn0sIGZ1bmN0aW9uKCkge1xuXHR0aGlzLnJlcXVlc3RFdmVudHNVbnJlbmRlcigpO1xufSk7XG5cbjs7XG5cblZpZXcubWl4aW4oe1xuXG5cdC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cblx0Ly8gZm9yIGV4YW1wbGUsIGEgbW9udGggdmlldyBtaWdodCBoYXZlIDFzdC0zMXN0LCBleGNsdWRpbmcgcGFkZGVkIGRhdGVzXG5cdGN1cnJlbnRSYW5nZTogbnVsbCxcblx0Y3VycmVudFJhbmdlVW5pdDogbnVsbCwgLy8gbmFtZSBvZiBsYXJnZXN0IHVuaXQgYmVpbmcgZGlzcGxheWVkLCBsaWtlIFwibW9udGhcIiBvciBcIndlZWtcIlxuXG5cdC8vIGRhdGUgcmFuZ2Ugd2l0aCBhIHJlbmRlcmVkIHNrZWxldG9uXG5cdC8vIGluY2x1ZGVzIG5vdC1hY3RpdmUgZGF5cyB0aGF0IG5lZWQgc29tZSBzb3J0IG9mIERPTVxuXHRyZW5kZXJSYW5nZTogbnVsbCxcblxuXHQvLyBkYXRlcyB0aGF0IGRpc3BsYXkgZXZlbnRzIGFuZCBhY2NlcHQgZHJhZy1uLWRyb3Bcblx0YWN0aXZlUmFuZ2U6IG51bGwsXG5cblx0Ly8gY29uc3RyYWludCBmb3Igd2hlcmUgcHJldi9uZXh0IG9wZXJhdGlvbnMgY2FuIGdvIGFuZCB3aGVyZSBldmVudHMgY2FuIGJlIGRyYWdnZWQvcmVzaXplZCB0by5cblx0Ly8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxuXHR2YWxpZFJhbmdlOiBudWxsLFxuXG5cdC8vIGhvdyBmYXIgdGhlIGN1cnJlbnQgZGF0ZSB3aWxsIG1vdmUgZm9yIGEgcHJldi9uZXh0IG9wZXJhdGlvblxuXHRkYXRlSW5jcmVtZW50OiBudWxsLFxuXG5cdG1pblRpbWU6IG51bGwsIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGZpcnN0IHZpc2libGUgdGltZSBvZiBhbnkgZ2l2ZW4gZGF5XG5cdG1heFRpbWU6IG51bGwsIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcblx0dXNlc01pbk1heFRpbWU6IGZhbHNlLCAvLyB3aGV0aGVyIG1pblRpbWUvbWF4VGltZSB3aWxsIGFmZmVjdCB0aGUgYWN0aXZlUmFuZ2UuIFZpZXdzIG11c3Qgb3B0LWluLlxuXG5cdC8vIERFUFJFQ0FURURcblx0c3RhcnQ6IG51bGwsIC8vIHVzZSBhY3RpdmVSYW5nZS5zdGFydFxuXHRlbmQ6IG51bGwsIC8vIHVzZSBhY3RpdmVSYW5nZS5lbmRcblx0aW50ZXJ2YWxTdGFydDogbnVsbCwgLy8gdXNlIGN1cnJlbnRSYW5nZS5zdGFydFxuXHRpbnRlcnZhbEVuZDogbnVsbCwgLy8gdXNlIGN1cnJlbnRSYW5nZS5lbmRcblxuXG5cdC8qIERhdGUgUmFuZ2UgQ29tcHV0YXRpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHNldERhdGVQcm9maWxlRm9yUmVuZGVyaW5nOiBmdW5jdGlvbihkYXRlUHJvZmlsZSkge1xuXHRcdHRoaXMuY3VycmVudFJhbmdlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlO1xuXHRcdHRoaXMuY3VycmVudFJhbmdlVW5pdCA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQ7XG5cdFx0dGhpcy5yZW5kZXJSYW5nZSA9IGRhdGVQcm9maWxlLnJlbmRlclJhbmdlO1xuXHRcdHRoaXMuYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZTtcblx0XHR0aGlzLnZhbGlkUmFuZ2UgPSBkYXRlUHJvZmlsZS52YWxpZFJhbmdlO1xuXHRcdHRoaXMuZGF0ZUluY3JlbWVudCA9IGRhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQ7XG5cdFx0dGhpcy5taW5UaW1lID0gZGF0ZVByb2ZpbGUubWluVGltZTtcblx0XHR0aGlzLm1heFRpbWUgPSBkYXRlUHJvZmlsZS5tYXhUaW1lO1xuXG5cdFx0Ly8gREVQUkVDQVRFRCwgYnV0IHdlIG5lZWQgdG8ga2VlcCBpdCB1cGRhdGVkXG5cdFx0dGhpcy5zdGFydCA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLnN0YXJ0O1xuXHRcdHRoaXMuZW5kID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UuZW5kO1xuXHRcdHRoaXMuaW50ZXJ2YWxTdGFydCA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcblx0XHR0aGlzLmludGVydmFsRW5kID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLmVuZDtcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcInByZXZcIiB2aWV3LlxuXHRidWlsZFByZXZEYXRlUHJvZmlsZTogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdHZhciBwcmV2RGF0ZSA9IGRhdGUuY2xvbmUoKS5zdGFydE9mKHRoaXMuY3VycmVudFJhbmdlVW5pdCkuc3VidHJhY3QodGhpcy5kYXRlSW5jcmVtZW50KTtcblxuXHRcdHJldHVybiB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGUocHJldkRhdGUsIC0xKTtcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxuXHRidWlsZE5leHREYXRlUHJvZmlsZTogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdHZhciBuZXh0RGF0ZSA9IGRhdGUuY2xvbmUoKS5zdGFydE9mKHRoaXMuY3VycmVudFJhbmdlVW5pdCkuYWRkKHRoaXMuZGF0ZUluY3JlbWVudCk7XG5cblx0XHRyZXR1cm4gdGhpcy5idWlsZERhdGVQcm9maWxlKG5leHREYXRlLCAxKTtcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSBob2xkaW5nIGRhdGVzL3JhbmdlcyBmb3IgcmVuZGVyaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gZGF0ZS5cblx0Ly8gT3B0aW9uYWwgZGlyZWN0aW9uIHBhcmFtIGluZGljYXRlcyB3aGV0aGVyIHRoZSBkYXRlIGlzIGJlaW5nIGluY3JlbWVudGVkL2RlY3JlbWVudGVkXG5cdC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxuXHRidWlsZERhdGVQcm9maWxlOiBmdW5jdGlvbihkYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCkge1xuXHRcdHZhciB2YWxpZFJhbmdlID0gdGhpcy5idWlsZFZhbGlkUmFuZ2UoKTtcblx0XHR2YXIgbWluVGltZSA9IG51bGw7XG5cdFx0dmFyIG1heFRpbWUgPSBudWxsO1xuXHRcdHZhciBjdXJyZW50SW5mbztcblx0XHR2YXIgcmVuZGVyUmFuZ2U7XG5cdFx0dmFyIGFjdGl2ZVJhbmdlO1xuXHRcdHZhciBpc1ZhbGlkO1xuXG5cdFx0aWYgKGZvcmNlVG9WYWxpZCkge1xuXHRcdFx0ZGF0ZSA9IGNvbnN0cmFpbkRhdGUoZGF0ZSwgdmFsaWRSYW5nZSk7XG5cdFx0fVxuXG5cdFx0Y3VycmVudEluZm8gPSB0aGlzLmJ1aWxkQ3VycmVudFJhbmdlSW5mbyhkYXRlLCBkaXJlY3Rpb24pO1xuXHRcdHJlbmRlclJhbmdlID0gdGhpcy5idWlsZFJlbmRlclJhbmdlKGN1cnJlbnRJbmZvLnJhbmdlLCBjdXJyZW50SW5mby51bml0KTtcblx0XHRhY3RpdmVSYW5nZSA9IGNsb25lUmFuZ2UocmVuZGVyUmFuZ2UpO1xuXG5cdFx0aWYgKCF0aGlzLm9wdCgnc2hvd05vbkN1cnJlbnREYXRlcycpKSB7XG5cdFx0XHRhY3RpdmVSYW5nZSA9IGNvbnN0cmFpblJhbmdlKGFjdGl2ZVJhbmdlLCBjdXJyZW50SW5mby5yYW5nZSk7XG5cdFx0fVxuXG5cdFx0bWluVGltZSA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm9wdCgnbWluVGltZScpKTtcblx0XHRtYXhUaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdtYXhUaW1lJykpO1xuXHRcdHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlUmFuZ2UsIG1pblRpbWUsIG1heFRpbWUpO1xuXG5cdFx0YWN0aXZlUmFuZ2UgPSBjb25zdHJhaW5SYW5nZShhY3RpdmVSYW5nZSwgdmFsaWRSYW5nZSk7XG5cdFx0ZGF0ZSA9IGNvbnN0cmFpbkRhdGUoZGF0ZSwgYWN0aXZlUmFuZ2UpO1xuXG5cdFx0Ly8gaXQncyBpbnZhbGlkIGlmIHRoZSBvcmlnaW5hbGx5IHJlcXVlc3RlZCBkYXRlIGlzIG5vdCBjb250YWluZWQsXG5cdFx0Ly8gb3IgaWYgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgb3V0c2lkZSBvZiB0aGUgdmFsaWQgcmFuZ2UuXG5cdFx0aXNWYWxpZCA9IGRvUmFuZ2VzSW50ZXJzZWN0KGN1cnJlbnRJbmZvLnJhbmdlLCB2YWxpZFJhbmdlKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR2YWxpZFJhbmdlOiB2YWxpZFJhbmdlLFxuXHRcdFx0Y3VycmVudFJhbmdlOiBjdXJyZW50SW5mby5yYW5nZSxcblx0XHRcdGN1cnJlbnRSYW5nZVVuaXQ6IGN1cnJlbnRJbmZvLnVuaXQsXG5cdFx0XHRhY3RpdmVSYW5nZTogYWN0aXZlUmFuZ2UsXG5cdFx0XHRyZW5kZXJSYW5nZTogcmVuZGVyUmFuZ2UsXG5cdFx0XHRtaW5UaW1lOiBtaW5UaW1lLFxuXHRcdFx0bWF4VGltZTogbWF4VGltZSxcblx0XHRcdGlzVmFsaWQ6IGlzVmFsaWQsXG5cdFx0XHRkYXRlOiBkYXRlLFxuXHRcdFx0ZGF0ZUluY3JlbWVudDogdGhpcy5idWlsZERhdGVJbmNyZW1lbnQoY3VycmVudEluZm8uZHVyYXRpb24pXG5cdFx0XHRcdC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxuXHRcdH07XG5cdH0sXG5cblxuXHQvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQvZW5kIHByb3BlcnRpZXMuXG5cdC8vIEluZGljYXRlcyB0aGUgbWluaW11bS9tYXhpbXVtIGRhdGVzIHRvIGRpc3BsYXkuXG5cdGJ1aWxkVmFsaWRSYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmFuZ2VPcHRpb24oJ3ZhbGlkUmFuZ2UnLCB0aGlzLmNhbGVuZGFyLmdldE5vdygpKSB8fCB7fTtcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgdGhlIFwiY3VycmVudFwiIHJhbmdlLCB0aGUgcmFuZ2UgdGhhdCBpc1xuXHQvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cblx0Ly8gU2VlIGJ1aWxkRGF0ZVByb2ZpbGUgZm9yIGEgZGVzY3JpcHRpb24gb2YgYGRpcmVjdGlvbmAuXG5cdC8vIEd1YXJhbnRlZWQgdG8gaGF2ZSBgcmFuZ2VgIGFuZCBgdW5pdGAgcHJvcGVydGllcy4gYGR1cmF0aW9uYCBpcyBvcHRpb25hbC5cblx0YnVpbGRDdXJyZW50UmFuZ2VJbmZvOiBmdW5jdGlvbihkYXRlLCBkaXJlY3Rpb24pIHtcblx0XHR2YXIgZHVyYXRpb24gPSBudWxsO1xuXHRcdHZhciB1bml0ID0gbnVsbDtcblx0XHR2YXIgcmFuZ2UgPSBudWxsO1xuXHRcdHZhciBkYXlDb3VudDtcblxuXHRcdGlmICh0aGlzLnZpZXdTcGVjLmR1cmF0aW9uKSB7XG5cdFx0XHRkdXJhdGlvbiA9IHRoaXMudmlld1NwZWMuZHVyYXRpb247XG5cdFx0XHR1bml0ID0gdGhpcy52aWV3U3BlYy5kdXJhdGlvblVuaXQ7XG5cdFx0XHRyYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGRheUNvdW50ID0gdGhpcy5vcHQoJ2RheUNvdW50JykpKSB7XG5cdFx0XHR1bml0ID0gJ2RheSc7XG5cdFx0XHRyYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EYXlDb3VudChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcblx0XHRcdHVuaXQgPSBjb21wdXRlR3JlYXRlc3RVbml0KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGR1cmF0aW9uID0gdGhpcy5nZXRGYWxsYmFja0R1cmF0aW9uKCk7XG5cdFx0XHR1bml0ID0gY29tcHV0ZUdyZWF0ZXN0VW5pdChkdXJhdGlvbik7XG5cdFx0XHRyYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcblx0XHR9XG5cblx0XHR0aGlzLm5vcm1hbGl6ZUN1cnJlbnRSYW5nZShyYW5nZSwgdW5pdCk7IC8vIG1vZGlmaWVzIGluLXBsYWNlXG5cblx0XHRyZXR1cm4geyBkdXJhdGlvbjogZHVyYXRpb24sIHVuaXQ6IHVuaXQsIHJhbmdlOiByYW5nZSB9O1xuXHR9LFxuXG5cblx0Z2V0RmFsbGJhY2tEdXJhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbih7IGRheXM6IDEgfSk7XG5cdH0sXG5cblxuXHQvLyBJZiB0aGUgcmFuZ2UgaGFzIGRheSB1bml0cyBvciBsYXJnZXIsIHJlbW92ZSB0aW1lcy4gT3RoZXJ3aXNlLCBlbnN1cmUgdGltZXMuXG5cdG5vcm1hbGl6ZUN1cnJlbnRSYW5nZTogZnVuY3Rpb24ocmFuZ2UsIHVuaXQpIHtcblxuXHRcdGlmICgvXih5ZWFyfG1vbnRofHdlZWt8ZGF5KSQvLnRlc3QodW5pdCkpIHsgLy8gd2hvbGUtZGF5cz9cblx0XHRcdHJhbmdlLnN0YXJ0LnN0cmlwVGltZSgpO1xuXHRcdFx0cmFuZ2UuZW5kLnN0cmlwVGltZSgpO1xuXHRcdH1cblx0XHRlbHNlIHsgLy8gbmVlZHMgdG8gaGF2ZSBhIHRpbWU/XG5cdFx0XHRpZiAoIXJhbmdlLnN0YXJ0Lmhhc1RpbWUoKSkge1xuXHRcdFx0XHRyYW5nZS5zdGFydC50aW1lKDApOyAvLyBnaXZlIDAwOjAwIHRpbWVcblx0XHRcdH1cblx0XHRcdGlmICghcmFuZ2UuZW5kLmhhc1RpbWUoKSkge1xuXHRcdFx0XHRyYW5nZS5lbmQudGltZSgwKTsgLy8gZ2l2ZSAwMDowMCB0aW1lXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gTXV0YXRlcyB0aGUgZ2l2ZW4gYWN0aXZlUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxuXHQvLyBpZiB0aGUgbWluVGltZSBvciBtYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxuXHQvLyBUT0RPOiBldmVudHVhbGx5IGFjdGl2ZVJhbmdlIHNob3VsZCAqYWx3YXlzKiBoYXZlIHRpbWVzLlxuXHRhZGp1c3RBY3RpdmVSYW5nZTogZnVuY3Rpb24ocmFuZ2UsIG1pblRpbWUsIG1heFRpbWUpIHtcblx0XHR2YXIgaGFzU3BlY2lhbFRpbWVzID0gZmFsc2U7XG5cblx0XHRpZiAodGhpcy51c2VzTWluTWF4VGltZSkge1xuXG5cdFx0XHRpZiAobWluVGltZSA8IDApIHtcblx0XHRcdFx0cmFuZ2Uuc3RhcnQudGltZSgwKS5hZGQobWluVGltZSk7XG5cdFx0XHRcdGhhc1NwZWNpYWxUaW1lcyA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXhUaW1lID4gMjQgKiA2MCAqIDYwICogMTAwMCkgeyAvLyBiZXlvbmQgMjQgaG91cnM/XG5cdFx0XHRcdHJhbmdlLmVuZC50aW1lKG1heFRpbWUgLSAoMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuXHRcdFx0XHRoYXNTcGVjaWFsVGltZXMgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaGFzU3BlY2lhbFRpbWVzKSB7XG5cdFx0XHRcdGlmICghcmFuZ2Uuc3RhcnQuaGFzVGltZSgpKSB7XG5cdFx0XHRcdFx0cmFuZ2Uuc3RhcnQudGltZSgwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXJhbmdlLmVuZC5oYXNUaW1lKCkpIHtcblx0XHRcdFx0XHRyYW5nZS5lbmQudGltZSgwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBpdCBpcyBzcGVjaWZpZWQgYXMgYW4gZXhwbGljaXQgZHVyYXRpb24uXG5cdC8vIGB1bml0YCBpcyB0aGUgYWxyZWFkeS1jb21wdXRlZCBjb21wdXRlR3JlYXRlc3RVbml0IHZhbHVlIG9mIGR1cmF0aW9uLlxuXHRidWlsZFJhbmdlRnJvbUR1cmF0aW9uOiBmdW5jdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KSB7XG5cdFx0dmFyIGFsaWdubWVudCA9IHRoaXMub3B0KCdkYXRlQWxpZ25tZW50Jyk7XG5cdFx0dmFyIHN0YXJ0ID0gZGF0ZS5jbG9uZSgpO1xuXHRcdHZhciBlbmQ7XG5cdFx0dmFyIGRhdGVJbmNyZW1lbnRJbnB1dDtcblx0XHR2YXIgZGF0ZUluY3JlbWVudER1cmF0aW9uO1xuXG5cdFx0Ly8gaWYgdGhlIHZpZXcgZGlzcGxheXMgYSBzaW5nbGUgZGF5IG9yIHNtYWxsZXJcblx0XHRpZiAoZHVyYXRpb24uYXMoJ2RheXMnKSA8PSAxKSB7XG5cdFx0XHRpZiAodGhpcy5pc0hpZGRlbkRheShzdGFydCkpIHtcblx0XHRcdFx0c3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xuXHRcdFx0XHRzdGFydC5zdGFydE9mKCdkYXknKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBjb21wdXRlIHdoYXQgdGhlIGFsaWdubWVudCBzaG91bGQgYmVcblx0XHRpZiAoIWFsaWdubWVudCkge1xuXHRcdFx0ZGF0ZUluY3JlbWVudElucHV0ID0gdGhpcy5vcHQoJ2RhdGVJbmNyZW1lbnQnKTtcblxuXHRcdFx0aWYgKGRhdGVJbmNyZW1lbnRJbnB1dCkge1xuXHRcdFx0XHRkYXRlSW5jcmVtZW50RHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24oZGF0ZUluY3JlbWVudElucHV0KTtcblxuXHRcdFx0XHQvLyB1c2UgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byB1bml0c1xuXHRcdFx0XHRpZiAoZGF0ZUluY3JlbWVudER1cmF0aW9uIDwgZHVyYXRpb24pIHtcblx0XHRcdFx0XHRhbGlnbm1lbnQgPSBjb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQoZGF0ZUluY3JlbWVudER1cmF0aW9uLCBkYXRlSW5jcmVtZW50SW5wdXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGFsaWdubWVudCA9IHVuaXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRhbGlnbm1lbnQgPSB1bml0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN0YXJ0LnN0YXJ0T2YoYWxpZ25tZW50KTtcblx0XHRlbmQgPSBzdGFydC5jbG9uZSgpLmFkZChkdXJhdGlvbik7XG5cblx0XHRyZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG5cdH0sXG5cblxuXHQvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gYSBkYXlDb3VudCBpcyBzcGVjaWZpZWQuXG5cdGJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQ6IGZ1bmN0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpIHtcblx0XHR2YXIgY3VzdG9tQWxpZ25tZW50ID0gdGhpcy5vcHQoJ2RhdGVBbGlnbm1lbnQnKTtcblx0XHR2YXIgcnVubmluZ0NvdW50ID0gMDtcblx0XHR2YXIgc3RhcnQgPSBkYXRlLmNsb25lKCk7XG5cdFx0dmFyIGVuZDtcblxuXHRcdGlmIChjdXN0b21BbGlnbm1lbnQpIHtcblx0XHRcdHN0YXJ0LnN0YXJ0T2YoY3VzdG9tQWxpZ25tZW50KTtcblx0XHR9XG5cblx0XHRzdGFydC5zdGFydE9mKCdkYXknKTtcblx0XHRzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQsIGRpcmVjdGlvbik7XG5cblx0XHRlbmQgPSBzdGFydC5jbG9uZSgpO1xuXHRcdGRvIHtcblx0XHRcdGVuZC5hZGQoMSwgJ2RheScpO1xuXHRcdFx0aWYgKCF0aGlzLmlzSGlkZGVuRGF5KGVuZCkpIHtcblx0XHRcdFx0cnVubmluZ0NvdW50Kys7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAocnVubmluZ0NvdW50IDwgZGF5Q291bnQpO1xuXG5cdFx0cmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuXHR9LFxuXG5cblx0Ly8gQnVpbGRzIGEgbm9ybWFsaXplZCByYW5nZSBvYmplY3QgZm9yIHRoZSBcInZpc2libGVcIiByYW5nZSxcblx0Ly8gd2hpY2ggaXMgYSB3YXkgdG8gZGVmaW5lIHRoZSBjdXJyZW50UmFuZ2UgYW5kIGFjdGl2ZVJhbmdlIGF0IHRoZSBzYW1lIHRpbWUuXG5cdGJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIHZpc2libGVSYW5nZSA9IHRoaXMuZ2V0UmFuZ2VPcHRpb24oXG5cdFx0XHQndmlzaWJsZVJhbmdlJyxcblx0XHRcdHRoaXMuY2FsZW5kYXIubW9tZW50KGRhdGUpIC8vIGNvcnJlY3Qgem9uZS4gYWxzbyBnZW5lcmF0ZXMgbmV3IG9iaiB0aGF0IGF2b2lkcyBtdXRhdGlvbnNcblx0XHQpO1xuXG5cdFx0aWYgKHZpc2libGVSYW5nZSAmJiAoIXZpc2libGVSYW5nZS5zdGFydCB8fCAhdmlzaWJsZVJhbmdlLmVuZCkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2aXNpYmxlUmFuZ2U7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgZWxlbWVudC9jZWxscyBmb3IgKnJlbmRlcmluZyosXG5cdC8vIGJ1dCB3aGljaCBtYXkgaGF2ZSB2b2lkZWQgZGF5cy90aW1lcy5cblx0YnVpbGRSZW5kZXJSYW5nZTogZnVuY3Rpb24oY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0KSB7XG5cdFx0Ly8gY3V0IG9mZiBkYXlzIGluIHRoZSBjdXJyZW50UmFuZ2UgdGhhdCBhcmUgaGlkZGVuXG5cdFx0cmV0dXJuIHRoaXMudHJpbUhpZGRlbkRheXMoY3VycmVudFJhbmdlKTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGUgdGhlIGR1cmF0aW9uIHZhbHVlIHRoYXQgc2hvdWxkIGJlIGFkZGVkL3N1YnN0cmFjdGVkIHRvIHRoZSBjdXJyZW50IGRhdGVcblx0Ly8gd2hlbiBhIHByZXYvbmV4dCBvcGVyYXRpb24gaGFwcGVucy5cblx0YnVpbGREYXRlSW5jcmVtZW50OiBmdW5jdGlvbihmYWxsYmFjaykge1xuXHRcdHZhciBkYXRlSW5jcmVtZW50SW5wdXQgPSB0aGlzLm9wdCgnZGF0ZUluY3JlbWVudCcpO1xuXHRcdHZhciBjdXN0b21BbGlnbm1lbnQ7XG5cblx0XHRpZiAoZGF0ZUluY3JlbWVudElucHV0KSB7XG5cdFx0XHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKGRhdGVJbmNyZW1lbnRJbnB1dCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjdXN0b21BbGlnbm1lbnQgPSB0aGlzLm9wdCgnZGF0ZUFsaWdubWVudCcpKSkge1xuXHRcdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbigxLCBjdXN0b21BbGlnbm1lbnQpO1xuXHRcdH1cblx0XHRlbHNlIGlmIChmYWxsYmFjaykge1xuXHRcdFx0cmV0dXJuIGZhbGxiYWNrO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiBtb21lbnQuZHVyYXRpb24oeyBkYXlzOiAxIH0pO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJlbW92ZSBkYXlzIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSByYW5nZSB0aGF0IGFyZSBjb21wdXRlZCBhcyBoaWRkZW4uXG5cdHRyaW1IaWRkZW5EYXlzOiBmdW5jdGlvbihpbnB1dFJhbmdlKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiB0aGlzLnNraXBIaWRkZW5EYXlzKGlucHV0UmFuZ2Uuc3RhcnQpLFxuXHRcdFx0ZW5kOiB0aGlzLnNraXBIaWRkZW5EYXlzKGlucHV0UmFuZ2UuZW5kLCAtMSwgdHJ1ZSkgLy8gZXhjbHVzaXZlbHkgbW92ZSBiYWNrd2FyZHNcblx0XHR9O1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIHRoZSBnaXZlIHVuaXRzIGluIHRoZSBcImN1cnJlbnRcIiByYW5nZS5cblx0Ly8gV2lsbCByZXR1cm4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIuIFdvbid0IHJvdW5kLlxuXHRjdXJyZW50UmFuZ2VBczogZnVuY3Rpb24odW5pdCkge1xuXHRcdHZhciBjdXJyZW50UmFuZ2UgPSB0aGlzLmN1cnJlbnRSYW5nZTtcblx0XHRyZXR1cm4gY3VycmVudFJhbmdlLmVuZC5kaWZmKGN1cnJlbnRSYW5nZS5zdGFydCwgdW5pdCwgdHJ1ZSk7XG5cdH0sXG5cblxuXHQvLyBBcmd1bWVudHMgYWZ0ZXIgbmFtZSB3aWxsIGJlIGZvcndhcmRlZCB0byBhIGh5cG90aGV0aWNhbCBmdW5jdGlvbiB2YWx1ZVxuXHQvLyBXQVJOSU5HOiBwYXNzZWQtaW4gYXJndW1lbnRzIHdpbGwgYmUgZ2l2ZW4gdG8gZ2VuZXJhdG9yIGZ1bmN0aW9ucyBhcy1pcyBhbmQgY2FuIGNhdXNlIHNpZGUtZWZmZWN0cy5cblx0Ly8gQWx3YXlzIGNsb25lIHlvdXIgb2JqZWN0cyBpZiB5b3UgZmVhciBtdXRhdGlvbi5cblx0Z2V0UmFuZ2VPcHRpb246IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIgdmFsID0gdGhpcy5vcHQobmFtZSk7XG5cblx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dmFsID0gdmFsLmFwcGx5KFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmICh2YWwpIHtcblx0XHRcdHJldHVybiB0aGlzLmNhbGVuZGFyLnBhcnNlUmFuZ2UodmFsKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBIaWRkZW4gRGF5c1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gSW5pdGlhbGl6ZXMgaW50ZXJuYWwgdmFyaWFibGVzIHJlbGF0ZWQgdG8gY2FsY3VsYXRpbmcgaGlkZGVuIGRheXMtb2Ytd2Vla1xuXHRpbml0SGlkZGVuRGF5czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhpZGRlbkRheXMgPSB0aGlzLm9wdCgnaGlkZGVuRGF5cycpIHx8IFtdOyAvLyBhcnJheSBvZiBkYXktb2Ytd2VlayBpbmRpY2VzIHRoYXQgYXJlIGhpZGRlblxuXHRcdHZhciBpc0hpZGRlbkRheUhhc2ggPSBbXTsgLy8gaXMgdGhlIGRheS1vZi13ZWVrIGhpZGRlbj8gKGhhc2ggd2l0aCBkYXktb2Ytd2Vlay1pbmRleCAtPiBib29sKVxuXHRcdHZhciBkYXlDbnQgPSAwO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKHRoaXMub3B0KCd3ZWVrZW5kcycpID09PSBmYWxzZSkge1xuXHRcdFx0aGlkZGVuRGF5cy5wdXNoKDAsIDYpOyAvLyAwPXN1bmRheSwgNj1zYXR1cmRheVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcblx0XHRcdGlmIChcblx0XHRcdFx0IShpc0hpZGRlbkRheUhhc2hbaV0gPSAkLmluQXJyYXkoaSwgaGlkZGVuRGF5cykgIT09IC0xKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGRheUNudCsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghZGF5Q250KSB7XG5cdFx0XHR0aHJvdyAnaW52YWxpZCBoaWRkZW5EYXlzJzsgLy8gYWxsIGRheXMgd2VyZSBoaWRkZW4/IGJhZC5cblx0XHR9XG5cblx0XHR0aGlzLmlzSGlkZGVuRGF5SGFzaCA9IGlzSGlkZGVuRGF5SGFzaDtcblx0fSxcblxuXG5cdC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XG5cdC8vIGBkYXlgIGlzIGEgZGF5LW9mLXdlZWsgaW5kZXggKDAtNiksIG9yIGEgTW9tZW50XG5cdGlzSGlkZGVuRGF5OiBmdW5jdGlvbihkYXkpIHtcblx0XHRpZiAobW9tZW50LmlzTW9tZW50KGRheSkpIHtcblx0XHRcdGRheSA9IGRheS5kYXkoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuaXNIaWRkZW5EYXlIYXNoW2RheV07XG5cdH0sXG5cblxuXHQvLyBJbmNyZW1lbnRpbmcgdGhlIGN1cnJlbnQgZGF5IHVudGlsIGl0IGlzIG5vIGxvbmdlciBhIGhpZGRlbiBkYXksIHJldHVybmluZyBhIGNvcHkuXG5cdC8vIERPRVMgTk9UIENPTlNJREVSIHZhbGlkUmFuZ2UhXG5cdC8vIElmIHRoZSBpbml0aWFsIHZhbHVlIG9mIGBkYXRlYCBpcyBub3QgYSBoaWRkZW4gZGF5LCBkb24ndCBkbyBhbnl0aGluZy5cblx0Ly8gUGFzcyBgaXNFeGNsdXNpdmVgIGFzIGB0cnVlYCBpZiB5b3UgYXJlIGRlYWxpbmcgd2l0aCBhbiBlbmQgZGF0ZS5cblx0Ly8gYGluY2AgZGVmYXVsdHMgdG8gYDFgIChpbmNyZW1lbnQgb25lIGRheSBmb3J3YXJkIGVhY2ggdGltZSlcblx0c2tpcEhpZGRlbkRheXM6IGZ1bmN0aW9uKGRhdGUsIGluYywgaXNFeGNsdXNpdmUpIHtcblx0XHR2YXIgb3V0ID0gZGF0ZS5jbG9uZSgpO1xuXHRcdGluYyA9IGluYyB8fCAxO1xuXHRcdHdoaWxlIChcblx0XHRcdHRoaXMuaXNIaWRkZW5EYXlIYXNoWyhvdXQuZGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN11cblx0XHQpIHtcblx0XHRcdG91dC5hZGQoaW5jLCAnZGF5cycpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cbn0pO1xuXG47O1xuXG4vKlxuRW1ib2RpZXMgYSBkaXYgdGhhdCBoYXMgcG90ZW50aWFsIHNjcm9sbGJhcnNcbiovXG52YXIgU2Nyb2xsZXIgPSBGQy5TY3JvbGxlciA9IENsYXNzLmV4dGVuZCh7XG5cblx0ZWw6IG51bGwsIC8vIHRoZSBndWFyYW50ZWVkIG91dGVyIGVsZW1lbnRcblx0c2Nyb2xsRWw6IG51bGwsIC8vIHRoZSBlbGVtZW50IHdpdGggdGhlIHNjcm9sbGJhcnNcblx0b3ZlcmZsb3dYOiBudWxsLFxuXHRvdmVyZmxvd1k6IG51bGwsXG5cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdHRoaXMub3ZlcmZsb3dYID0gb3B0aW9ucy5vdmVyZmxvd1ggfHwgb3B0aW9ucy5vdmVyZmxvdyB8fCAnYXV0byc7XG5cdFx0dGhpcy5vdmVyZmxvd1kgPSBvcHRpb25zLm92ZXJmbG93WSB8fCBvcHRpb25zLm92ZXJmbG93IHx8ICdhdXRvJztcblx0fSxcblxuXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbCA9IHRoaXMucmVuZGVyRWwoKTtcblx0XHR0aGlzLmFwcGx5T3ZlcmZsb3coKTtcblx0fSxcblxuXG5cdHJlbmRlckVsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuc2Nyb2xsRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtc2Nyb2xsZXJcIj48L2Rpdj4nKSk7XG5cdH0sXG5cblxuXHQvLyBzZXRzIHRvIG5hdHVyYWwgaGVpZ2h0LCB1bmxvY2tzIG92ZXJmbG93XG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNldEhlaWdodCgnYXV0bycpO1xuXHRcdHRoaXMuYXBwbHlPdmVyZmxvdygpO1xuXHR9LFxuXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbC5yZW1vdmUoKTtcblx0fSxcblxuXG5cdC8vIE92ZXJmbG93XG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRhcHBseU92ZXJmbG93OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNjcm9sbEVsLmNzcyh7XG5cdFx0XHQnb3ZlcmZsb3cteCc6IHRoaXMub3ZlcmZsb3dYLFxuXHRcdFx0J292ZXJmbG93LXknOiB0aGlzLm92ZXJmbG93WVxuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gQ2F1c2VzIGFueSAnYXV0bycgb3ZlcmZsb3cgdmFsdWVzIHRvIHJlc29sdmVzIHRvICdzY3JvbGwnIG9yICdoaWRkZW4nLlxuXHQvLyBVc2VmdWwgZm9yIHByZXNlcnZpbmcgc2Nyb2xsYmFyIHdpZHRocyByZWdhcmRsZXNzIG9mIGZ1dHVyZSByZXNpemVzLlxuXHQvLyBDYW4gcGFzcyBpbiBzY3JvbGxiYXJXaWR0aHMgZm9yIG9wdGltaXphdGlvbi5cblx0bG9ja092ZXJmbG93OiBmdW5jdGlvbihzY3JvbGxiYXJXaWR0aHMpIHtcblx0XHR2YXIgb3ZlcmZsb3dYID0gdGhpcy5vdmVyZmxvd1g7XG5cdFx0dmFyIG92ZXJmbG93WSA9IHRoaXMub3ZlcmZsb3dZO1xuXG5cdFx0c2Nyb2xsYmFyV2lkdGhzID0gc2Nyb2xsYmFyV2lkdGhzIHx8IHRoaXMuZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XG5cblx0XHRpZiAob3ZlcmZsb3dYID09PSAnYXV0bycpIHtcblx0XHRcdG92ZXJmbG93WCA9IChcblx0XHRcdFx0XHRzY3JvbGxiYXJXaWR0aHMudG9wIHx8IHNjcm9sbGJhcldpZHRocy5ib3R0b20gfHwgLy8gaG9yaXpvbnRhbCBzY3JvbGxiYXJzP1xuXHRcdFx0XHRcdC8vIE9SIHNjcm9sbGluZyBwYW5lIHdpdGggbWFzc2xlc3Mgc2Nyb2xsYmFycz9cblx0XHRcdFx0XHR0aGlzLnNjcm9sbEVsWzBdLnNjcm9sbFdpZHRoIC0gMSA+IHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50V2lkdGhcblx0XHRcdFx0XHRcdC8vIHN1YnRyYWN0IDEgYmVjYXVzZSBvZiBJRSBvZmYtYnktb25lIGlzc3VlXG5cdFx0XHRcdCkgPyAnc2Nyb2xsJyA6ICdoaWRkZW4nO1xuXHRcdH1cblxuXHRcdGlmIChvdmVyZmxvd1kgPT09ICdhdXRvJykge1xuXHRcdFx0b3ZlcmZsb3dZID0gKFxuXHRcdFx0XHRcdHNjcm9sbGJhcldpZHRocy5sZWZ0IHx8IHNjcm9sbGJhcldpZHRocy5yaWdodCB8fCAvLyB2ZXJ0aWNhbCBzY3JvbGxiYXJzP1xuXHRcdFx0XHRcdC8vIE9SIHNjcm9sbGluZyBwYW5lIHdpdGggbWFzc2xlc3Mgc2Nyb2xsYmFycz9cblx0XHRcdFx0XHR0aGlzLnNjcm9sbEVsWzBdLnNjcm9sbEhlaWdodCAtIDEgPiB0aGlzLnNjcm9sbEVsWzBdLmNsaWVudEhlaWdodFxuXHRcdFx0XHRcdFx0Ly8gc3VidHJhY3QgMSBiZWNhdXNlIG9mIElFIG9mZi1ieS1vbmUgaXNzdWVcblx0XHRcdFx0KSA/ICdzY3JvbGwnIDogJ2hpZGRlbic7XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxFbC5jc3MoeyAnb3ZlcmZsb3cteCc6IG92ZXJmbG93WCwgJ292ZXJmbG93LXknOiBvdmVyZmxvd1kgfSk7XG5cdH0sXG5cblxuXHQvLyBHZXR0ZXJzIC8gU2V0dGVyc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0c2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcblx0XHR0aGlzLnNjcm9sbEVsLmhlaWdodChoZWlnaHQpO1xuXHR9LFxuXG5cblx0Z2V0U2Nyb2xsVG9wOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5zY3JvbGxFbC5zY3JvbGxUb3AoKTtcblx0fSxcblxuXG5cdHNldFNjcm9sbFRvcDogZnVuY3Rpb24odG9wKSB7XG5cdFx0dGhpcy5zY3JvbGxFbC5zY3JvbGxUb3AodG9wKTtcblx0fSxcblxuXG5cdGdldENsaWVudFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRXaWR0aDtcblx0fSxcblxuXG5cdGdldENsaWVudEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50SGVpZ2h0O1xuXHR9LFxuXG5cblx0Z2V0U2Nyb2xsYmFyV2lkdGhzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZ2V0U2Nyb2xsYmFyV2lkdGhzKHRoaXMuc2Nyb2xsRWwpO1xuXHR9XG5cbn0pO1xuXG47O1xuZnVuY3Rpb24gSXRlcmF0b3IoaXRlbXMpIHtcbiAgICB0aGlzLml0ZW1zID0gaXRlbXMgfHwgW107XG59XG5cblxuLyogQ2FsbHMgYSBtZXRob2Qgb24gZXZlcnkgaXRlbSBwYXNzaW5nIHRoZSBhcmd1bWVudHMgdGhyb3VnaCAqL1xuSXRlcmF0b3IucHJvdG90eXBlLnByb3h5Q2FsbCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChpdGVtW21ldGhvZE5hbWVdLmFwcGx5KGl0ZW0sIGFyZ3MpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuOztcblxuLyogVG9vbGJhciB3aXRoIGJ1dHRvbnMgYW5kIHRpdGxlXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZnVuY3Rpb24gVG9vbGJhcihjYWxlbmRhciwgdG9vbGJhck9wdGlvbnMpIHtcblx0dmFyIHQgPSB0aGlzO1xuXG5cdC8vIGV4cG9ydHNcblx0dC5zZXRUb29sYmFyT3B0aW9ucyA9IHNldFRvb2xiYXJPcHRpb25zO1xuXHR0LnJlbmRlciA9IHJlbmRlcjtcblx0dC5yZW1vdmVFbGVtZW50ID0gcmVtb3ZlRWxlbWVudDtcblx0dC51cGRhdGVUaXRsZSA9IHVwZGF0ZVRpdGxlO1xuXHR0LmFjdGl2YXRlQnV0dG9uID0gYWN0aXZhdGVCdXR0b247XG5cdHQuZGVhY3RpdmF0ZUJ1dHRvbiA9IGRlYWN0aXZhdGVCdXR0b247XG5cdHQuZGlzYWJsZUJ1dHRvbiA9IGRpc2FibGVCdXR0b247XG5cdHQuZW5hYmxlQnV0dG9uID0gZW5hYmxlQnV0dG9uO1xuXHR0LmdldFZpZXdzV2l0aEJ1dHRvbnMgPSBnZXRWaWV3c1dpdGhCdXR0b25zO1xuXHR0LmVsID0gbnVsbDsgLy8gbWlycm9ycyBsb2NhbCBgZWxgXG5cblx0Ly8gbG9jYWxzXG5cdHZhciBlbDtcblx0dmFyIHZpZXdzV2l0aEJ1dHRvbnMgPSBbXTtcblx0dmFyIHRtO1xuXG5cdC8vIG1ldGhvZCB0byB1cGRhdGUgdG9vbGJhci1zcGVjaWZpYyBvcHRpb25zLCBub3QgY2FsZW5kYXItd2lkZSBvcHRpb25zXG5cdGZ1bmN0aW9uIHNldFRvb2xiYXJPcHRpb25zKG5ld1Rvb2xiYXJPcHRpb25zKSB7XG5cdFx0dG9vbGJhck9wdGlvbnMgPSBuZXdUb29sYmFyT3B0aW9ucztcblx0fVxuXG5cdC8vIGNhbiBiZSBjYWxsZWQgcmVwZWF0ZWRseSBhbmQgd2lsbCByZXJlbmRlclxuXHRmdW5jdGlvbiByZW5kZXIoKSB7XG5cdFx0dmFyIHNlY3Rpb25zID0gdG9vbGJhck9wdGlvbnMubGF5b3V0O1xuXG5cdFx0dG0gPSBjYWxlbmRhci5vcHQoJ3RoZW1lJykgPyAndWknIDogJ2ZjJztcblxuXHRcdGlmIChzZWN0aW9ucykge1xuXHRcdFx0aWYgKCFlbCkge1xuXHRcdFx0XHRlbCA9IHRoaXMuZWwgPSAkKFwiPGRpdiBjbGFzcz0nZmMtdG9vbGJhciBcIisgdG9vbGJhck9wdGlvbnMuZXh0cmFDbGFzc2VzICsgXCInLz5cIik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZWwuZW1wdHkoKTtcblx0XHRcdH1cblx0XHRcdGVsLmFwcGVuZChyZW5kZXJTZWN0aW9uKCdsZWZ0JykpXG5cdFx0XHRcdC5hcHBlbmQocmVuZGVyU2VjdGlvbigncmlnaHQnKSlcblx0XHRcdFx0LmFwcGVuZChyZW5kZXJTZWN0aW9uKCdjZW50ZXInKSlcblx0XHRcdFx0LmFwcGVuZCgnPGRpdiBjbGFzcz1cImZjLWNsZWFyXCIvPicpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJlbW92ZUVsZW1lbnQoKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoKSB7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRlbC5yZW1vdmUoKTtcblx0XHRcdGVsID0gdC5lbCA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiByZW5kZXJTZWN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0dmFyIHNlY3Rpb25FbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy0nICsgcG9zaXRpb24gKyAnXCIvPicpO1xuXHRcdHZhciBidXR0b25TdHIgPSB0b29sYmFyT3B0aW9ucy5sYXlvdXRbcG9zaXRpb25dO1xuXHRcdHZhciBjYWxlbmRhckN1c3RvbUJ1dHRvbnMgPSBjYWxlbmRhci5vcHQoJ2N1c3RvbUJ1dHRvbnMnKSB8fCB7fTtcblx0XHR2YXIgY2FsZW5kYXJCdXR0b25UZXh0ID0gY2FsZW5kYXIub3B0KCdidXR0b25UZXh0JykgfHwge307XG5cblx0XHRpZiAoYnV0dG9uU3RyKSB7XG5cdFx0XHQkLmVhY2goYnV0dG9uU3RyLnNwbGl0KCcgJyksIGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0dmFyIGdyb3VwQ2hpbGRyZW4gPSAkKCk7XG5cdFx0XHRcdHZhciBpc09ubHlCdXR0b25zID0gdHJ1ZTtcblx0XHRcdFx0dmFyIGdyb3VwRWw7XG5cblx0XHRcdFx0JC5lYWNoKHRoaXMuc3BsaXQoJywnKSwgZnVuY3Rpb24oaiwgYnV0dG9uTmFtZSkge1xuXHRcdFx0XHRcdHZhciBjdXN0b21CdXR0b25Qcm9wcztcblx0XHRcdFx0XHR2YXIgdmlld1NwZWM7XG5cdFx0XHRcdFx0dmFyIGJ1dHRvbkNsaWNrO1xuXHRcdFx0XHRcdHZhciBvdmVycmlkZVRleHQ7IC8vIHRleHQgZXhwbGljaXRseSBzZXQgYnkgY2FsZW5kYXIncyBjb25zdHJ1Y3RvciBvcHRpb25zLiBvdmVyY29tZXMgaWNvbnNcblx0XHRcdFx0XHR2YXIgZGVmYXVsdFRleHQ7XG5cdFx0XHRcdFx0dmFyIHRoZW1lSWNvbjtcblx0XHRcdFx0XHR2YXIgbm9ybWFsSWNvbjtcblx0XHRcdFx0XHR2YXIgaW5uZXJIdG1sO1xuXHRcdFx0XHRcdHZhciBjbGFzc2VzO1xuXHRcdFx0XHRcdHZhciBidXR0b247IC8vIHRoZSBlbGVtZW50XG5cblx0XHRcdFx0XHRpZiAoYnV0dG9uTmFtZSA9PSAndGl0bGUnKSB7XG5cdFx0XHRcdFx0XHRncm91cENoaWxkcmVuID0gZ3JvdXBDaGlsZHJlbi5hZGQoJCgnPGgyPiZuYnNwOzwvaDI+JykpOyAvLyB3ZSBhbHdheXMgd2FudCBpdCB0byB0YWtlIHVwIGhlaWdodFxuXHRcdFx0XHRcdFx0aXNPbmx5QnV0dG9ucyA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGlmICgoY3VzdG9tQnV0dG9uUHJvcHMgPSBjYWxlbmRhckN1c3RvbUJ1dHRvbnNbYnV0dG9uTmFtZV0pKSB7XG5cdFx0XHRcdFx0XHRcdGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2spIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrLmNhbGwoYnV0dG9uWzBdLCBldik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRvdmVycmlkZVRleHQgPSAnJzsgLy8gaWNvbnMgd2lsbCBvdmVycmlkZSB0ZXh0XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRUZXh0ID0gY3VzdG9tQnV0dG9uUHJvcHMudGV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKCh2aWV3U3BlYyA9IGNhbGVuZGFyLmdldFZpZXdTcGVjKGJ1dHRvbk5hbWUpKSkge1xuXHRcdFx0XHRcdFx0XHRidXR0b25DbGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGNhbGVuZGFyLmNoYW5nZVZpZXcoYnV0dG9uTmFtZSk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdHZpZXdzV2l0aEJ1dHRvbnMucHVzaChidXR0b25OYW1lKTtcblx0XHRcdFx0XHRcdFx0b3ZlcnJpZGVUZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dE92ZXJyaWRlO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoY2FsZW5kYXJbYnV0dG9uTmFtZV0pIHsgLy8gYSBjYWxlbmRhciBtZXRob2Rcblx0XHRcdFx0XHRcdFx0YnV0dG9uQ2xpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRjYWxlbmRhcltidXR0b25OYW1lXSgpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRvdmVycmlkZVRleHQgPSAoY2FsZW5kYXIub3ZlcnJpZGVzLmJ1dHRvblRleHQgfHwge30pW2J1dHRvbk5hbWVdO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXTsgLy8gZXZlcnl0aGluZyBlbHNlIGlzIGNvbnNpZGVyZWQgZGVmYXVsdFxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoYnV0dG9uQ2xpY2spIHtcblxuXHRcdFx0XHRcdFx0XHR0aGVtZUljb24gPVxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUJ1dHRvblByb3BzID9cblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUJ1dHRvblByb3BzLnRoZW1lSWNvbiA6XG5cdFx0XHRcdFx0XHRcdFx0XHRjYWxlbmRhci5vcHQoJ3RoZW1lQnV0dG9uSWNvbnMnKVtidXR0b25OYW1lXTtcblxuXHRcdFx0XHRcdFx0XHRub3JtYWxJY29uID1cblx0XHRcdFx0XHRcdFx0XHRjdXN0b21CdXR0b25Qcm9wcyA/XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21CdXR0b25Qcm9wcy5pY29uIDpcblx0XHRcdFx0XHRcdFx0XHRcdGNhbGVuZGFyLm9wdCgnYnV0dG9uSWNvbnMnKVtidXR0b25OYW1lXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAob3ZlcnJpZGVUZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXJIdG1sID0gaHRtbEVzY2FwZShvdmVycmlkZVRleHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYgKHRoZW1lSWNvbiAmJiBjYWxlbmRhci5vcHQoJ3RoZW1lJykpIHtcblx0XHRcdFx0XHRcdFx0XHRpbm5lckh0bWwgPSBcIjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tXCIgKyB0aGVtZUljb24gKyBcIic+PC9zcGFuPlwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYgKG5vcm1hbEljb24gJiYgIWNhbGVuZGFyLm9wdCgndGhlbWUnKSkge1xuXHRcdFx0XHRcdFx0XHRcdGlubmVySHRtbCA9IFwiPHNwYW4gY2xhc3M9J2ZjLWljb24gZmMtaWNvbi1cIiArIG5vcm1hbEljb24gKyBcIic+PC9zcGFuPlwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlubmVySHRtbCA9IGh0bWxFc2NhcGUoZGVmYXVsdFRleHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Y2xhc3NlcyA9IFtcblx0XHRcdFx0XHRcdFx0XHQnZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicsXG5cdFx0XHRcdFx0XHRcdFx0dG0gKyAnLWJ1dHRvbicsXG5cdFx0XHRcdFx0XHRcdFx0dG0gKyAnLXN0YXRlLWRlZmF1bHQnXG5cdFx0XHRcdFx0XHRcdF07XG5cblx0XHRcdFx0XHRcdFx0YnV0dG9uID0gJCggLy8gdHlwZT1cImJ1dHRvblwiIHNvIHRoYXQgaXQgZG9lc24ndCBzdWJtaXQgYSBmb3JtXG5cdFx0XHRcdFx0XHRcdFx0JzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiPicgK1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5uZXJIdG1sICtcblx0XHRcdFx0XHRcdFx0XHQnPC9idXR0b24+J1xuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0XHQuY2xpY2soZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGRvbid0IHByb2Nlc3MgY2xpY2tzIGZvciBkaXNhYmxlZCBidXR0b25zXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIWJ1dHRvbi5oYXNDbGFzcyh0bSArICctc3RhdGUtZGlzYWJsZWQnKSkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ1dHRvbkNsaWNrKGV2KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhZnRlciB0aGUgY2xpY2sgYWN0aW9uLCBpZiB0aGUgYnV0dG9uIGJlY29tZXMgdGhlIFwiYWN0aXZlXCIgdGFiLCBvciBkaXNhYmxlZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaXQgc2hvdWxkIG5ldmVyIGhhdmUgYSBob3ZlciBjbGFzcywgc28gcmVtb3ZlIGl0IG5vdy5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJ1dHRvbi5oYXNDbGFzcyh0bSArICctc3RhdGUtYWN0aXZlJykgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRidXR0b24uaGFzQ2xhc3ModG0gKyAnLXN0YXRlLWRpc2FibGVkJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnV0dG9uLnJlbW92ZUNsYXNzKHRtICsgJy1zdGF0ZS1ob3ZlcicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0XHQubW91c2Vkb3duKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdGhlICpkb3duKiBlZmZlY3QgKG1vdXNlIHByZXNzZWQgaW4pLlxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gb25seSBvbiBidXR0b25zIHRoYXQgYXJlIG5vdCB0aGUgXCJhY3RpdmVcIiB0YWIsIG9yIGRpc2FibGVkXG5cdFx0XHRcdFx0XHRcdFx0XHRidXR0b25cblx0XHRcdFx0XHRcdFx0XHRcdFx0Lm5vdCgnLicgKyB0bSArICctc3RhdGUtYWN0aXZlJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Lm5vdCgnLicgKyB0bSArICctc3RhdGUtZGlzYWJsZWQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3ModG0gKyAnLXN0YXRlLWRvd24nKTtcblx0XHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHRcdC5tb3VzZXVwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdW5kbyB0aGUgKmRvd24qIGVmZmVjdFxuXHRcdFx0XHRcdFx0XHRcdFx0YnV0dG9uLnJlbW92ZUNsYXNzKHRtICsgJy1zdGF0ZS1kb3duJyk7XG5cdFx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0XHQuaG92ZXIoXG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gdGhlICpob3ZlciogZWZmZWN0LlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBvbmx5IG9uIGJ1dHRvbnMgdGhhdCBhcmUgbm90IHRoZSBcImFjdGl2ZVwiIHRhYiwgb3IgZGlzYWJsZWRcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnV0dG9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Lm5vdCgnLicgKyB0bSArICctc3RhdGUtYWN0aXZlJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQubm90KCcuJyArIHRtICsgJy1zdGF0ZS1kaXNhYmxlZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LmFkZENsYXNzKHRtICsgJy1zdGF0ZS1ob3ZlcicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyB1bmRvIHRoZSAqaG92ZXIqIGVmZmVjdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRidXR0b25cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3ModG0gKyAnLXN0YXRlLWhvdmVyJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3ModG0gKyAnLXN0YXRlLWRvd24nKTsgLy8gaWYgbW91c2VsZWF2ZSBoYXBwZW5zIGJlZm9yZSBtb3VzZXVwXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRncm91cENoaWxkcmVuID0gZ3JvdXBDaGlsZHJlbi5hZGQoYnV0dG9uKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChpc09ubHlCdXR0b25zKSB7XG5cdFx0XHRcdFx0Z3JvdXBDaGlsZHJlblxuXHRcdFx0XHRcdFx0LmZpcnN0KCkuYWRkQ2xhc3ModG0gKyAnLWNvcm5lci1sZWZ0JykuZW5kKClcblx0XHRcdFx0XHRcdC5sYXN0KCkuYWRkQ2xhc3ModG0gKyAnLWNvcm5lci1yaWdodCcpLmVuZCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGdyb3VwQ2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGdyb3VwRWwgPSAkKCc8ZGl2Lz4nKTtcblx0XHRcdFx0XHRpZiAoaXNPbmx5QnV0dG9ucykge1xuXHRcdFx0XHRcdFx0Z3JvdXBFbC5hZGRDbGFzcygnZmMtYnV0dG9uLWdyb3VwJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGdyb3VwRWwuYXBwZW5kKGdyb3VwQ2hpbGRyZW4pO1xuXHRcdFx0XHRcdHNlY3Rpb25FbC5hcHBlbmQoZ3JvdXBFbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0c2VjdGlvbkVsLmFwcGVuZChncm91cENoaWxkcmVuKTsgLy8gMSBvciAwIGNoaWxkcmVuXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWN0aW9uRWw7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVRpdGxlKHRleHQpIHtcblx0XHRpZiAoZWwpIHtcblx0XHRcdGVsLmZpbmQoJ2gyJykudGV4dCh0ZXh0KTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGFjdGl2YXRlQnV0dG9uKGJ1dHRvbk5hbWUpIHtcblx0XHRpZiAoZWwpIHtcblx0XHRcdGVsLmZpbmQoJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJylcblx0XHRcdFx0LmFkZENsYXNzKHRtICsgJy1zdGF0ZS1hY3RpdmUnKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGRlYWN0aXZhdGVCdXR0b24oYnV0dG9uTmFtZSkge1xuXHRcdGlmIChlbCkge1xuXHRcdFx0ZWwuZmluZCgnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3ModG0gKyAnLXN0YXRlLWFjdGl2ZScpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gZGlzYWJsZUJ1dHRvbihidXR0b25OYW1lKSB7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRlbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXG5cdFx0XHRcdC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpXG5cdFx0XHRcdC5hZGRDbGFzcyh0bSArICctc3RhdGUtZGlzYWJsZWQnKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGVuYWJsZUJ1dHRvbihidXR0b25OYW1lKSB7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRlbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXG5cdFx0XHRcdC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3ModG0gKyAnLXN0YXRlLWRpc2FibGVkJyk7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBnZXRWaWV3c1dpdGhCdXR0b25zKCkge1xuXHRcdHJldHVybiB2aWV3c1dpdGhCdXR0b25zO1xuXHR9XG5cbn1cblxuOztcblxudmFyIENhbGVuZGFyID0gRkMuQ2FsZW5kYXIgPSBDbGFzcy5leHRlbmQoRW1pdHRlck1peGluLCB7XG5cblx0dmlldzogbnVsbCwgLy8gY3VycmVudCBWaWV3IG9iamVjdFxuXHR2aWV3c0J5VHlwZTogbnVsbCwgLy8gaG9sZHMgYWxsIGluc3RhbnRpYXRlZCB2aWV3IGluc3RhbmNlcywgY3VycmVudCBvciBub3Rcblx0Y3VycmVudERhdGU6IG51bGwsIC8vIHVuem9uZWQgbW9tZW50LiBwcml2YXRlIChwdWJsaWMgQVBJIHNob3VsZCB1c2UgZ2V0RGF0ZSBpbnN0ZWFkKVxuXHRsb2FkaW5nTGV2ZWw6IDAsIC8vIG51bWJlciBvZiBzaW11bHRhbmVvdXMgbG9hZGluZyB0YXNrc1xuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKGVsLCBvdmVycmlkZXMpIHtcblxuXHRcdC8vIGRlY2xhcmUgdGhlIGN1cnJlbnQgY2FsZW5kYXIgaW5zdGFuY2UgcmVsaWVzIG9uIEdsb2JhbEVtaXR0ZXIuIG5lZWRlZCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuXHRcdC8vIHVubmVlZGVkKCkgaXMgY2FsbGVkIGluIGRlc3Ryb3kuXG5cdFx0R2xvYmFsRW1pdHRlci5uZWVkZWQoKTtcblxuXHRcdHRoaXMuZWwgPSBlbDtcblx0XHR0aGlzLnZpZXdzQnlUeXBlID0ge307XG5cdFx0dGhpcy52aWV3U3BlY0NhY2hlID0ge307XG5cblx0XHR0aGlzLmluaXRPcHRpb25zSW50ZXJuYWxzKG92ZXJyaWRlcyk7XG5cdFx0dGhpcy5pbml0TW9tZW50SW50ZXJuYWxzKCk7IC8vIG5lZWRzIHRvIGhhcHBlbiBhZnRlciBvcHRpb25zIGhhc2ggaW5pdGlhbGl6ZWRcblx0XHR0aGlzLmluaXRDdXJyZW50RGF0ZSgpO1xuXG5cdFx0RXZlbnRNYW5hZ2VyLmNhbGwodGhpcyk7IC8vIG5lZWRzIG9wdGlvbnMgaW1tZWRpYXRlbHlcblx0XHR0aGlzLmluaXRpYWxpemUoKTtcblx0fSxcblxuXG5cdC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uIGxvZ2ljIGFmdGVyIHRoZSBjb25zdHJ1Y3RvciBoYXMgYmVlbiBjYWxsZWRcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdH0sXG5cblxuXHQvLyBQdWJsaWMgQVBJXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRnZXRDYWxlbmRhcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy52aWV3O1xuXHR9LFxuXG5cblx0cHVibGljbHlUcmlnZ2VyOiBmdW5jdGlvbihuYW1lLCB0aGlzT2JqKSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHRcdHZhciBvcHRIYW5kbGVyID0gdGhpcy5vcHQobmFtZSk7XG5cblx0XHR0aGlzT2JqID0gdGhpc09iaiB8fCB0aGlzLmVsWzBdO1xuXHRcdHRoaXMudHJpZ2dlcldpdGgobmFtZSwgdGhpc09iaiwgYXJncyk7IC8vIEVtaXR0ZXIncyBtZXRob2RcblxuXHRcdGlmIChvcHRIYW5kbGVyKSB7XG5cdFx0XHRyZXR1cm4gb3B0SGFuZGxlci5hcHBseSh0aGlzT2JqLCBhcmdzKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBWaWV3XG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHQvLyBHaXZlbiBhIHZpZXcgbmFtZSBmb3IgYSBjdXN0b20gdmlldyBvciBhIHN0YW5kYXJkIHZpZXcsIGNyZWF0ZXMgYSByZWFkeS10by1nbyBWaWV3IG9iamVjdFxuXHRpbnN0YW50aWF0ZVZpZXc6IGZ1bmN0aW9uKHZpZXdUeXBlKSB7XG5cdFx0dmFyIHNwZWMgPSB0aGlzLmdldFZpZXdTcGVjKHZpZXdUeXBlKTtcblxuXHRcdHJldHVybiBuZXcgc3BlY1snY2xhc3MnXSh0aGlzLCBzcGVjKTtcblx0fSxcblxuXG5cdC8vIFJldHVybnMgYSBib29sZWFuIGFib3V0IHdoZXRoZXIgdGhlIHZpZXcgaXMgb2theSB0byBpbnN0YW50aWF0ZSBhdCBzb21lIHBvaW50XG5cdGlzVmFsaWRWaWV3VHlwZTogZnVuY3Rpb24odmlld1R5cGUpIHtcblx0XHRyZXR1cm4gQm9vbGVhbih0aGlzLmdldFZpZXdTcGVjKHZpZXdUeXBlKSk7XG5cdH0sXG5cblxuXHRjaGFuZ2VWaWV3OiBmdW5jdGlvbih2aWV3TmFtZSwgZGF0ZU9yUmFuZ2UpIHtcblxuXHRcdGlmIChkYXRlT3JSYW5nZSkge1xuXG5cdFx0XHRpZiAoZGF0ZU9yUmFuZ2Uuc3RhcnQgJiYgZGF0ZU9yUmFuZ2UuZW5kKSB7IC8vIGEgcmFuZ2Vcblx0XHRcdFx0dGhpcy5yZWNvcmRPcHRpb25PdmVycmlkZXMoeyAvLyB3aWxsIG5vdCByZXJlbmRlclxuXHRcdFx0XHRcdHZpc2libGVSYW5nZTogZGF0ZU9yUmFuZ2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHsgLy8gYSBkYXRlXG5cdFx0XHRcdHRoaXMuY3VycmVudERhdGUgPSB0aGlzLm1vbWVudChkYXRlT3JSYW5nZSkuc3RyaXBab25lKCk7IC8vIGp1c3QgbGlrZSBnb3RvRGF0ZVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMucmVuZGVyVmlldyh2aWV3TmFtZSk7XG5cdH0sXG5cblxuXHQvLyBGb3JjZXMgbmF2aWdhdGlvbiB0byBhIHZpZXcgZm9yIHRoZSBnaXZlbiBkYXRlLlxuXHQvLyBgdmlld1R5cGVgIGNhbiBiZSBhIHNwZWNpZmljIHZpZXcgbmFtZSBvciBhIGdlbmVyaWMgb25lIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIi5cblx0em9vbVRvOiBmdW5jdGlvbihuZXdEYXRlLCB2aWV3VHlwZSkge1xuXHRcdHZhciBzcGVjO1xuXG5cdFx0dmlld1R5cGUgPSB2aWV3VHlwZSB8fCAnZGF5JzsgLy8gZGF5IGlzIGRlZmF1bHQgem9vbVxuXHRcdHNwZWMgPSB0aGlzLmdldFZpZXdTcGVjKHZpZXdUeXBlKSB8fCB0aGlzLmdldFVuaXRWaWV3U3BlYyh2aWV3VHlwZSk7XG5cblx0XHR0aGlzLmN1cnJlbnREYXRlID0gbmV3RGF0ZS5jbG9uZSgpO1xuXHRcdHRoaXMucmVuZGVyVmlldyhzcGVjID8gc3BlYy50eXBlIDogbnVsbCk7XG5cdH0sXG5cblxuXHQvLyBDdXJyZW50IERhdGVcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdGluaXRDdXJyZW50RGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlZmF1bHREYXRlSW5wdXQgPSB0aGlzLm9wdCgnZGVmYXVsdERhdGUnKTtcblxuXHRcdC8vIGNvbXB1dGUgdGhlIGluaXRpYWwgYW1iaWctdGltZXpvbmUgZGF0ZVxuXHRcdGlmIChkZWZhdWx0RGF0ZUlucHV0ICE9IG51bGwpIHtcblx0XHRcdHRoaXMuY3VycmVudERhdGUgPSB0aGlzLm1vbWVudChkZWZhdWx0RGF0ZUlucHV0KS5zdHJpcFpvbmUoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5nZXROb3coKTsgLy8gZ2V0Tm93IGFscmVhZHkgcmV0dXJucyB1bnpvbmVkXG5cdFx0fVxuXHR9LFxuXG5cblx0cHJldjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZXZJbmZvID0gdGhpcy52aWV3LmJ1aWxkUHJldkRhdGVQcm9maWxlKHRoaXMuY3VycmVudERhdGUpO1xuXG5cdFx0aWYgKHByZXZJbmZvLmlzVmFsaWQpIHtcblx0XHRcdHRoaXMuY3VycmVudERhdGUgPSBwcmV2SW5mby5kYXRlO1xuXHRcdFx0dGhpcy5yZW5kZXJWaWV3KCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0bmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5leHRJbmZvID0gdGhpcy52aWV3LmJ1aWxkTmV4dERhdGVQcm9maWxlKHRoaXMuY3VycmVudERhdGUpO1xuXG5cdFx0aWYgKG5leHRJbmZvLmlzVmFsaWQpIHtcblx0XHRcdHRoaXMuY3VycmVudERhdGUgPSBuZXh0SW5mby5kYXRlO1xuXHRcdFx0dGhpcy5yZW5kZXJWaWV3KCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0cHJldlllYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY3VycmVudERhdGUuYWRkKC0xLCAneWVhcnMnKTtcblx0XHR0aGlzLnJlbmRlclZpZXcoKTtcblx0fSxcblxuXG5cdG5leHRZZWFyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmN1cnJlbnREYXRlLmFkZCgxLCAneWVhcnMnKTtcblx0XHR0aGlzLnJlbmRlclZpZXcoKTtcblx0fSxcblxuXG5cdHRvZGF5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5nZXROb3coKTsgLy8gc2hvdWxkIGRlbnkgbGlrZSBwcmV2L25leHQ/XG5cdFx0dGhpcy5yZW5kZXJWaWV3KCk7XG5cdH0sXG5cblxuXHRnb3RvRGF0ZTogZnVuY3Rpb24oem9uZWREYXRlSW5wdXQpIHtcblx0XHR0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5tb21lbnQoem9uZWREYXRlSW5wdXQpLnN0cmlwWm9uZSgpO1xuXHRcdHRoaXMucmVuZGVyVmlldygpO1xuXHR9LFxuXG5cblx0aW5jcmVtZW50RGF0ZTogZnVuY3Rpb24oZGVsdGEpIHtcblx0XHR0aGlzLmN1cnJlbnREYXRlLmFkZChtb21lbnQuZHVyYXRpb24oZGVsdGEpKTtcblx0XHR0aGlzLnJlbmRlclZpZXcoKTtcblx0fSxcblxuXG5cdC8vIGZvciBleHRlcm5hbCBBUElcblx0Z2V0RGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlUaW1lem9uZSh0aGlzLmN1cnJlbnREYXRlKTsgLy8gaW5mdXNlIHRoZSBjYWxlbmRhcidzIHRpbWV6b25lXG5cdH0sXG5cblxuXHQvLyBMb2FkaW5nIFRyaWdnZXJpbmdcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdC8vIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBhbnkgdHlwZSBvZiBhc3luYyBkYXRhIGZldGNoaW5nIGJlZ2luc1xuXHRwdXNoTG9hZGluZzogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCEodGhpcy5sb2FkaW5nTGV2ZWwrKykpIHtcblx0XHRcdHRoaXMucHVibGljbHlUcmlnZ2VyKCdsb2FkaW5nJywgbnVsbCwgdHJ1ZSwgdGhpcy52aWV3KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBTaG91bGQgYmUgY2FsbGVkIHdoZW4gYW55IHR5cGUgb2YgYXN5bmMgZGF0YSBmZXRjaGluZyBjb21wbGV0ZXNcblx0cG9wTG9hZGluZzogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCEoLS10aGlzLmxvYWRpbmdMZXZlbCkpIHtcblx0XHRcdHRoaXMucHVibGljbHlUcmlnZ2VyKCdsb2FkaW5nJywgbnVsbCwgZmFsc2UsIHRoaXMudmlldyk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gU2VsZWN0aW9uXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHQvLyB0aGlzIHB1YmxpYyBtZXRob2QgcmVjZWl2ZXMgc3RhcnQvZW5kIGRhdGVzIGluIGFueSBmb3JtYXQsIHdpdGggYW55IHRpbWV6b25lXG5cdHNlbGVjdDogZnVuY3Rpb24oem9uZWRTdGFydElucHV0LCB6b25lZEVuZElucHV0KSB7XG5cdFx0dGhpcy52aWV3LnNlbGVjdChcblx0XHRcdHRoaXMuYnVpbGRTZWxlY3RTcGFuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblx0XHQpO1xuXHR9LFxuXG5cblx0dW5zZWxlY3Q6IGZ1bmN0aW9uKCkgeyAvLyBzYWZlIHRvIGJlIGNhbGxlZCBiZWZvcmUgcmVuZGVyVmlld1xuXHRcdGlmICh0aGlzLnZpZXcpIHtcblx0XHRcdHRoaXMudmlldy51bnNlbGVjdCgpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEdpdmVuIGFyZ3VtZW50cyB0byB0aGUgc2VsZWN0IG1ldGhvZCBpbiB0aGUgQVBJLCByZXR1cm5zIGEgc3BhbiAodW56b25lZCBzdGFydC9lbmQgYW5kIG90aGVyIGluZm8pXG5cdGJ1aWxkU2VsZWN0U3BhbjogZnVuY3Rpb24oem9uZWRTdGFydElucHV0LCB6b25lZEVuZElucHV0KSB7XG5cdFx0dmFyIHN0YXJ0ID0gdGhpcy5tb21lbnQoem9uZWRTdGFydElucHV0KS5zdHJpcFpvbmUoKTtcblx0XHR2YXIgZW5kO1xuXG5cdFx0aWYgKHpvbmVkRW5kSW5wdXQpIHtcblx0XHRcdGVuZCA9IHRoaXMubW9tZW50KHpvbmVkRW5kSW5wdXQpLnN0cmlwWm9uZSgpO1xuXHRcdH1cblx0XHRlbHNlIGlmIChzdGFydC5oYXNUaW1lKCkpIHtcblx0XHRcdGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKHRoaXMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbik7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQodGhpcy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuXHR9LFxuXG5cblx0Ly8gTWlzY1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gd2lsbCByZXR1cm4gYG51bGxgIGlmIGludmFsaWQgcmFuZ2Vcblx0cGFyc2VSYW5nZTogZnVuY3Rpb24ocmFuZ2VJbnB1dCkge1xuXHRcdHZhciBzdGFydCA9IG51bGw7XG5cdFx0dmFyIGVuZCA9IG51bGw7XG5cblx0XHRpZiAocmFuZ2VJbnB1dC5zdGFydCkge1xuXHRcdFx0c3RhcnQgPSB0aGlzLm1vbWVudChyYW5nZUlucHV0LnN0YXJ0KS5zdHJpcFpvbmUoKTtcblx0XHR9XG5cblx0XHRpZiAocmFuZ2VJbnB1dC5lbmQpIHtcblx0XHRcdGVuZCA9IHRoaXMubW9tZW50KHJhbmdlSW5wdXQuZW5kKS5zdHJpcFpvbmUoKTtcblx0XHR9XG5cblx0XHRpZiAoIXN0YXJ0ICYmICFlbmQpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChzdGFydCAmJiBlbmQgJiYgZW5kLmlzQmVmb3JlKHN0YXJ0KSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuXHR9LFxuXG5cblx0cmVyZW5kZXJFdmVudHM6IGZ1bmN0aW9uKCkgeyAvLyBBUEkgbWV0aG9kLiBkZXN0cm95cyBvbGQgZXZlbnRzIGlmIHByZXZpb3VzbHkgcmVuZGVyZWQuXG5cdFx0aWYgKHRoaXMuZWxlbWVudFZpc2libGUoKSkge1xuXHRcdFx0dGhpcy5yZXBvcnRFdmVudENoYW5nZSgpOyAvLyB3aWxsIHJlLXRyYXNtaXQgZXZlbnRzIHRvIHRoZSB2aWV3LCBjYXVzaW5nIGEgcmVyZW5kZXJcblx0XHR9XG5cdH1cblxufSk7XG5cbjs7XG4vKlxuT3B0aW9ucyBiaW5kaW5nL3RyaWdnZXJpbmcgc3lzdGVtLlxuKi9cbkNhbGVuZGFyLm1peGluKHtcblxuXHRkaXJEZWZhdWx0czogbnVsbCwgLy8gb3B0aW9uIGRlZmF1bHRzIHJlbGF0ZWQgdG8gTFRSIG9yIFJUTFxuXHRsb2NhbGVEZWZhdWx0czogbnVsbCwgLy8gb3B0aW9uIGRlZmF1bHRzIHJlbGF0ZWQgdG8gY3VycmVudCBsb2NhbGVcblx0b3ZlcnJpZGVzOiBudWxsLCAvLyBvcHRpb24gb3ZlcnJpZGVzIGdpdmVuIHRvIHRoZSBmdWxsQ2FsZW5kYXIgY29uc3RydWN0b3Jcblx0ZHluYW1pY092ZXJyaWRlczogbnVsbCwgLy8gb3B0aW9ucyBzZXQgd2l0aCBkeW5hbWljIHNldHRlciBtZXRob2QuIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gdmlldyBvdmVycmlkZXMuXG5cdG9wdGlvbnNNb2RlbDogbnVsbCwgLy8gYWxsIGRlZmF1bHRzIGNvbWJpbmVkIHdpdGggb3ZlcnJpZGVzXG5cblxuXHRpbml0T3B0aW9uc0ludGVybmFsczogZnVuY3Rpb24ob3ZlcnJpZGVzKSB7XG5cdFx0dGhpcy5vdmVycmlkZXMgPSAkLmV4dGVuZCh7fSwgb3ZlcnJpZGVzKTsgLy8gbWFrZSBhIGNvcHlcblx0XHR0aGlzLmR5bmFtaWNPdmVycmlkZXMgPSB7fTtcblx0XHR0aGlzLm9wdGlvbnNNb2RlbCA9IG5ldyBNb2RlbCgpO1xuXG5cdFx0dGhpcy5wb3B1bGF0ZU9wdGlvbnNIYXNoKCk7XG5cdH0sXG5cblxuXHQvLyBwdWJsaWMgZ2V0dGVyL3NldHRlclxuXHRvcHRpb246IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cdFx0dmFyIG5ld09wdGlvbkhhc2g7XG5cblx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgeyAvLyBnZXR0ZXJcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc01vZGVsLmdldChuYW1lKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgeyAvLyBzZXR0ZXIgZm9yIGluZGl2aWR1YWwgb3B0aW9uXG5cdFx0XHRcdG5ld09wdGlvbkhhc2ggPSB7fTtcblx0XHRcdFx0bmV3T3B0aW9uSGFzaFtuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLnNldE9wdGlvbnMobmV3T3B0aW9uSGFzaCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgeyAvLyBjb21wb3VuZCBzZXR0ZXIgd2l0aCBvYmplY3QgaW5wdXRcblx0XHRcdHRoaXMuc2V0T3B0aW9ucyhuYW1lKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBwcml2YXRlIGdldHRlclxuXHRvcHQ6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zTW9kZWwuZ2V0KG5hbWUpO1xuXHR9LFxuXG5cblx0c2V0T3B0aW9uczogZnVuY3Rpb24obmV3T3B0aW9uSGFzaCkge1xuXHRcdHZhciBvcHRpb25DbnQgPSAwO1xuXHRcdHZhciBvcHRpb25OYW1lO1xuXG5cdFx0dGhpcy5yZWNvcmRPcHRpb25PdmVycmlkZXMobmV3T3B0aW9uSGFzaCk7XG5cblx0XHRmb3IgKG9wdGlvbk5hbWUgaW4gbmV3T3B0aW9uSGFzaCkge1xuXHRcdFx0b3B0aW9uQ250Kys7XG5cdFx0fVxuXG5cdFx0Ly8gc3BlY2lhbC1jYXNlIGhhbmRsaW5nIG9mIHNpbmdsZSBvcHRpb24gY2hhbmdlLlxuXHRcdC8vIGlmIG9ubHkgb25lIG9wdGlvbiBjaGFuZ2UsIGBvcHRpb25OYW1lYCB3aWxsIGJlIGl0cyBuYW1lLlxuXHRcdGlmIChvcHRpb25DbnQgPT09IDEpIHtcblx0XHRcdGlmIChvcHRpb25OYW1lID09PSAnaGVpZ2h0JyB8fCBvcHRpb25OYW1lID09PSAnY29udGVudEhlaWdodCcgfHwgb3B0aW9uTmFtZSA9PT0gJ2FzcGVjdFJhdGlvJykge1xuXHRcdFx0XHR0aGlzLnVwZGF0ZVNpemUodHJ1ZSk7IC8vIHRydWUgPSBhbGxvdyByZWNhbGN1bGF0aW9uIG9mIGhlaWdodFxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChvcHRpb25OYW1lID09PSAnZGVmYXVsdERhdGUnKSB7XG5cdFx0XHRcdHJldHVybjsgLy8gY2FuJ3QgY2hhbmdlIGRhdGUgdGhpcyB3YXkuIHVzZSBnb3RvRGF0ZSBpbnN0ZWFkXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChvcHRpb25OYW1lID09PSAnYnVzaW5lc3NIb3VycycpIHtcblx0XHRcdFx0aWYgKHRoaXMudmlldykge1xuXHRcdFx0XHRcdHRoaXMudmlldy51bnJlbmRlckJ1c2luZXNzSG91cnMoKTtcblx0XHRcdFx0XHR0aGlzLnZpZXcucmVuZGVyQnVzaW5lc3NIb3VycygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09ICd0aW1lem9uZScpIHtcblx0XHRcdFx0dGhpcy5yZXpvbmVBcnJheUV2ZW50U291cmNlcygpO1xuXHRcdFx0XHR0aGlzLnJlZmV0Y2hFdmVudHMoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGNhdGNoLWFsbC4gcmVyZW5kZXIgdGhlIGhlYWRlciBhbmQgZm9vdGVyIGFuZCByZWJ1aWxkL3JlcmVuZGVyIHRoZSBjdXJyZW50IHZpZXdcblx0XHR0aGlzLnJlbmRlckhlYWRlcigpO1xuXHRcdHRoaXMucmVuZGVyRm9vdGVyKCk7XG5cblx0XHQvLyBldmVuIG5vbi1jdXJyZW50IHZpZXdzIHdpbGwgYmUgYWZmZWN0ZWQgYnkgdGhpcyBvcHRpb24gY2hhbmdlLiBkbyBiZWZvcmUgcmVyZW5kZXJcblx0XHQvLyBUT0RPOiBkZXRhbmdsZVxuXHRcdHRoaXMudmlld3NCeVR5cGUgPSB7fTtcblxuXHRcdHRoaXMucmVpbml0VmlldygpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgdGhlIGZsYXR0ZW5lZCBvcHRpb25zIGhhc2ggZm9yIHRoZSBjYWxlbmRhciBhbmQgYXNzaWducyB0byBgdGhpcy5vcHRpb25zYC5cblx0Ly8gQXNzdW1lcyB0aGlzLm92ZXJyaWRlcyBhbmQgdGhpcy5keW5hbWljT3ZlcnJpZGVzIGhhdmUgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLlxuXHRwb3B1bGF0ZU9wdGlvbnNIYXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jYWxlLCBsb2NhbGVEZWZhdWx0cztcblx0XHR2YXIgaXNSVEwsIGRpckRlZmF1bHRzO1xuXHRcdHZhciByYXdPcHRpb25zO1xuXG5cdFx0bG9jYWxlID0gZmlyc3REZWZpbmVkKCAvLyBleHBsaWNpdCBsb2NhbGUgb3B0aW9uIGdpdmVuP1xuXHRcdFx0dGhpcy5keW5hbWljT3ZlcnJpZGVzLmxvY2FsZSxcblx0XHRcdHRoaXMub3ZlcnJpZGVzLmxvY2FsZVxuXHRcdCk7XG5cdFx0bG9jYWxlRGVmYXVsdHMgPSBsb2NhbGVPcHRpb25IYXNoW2xvY2FsZV07XG5cdFx0aWYgKCFsb2NhbGVEZWZhdWx0cykgeyAvLyBleHBsaWNpdCBsb2NhbGUgb3B0aW9uIG5vdCBnaXZlbiBvciBpbnZhbGlkP1xuXHRcdFx0bG9jYWxlID0gQ2FsZW5kYXIuZGVmYXVsdHMubG9jYWxlO1xuXHRcdFx0bG9jYWxlRGVmYXVsdHMgPSBsb2NhbGVPcHRpb25IYXNoW2xvY2FsZV0gfHwge307XG5cdFx0fVxuXG5cdFx0aXNSVEwgPSBmaXJzdERlZmluZWQoIC8vIGJhc2VkIG9uIG9wdGlvbnMgY29tcHV0ZWQgc28gZmFyLCBpcyBkaXJlY3Rpb24gUlRMP1xuXHRcdFx0dGhpcy5keW5hbWljT3ZlcnJpZGVzLmlzUlRMLFxuXHRcdFx0dGhpcy5vdmVycmlkZXMuaXNSVEwsXG5cdFx0XHRsb2NhbGVEZWZhdWx0cy5pc1JUTCxcblx0XHRcdENhbGVuZGFyLmRlZmF1bHRzLmlzUlRMXG5cdFx0KTtcblx0XHRkaXJEZWZhdWx0cyA9IGlzUlRMID8gQ2FsZW5kYXIucnRsRGVmYXVsdHMgOiB7fTtcblxuXHRcdHRoaXMuZGlyRGVmYXVsdHMgPSBkaXJEZWZhdWx0cztcblx0XHR0aGlzLmxvY2FsZURlZmF1bHRzID0gbG9jYWxlRGVmYXVsdHM7XG5cblx0XHRyYXdPcHRpb25zID0gbWVyZ2VPcHRpb25zKFsgLy8gbWVyZ2UgZGVmYXVsdHMgYW5kIG92ZXJyaWRlcy4gbG93ZXN0IHRvIGhpZ2hlc3QgcHJlY2VkZW5jZVxuXHRcdFx0Q2FsZW5kYXIuZGVmYXVsdHMsIC8vIGdsb2JhbCBkZWZhdWx0c1xuXHRcdFx0ZGlyRGVmYXVsdHMsXG5cdFx0XHRsb2NhbGVEZWZhdWx0cyxcblx0XHRcdHRoaXMub3ZlcnJpZGVzLFxuXHRcdFx0dGhpcy5keW5hbWljT3ZlcnJpZGVzXG5cdFx0XSk7XG5cdFx0cG9wdWxhdGVJbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zKHJhd09wdGlvbnMpOyAvLyBmaWxsIGluIGdhcHMgd2l0aCBjb21wdXRlZCBvcHRpb25zXG5cblx0XHR0aGlzLm9wdGlvbnNNb2RlbC5yZXNldChyYXdPcHRpb25zKTtcblx0fSxcblxuXG5cdC8vIHN0b3JlcyB0aGUgbmV3IG9wdGlvbnMgaW50ZXJuYWxseSwgYnV0IGRvZXMgbm90IHJlcmVuZGVyIGFueXRoaW5nLlxuXHRyZWNvcmRPcHRpb25PdmVycmlkZXM6IGZ1bmN0aW9uKG5ld09wdGlvbkhhc2gpIHtcblx0XHR2YXIgb3B0aW9uTmFtZTtcblxuXHRcdGZvciAob3B0aW9uTmFtZSBpbiBuZXdPcHRpb25IYXNoKSB7XG5cdFx0XHR0aGlzLmR5bmFtaWNPdmVycmlkZXNbb3B0aW9uTmFtZV0gPSBuZXdPcHRpb25IYXNoW29wdGlvbk5hbWVdO1xuXHRcdH1cblxuXHRcdHRoaXMudmlld1NwZWNDYWNoZSA9IHt9OyAvLyB0aGUgZHluYW1pYyBvdmVycmlkZSBpbnZhbGlkYXRlcyB0aGUgb3B0aW9ucyBpbiB0aGlzIGNhY2hlLCBzbyBqdXN0IGNsZWFyIGl0XG5cdFx0dGhpcy5wb3B1bGF0ZU9wdGlvbnNIYXNoKCk7IC8vIHRoaXMub3B0aW9ucyBuZWVkcyB0byBiZSByZWNvbXB1dGVkIGFmdGVyIHRoZSBkeW5hbWljIG92ZXJyaWRlXG5cdH1cblxufSk7XG5cbjs7XG5cbkNhbGVuZGFyLm1peGluKHtcblxuXHRkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogbnVsbCxcblx0ZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogbnVsbCxcblx0bG9jYWxlRGF0YTogbnVsbCxcblxuXG5cdGluaXRNb21lbnRJbnRlcm5hbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHR0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbicpKTtcblx0XHR0aGlzLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ2RlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24nKSk7XG5cblx0XHQvLyBDYWxsZWQgaW1tZWRpYXRlbHksIGFuZCB3aGVuIGFueSBvZiB0aGUgb3B0aW9ucyBjaGFuZ2UuXG5cdFx0Ly8gSGFwcGVucyBiZWZvcmUgYW55IGludGVybmFsIG9iamVjdHMgcmVidWlsZCBvciByZXJlbmRlciwgYmVjYXVzZSB0aGlzIGlzIHZlcnkgY29yZS5cblx0XHR0aGlzLm9wdGlvbnNNb2RlbC53YXRjaCgnYnVpbGRpbmdNb21lbnRMb2NhbGUnLCBbXG5cdFx0XHQnP2xvY2FsZScsICc/bW9udGhOYW1lcycsICc/bW9udGhOYW1lc1Nob3J0JywgJz9kYXlOYW1lcycsICc/ZGF5TmFtZXNTaG9ydCcsXG5cdFx0XHQnP2ZpcnN0RGF5JywgJz93ZWVrTnVtYmVyQ2FsY3VsYXRpb24nXG5cdFx0XSwgZnVuY3Rpb24ob3B0cykge1xuXHRcdFx0dmFyIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9IG9wdHMud2Vla051bWJlckNhbGN1bGF0aW9uO1xuXHRcdFx0dmFyIGZpcnN0RGF5ID0gb3B0cy5maXJzdERheTtcblx0XHRcdHZhciBfd2VlaztcblxuXHRcdFx0Ly8gbm9ybWFsaXplXG5cdFx0XHRpZiAod2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnaXNvJykge1xuXHRcdFx0XHR3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPSAnSVNPJzsgLy8gbm9ybWFsaXplXG5cdFx0XHR9XG5cblx0XHRcdHZhciBsb2NhbGVEYXRhID0gY3JlYXRlT2JqZWN0KCAvLyBtYWtlIGEgY2hlYXAgY29weVxuXHRcdFx0XHRnZXRNb21lbnRMb2NhbGVEYXRhKG9wdHMubG9jYWxlKSAvLyB3aWxsIGZhbGwgYmFjayB0byBlblxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKG9wdHMubW9udGhOYW1lcykge1xuXHRcdFx0XHRsb2NhbGVEYXRhLl9tb250aHMgPSBvcHRzLm1vbnRoTmFtZXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0cy5tb250aE5hbWVzU2hvcnQpIHtcblx0XHRcdFx0bG9jYWxlRGF0YS5fbW9udGhzU2hvcnQgPSBvcHRzLm1vbnRoTmFtZXNTaG9ydDtcblx0XHRcdH1cblx0XHRcdGlmIChvcHRzLmRheU5hbWVzKSB7XG5cdFx0XHRcdGxvY2FsZURhdGEuX3dlZWtkYXlzID0gb3B0cy5kYXlOYW1lcztcblx0XHRcdH1cblx0XHRcdGlmIChvcHRzLmRheU5hbWVzU2hvcnQpIHtcblx0XHRcdFx0bG9jYWxlRGF0YS5fd2Vla2RheXNTaG9ydCA9IG9wdHMuZGF5TmFtZXNTaG9ydDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGZpcnN0RGF5ID09IG51bGwgJiYgd2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnSVNPJykge1xuXHRcdFx0XHRmaXJzdERheSA9IDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZmlyc3REYXkgIT0gbnVsbCkge1xuXHRcdFx0XHRfd2VlayA9IGNyZWF0ZU9iamVjdChsb2NhbGVEYXRhLl93ZWVrKTsgLy8gX3dlZWs6IHsgZG93OiAjIH1cblx0XHRcdFx0X3dlZWsuZG93ID0gZmlyc3REYXk7XG5cdFx0XHRcdGxvY2FsZURhdGEuX3dlZWsgPSBfd2Vlaztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAvLyB3aGl0ZWxpc3QgY2VydGFpbiBraW5kcyBvZiBpbnB1dFxuXHRcdFx0XHR3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nIHx8XG5cdFx0XHRcdHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ2xvY2FsJyB8fFxuXHRcdFx0XHR0eXBlb2Ygd2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnZnVuY3Rpb24nXG5cdFx0XHQpIHtcblx0XHRcdFx0bG9jYWxlRGF0YS5fZnVsbENhbGVuZGFyX3dlZWtDYWxjID0gd2Vla051bWJlckNhbGN1bGF0aW9uOyAvLyBtb21lbnQtZXh0IHdpbGwga25vdyB3aGF0IHRvIGRvIHdpdGggaXRcblx0XHRcdH1cblxuXHRcdFx0X3RoaXMubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XG5cblx0XHRcdC8vIElmIHRoZSBpbnRlcm5hbCBjdXJyZW50IGRhdGUgb2JqZWN0IGFscmVhZHkgZXhpc3RzLCBtb3ZlIHRvIG5ldyBsb2NhbGUuXG5cdFx0XHQvLyBXZSBkbyBOT1QgbmVlZCB0byBkbyB0aGlzIHRlY2huaXF1ZSBmb3IgZXZlbnQgZGF0ZXMsIGJlY2F1c2UgdGhpcyBoYXBwZW5zIHdoZW4gY29udmVydGluZyB0byBcInNlZ21lbnRzXCIuXG5cdFx0XHRpZiAoX3RoaXMuY3VycmVudERhdGUpIHtcblx0XHRcdFx0X3RoaXMubG9jYWxpemVNb21lbnQoX3RoaXMuY3VycmVudERhdGUpOyAvLyBzZXRzIHRvIGxvY2FsZURhdGFcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyBhIG1vbWVudCB1c2luZyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGN1cnJlbnQgY2FsZW5kYXI6IHRpbWV6b25lIGFuZCBsb2NhbGUuXG5cdC8vIEFjY2VwdHMgYW55dGhpbmcgdGhlIHZhbmlsbGEgbW9tZW50KCkgY29uc3RydWN0b3IgYWNjZXB0cy5cblx0bW9tZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbW9tO1xuXG5cdFx0aWYgKHRoaXMub3B0KCd0aW1lem9uZScpID09PSAnbG9jYWwnKSB7XG5cdFx0XHRtb20gPSBGQy5tb21lbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblxuXHRcdFx0Ly8gRm9yY2UgdGhlIG1vbWVudCB0byBiZSBsb2NhbCwgYmVjYXVzZSBGQy5tb21lbnQgZG9lc24ndCBndWFyYW50ZWUgaXQuXG5cdFx0XHRpZiAobW9tLmhhc1RpbWUoKSkgeyAvLyBkb24ndCBnaXZlIGFtYmlndW91c2x5LXRpbWVkIG1vbWVudHMgYSBsb2NhbCB6b25lXG5cdFx0XHRcdG1vbS5sb2NhbCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLm9wdCgndGltZXpvbmUnKSA9PT0gJ1VUQycpIHtcblx0XHRcdG1vbSA9IEZDLm1vbWVudC51dGMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgLy8gcHJvY2VzcyBhcyBVVENcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRtb20gPSBGQy5tb21lbnQucGFyc2Vab25lLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IC8vIGxldCB0aGUgaW5wdXQgZGVjaWRlIHRoZSB6b25lXG5cdFx0fVxuXG5cdFx0dGhpcy5sb2NhbGl6ZU1vbWVudChtb20pOyAvLyBUT0RPXG5cblx0XHRyZXR1cm4gbW9tO1xuXHR9LFxuXG5cblx0Ly8gVXBkYXRlcyB0aGUgZ2l2ZW4gbW9tZW50J3MgbG9jYWxlIHNldHRpbmdzIHRvIHRoZSBjdXJyZW50IGNhbGVuZGFyIGxvY2FsZSBzZXR0aW5ncy5cblx0bG9jYWxpemVNb21lbnQ6IGZ1bmN0aW9uKG1vbSkge1xuXHRcdG1vbS5fbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhO1xuXHR9LFxuXG5cblx0Ly8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciBvciBub3QgdGhlIGNhbGVuZGFyIGtub3dzIGhvdyB0byBjYWxjdWxhdGVcblx0Ly8gdGhlIHRpbWV6b25lIG9mZnNldCBvZiBhcmJpdHJhcnkgZGF0ZXMgaW4gdGhlIGN1cnJlbnQgdGltZXpvbmUuXG5cdGdldElzQW1iaWdUaW1lem9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0KCd0aW1lem9uZScpICE9PSAnbG9jYWwnICYmIHRoaXMub3B0KCd0aW1lem9uZScpICE9PSAnVVRDJztcblx0fSxcblxuXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBjdXJyZW50IHRpbWV6b25lLiBIYXMgbm8gZWZmZWN0IG9uIGRhdGVzIHdpdGhvdXQgdGltZXMuXG5cdGFwcGx5VGltZXpvbmU6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHRpZiAoIWRhdGUuaGFzVGltZSgpKSB7XG5cdFx0XHRyZXR1cm4gZGF0ZS5jbG9uZSgpO1xuXHRcdH1cblxuXHRcdHZhciB6b25lZERhdGUgPSB0aGlzLm1vbWVudChkYXRlLnRvQXJyYXkoKSk7XG5cdFx0dmFyIHRpbWVBZGp1c3QgPSBkYXRlLnRpbWUoKSAtIHpvbmVkRGF0ZS50aW1lKCk7XG5cdFx0dmFyIGFkanVzdGVkWm9uZWREYXRlO1xuXG5cdFx0Ly8gU2FmYXJpIHNvbWV0aW1lcyBoYXMgcHJvYmxlbXMgd2l0aCB0aGlzIGNvZXJzaW9uIHdoZW4gbmVhciBEU1QuIEFkanVzdCBpZiBuZWNlc3NhcnkuIChidWcgIzIzOTYpXG5cdFx0aWYgKHRpbWVBZGp1c3QpIHsgLy8gaXMgdGhlIHRpbWUgcmVzdWx0IGRpZmZlcmVudCB0aGFuIGV4cGVjdGVkP1xuXHRcdFx0YWRqdXN0ZWRab25lZERhdGUgPSB6b25lZERhdGUuY2xvbmUoKS5hZGQodGltZUFkanVzdCk7IC8vIGFkZCBtaWxsaXNlY29uZHNcblx0XHRcdGlmIChkYXRlLnRpbWUoKSAtIGFkanVzdGVkWm9uZWREYXRlLnRpbWUoKSA9PT0gMCkgeyAvLyBkb2VzIGl0IG1hdGNoIHBlcmZlY3RseSBub3c/XG5cdFx0XHRcdHpvbmVkRGF0ZSA9IGFkanVzdGVkWm9uZWREYXRlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB6b25lZERhdGU7XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIGEgbW9tZW50IGZvciB0aGUgY3VycmVudCBkYXRlLCBhcyBkZWZpbmVkIGJ5IHRoZSBjbGllbnQncyBjb21wdXRlciBvciBmcm9tIHRoZSBgbm93YCBvcHRpb24uXG5cdC8vIFdpbGwgcmV0dXJuIGFuIG1vbWVudCB3aXRoIGFuIGFtYmlndW91cyB0aW1lem9uZS5cblx0Z2V0Tm93OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbm93ID0gdGhpcy5vcHQoJ25vdycpO1xuXHRcdGlmICh0eXBlb2Ygbm93ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRub3cgPSBub3coKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMubW9tZW50KG5vdykuc3RyaXBab25lKCk7XG5cdH0sXG5cblxuXHQvLyBQcm9kdWNlcyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLlxuXHQvLyBTaWRlLWVmZmVjdDogY2hhbmdlcyB0aGUgbG9jYWxlIG9mIHRoZSBnaXZlbiBkdXJhdGlvbi5cblx0aHVtYW5pemVEdXJhdGlvbjogZnVuY3Rpb24oZHVyYXRpb24pIHtcblx0XHRyZXR1cm4gZHVyYXRpb24ubG9jYWxlKHRoaXMub3B0KCdsb2NhbGUnKSkuaHVtYW5pemUoKTtcblx0fSxcblxuXG5cblx0Ly8gRXZlbnQtU3BlY2lmaWMgRGF0ZSBVdGlsaXRpZXMuIFRPRE86IG1vdmVcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdC8vIEdldCBhbiBldmVudCdzIG5vcm1hbGl6ZWQgZW5kIGRhdGUuIElmIG5vdCBwcmVzZW50LCBjYWxjdWxhdGUgaXQgZnJvbSB0aGUgZGVmYXVsdHMuXG5cdGdldEV2ZW50RW5kOiBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmIChldmVudC5lbmQpIHtcblx0XHRcdHJldHVybiBldmVudC5lbmQuY2xvbmUoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnQuYWxsRGF5LCBldmVudC5zdGFydCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxuXHQvLyBUT0RPOiByZW5hbWUgdG8gY29tcHV0ZURlZmF1bHRFdmVudEVuZFxuXHRnZXREZWZhdWx0RXZlbnRFbmQ6IGZ1bmN0aW9uKGFsbERheSwgem9uZWRTdGFydCkge1xuXHRcdHZhciBlbmQgPSB6b25lZFN0YXJ0LmNsb25lKCk7XG5cblx0XHRpZiAoYWxsRGF5KSB7XG5cdFx0XHRlbmQuc3RyaXBUaW1lKCkuYWRkKHRoaXMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGVuZC5hZGQodGhpcy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5nZXRJc0FtYmlnVGltZXpvbmUoKSkge1xuXHRcdFx0ZW5kLnN0cmlwWm9uZSgpOyAvLyB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHR6byBzaG91bGQgYmVcblx0XHR9XG5cblx0XHRyZXR1cm4gZW5kO1xuXHR9XG5cbn0pO1xuXG47O1xuXG5DYWxlbmRhci5taXhpbih7XG5cblx0dmlld1NwZWNDYWNoZTogbnVsbCwgLy8gY2FjaGUgb2YgdmlldyBkZWZpbml0aW9ucyAoaW5pdGlhbGl6ZWQgaW4gQ2FsZW5kYXIuanMpXG5cblxuXHQvLyBHZXRzIGluZm9ybWF0aW9uIGFib3V0IGhvdyB0byBjcmVhdGUgYSB2aWV3LiBXaWxsIHVzZSBhIGNhY2hlLlxuXHRnZXRWaWV3U3BlYzogZnVuY3Rpb24odmlld1R5cGUpIHtcblx0XHR2YXIgY2FjaGUgPSB0aGlzLnZpZXdTcGVjQ2FjaGU7XG5cblx0XHRyZXR1cm4gY2FjaGVbdmlld1R5cGVdIHx8IChjYWNoZVt2aWV3VHlwZV0gPSB0aGlzLmJ1aWxkVmlld1NwZWModmlld1R5cGUpKTtcblx0fSxcblxuXG5cdC8vIEdpdmVuIGEgZHVyYXRpb24gc2luZ3VsYXIgdW5pdCwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLCBmaW5kcyBhIG1hdGNoaW5nIHZpZXcgc3BlYy5cblx0Ly8gUHJlZmVyZW5jZSBpcyBnaXZlbiB0byB2aWV3cyB0aGF0IGhhdmUgY29ycmVzcG9uZGluZyBidXR0b25zLlxuXHRnZXRVbml0Vmlld1NwZWM6IGZ1bmN0aW9uKHVuaXQpIHtcblx0XHR2YXIgdmlld1R5cGVzO1xuXHRcdHZhciBpO1xuXHRcdHZhciBzcGVjO1xuXG5cdFx0aWYgKCQuaW5BcnJheSh1bml0LCB1bml0c0Rlc2MpICE9IC0xKSB7XG5cblx0XHRcdC8vIHB1dCB2aWV3cyB0aGF0IGhhdmUgYnV0dG9ucyBmaXJzdC4gdGhlcmUgd2lsbCBiZSBkdXBsaWNhdGVzLCBidXQgb2ggd2VsbFxuXHRcdFx0dmlld1R5cGVzID0gdGhpcy5oZWFkZXIuZ2V0Vmlld3NXaXRoQnV0dG9ucygpOyAvLyBUT0RPOiBpbmNsdWRlIGZvb3RlciBhcyB3ZWxsP1xuXHRcdFx0JC5lYWNoKEZDLnZpZXdzLCBmdW5jdGlvbih2aWV3VHlwZSkgeyAvLyBhbGwgdmlld3Ncblx0XHRcdFx0dmlld1R5cGVzLnB1c2godmlld1R5cGUpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCB2aWV3VHlwZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0c3BlYyA9IHRoaXMuZ2V0Vmlld1NwZWModmlld1R5cGVzW2ldKTtcblx0XHRcdFx0aWYgKHNwZWMpIHtcblx0XHRcdFx0XHRpZiAoc3BlYy5zaW5nbGVVbml0ID09IHVuaXQpIHtcblx0XHRcdFx0XHRcdHJldHVybiBzcGVjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBvbiBob3cgdG8gY3JlYXRlIGEgZ2l2ZW4gdmlld1xuXHRidWlsZFZpZXdTcGVjOiBmdW5jdGlvbihyZXF1ZXN0ZWRWaWV3VHlwZSkge1xuXHRcdHZhciB2aWV3T3ZlcnJpZGVzID0gdGhpcy5vdmVycmlkZXMudmlld3MgfHwge307XG5cdFx0dmFyIHNwZWNDaGFpbiA9IFtdOyAvLyBmb3IgdGhlIHZpZXcuIGxvd2VzdCB0byBoaWdoZXN0IHByaW9yaXR5XG5cdFx0dmFyIGRlZmF1bHRzQ2hhaW4gPSBbXTsgLy8gZm9yIHRoZSB2aWV3LiBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxuXHRcdHZhciBvdmVycmlkZXNDaGFpbiA9IFtdOyAvLyBmb3IgdGhlIHZpZXcuIGxvd2VzdCB0byBoaWdoZXN0IHByaW9yaXR5XG5cdFx0dmFyIHZpZXdUeXBlID0gcmVxdWVzdGVkVmlld1R5cGU7XG5cdFx0dmFyIHNwZWM7IC8vIGZvciB0aGUgdmlld1xuXHRcdHZhciBvdmVycmlkZXM7IC8vIGZvciB0aGUgdmlld1xuXHRcdHZhciBkdXJhdGlvbklucHV0O1xuXHRcdHZhciBkdXJhdGlvbjtcblx0XHR2YXIgdW5pdDtcblxuXHRcdC8vIGl0ZXJhdGUgZnJvbSB0aGUgc3BlY2lmaWMgdmlldyBkZWZpbml0aW9uIHRvIGEgbW9yZSBnZW5lcmFsIG9uZSB1bnRpbCB3ZSBoaXQgYW4gYWN0dWFsIFZpZXcgY2xhc3Ncblx0XHR3aGlsZSAodmlld1R5cGUpIHtcblx0XHRcdHNwZWMgPSBmY1ZpZXdzW3ZpZXdUeXBlXTtcblx0XHRcdG92ZXJyaWRlcyA9IHZpZXdPdmVycmlkZXNbdmlld1R5cGVdO1xuXHRcdFx0dmlld1R5cGUgPSBudWxsOyAvLyBjbGVhci4gbWlnaHQgcmVwb3B1bGF0ZSBmb3IgYW5vdGhlciBpdGVyYXRpb25cblxuXHRcdFx0aWYgKHR5cGVvZiBzcGVjID09PSAnZnVuY3Rpb24nKSB7IC8vIFRPRE86IGRlcHJlY2F0ZVxuXHRcdFx0XHRzcGVjID0geyAnY2xhc3MnOiBzcGVjIH07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzcGVjKSB7XG5cdFx0XHRcdHNwZWNDaGFpbi51bnNoaWZ0KHNwZWMpO1xuXHRcdFx0XHRkZWZhdWx0c0NoYWluLnVuc2hpZnQoc3BlYy5kZWZhdWx0cyB8fCB7fSk7XG5cdFx0XHRcdGR1cmF0aW9uSW5wdXQgPSBkdXJhdGlvbklucHV0IHx8IHNwZWMuZHVyYXRpb247XG5cdFx0XHRcdHZpZXdUeXBlID0gdmlld1R5cGUgfHwgc3BlYy50eXBlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3ZlcnJpZGVzKSB7XG5cdFx0XHRcdG92ZXJyaWRlc0NoYWluLnVuc2hpZnQob3ZlcnJpZGVzKTsgLy8gdmlldy1zcGVjaWZpYyBvcHRpb24gaGFzaGVzIGhhdmUgb3B0aW9ucyBhdCB6ZXJvLWxldmVsXG5cdFx0XHRcdGR1cmF0aW9uSW5wdXQgPSBkdXJhdGlvbklucHV0IHx8IG92ZXJyaWRlcy5kdXJhdGlvbjtcblx0XHRcdFx0dmlld1R5cGUgPSB2aWV3VHlwZSB8fCBvdmVycmlkZXMudHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzcGVjID0gbWVyZ2VQcm9wcyhzcGVjQ2hhaW4pO1xuXHRcdHNwZWMudHlwZSA9IHJlcXVlc3RlZFZpZXdUeXBlO1xuXHRcdGlmICghc3BlY1snY2xhc3MnXSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGZhbGwgYmFjayB0byB0b3AtbGV2ZWwgYGR1cmF0aW9uYCBvcHRpb25cblx0XHRkdXJhdGlvbklucHV0ID0gZHVyYXRpb25JbnB1dCB8fFxuXHRcdFx0dGhpcy5keW5hbWljT3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG5cdFx0XHR0aGlzLm92ZXJyaWRlcy5kdXJhdGlvbjtcblxuXHRcdGlmIChkdXJhdGlvbklucHV0KSB7XG5cdFx0XHRkdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihkdXJhdGlvbklucHV0KTtcblxuXHRcdFx0aWYgKGR1cmF0aW9uLnZhbHVlT2YoKSkgeyAvLyB2YWxpZD9cblxuXHRcdFx0XHR1bml0ID0gY29tcHV0ZUR1cmF0aW9uR3JlYXRlc3RVbml0KGR1cmF0aW9uLCBkdXJhdGlvbklucHV0KTtcblxuXHRcdFx0XHRzcGVjLmR1cmF0aW9uID0gZHVyYXRpb247XG5cdFx0XHRcdHNwZWMuZHVyYXRpb25Vbml0ID0gdW5pdDtcblxuXHRcdFx0XHQvLyB2aWV3IGlzIGEgc2luZ2xlLXVuaXQgZHVyYXRpb24sIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIlxuXHRcdFx0XHQvLyBpbmNvcnBvcmF0ZSBvcHRpb25zIGZvciB0aGlzLiBsb3dlc3QgcHJpb3JpdHlcblx0XHRcdFx0aWYgKGR1cmF0aW9uLmFzKHVuaXQpID09PSAxKSB7XG5cdFx0XHRcdFx0c3BlYy5zaW5nbGVVbml0ID0gdW5pdDtcblx0XHRcdFx0XHRvdmVycmlkZXNDaGFpbi51bnNoaWZ0KHZpZXdPdmVycmlkZXNbdW5pdF0gfHwge30pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3BlYy5kZWZhdWx0cyA9IG1lcmdlT3B0aW9ucyhkZWZhdWx0c0NoYWluKTtcblx0XHRzcGVjLm92ZXJyaWRlcyA9IG1lcmdlT3B0aW9ucyhvdmVycmlkZXNDaGFpbik7XG5cblx0XHR0aGlzLmJ1aWxkVmlld1NwZWNPcHRpb25zKHNwZWMpO1xuXHRcdHRoaXMuYnVpbGRWaWV3U3BlY0J1dHRvblRleHQoc3BlYywgcmVxdWVzdGVkVmlld1R5cGUpO1xuXG5cdFx0cmV0dXJuIHNwZWM7XG5cdH0sXG5cblxuXHQvLyBCdWlsZHMgYW5kIGFzc2lnbnMgYSB2aWV3IHNwZWMncyBvcHRpb25zIG9iamVjdCBmcm9tIGl0cyBhbHJlYWR5LWFzc2lnbmVkIGRlZmF1bHRzIGFuZCBvdmVycmlkZXNcblx0YnVpbGRWaWV3U3BlY09wdGlvbnM6IGZ1bmN0aW9uKHNwZWMpIHtcblx0XHRzcGVjLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoWyAvLyBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxuXHRcdFx0Q2FsZW5kYXIuZGVmYXVsdHMsIC8vIGdsb2JhbCBkZWZhdWx0c1xuXHRcdFx0c3BlYy5kZWZhdWx0cywgLy8gdmlldydzIGRlZmF1bHRzIChmcm9tIFZpZXdTdWJjbGFzcy5kZWZhdWx0cylcblx0XHRcdHRoaXMuZGlyRGVmYXVsdHMsXG5cdFx0XHR0aGlzLmxvY2FsZURlZmF1bHRzLCAvLyBsb2NhbGUgYW5kIGRpciB0YWtlIHByZWNlZGVuY2Ugb3ZlciB2aWV3J3MgZGVmYXVsdHMhXG5cdFx0XHR0aGlzLm92ZXJyaWRlcywgLy8gY2FsZW5kYXIncyBvdmVycmlkZXMgKG9wdGlvbnMgZ2l2ZW4gdG8gY29uc3RydWN0b3IpXG5cdFx0XHRzcGVjLm92ZXJyaWRlcywgLy8gdmlldydzIG92ZXJyaWRlcyAodmlldy1zcGVjaWZpYyBvcHRpb25zKVxuXHRcdFx0dGhpcy5keW5hbWljT3ZlcnJpZGVzIC8vIGR5bmFtaWNhbGx5IHNldCB2aWEgc2V0dGVyLiBoaWdoZXN0IHByZWNlZGVuY2Vcblx0XHRdKTtcblx0XHRwb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMoc3BlYy5vcHRpb25zKTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGFuZCBhc3NpZ25zIGEgdmlldyBzcGVjJ3MgYnV0dG9uVGV4dC1yZWxhdGVkIG9wdGlvbnNcblx0YnVpbGRWaWV3U3BlY0J1dHRvblRleHQ6IGZ1bmN0aW9uKHNwZWMsIHJlcXVlc3RlZFZpZXdUeXBlKSB7XG5cblx0XHQvLyBnaXZlbiBhbiBvcHRpb25zIG9iamVjdCB3aXRoIGEgcG9zc2libGUgYGJ1dHRvblRleHRgIGhhc2gsIGxvb2t1cCB0aGUgYnV0dG9uVGV4dCBmb3IgdGhlXG5cdFx0Ly8gcmVxdWVzdGVkIHZpZXcsIGZhbGxpbmcgYmFjayB0byBhIGdlbmVyaWMgdW5pdCBlbnRyeSBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCJcblx0XHRmdW5jdGlvbiBxdWVyeUJ1dHRvblRleHQob3B0aW9ucykge1xuXHRcdFx0dmFyIGJ1dHRvblRleHQgPSBvcHRpb25zLmJ1dHRvblRleHQgfHwge307XG5cdFx0XHRyZXR1cm4gYnV0dG9uVGV4dFtyZXF1ZXN0ZWRWaWV3VHlwZV0gfHxcblx0XHRcdFx0Ly8gdmlldyBjYW4gZGVjaWRlIHRvIGxvb2sgdXAgYSBjZXJ0YWluIGtleVxuXHRcdFx0XHQoc3BlYy5idXR0b25UZXh0S2V5ID8gYnV0dG9uVGV4dFtzcGVjLmJ1dHRvblRleHRLZXldIDogbnVsbCkgfHxcblx0XHRcdFx0Ly8gYSBrZXkgbGlrZSBcIm1vbnRoXCJcblx0XHRcdFx0KHNwZWMuc2luZ2xlVW5pdCA/IGJ1dHRvblRleHRbc3BlYy5zaW5nbGVVbml0XSA6IG51bGwpO1xuXHRcdH1cblxuXHRcdC8vIGhpZ2hlc3QgdG8gbG93ZXN0IHByaW9yaXR5XG5cdFx0c3BlYy5idXR0b25UZXh0T3ZlcnJpZGUgPVxuXHRcdFx0cXVlcnlCdXR0b25UZXh0KHRoaXMuZHluYW1pY092ZXJyaWRlcykgfHxcblx0XHRcdHF1ZXJ5QnV0dG9uVGV4dCh0aGlzLm92ZXJyaWRlcykgfHwgLy8gY29uc3RydWN0b3Itc3BlY2lmaWVkIGJ1dHRvblRleHQgbG9va3VwIGhhc2ggdGFrZXMgcHJlY2VkZW5jZVxuXHRcdFx0c3BlYy5vdmVycmlkZXMuYnV0dG9uVGV4dDsgLy8gYGJ1dHRvblRleHRgIGZvciB2aWV3LXNwZWNpZmljIG9wdGlvbnMgaXMgYSBzdHJpbmdcblxuXHRcdC8vIGhpZ2hlc3QgdG8gbG93ZXN0IHByaW9yaXR5LiBtaXJyb3JzIGJ1aWxkVmlld1NwZWNPcHRpb25zXG5cdFx0c3BlYy5idXR0b25UZXh0RGVmYXVsdCA9XG5cdFx0XHRxdWVyeUJ1dHRvblRleHQodGhpcy5sb2NhbGVEZWZhdWx0cykgfHxcblx0XHRcdHF1ZXJ5QnV0dG9uVGV4dCh0aGlzLmRpckRlZmF1bHRzKSB8fFxuXHRcdFx0c3BlYy5kZWZhdWx0cy5idXR0b25UZXh0IHx8IC8vIGEgc2luZ2xlIHN0cmluZy4gZnJvbSBWaWV3U3ViY2xhc3MuZGVmYXVsdHNcblx0XHRcdHF1ZXJ5QnV0dG9uVGV4dChDYWxlbmRhci5kZWZhdWx0cykgfHxcblx0XHRcdChzcGVjLmR1cmF0aW9uID8gdGhpcy5odW1hbml6ZUR1cmF0aW9uKHNwZWMuZHVyYXRpb24pIDogbnVsbCkgfHwgLy8gbGlrZSBcIjMgZGF5c1wiXG5cdFx0XHRyZXF1ZXN0ZWRWaWV3VHlwZTsgLy8gZmFsbCBiYWNrIHRvIGdpdmVuIHZpZXcgbmFtZVxuXHR9XG5cbn0pO1xuXG47O1xuXG5DYWxlbmRhci5taXhpbih7XG5cblx0ZWw6IG51bGwsXG5cdGNvbnRlbnRFbDogbnVsbCxcblx0c3VnZ2VzdGVkVmlld0hlaWdodDogbnVsbCxcblx0d2luZG93UmVzaXplUHJveHk6IG51bGwsXG5cdGlnbm9yZVdpbmRvd1Jlc2l6ZTogMCxcblxuXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmNvbnRlbnRFbCkge1xuXHRcdFx0dGhpcy5pbml0aWFsUmVuZGVyKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuZWxlbWVudFZpc2libGUoKSkge1xuXHRcdFx0Ly8gbWFpbmx5IGZvciB0aGUgcHVibGljIEFQSVxuXHRcdFx0dGhpcy5jYWxjU2l6ZSgpO1xuXHRcdFx0dGhpcy5yZW5kZXJWaWV3KCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0aW5pdGlhbFJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgZWwgPSB0aGlzLmVsO1xuXG5cdFx0ZWwuYWRkQ2xhc3MoJ2ZjJyk7XG5cblx0XHQvLyBldmVudCBkZWxlZ2F0aW9uIGZvciBuYXYgbGlua3Ncblx0XHRlbC5vbignY2xpY2suZmMnLCAnYVtkYXRhLWdvdG9dJywgZnVuY3Rpb24oZXYpIHtcblx0XHRcdHZhciBhbmNob3JFbCA9ICQodGhpcyk7XG5cdFx0XHR2YXIgZ290b09wdGlvbnMgPSBhbmNob3JFbC5kYXRhKCdnb3RvJyk7IC8vIHdpbGwgYXV0b21hdGljYWxseSBwYXJzZSBKU09OXG5cdFx0XHR2YXIgZGF0ZSA9IF90aGlzLm1vbWVudChnb3RvT3B0aW9ucy5kYXRlKTtcblx0XHRcdHZhciB2aWV3VHlwZSA9IGdvdG9PcHRpb25zLnR5cGU7XG5cblx0XHRcdC8vIHByb3BlcnR5IGxpa2UgXCJuYXZMaW5rRGF5Q2xpY2tcIi4gbWlnaHQgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvblxuXHRcdFx0dmFyIGN1c3RvbUFjdGlvbiA9IF90aGlzLnZpZXcub3B0KCduYXZMaW5rJyArIGNhcGl0YWxpc2VGaXJzdExldHRlcih2aWV3VHlwZSkgKyAnQ2xpY2snKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y3VzdG9tQWN0aW9uKGRhdGUsIGV2KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAodHlwZW9mIGN1c3RvbUFjdGlvbiA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR2aWV3VHlwZSA9IGN1c3RvbUFjdGlvbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdGhpcy56b29tVG8oZGF0ZSwgdmlld1R5cGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gY2FsbGVkIGltbWVkaWF0ZWx5LCBhbmQgdXBvbiBvcHRpb24gY2hhbmdlXG5cdFx0dGhpcy5vcHRpb25zTW9kZWwud2F0Y2goJ2FwcGx5aW5nVGhlbWVDbGFzc2VzJywgWyAnP3RoZW1lJyBdLCBmdW5jdGlvbihvcHRzKSB7XG5cdFx0XHRlbC50b2dnbGVDbGFzcygndWktd2lkZ2V0Jywgb3B0cy50aGVtZSk7XG5cdFx0XHRlbC50b2dnbGVDbGFzcygnZmMtdW50aGVtZWQnLCAhb3B0cy50aGVtZSk7XG5cdFx0fSk7XG5cblx0XHQvLyBjYWxsZWQgaW1tZWRpYXRlbHksIGFuZCB1cG9uIG9wdGlvbiBjaGFuZ2UuXG5cdFx0Ly8gSEFDSzogbG9jYWxlIG9mdGVuIGFmZmVjdHMgaXNSVEwsIHNvIHdlIGV4cGxpY2l0bHkgbGlzdGVuIHRvIHRoYXQgdG9vLlxuXHRcdHRoaXMub3B0aW9uc01vZGVsLndhdGNoKCdhcHBseWluZ0RpckNsYXNzZXMnLCBbICc/aXNSVEwnLCAnP2xvY2FsZScgXSwgZnVuY3Rpb24ob3B0cykge1xuXHRcdFx0ZWwudG9nZ2xlQ2xhc3MoJ2ZjLWx0cicsICFvcHRzLmlzUlRMKTtcblx0XHRcdGVsLnRvZ2dsZUNsYXNzKCdmYy1ydGwnLCBvcHRzLmlzUlRMKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuY29udGVudEVsID0gJChcIjxkaXYgY2xhc3M9J2ZjLXZpZXctY29udGFpbmVyJy8+XCIpLnByZXBlbmRUbyhlbCk7XG5cblx0XHR0aGlzLmluaXRUb29sYmFycygpO1xuXHRcdHRoaXMucmVuZGVySGVhZGVyKCk7XG5cdFx0dGhpcy5yZW5kZXJGb290ZXIoKTtcblx0XHR0aGlzLnJlbmRlclZpZXcodGhpcy5vcHQoJ2RlZmF1bHRWaWV3JykpO1xuXG5cdFx0aWYgKHRoaXMub3B0KCdoYW5kbGVXaW5kb3dSZXNpemUnKSkge1xuXHRcdFx0JCh3aW5kb3cpLnJlc2l6ZShcblx0XHRcdFx0dGhpcy53aW5kb3dSZXNpemVQcm94eSA9IGRlYm91bmNlKCAvLyBwcmV2ZW50cyByYXBpZCBjYWxsc1xuXHRcdFx0XHRcdHRoaXMud2luZG93UmVzaXplLmJpbmQodGhpcyksXG5cdFx0XHRcdFx0dGhpcy5vcHQoJ3dpbmRvd1Jlc2l6ZURlbGF5Jylcblx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblxuXHRcdGlmICh0aGlzLnZpZXcpIHtcblx0XHRcdHRoaXMudmlldy5yZW1vdmVFbGVtZW50KCk7XG5cblx0XHRcdC8vIE5PVEU6IGRvbid0IG51bGwtb3V0IHRoaXMudmlldyBpbiBjYXNlIEFQSSBtZXRob2RzIGFyZSBjYWxsZWQgYWZ0ZXIgZGVzdHJveS5cblx0XHRcdC8vIEl0IGlzIHN0aWxsIHRoZSBcImN1cnJlbnRcIiB2aWV3LCBqdXN0IG5vdCByZW5kZXJlZC5cblx0XHR9XG5cblx0XHR0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ3JlbW92ZUVsZW1lbnQnKTtcblx0XHR0aGlzLmNvbnRlbnRFbC5yZW1vdmUoKTtcblx0XHR0aGlzLmVsLnJlbW92ZUNsYXNzKCdmYyBmYy1sdHIgZmMtcnRsIGZjLXVudGhlbWVkIHVpLXdpZGdldCcpO1xuXG5cdFx0dGhpcy5lbC5vZmYoJy5mYycpOyAvLyB1bmJpbmQgbmF2IGxpbmsgaGFuZGxlcnNcblxuXHRcdGlmICh0aGlzLndpbmRvd1Jlc2l6ZVByb3h5KSB7XG5cdFx0XHQkKHdpbmRvdykudW5iaW5kKCdyZXNpemUnLCB0aGlzLndpbmRvd1Jlc2l6ZVByb3h5KTtcblx0XHRcdHRoaXMud2luZG93UmVzaXplUHJveHkgPSBudWxsO1xuXHRcdH1cblxuXHRcdEdsb2JhbEVtaXR0ZXIudW5uZWVkZWQoKTtcblx0fSxcblxuXG5cdGVsZW1lbnRWaXNpYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lbC5pcygnOnZpc2libGUnKTtcblx0fSxcblxuXG5cblx0Ly8gVmlldyBSZW5kZXJpbmdcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdC8vIFJlbmRlcnMgYSB2aWV3IGJlY2F1c2Ugb2YgYSBkYXRlIGNoYW5nZSwgdmlldy10eXBlIGNoYW5nZSwgb3IgZm9yIHRoZSBmaXJzdCB0aW1lLlxuXHQvLyBJZiBub3QgZ2l2ZW4gYSB2aWV3VHlwZSwga2VlcCB0aGUgY3VycmVudCB2aWV3IGJ1dCByZW5kZXIgZGlmZmVyZW50IGRhdGVzLlxuXHQvLyBBY2NlcHRzIGFuIG9wdGlvbmFsIHNjcm9sbCBzdGF0ZSB0byByZXN0b3JlIHRvLlxuXHRyZW5kZXJWaWV3OiBmdW5jdGlvbih2aWV3VHlwZSwgZm9yY2VkU2Nyb2xsKSB7XG5cblx0XHR0aGlzLmlnbm9yZVdpbmRvd1Jlc2l6ZSsrO1xuXG5cdFx0dmFyIG5lZWRzQ2xlYXJWaWV3ID0gdGhpcy52aWV3ICYmIHZpZXdUeXBlICYmIHRoaXMudmlldy50eXBlICE9PSB2aWV3VHlwZTtcblxuXHRcdC8vIGlmIHZpZXdUeXBlIGlzIGNoYW5naW5nLCByZW1vdmUgdGhlIG9sZCB2aWV3J3MgcmVuZGVyaW5nXG5cdFx0aWYgKG5lZWRzQ2xlYXJWaWV3KSB7XG5cdFx0XHR0aGlzLmZyZWV6ZUNvbnRlbnRIZWlnaHQoKTsgLy8gcHJldmVudCBhIHNjcm9sbCBqdW1wIHdoZW4gdmlldyBlbGVtZW50IGlzIHJlbW92ZWRcblx0XHRcdHRoaXMuY2xlYXJWaWV3KCk7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdmlld1R5cGUgY2hhbmdlZCwgb3IgdGhlIHZpZXcgd2FzIG5ldmVyIGNyZWF0ZWQsIGNyZWF0ZSBhIGZyZXNoIHZpZXdcblx0XHRpZiAoIXRoaXMudmlldyAmJiB2aWV3VHlwZSkge1xuXHRcdFx0dGhpcy52aWV3ID1cblx0XHRcdFx0dGhpcy52aWV3c0J5VHlwZVt2aWV3VHlwZV0gfHxcblx0XHRcdFx0KHRoaXMudmlld3NCeVR5cGVbdmlld1R5cGVdID0gdGhpcy5pbnN0YW50aWF0ZVZpZXcodmlld1R5cGUpKTtcblxuXHRcdFx0dGhpcy52aWV3LnNldEVsZW1lbnQoXG5cdFx0XHRcdCQoXCI8ZGl2IGNsYXNzPSdmYy12aWV3IGZjLVwiICsgdmlld1R5cGUgKyBcIi12aWV3JyAvPlwiKS5hcHBlbmRUbyh0aGlzLmNvbnRlbnRFbClcblx0XHRcdCk7XG5cdFx0XHR0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ2FjdGl2YXRlQnV0dG9uJywgdmlld1R5cGUpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnZpZXcpIHtcblxuXHRcdFx0aWYgKGZvcmNlZFNjcm9sbCkge1xuXHRcdFx0XHR0aGlzLnZpZXcuYWRkRm9yY2VkU2Nyb2xsKGZvcmNlZFNjcm9sbCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmVsZW1lbnRWaXNpYmxlKCkpIHtcblx0XHRcdFx0dGhpcy5jdXJyZW50RGF0ZSA9IHRoaXMudmlldy5zZXREYXRlKHRoaXMuY3VycmVudERhdGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChuZWVkc0NsZWFyVmlldykge1xuXHRcdFx0dGhpcy50aGF3Q29udGVudEhlaWdodCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuaWdub3JlV2luZG93UmVzaXplLS07XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgdGhlIGN1cnJlbnQgdmlldyBhbmQgcmVmbGVjdHMgdGhpcyBjaGFuZ2UgaW4gdGhlIEhlYWRlci5cblx0Ly8gVW5yZWdzaXRlcnMgdGhlIGB2aWV3YCwgYnV0IGRvZXMgbm90IHJlbW92ZSBmcm9tIHZpZXdCeVR5cGUgaGFzaC5cblx0Y2xlYXJWaWV3OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ2RlYWN0aXZhdGVCdXR0b24nLCB0aGlzLnZpZXcudHlwZSk7XG5cdFx0dGhpcy52aWV3LnJlbW92ZUVsZW1lbnQoKTtcblx0XHR0aGlzLnZpZXcgPSBudWxsO1xuXHR9LFxuXG5cblx0Ly8gRGVzdHJveXMgdGhlIHZpZXcsIGluY2x1ZGluZyB0aGUgdmlldyBvYmplY3QuIFRoZW4sIHJlLWluc3RhbnRpYXRlcyBpdCBhbmQgcmVuZGVycyBpdC5cblx0Ly8gTWFpbnRhaW5zIHRoZSBzYW1lIHNjcm9sbCBzdGF0ZS5cblx0Ly8gVE9ETzogbWFpbnRhaW4gYW55IG90aGVyIHVzZXItbWFuaXB1bGF0ZWQgc3RhdGUuXG5cdHJlaW5pdFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaWdub3JlV2luZG93UmVzaXplKys7XG5cdFx0dGhpcy5mcmVlemVDb250ZW50SGVpZ2h0KCk7XG5cblx0XHR2YXIgdmlld1R5cGUgPSB0aGlzLnZpZXcudHlwZTtcblx0XHR2YXIgc2Nyb2xsU3RhdGUgPSB0aGlzLnZpZXcucXVlcnlTY3JvbGwoKTtcblx0XHR0aGlzLmNsZWFyVmlldygpO1xuXHRcdHRoaXMuY2FsY1NpemUoKTtcblx0XHR0aGlzLnJlbmRlclZpZXcodmlld1R5cGUsIHNjcm9sbFN0YXRlKTtcblxuXHRcdHRoaXMudGhhd0NvbnRlbnRIZWlnaHQoKTtcblx0XHR0aGlzLmlnbm9yZVdpbmRvd1Jlc2l6ZS0tO1xuXHR9LFxuXG5cblx0Ly8gUmVzaXppbmdcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdGdldFN1Z2dlc3RlZFZpZXdIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPT09IG51bGwpIHtcblx0XHRcdHRoaXMuY2FsY1NpemUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodDtcblx0fSxcblxuXG5cdGlzSGVpZ2h0QXV0bzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0KCdjb250ZW50SGVpZ2h0JykgPT09ICdhdXRvJyB8fCB0aGlzLm9wdCgnaGVpZ2h0JykgPT09ICdhdXRvJztcblx0fSxcblxuXG5cdHVwZGF0ZVNpemU6IGZ1bmN0aW9uKHNob3VsZFJlY2FsYykge1xuXHRcdGlmICh0aGlzLmVsZW1lbnRWaXNpYmxlKCkpIHtcblxuXHRcdFx0aWYgKHNob3VsZFJlY2FsYykge1xuXHRcdFx0XHR0aGlzLl9jYWxjU2l6ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmlnbm9yZVdpbmRvd1Jlc2l6ZSsrO1xuXHRcdFx0dGhpcy52aWV3LnVwZGF0ZVNpemUodHJ1ZSk7IC8vIGlzUmVzaXplPXRydWUuIHdpbGwgcG9sbCBnZXRTdWdnZXN0ZWRWaWV3SGVpZ2h0KCkgYW5kIGlzSGVpZ2h0QXV0bygpXG5cdFx0XHR0aGlzLmlnbm9yZVdpbmRvd1Jlc2l6ZS0tO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gc2lnbmFsIHN1Y2Nlc3Ncblx0XHR9XG5cdH0sXG5cblxuXHRjYWxjU2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuZWxlbWVudFZpc2libGUoKSkge1xuXHRcdFx0dGhpcy5fY2FsY1NpemUoKTtcblx0XHR9XG5cdH0sXG5cblxuXHRfY2FsY1NpemU6IGZ1bmN0aW9uKCkgeyAvLyBhc3N1bWVzIGVsZW1lbnRWaXNpYmxlXG5cdFx0dmFyIGNvbnRlbnRIZWlnaHRJbnB1dCA9IHRoaXMub3B0KCdjb250ZW50SGVpZ2h0Jyk7XG5cdFx0dmFyIGhlaWdodElucHV0ID0gdGhpcy5vcHQoJ2hlaWdodCcpO1xuXG5cdFx0aWYgKHR5cGVvZiBjb250ZW50SGVpZ2h0SW5wdXQgPT09ICdudW1iZXInKSB7IC8vIGV4aXN0cyBhbmQgbm90ICdhdXRvJ1xuXHRcdFx0dGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gY29udGVudEhlaWdodElucHV0O1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2YgY29udGVudEhlaWdodElucHV0ID09PSAnZnVuY3Rpb24nKSB7IC8vIGV4aXN0cyBhbmQgaXMgYSBmdW5jdGlvblxuXHRcdFx0dGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gY29udGVudEhlaWdodElucHV0KCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiBoZWlnaHRJbnB1dCA9PT0gJ251bWJlcicpIHsgLy8gZXhpc3RzIGFuZCBub3QgJ2F1dG8nXG5cdFx0XHR0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBoZWlnaHRJbnB1dCAtIHRoaXMucXVlcnlUb29sYmFyc0hlaWdodCgpO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2YgaGVpZ2h0SW5wdXQgPT09ICdmdW5jdGlvbicpIHsgLy8gZXhpc3RzIGFuZCBpcyBhIGZ1bmN0aW9uXG5cdFx0XHR0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBoZWlnaHRJbnB1dCgpIC0gdGhpcy5xdWVyeVRvb2xiYXJzSGVpZ2h0KCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGhlaWdodElucHV0ID09PSAncGFyZW50JykgeyAvLyBzZXQgdG8gaGVpZ2h0IG9mIHBhcmVudCBlbGVtZW50XG5cdFx0XHR0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSB0aGlzLmVsLnBhcmVudCgpLmhlaWdodCgpIC0gdGhpcy5xdWVyeVRvb2xiYXJzSGVpZ2h0KCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gTWF0aC5yb3VuZChcblx0XHRcdFx0dGhpcy5jb250ZW50RWwud2lkdGgoKSAvXG5cdFx0XHRcdE1hdGgubWF4KHRoaXMub3B0KCdhc3BlY3RSYXRpbycpLCAuNSlcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0d2luZG93UmVzaXplOiBmdW5jdGlvbihldikge1xuXHRcdGlmIChcblx0XHRcdCF0aGlzLmlnbm9yZVdpbmRvd1Jlc2l6ZSAmJlxuXHRcdFx0ZXYudGFyZ2V0ID09PSB3aW5kb3cgJiYgLy8gc28gd2UgZG9uJ3QgcHJvY2VzcyBqcXVpIFwicmVzaXplXCIgZXZlbnRzIHRoYXQgaGF2ZSBidWJibGVkIHVwXG5cdFx0XHR0aGlzLnZpZXcucmVuZGVyUmFuZ2UgLy8gdmlldyBoYXMgYWxyZWFkeSBiZWVuIHJlbmRlcmVkXG5cdFx0KSB7XG5cdFx0XHRpZiAodGhpcy51cGRhdGVTaXplKHRydWUpKSB7XG5cdFx0XHRcdHRoaXMudmlldy5wdWJsaWNseVRyaWdnZXIoJ3dpbmRvd1Jlc2l6ZScsIHRoaXMuZWxbMF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8qIEhlaWdodCBcIkZyZWV6aW5nXCJcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0ZnJlZXplQ29udGVudEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jb250ZW50RWwuY3NzKHtcblx0XHRcdHdpZHRoOiAnMTAwJScsXG5cdFx0XHRoZWlnaHQ6IHRoaXMuY29udGVudEVsLmhlaWdodCgpLFxuXHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0fSk7XG5cdH0sXG5cblxuXHR0aGF3Q29udGVudEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jb250ZW50RWwuY3NzKHtcblx0XHRcdHdpZHRoOiAnJyxcblx0XHRcdGhlaWdodDogJycsXG5cdFx0XHRvdmVyZmxvdzogJydcblx0XHR9KTtcblx0fVxuXG59KTtcblxuOztcblxuQ2FsZW5kYXIubWl4aW4oe1xuXG5cdGhlYWRlcjogbnVsbCxcblx0Zm9vdGVyOiBudWxsLFxuXHR0b29sYmFyc01hbmFnZXI6IG51bGwsXG5cblxuXHRpbml0VG9vbGJhcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVhZGVyID0gbmV3IFRvb2xiYXIodGhpcywgdGhpcy5jb21wdXRlSGVhZGVyT3B0aW9ucygpKTtcblx0XHR0aGlzLmZvb3RlciA9IG5ldyBUb29sYmFyKHRoaXMsIHRoaXMuY29tcHV0ZUZvb3Rlck9wdGlvbnMoKSk7XG5cdFx0dGhpcy50b29sYmFyc01hbmFnZXIgPSBuZXcgSXRlcmF0b3IoWyB0aGlzLmhlYWRlciwgdGhpcy5mb290ZXIgXSk7XG5cdH0sXG5cblxuXHRjb21wdXRlSGVhZGVyT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dHJhQ2xhc3NlczogJ2ZjLWhlYWRlci10b29sYmFyJyxcblx0XHRcdGxheW91dDogdGhpcy5vcHQoJ2hlYWRlcicpXG5cdFx0fTtcblx0fSxcblxuXG5cdGNvbXB1dGVGb290ZXJPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0cmFDbGFzc2VzOiAnZmMtZm9vdGVyLXRvb2xiYXInLFxuXHRcdFx0bGF5b3V0OiB0aGlzLm9wdCgnZm9vdGVyJylcblx0XHR9O1xuXHR9LFxuXG5cblx0Ly8gY2FuIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFuZCBIZWFkZXIgd2lsbCByZXJlbmRlclxuXHRyZW5kZXJIZWFkZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlcjtcblxuXHRcdGhlYWRlci5zZXRUb29sYmFyT3B0aW9ucyh0aGlzLmNvbXB1dGVIZWFkZXJPcHRpb25zKCkpO1xuXHRcdGhlYWRlci5yZW5kZXIoKTtcblxuXHRcdGlmIChoZWFkZXIuZWwpIHtcblx0XHRcdHRoaXMuZWwucHJlcGVuZChoZWFkZXIuZWwpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIGNhbiBiZSBjYWxsZWQgcmVwZWF0ZWRseSBhbmQgRm9vdGVyIHdpbGwgcmVyZW5kZXJcblx0cmVuZGVyRm9vdGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZm9vdGVyID0gdGhpcy5mb290ZXI7XG5cblx0XHRmb290ZXIuc2V0VG9vbGJhck9wdGlvbnModGhpcy5jb21wdXRlRm9vdGVyT3B0aW9ucygpKTtcblx0XHRmb290ZXIucmVuZGVyKCk7XG5cblx0XHRpZiAoZm9vdGVyLmVsKSB7XG5cdFx0XHR0aGlzLmVsLmFwcGVuZChmb290ZXIuZWwpO1xuXHRcdH1cblx0fSxcblxuXG5cdHNldFRvb2xiYXJzVGl0bGU6IGZ1bmN0aW9uKHRpdGxlKSB7XG5cdFx0dGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKCd1cGRhdGVUaXRsZScsIHRpdGxlKTtcblx0fSxcblxuXG5cdHVwZGF0ZVRvb2xiYXJCdXR0b25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbm93ID0gdGhpcy5nZXROb3coKTtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgdG9kYXlJbmZvID0gdmlldy5idWlsZERhdGVQcm9maWxlKG5vdyk7XG5cdFx0dmFyIHByZXZJbmZvID0gdmlldy5idWlsZFByZXZEYXRlUHJvZmlsZSh0aGlzLmN1cnJlbnREYXRlKTtcblx0XHR2YXIgbmV4dEluZm8gPSB2aWV3LmJ1aWxkTmV4dERhdGVQcm9maWxlKHRoaXMuY3VycmVudERhdGUpO1xuXG5cdFx0dGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKFxuXHRcdFx0KHRvZGF5SW5mby5pc1ZhbGlkICYmICFpc0RhdGVXaXRoaW5SYW5nZShub3csIHZpZXcuY3VycmVudFJhbmdlKSkgP1xuXHRcdFx0XHQnZW5hYmxlQnV0dG9uJyA6XG5cdFx0XHRcdCdkaXNhYmxlQnV0dG9uJyxcblx0XHRcdCd0b2RheSdcblx0XHQpO1xuXG5cdFx0dGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKFxuXHRcdFx0cHJldkluZm8uaXNWYWxpZCA/XG5cdFx0XHRcdCdlbmFibGVCdXR0b24nIDpcblx0XHRcdFx0J2Rpc2FibGVCdXR0b24nLFxuXHRcdFx0J3ByZXYnXG5cdFx0KTtcblxuXHRcdHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbChcblx0XHRcdG5leHRJbmZvLmlzVmFsaWQgP1xuXHRcdFx0XHQnZW5hYmxlQnV0dG9uJyA6XG5cdFx0XHRcdCdkaXNhYmxlQnV0dG9uJyxcblx0XHRcdCduZXh0J1xuXHRcdCk7XG5cdH0sXG5cblxuXHRxdWVyeVRvb2xiYXJzSGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50b29sYmFyc01hbmFnZXIuaXRlbXMucmVkdWNlKGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB0b29sYmFyKSB7XG5cdFx0XHR2YXIgdG9vbGJhckhlaWdodCA9IHRvb2xiYXIuZWwgPyB0b29sYmFyLmVsLm91dGVySGVpZ2h0KHRydWUpIDogMDsgLy8gaW5jbHVkZXMgbWFyZ2luXG5cdFx0XHRyZXR1cm4gYWNjdW11bGF0b3IgKyB0b29sYmFySGVpZ2h0O1xuXHRcdH0sIDApO1xuXHR9XG5cbn0pO1xuXG47O1xuXG5DYWxlbmRhci5kZWZhdWx0cyA9IHtcblxuXHR0aXRsZVJhbmdlU2VwYXJhdG9yOiAnIFxcdTIwMTMgJywgLy8gZW4gZGFzaFxuXHRtb250aFllYXJGb3JtYXQ6ICdNTU1NIFlZWVknLCAvLyByZXF1aXJlZCBmb3IgZW4uIG90aGVyIGxvY2FsZXMgcmVseSBvbiBkYXRlcGlja2VyIGNvbXB1dGFibGUgb3B0aW9uXG5cblx0ZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogJzAyOjAwOjAwJyxcblx0ZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IHsgZGF5czogMSB9LFxuXHRmb3JjZUV2ZW50RHVyYXRpb246IGZhbHNlLFxuXHRuZXh0RGF5VGhyZXNob2xkOiAnMDk6MDA6MDAnLCAvLyA5YW1cblxuXHQvLyBkaXNwbGF5XG5cdGRlZmF1bHRWaWV3OiAnbW9udGgnLFxuXHRhc3BlY3RSYXRpbzogMS4zNSxcblx0aGVhZGVyOiB7XG5cdFx0bGVmdDogJ3RpdGxlJyxcblx0XHRjZW50ZXI6ICcnLFxuXHRcdHJpZ2h0OiAndG9kYXkgcHJldixuZXh0J1xuXHR9LFxuXHR3ZWVrZW5kczogdHJ1ZSxcblx0d2Vla051bWJlcnM6IGZhbHNlLFxuXG5cdHdlZWtOdW1iZXJUaXRsZTogJ1cnLFxuXHR3ZWVrTnVtYmVyQ2FsY3VsYXRpb246ICdsb2NhbCcsXG5cdFxuXHQvL2VkaXRhYmxlOiBmYWxzZSxcblxuXHQvL25vd0luZGljYXRvcjogZmFsc2UsXG5cblx0c2Nyb2xsVGltZTogJzA2OjAwOjAwJyxcblx0bWluVGltZTogJzAwOjAwOjAwJyxcblx0bWF4VGltZTogJzI0OjAwOjAwJyxcblx0c2hvd05vbkN1cnJlbnREYXRlczogdHJ1ZSxcblx0XG5cdC8vIGV2ZW50IGFqYXhcblx0bGF6eUZldGNoaW5nOiB0cnVlLFxuXHRzdGFydFBhcmFtOiAnc3RhcnQnLFxuXHRlbmRQYXJhbTogJ2VuZCcsXG5cdHRpbWV6b25lUGFyYW06ICd0aW1lem9uZScsXG5cblx0dGltZXpvbmU6IGZhbHNlLFxuXG5cdC8vYWxsRGF5RGVmYXVsdDogdW5kZWZpbmVkLFxuXG5cdC8vIGxvY2FsZVxuXHRpc1JUTDogZmFsc2UsXG5cdGJ1dHRvblRleHQ6IHtcblx0XHRwcmV2OiBcInByZXZcIixcblx0XHRuZXh0OiBcIm5leHRcIixcblx0XHRwcmV2WWVhcjogXCJwcmV2IHllYXJcIixcblx0XHRuZXh0WWVhcjogXCJuZXh0IHllYXJcIixcblx0XHR5ZWFyOiAneWVhcicsIC8vIFRPRE86IGxvY2FsZSBmaWxlcyBuZWVkIHRvIHNwZWNpZnkgdGhpc1xuXHRcdHRvZGF5OiAndG9kYXknLFxuXHRcdG1vbnRoOiAnbW9udGgnLFxuXHRcdHdlZWs6ICd3ZWVrJyxcblx0XHRkYXk6ICdkYXknXG5cdH0sXG5cblx0YnV0dG9uSWNvbnM6IHtcblx0XHRwcmV2OiAnbGVmdC1zaW5nbGUtYXJyb3cnLFxuXHRcdG5leHQ6ICdyaWdodC1zaW5nbGUtYXJyb3cnLFxuXHRcdHByZXZZZWFyOiAnbGVmdC1kb3VibGUtYXJyb3cnLFxuXHRcdG5leHRZZWFyOiAncmlnaHQtZG91YmxlLWFycm93J1xuXHR9LFxuXG5cdGFsbERheVRleHQ6ICdhbGwtZGF5Jyxcblx0XG5cdC8vIGpxdWVyeS11aSB0aGVtaW5nXG5cdHRoZW1lOiBmYWxzZSxcblx0dGhlbWVCdXR0b25JY29uczoge1xuXHRcdHByZXY6ICdjaXJjbGUtdHJpYW5nbGUtdycsXG5cdFx0bmV4dDogJ2NpcmNsZS10cmlhbmdsZS1lJyxcblx0XHRwcmV2WWVhcjogJ3NlZWstcHJldicsXG5cdFx0bmV4dFllYXI6ICdzZWVrLW5leHQnXG5cdH0sXG5cblx0Ly9ldmVudFJlc2l6YWJsZUZyb21TdGFydDogZmFsc2UsXG5cdGRyYWdPcGFjaXR5OiAuNzUsXG5cdGRyYWdSZXZlcnREdXJhdGlvbjogNTAwLFxuXHRkcmFnU2Nyb2xsOiB0cnVlLFxuXHRcblx0Ly9zZWxlY3RhYmxlOiBmYWxzZSxcblx0dW5zZWxlY3RBdXRvOiB0cnVlLFxuXHQvL3NlbGVjdE1pbkRpc3RhbmNlOiAwLFxuXHRcblx0ZHJvcEFjY2VwdDogJyonLFxuXG5cdGV2ZW50T3JkZXI6ICd0aXRsZScsXG5cdC8vZXZlbnRSZW5kZXJXYWl0OiBudWxsLFxuXG5cdGV2ZW50TGltaXQ6IGZhbHNlLFxuXHRldmVudExpbWl0VGV4dDogJ21vcmUnLFxuXHRldmVudExpbWl0Q2xpY2s6ICdwb3BvdmVyJyxcblx0ZGF5UG9wb3ZlckZvcm1hdDogJ0xMJyxcblx0XG5cdGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcblx0d2luZG93UmVzaXplRGVsYXk6IDEwMCwgLy8gbWlsbGlzZWNvbmRzIGJlZm9yZSBhbiB1cGRhdGVTaXplIGhhcHBlbnNcblxuXHRsb25nUHJlc3NEZWxheTogMTAwMFxuXHRcbn07XG5cblxuQ2FsZW5kYXIuZW5nbGlzaERlZmF1bHRzID0geyAvLyB1c2VkIGJ5IGxvY2FsZS5qc1xuXHRkYXlQb3BvdmVyRm9ybWF0OiAnZGRkZCwgTU1NTSBEJ1xufTtcblxuXG5DYWxlbmRhci5ydGxEZWZhdWx0cyA9IHsgLy8gcmlnaHQtdG8tbGVmdCBkZWZhdWx0c1xuXHRoZWFkZXI6IHsgLy8gVE9ETzogc21hcnRlciBzb2x1dGlvbiAoZmlyc3QvY2VudGVyL2xhc3QgPylcblx0XHRsZWZ0OiAnbmV4dCxwcmV2IHRvZGF5Jyxcblx0XHRjZW50ZXI6ICcnLFxuXHRcdHJpZ2h0OiAndGl0bGUnXG5cdH0sXG5cdGJ1dHRvbkljb25zOiB7XG5cdFx0cHJldjogJ3JpZ2h0LXNpbmdsZS1hcnJvdycsXG5cdFx0bmV4dDogJ2xlZnQtc2luZ2xlLWFycm93Jyxcblx0XHRwcmV2WWVhcjogJ3JpZ2h0LWRvdWJsZS1hcnJvdycsXG5cdFx0bmV4dFllYXI6ICdsZWZ0LWRvdWJsZS1hcnJvdydcblx0fSxcblx0dGhlbWVCdXR0b25JY29uczoge1xuXHRcdHByZXY6ICdjaXJjbGUtdHJpYW5nbGUtZScsXG5cdFx0bmV4dDogJ2NpcmNsZS10cmlhbmdsZS13Jyxcblx0XHRuZXh0WWVhcjogJ3NlZWstcHJldicsXG5cdFx0cHJldlllYXI6ICdzZWVrLW5leHQnXG5cdH1cbn07XG5cbjs7XG5cbnZhciBsb2NhbGVPcHRpb25IYXNoID0gRkMubG9jYWxlcyA9IHt9OyAvLyBpbml0aWFsaXplIGFuZCBleHBvc2VcblxuXG4vLyBUT0RPOiBkb2N1bWVudCB0aGUgc3RydWN0dXJlIGFuZCBvcmRlcmluZyBvZiBhIEZ1bGxDYWxlbmRhciBsb2NhbGUgZmlsZVxuXG5cbi8vIEluaXRpYWxpemUgalF1ZXJ5IFVJIGRhdGVwaWNrZXIgdHJhbnNsYXRpb25zIHdoaWxlIHVzaW5nIHNvbWUgb2YgdGhlIHRyYW5zbGF0aW9uc1xuLy8gV2lsbCBzZXQgdGhpcyBhcyB0aGUgZGVmYXVsdCBsb2NhbGVzIGZvciBkYXRlcGlja2VyLlxuRkMuZGF0ZXBpY2tlckxvY2FsZSA9IGZ1bmN0aW9uKGxvY2FsZUNvZGUsIGRwTG9jYWxlQ29kZSwgZHBPcHRpb25zKSB7XG5cblx0Ly8gZ2V0IHRoZSBGdWxsQ2FsZW5kYXIgaW50ZXJuYWwgb3B0aW9uIGhhc2ggZm9yIHRoaXMgbG9jYWxlLiBjcmVhdGUgaWYgbmVjZXNzYXJ5XG5cdHZhciBmY09wdGlvbnMgPSBsb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdIHx8IChsb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdID0ge30pO1xuXG5cdC8vIHRyYW5zZmVyIHNvbWUgc2ltcGxlIG9wdGlvbnMgZnJvbSBkYXRlcGlja2VyIHRvIGZjXG5cdGZjT3B0aW9ucy5pc1JUTCA9IGRwT3B0aW9ucy5pc1JUTDtcblx0ZmNPcHRpb25zLndlZWtOdW1iZXJUaXRsZSA9IGRwT3B0aW9ucy53ZWVrSGVhZGVyO1xuXG5cdC8vIGNvbXB1dGUgc29tZSBtb3JlIGNvbXBsZXggb3B0aW9ucyBmcm9tIGRhdGVwaWNrZXJcblx0JC5lYWNoKGRwQ29tcHV0YWJsZU9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcblx0XHRmY09wdGlvbnNbbmFtZV0gPSBmdW5jKGRwT3B0aW9ucyk7XG5cdH0pO1xuXG5cdC8vIGlzIGpRdWVyeSBVSSBEYXRlcGlja2VyIGlzIG9uIHRoZSBwYWdlP1xuXHRpZiAoJC5kYXRlcGlja2VyKSB7XG5cblx0XHQvLyBSZWdpc3RlciB0aGUgbG9jYWxlIGRhdGEuXG5cdFx0Ly8gRnVsbENhbGVuZGFyIGFuZCBNb21lbnRKUyB1c2UgbG9jYWxlIGNvZGVzIGxpa2UgXCJwdC1iclwiIGJ1dCBEYXRlcGlja2VyXG5cdFx0Ly8gZG9lcyBpdCBsaWtlIFwicHQtQlJcIiBvciBpZiBpdCBkb2Vzbid0IGhhdmUgdGhlIGxvY2FsZSwgbWF5YmUganVzdCBcInB0XCIuXG5cdFx0Ly8gTWFrZSBhbiBhbGlhcyBzbyB0aGUgbG9jYWxlIGNhbiBiZSByZWZlcmVuY2VkIGVpdGhlciB3YXkuXG5cdFx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsW2RwTG9jYWxlQ29kZV0gPVxuXHRcdFx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsW2xvY2FsZUNvZGVdID0gLy8gYWxpYXNcblx0XHRcdFx0ZHBPcHRpb25zO1xuXG5cdFx0Ly8gQWxpYXMgJ2VuJyB0byB0aGUgZGVmYXVsdCBsb2NhbGUgZGF0YS4gRG8gdGhpcyBldmVyeSB0aW1lLlxuXHRcdCQuZGF0ZXBpY2tlci5yZWdpb25hbC5lbiA9ICQuZGF0ZXBpY2tlci5yZWdpb25hbFsnJ107XG5cblx0XHQvLyBTZXQgYXMgRGF0ZXBpY2tlcidzIGdsb2JhbCBkZWZhdWx0cy5cblx0XHQkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoZHBPcHRpb25zKTtcblx0fVxufTtcblxuXG4vLyBTZXRzIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyB0cmFuc2xhdGlvbnMuIFdpbGwgc2V0IHRoZSBsb2NhbGVzIGFzIHRoZSBnbG9iYWwgZGVmYXVsdC5cbkZDLmxvY2FsZSA9IGZ1bmN0aW9uKGxvY2FsZUNvZGUsIG5ld0ZjT3B0aW9ucykge1xuXHR2YXIgZmNPcHRpb25zO1xuXHR2YXIgbW9tT3B0aW9ucztcblxuXHQvLyBnZXQgdGhlIEZ1bGxDYWxlbmRhciBpbnRlcm5hbCBvcHRpb24gaGFzaCBmb3IgdGhpcyBsb2NhbGUuIGNyZWF0ZSBpZiBuZWNlc3Nhcnlcblx0ZmNPcHRpb25zID0gbG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVDb2RlXSB8fCAobG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVDb2RlXSA9IHt9KTtcblxuXHQvLyBwcm92aWRlZCBuZXcgb3B0aW9ucyBmb3IgdGhpcyBsb2NhbGVzPyBtZXJnZSB0aGVtIGluXG5cdGlmIChuZXdGY09wdGlvbnMpIHtcblx0XHRmY09wdGlvbnMgPSBsb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdID0gbWVyZ2VPcHRpb25zKFsgZmNPcHRpb25zLCBuZXdGY09wdGlvbnMgXSk7XG5cdH1cblxuXHQvLyBjb21wdXRlIGxvY2FsZSBvcHRpb25zIHRoYXQgd2VyZW4ndCBkZWZpbmVkLlxuXHQvLyBhbHdheXMgZG8gdGhpcy4gbmV3RmNPcHRpb25zIGNhbiBiZSB1bmRlZmluZWQgd2hlbiBpbml0aWFsaXppbmcgZnJvbSBpMThuIGZpbGUsXG5cdC8vIHNvIG5vIHdheSB0byB0ZWxsIGlmIHRoaXMgaXMgYW4gaW5pdGlhbGl6YXRpb24gb3IgYSBkZWZhdWx0LXNldHRpbmcuXG5cdG1vbU9wdGlvbnMgPSBnZXRNb21lbnRMb2NhbGVEYXRhKGxvY2FsZUNvZGUpOyAvLyB3aWxsIGZhbGwgYmFjayB0byBlblxuXHQkLmVhY2gobW9tQ29tcHV0YWJsZU9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcblx0XHRpZiAoZmNPcHRpb25zW25hbWVdID09IG51bGwpIHtcblx0XHRcdGZjT3B0aW9uc1tuYW1lXSA9IGZ1bmMobW9tT3B0aW9ucywgZmNPcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIHNldCBpdCBhcyB0aGUgZGVmYXVsdCBsb2NhbGUgZm9yIEZ1bGxDYWxlbmRhclxuXHRDYWxlbmRhci5kZWZhdWx0cy5sb2NhbGUgPSBsb2NhbGVDb2RlO1xufTtcblxuXG4vLyBOT1RFOiBjYW4ndCBndWFyYW50ZWUgYW55IG9mIHRoZXNlIGNvbXB1dGF0aW9ucyB3aWxsIHJ1biBiZWNhdXNlIG5vdCBldmVyeSBsb2NhbGUgaGFzIGRhdGVwaWNrZXJcbi8vIGNvbmZpZ3MsIHNvIG1ha2Ugc3VyZSB0aGVyZSBhcmUgRW5nbGlzaCBmYWxsYmFja3MgZm9yIHRoZXNlIGluIHRoZSBkZWZhdWx0cyBmaWxlLlxudmFyIGRwQ29tcHV0YWJsZU9wdGlvbnMgPSB7XG5cblx0YnV0dG9uVGV4dDogZnVuY3Rpb24oZHBPcHRpb25zKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdC8vIHRoZSB0cmFuc2xhdGlvbnMgc29tZXRpbWVzIHdyb25nbHkgY29udGFpbiBIVE1MIGVudGl0aWVzXG5cdFx0XHRwcmV2OiBzdHJpcEh0bWxFbnRpdGllcyhkcE9wdGlvbnMucHJldlRleHQpLFxuXHRcdFx0bmV4dDogc3RyaXBIdG1sRW50aXRpZXMoZHBPcHRpb25zLm5leHRUZXh0KSxcblx0XHRcdHRvZGF5OiBzdHJpcEh0bWxFbnRpdGllcyhkcE9wdGlvbnMuY3VycmVudFRleHQpXG5cdFx0fTtcblx0fSxcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiTU1NTSBZWVlZXCIgLT4gXCJTZXB0ZW1iZXIgMjAxNFwiXG5cdG1vbnRoWWVhckZvcm1hdDogZnVuY3Rpb24oZHBPcHRpb25zKSB7XG5cdFx0cmV0dXJuIGRwT3B0aW9ucy5zaG93TW9udGhBZnRlclllYXIgP1xuXHRcdFx0J1lZWVlbJyArIGRwT3B0aW9ucy55ZWFyU3VmZml4ICsgJ10gTU1NTScgOlxuXHRcdFx0J01NTU0gWVlZWVsnICsgZHBPcHRpb25zLnllYXJTdWZmaXggKyAnXSc7XG5cdH1cblxufTtcblxudmFyIG1vbUNvbXB1dGFibGVPcHRpb25zID0ge1xuXG5cdC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJkZGQgTS9EXCIgLT4gXCJGcmkgOS8xNVwiXG5cdGRheU9mTW9udGhGb3JtYXQ6IGZ1bmN0aW9uKG1vbU9wdGlvbnMsIGZjT3B0aW9ucykge1xuXHRcdHZhciBmb3JtYXQgPSBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdsJyk7IC8vIGZvciB0aGUgZm9ybWF0IGxpa2UgXCJNL0QvWVlZWVwiXG5cblx0XHQvLyBzdHJpcCB0aGUgeWVhciBvZmYgdGhlIGVkZ2UsIGFzIHdlbGwgYXMgb3RoZXIgbWlzYyBub24td2hpdGVzcGFjZSBjaGFyc1xuXHRcdGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9eWStbXlxcd1xcc10qfFteXFx3XFxzXSpZKyQvZywgJycpO1xuXG5cdFx0aWYgKGZjT3B0aW9ucy5pc1JUTCkge1xuXHRcdFx0Zm9ybWF0ICs9ICcgZGRkJzsgLy8gZm9yIFJUTCwgYWRkIGRheS1vZi13ZWVrIHRvIGVuZFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGZvcm1hdCA9ICdkZGQgJyArIGZvcm1hdDsgLy8gZm9yIExUUiwgYWRkIGRheS1vZi13ZWVrIHRvIGJlZ2lubmluZ1xuXHRcdH1cblx0XHRyZXR1cm4gZm9ybWF0O1xuXHR9LFxuXG5cdC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJoOm1tYVwiIC0+IFwiNjowMHBtXCJcblx0bWVkaXVtVGltZUZvcm1hdDogZnVuY3Rpb24obW9tT3B0aW9ucykgeyAvLyBjYW4ndCBiZSBjYWxsZWQgYHRpbWVGb3JtYXRgIGJlY2F1c2UgY29sbGlkZXMgd2l0aCBvcHRpb25cblx0XHRyZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxuXHRcdFx0LnJlcGxhY2UoL1xccyphJC9pLCAnYScpOyAvLyBjb252ZXJ0IEFNL1BNL2FtL3BtIHRvIGxvd2VyY2FzZS4gcmVtb3ZlIGFueSBzcGFjZXMgYmVmb3JlaGFuZFxuXHR9LFxuXG5cdC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJoKDptbSlhXCIgLT4gXCI2cG1cIiAvIFwiNjozMHBtXCJcblx0c21hbGxUaW1lRm9ybWF0OiBmdW5jdGlvbihtb21PcHRpb25zKSB7XG5cdFx0cmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcblx0XHRcdC5yZXBsYWNlKCc6bW0nLCAnKDptbSknKVxuXHRcdFx0LnJlcGxhY2UoLyhcXFdtbSkkLywgJygkMSknKSAvLyBsaWtlIGFib3ZlLCBidXQgZm9yIGZvcmVpZ24gbG9jYWxlc1xuXHRcdFx0LnJlcGxhY2UoL1xccyphJC9pLCAnYScpOyAvLyBjb252ZXJ0IEFNL1BNL2FtL3BtIHRvIGxvd2VyY2FzZS4gcmVtb3ZlIGFueSBzcGFjZXMgYmVmb3JlaGFuZFxuXHR9LFxuXG5cdC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJoKDptbSl0XCIgLT4gXCI2cFwiIC8gXCI2OjMwcFwiXG5cdGV4dHJhU21hbGxUaW1lRm9ybWF0OiBmdW5jdGlvbihtb21PcHRpb25zKSB7XG5cdFx0cmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcblx0XHRcdC5yZXBsYWNlKCc6bW0nLCAnKDptbSknKVxuXHRcdFx0LnJlcGxhY2UoLyhcXFdtbSkkLywgJygkMSknKSAvLyBsaWtlIGFib3ZlLCBidXQgZm9yIGZvcmVpZ24gbG9jYWxlc1xuXHRcdFx0LnJlcGxhY2UoL1xccyphJC9pLCAndCcpOyAvLyBjb252ZXJ0IHRvIEFNL1BNL2FtL3BtIHRvIGxvd2VyY2FzZSBvbmUtbGV0dGVyLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXG5cdH0sXG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImhhXCIgLyBcIkhcIiAtPiBcIjZwbVwiIC8gXCIxOFwiXG5cdGhvdXJGb3JtYXQ6IGZ1bmN0aW9uKG1vbU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxuXHRcdFx0LnJlcGxhY2UoJzptbScsICcnKVxuXHRcdFx0LnJlcGxhY2UoLyhcXFdtbSkkLywgJycpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsb2NhbGVzXG5cdFx0XHQucmVwbGFjZSgvXFxzKmEkL2ksICdhJyk7IC8vIGNvbnZlcnQgQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXG5cdH0sXG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImg6bW1cIiAtPiBcIjY6MzBcIiAod2l0aCBubyBBTS9QTSlcblx0bm9NZXJpZGllbVRpbWVGb3JtYXQ6IGZ1bmN0aW9uKG1vbU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxuXHRcdFx0LnJlcGxhY2UoL1xccyphJC9pLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBBTS9QTVxuXHR9XG5cbn07XG5cblxuLy8gb3B0aW9ucyB0aGF0IHNob3VsZCBiZSBjb21wdXRlZCBvZmYgbGl2ZSBjYWxlbmRhciBvcHRpb25zIChjb25zaWRlcnMgb3ZlcnJpZGUgb3B0aW9ucylcbi8vIFRPRE86IGJlc3QgcGxhY2UgZm9yIHRoaXM/IHJlbGF0ZWQgdG8gbG9jYWxlP1xuLy8gVE9ETzogZmxpcHBpbmcgdGV4dCBiYXNlZCBvbiBpc1JUTCBpcyBhIGJhZCBpZGVhIGJlY2F1c2UgdGhlIENTUyBgZGlyZWN0aW9uYCBtaWdodCB3YW50IHRvIGhhbmRsZSBpdFxudmFyIGluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMgPSB7XG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgZm9yIHJlc3VsdHMgbGlrZSBcIk1vIDE2XCJcblx0c21hbGxEYXlEYXRlRm9ybWF0OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuaXNSVEwgP1xuXHRcdFx0J0QgZGQnIDpcblx0XHRcdCdkZCBEJztcblx0fSxcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBmb3IgcmVzdWx0cyBsaWtlIFwiV2sgNVwiXG5cdHdlZWtGb3JtYXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5pc1JUTCA/XG5cdFx0XHQnd1sgJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJ10nIDpcblx0XHRcdCdbJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJyBddyc7XG5cdH0sXG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgZm9yIHJlc3VsdHMgbGlrZSBcIldrNVwiXG5cdHNtYWxsV2Vla0Zvcm1hdDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBvcHRpb25zLmlzUlRMID9cblx0XHRcdCd3WycgKyBvcHRpb25zLndlZWtOdW1iZXJUaXRsZSArICddJyA6XG5cdFx0XHQnWycgKyBvcHRpb25zLndlZWtOdW1iZXJUaXRsZSArICdddyc7XG5cdH1cblxufTtcblxuLy8gVE9ETzogbWFrZSB0aGVzZSBjb21wdXRhYmxlIHByb3BlcnRpZXMgaW4gb3B0aW9uc01vZGVsXG5mdW5jdGlvbiBwb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMob3B0aW9ucykge1xuXHQkLmVhY2goaW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24obmFtZSwgZnVuYykge1xuXHRcdGlmIChvcHRpb25zW25hbWVdID09IG51bGwpIHtcblx0XHRcdG9wdGlvbnNbbmFtZV0gPSBmdW5jKG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG59XG5cblxuLy8gUmV0dXJucyBtb21lbnQncyBpbnRlcm5hbCBsb2NhbGUgZGF0YS4gSWYgZG9lc24ndCBleGlzdCwgcmV0dXJucyBFbmdsaXNoLlxuZnVuY3Rpb24gZ2V0TW9tZW50TG9jYWxlRGF0YShsb2NhbGVDb2RlKSB7XG5cdHJldHVybiBtb21lbnQubG9jYWxlRGF0YShsb2NhbGVDb2RlKSB8fCBtb21lbnQubG9jYWxlRGF0YSgnZW4nKTtcbn1cblxuXG4vLyBJbml0aWFsaXplIEVuZ2xpc2ggYnkgZm9yY2luZyBjb21wdXRhdGlvbiBvZiBtb21lbnQtZGVyaXZlZCBvcHRpb25zLlxuLy8gQWxzbywgc2V0cyBpdCBhcyB0aGUgZGVmYXVsdC5cbkZDLmxvY2FsZSgnZW4nLCBDYWxlbmRhci5lbmdsaXNoRGVmYXVsdHMpO1xuXG47O1xuXG5GQy5zb3VyY2VOb3JtYWxpemVycyA9IFtdO1xuRkMuc291cmNlRmV0Y2hlcnMgPSBbXTtcblxudmFyIGFqYXhEZWZhdWx0cyA9IHtcblx0ZGF0YVR5cGU6ICdqc29uJyxcblx0Y2FjaGU6IGZhbHNlXG59O1xuXG52YXIgZXZlbnRHVUlEID0gMTtcblxuXG5mdW5jdGlvbiBFdmVudE1hbmFnZXIoKSB7IC8vIGFzc3VtZWQgdG8gYmUgYSBjYWxlbmRhclxuXHR2YXIgdCA9IHRoaXM7XG5cblxuXHQvLyBleHBvcnRzXG5cdHQucmVxdWVzdEV2ZW50cyA9IHJlcXVlc3RFdmVudHM7XG5cdHQucmVwb3J0RXZlbnRDaGFuZ2UgPSByZXBvcnRFdmVudENoYW5nZTtcblx0dC5pc0ZldGNoTmVlZGVkID0gaXNGZXRjaE5lZWRlZDtcblx0dC5mZXRjaEV2ZW50cyA9IGZldGNoRXZlbnRzO1xuXHR0LmZldGNoRXZlbnRTb3VyY2VzID0gZmV0Y2hFdmVudFNvdXJjZXM7XG5cdHQucmVmZXRjaEV2ZW50cyA9IHJlZmV0Y2hFdmVudHM7XG5cdHQucmVmZXRjaEV2ZW50U291cmNlcyA9IHJlZmV0Y2hFdmVudFNvdXJjZXM7XG5cdHQuZ2V0RXZlbnRTb3VyY2VzID0gZ2V0RXZlbnRTb3VyY2VzO1xuXHR0LmdldEV2ZW50U291cmNlQnlJZCA9IGdldEV2ZW50U291cmNlQnlJZDtcblx0dC5hZGRFdmVudFNvdXJjZSA9IGFkZEV2ZW50U291cmNlO1xuXHR0LnJlbW92ZUV2ZW50U291cmNlID0gcmVtb3ZlRXZlbnRTb3VyY2U7XG5cdHQucmVtb3ZlRXZlbnRTb3VyY2VzID0gcmVtb3ZlRXZlbnRTb3VyY2VzO1xuXHR0LnVwZGF0ZUV2ZW50ID0gdXBkYXRlRXZlbnQ7XG5cdHQudXBkYXRlRXZlbnRzID0gdXBkYXRlRXZlbnRzO1xuXHR0LnJlbmRlckV2ZW50ID0gcmVuZGVyRXZlbnQ7XG5cdHQucmVuZGVyRXZlbnRzID0gcmVuZGVyRXZlbnRzO1xuXHR0LnJlbW92ZUV2ZW50cyA9IHJlbW92ZUV2ZW50cztcblx0dC5jbGllbnRFdmVudHMgPSBjbGllbnRFdmVudHM7XG5cdHQubXV0YXRlRXZlbnQgPSBtdXRhdGVFdmVudDtcblx0dC5ub3JtYWxpemVFdmVudERhdGVzID0gbm9ybWFsaXplRXZlbnREYXRlcztcblx0dC5ub3JtYWxpemVFdmVudFRpbWVzID0gbm9ybWFsaXplRXZlbnRUaW1lcztcblxuXG5cdC8vIGxvY2Fsc1xuXHR2YXIgc3RpY2t5U291cmNlID0geyBldmVudHM6IFtdIH07XG5cdHZhciBzb3VyY2VzID0gWyBzdGlja3lTb3VyY2UgXTtcblx0dmFyIHJhbmdlU3RhcnQsIHJhbmdlRW5kO1xuXHR2YXIgcGVuZGluZ1NvdXJjZUNudCA9IDA7IC8vIG91dHN0YW5kaW5nIGZldGNoIHJlcXVlc3RzLCBtYXggb25lIHBlciBzb3VyY2Vcblx0dmFyIGNhY2hlID0gW107IC8vIGhvbGRzIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGV4cGFuZGVkXG5cdHZhciBwcnVuZWRDYWNoZTsgLy8gbGlrZSBjYWNoZSwgYnV0IG9ubHkgZXZlbnRzIHRoYXQgaW50ZXJzZWN0IHdpdGggcmFuZ2VTdGFydC9yYW5nZUVuZFxuXG5cblx0JC5lYWNoKFxuXHRcdCh0Lm9wdCgnZXZlbnRzJykgPyBbIHQub3B0KCdldmVudHMnKSBdIDogW10pLmNvbmNhdCh0Lm9wdCgnZXZlbnRTb3VyY2VzJykgfHwgW10pLFxuXHRcdGZ1bmN0aW9uKGksIHNvdXJjZUlucHV0KSB7XG5cdFx0XHR2YXIgc291cmNlID0gYnVpbGRFdmVudFNvdXJjZShzb3VyY2VJbnB1dCk7XG5cdFx0XHRpZiAoc291cmNlKSB7XG5cdFx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcblxuXG5cblx0ZnVuY3Rpb24gcmVxdWVzdEV2ZW50cyhzdGFydCwgZW5kKSB7XG5cdFx0aWYgKCF0Lm9wdCgnbGF6eUZldGNoaW5nJykgfHwgaXNGZXRjaE5lZWRlZChzdGFydCwgZW5kKSkge1xuXHRcdFx0cmV0dXJuIGZldGNoRXZlbnRzKHN0YXJ0LCBlbmQpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocHJ1bmVkQ2FjaGUpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gcmVwb3J0RXZlbnRDaGFuZ2UoKSB7XG5cdFx0cHJ1bmVkQ2FjaGUgPSBmaWx0ZXJFdmVudHNXaXRoaW5SYW5nZShjYWNoZSk7XG5cdFx0dC50cmlnZ2VyKCdldmVudHNSZXNldCcsIHBydW5lZENhY2hlKTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gZmlsdGVyRXZlbnRzV2l0aGluUmFuZ2UoZXZlbnRzKSB7XG5cdFx0dmFyIGZpbHRlcmVkRXZlbnRzID0gW107XG5cdFx0dmFyIGksIGV2ZW50O1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZXZlbnQgPSBldmVudHNbaV07XG5cblx0XHRcdGlmIChcblx0XHRcdFx0ZXZlbnQuc3RhcnQuY2xvbmUoKS5zdHJpcFpvbmUoKSA8IHJhbmdlRW5kICYmXG5cdFx0XHRcdHQuZ2V0RXZlbnRFbmQoZXZlbnQpLnN0cmlwWm9uZSgpID4gcmFuZ2VTdGFydFxuXHRcdFx0KSB7XG5cdFx0XHRcdGZpbHRlcmVkRXZlbnRzLnB1c2goZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmaWx0ZXJlZEV2ZW50cztcblx0fVxuXG5cblx0dC5nZXRFdmVudENhY2hlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9O1xuXG5cblxuXHQvKiBGZXRjaGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBzdGFydCBhbmQgZW5kIGFyZSBhc3N1bWVkIHRvIGJlIHVuem9uZWRcblx0ZnVuY3Rpb24gaXNGZXRjaE5lZWRlZChzdGFydCwgZW5kKSB7XG5cdFx0cmV0dXJuICFyYW5nZVN0YXJ0IHx8IC8vIG5vdGhpbmcgaGFzIGJlZW4gZmV0Y2hlZCB5ZXQ/XG5cdFx0XHRzdGFydCA8IHJhbmdlU3RhcnQgfHwgZW5kID4gcmFuZ2VFbmQ7IC8vIGlzIHBhcnQgb2YgdGhlIG5ldyByYW5nZSBvdXRzaWRlIG9mIHRoZSBvbGQgcmFuZ2U/XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGZldGNoRXZlbnRzKHN0YXJ0LCBlbmQpIHtcblx0XHRyYW5nZVN0YXJ0ID0gc3RhcnQ7XG5cdFx0cmFuZ2VFbmQgPSBlbmQ7XG5cdFx0cmV0dXJuIHJlZmV0Y2hFdmVudHMoKTtcblx0fVxuXG5cblx0Ly8gcG9vcmx5IG5hbWVkLiBmZXRjaGVzIGFsbCBzb3VyY2VzIHdpdGggY3VycmVudCBgcmFuZ2VTdGFydGAgYW5kIGByYW5nZUVuZGAuXG5cdGZ1bmN0aW9uIHJlZmV0Y2hFdmVudHMoKSB7XG5cdFx0cmV0dXJuIGZldGNoRXZlbnRTb3VyY2VzKHNvdXJjZXMsICdyZXNldCcpO1xuXHR9XG5cblxuXHQvLyBwb29ybHkgbmFtZWQuIGZldGNoZXMgYSBzdWJzZXQgb2YgZXZlbnQgc291cmNlcy5cblx0ZnVuY3Rpb24gcmVmZXRjaEV2ZW50U291cmNlcyhtYXRjaElucHV0cykge1xuXHRcdHJldHVybiBmZXRjaEV2ZW50U291cmNlcyhnZXRFdmVudFNvdXJjZXNCeU1hdGNoQXJyYXkobWF0Y2hJbnB1dHMpKTtcblx0fVxuXG5cblx0Ly8gZXhwZWN0cyBhbiBhcnJheSBvZiBldmVudCBzb3VyY2Ugb2JqZWN0cyAodGhlIG9yaWdpbmFscywgbm90IGNvcGllcylcblx0Ly8gYHNwZWNpYWxGZXRjaFR5cGVgIGlzIGFuIG9wdGltaXphdGlvbiBwYXJhbWV0ZXIgdGhhdCBhZmZlY3RzIHB1cmdpbmcgb2YgdGhlIGV2ZW50IGNhY2hlLlxuXHRmdW5jdGlvbiBmZXRjaEV2ZW50U291cmNlcyhzcGVjaWZpY1NvdXJjZXMsIHNwZWNpYWxGZXRjaFR5cGUpIHtcblx0XHR2YXIgaSwgc291cmNlO1xuXG5cdFx0aWYgKHNwZWNpYWxGZXRjaFR5cGUgPT09ICdyZXNldCcpIHtcblx0XHRcdGNhY2hlID0gW107XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHNwZWNpYWxGZXRjaFR5cGUgIT09ICdhZGQnKSB7XG5cdFx0XHRjYWNoZSA9IGV4Y2x1ZGVFdmVudHNCeVNvdXJjZXMoY2FjaGUsIHNwZWNpZmljU291cmNlcyk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNwZWNpZmljU291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c291cmNlID0gc3BlY2lmaWNTb3VyY2VzW2ldO1xuXG5cdFx0XHQvLyBhbHJlYWR5LXBlbmRpbmcgc291cmNlcyBoYXZlIGFscmVhZHkgYmVlbiBhY2NvdW50ZWQgZm9yIGluIHBlbmRpbmdTb3VyY2VDbnRcblx0XHRcdGlmIChzb3VyY2UuX3N0YXR1cyAhPT0gJ3BlbmRpbmcnKSB7XG5cdFx0XHRcdHBlbmRpbmdTb3VyY2VDbnQrKztcblx0XHRcdH1cblxuXHRcdFx0c291cmNlLl9mZXRjaElkID0gKHNvdXJjZS5fZmV0Y2hJZCB8fCAwKSArIDE7XG5cdFx0XHRzb3VyY2UuX3N0YXR1cyA9ICdwZW5kaW5nJztcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BlY2lmaWNTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzb3VyY2UgPSBzcGVjaWZpY1NvdXJjZXNbaV07XG5cdFx0XHR0cnlGZXRjaEV2ZW50U291cmNlKHNvdXJjZSwgc291cmNlLl9mZXRjaElkKTtcblx0XHR9XG5cblx0XHRpZiAocGVuZGluZ1NvdXJjZUNudCkge1xuXHRcdFx0cmV0dXJuIFByb21pc2UuY29uc3RydWN0KGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0XHRcdFx0dC5vbmUoJ2V2ZW50c1JlY2VpdmVkJywgcmVzb2x2ZSk7IC8vIHdpbGwgc2VuZCBwcnVuZWRDYWNoZVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGVsc2UgeyAvLyBleGVjdXRlZCBhbGwgc3luY2hyb25vdXNseSwgb3Igbm8gc291cmNlcyBhdCBhbGxcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocHJ1bmVkQ2FjaGUpO1xuXHRcdH1cblx0fVxuXG5cblx0Ly8gZmV0Y2hlcyBhbiBldmVudCBzb3VyY2UgYW5kIHByb2Nlc3NlcyBpdHMgcmVzdWx0IE9OTFkgaWYgaXQgaXMgc3RpbGwgdGhlIGN1cnJlbnQgZmV0Y2guXG5cdC8vIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgaW5jcmVtZW50aW5nIHBlbmRpbmdTb3VyY2VDbnQgZmlyc3QuXG5cdGZ1bmN0aW9uIHRyeUZldGNoRXZlbnRTb3VyY2Uoc291cmNlLCBmZXRjaElkKSB7XG5cdFx0X2ZldGNoRXZlbnRTb3VyY2Uoc291cmNlLCBmdW5jdGlvbihldmVudElucHV0cykge1xuXHRcdFx0dmFyIGlzQXJyYXlTb3VyY2UgPSAkLmlzQXJyYXkoc291cmNlLmV2ZW50cyk7XG5cdFx0XHR2YXIgaSwgZXZlbnRJbnB1dDtcblx0XHRcdHZhciBhYnN0cmFjdEV2ZW50O1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdC8vIGlzIHRoaXMgdGhlIHNvdXJjZSdzIG1vc3QgcmVjZW50IGZldGNoP1xuXHRcdFx0XHQvLyBpZiBub3QsIHJlbHkgb24gYW4gdXBjb21pbmcgZmV0Y2ggb2YgdGhpcyBzb3VyY2UgdG8gZGVjcmVtZW50IHBlbmRpbmdTb3VyY2VDbnRcblx0XHRcdFx0ZmV0Y2hJZCA9PT0gc291cmNlLl9mZXRjaElkICYmXG5cdFx0XHRcdC8vIGV2ZW50IHNvdXJjZSBubyBsb25nZXIgdmFsaWQ/XG5cdFx0XHRcdHNvdXJjZS5fc3RhdHVzICE9PSAncmVqZWN0ZWQnXG5cdFx0XHQpIHtcblx0XHRcdFx0c291cmNlLl9zdGF0dXMgPSAncmVzb2x2ZWQnO1xuXG5cdFx0XHRcdGlmIChldmVudElucHV0cykge1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBldmVudElucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0ZXZlbnRJbnB1dCA9IGV2ZW50SW5wdXRzW2ldO1xuXG5cdFx0XHRcdFx0XHRpZiAoaXNBcnJheVNvdXJjZSkgeyAvLyBhcnJheSBzb3VyY2VzIGhhdmUgYWxyZWFkeSBiZWVuIGNvbnZlcnQgdG8gRXZlbnQgT2JqZWN0c1xuXHRcdFx0XHRcdFx0XHRhYnN0cmFjdEV2ZW50ID0gZXZlbnRJbnB1dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRhYnN0cmFjdEV2ZW50ID0gYnVpbGRFdmVudEZyb21JbnB1dChldmVudElucHV0LCBzb3VyY2UpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoYWJzdHJhY3RFdmVudCkgeyAvLyBub3QgZmFsc2UgKGFuIGludmFsaWQgZXZlbnQpXG5cdFx0XHRcdFx0XHRcdGNhY2hlLnB1c2guYXBwbHkoIC8vIGFwcGVuZFxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlLFxuXHRcdFx0XHRcdFx0XHRcdGV4cGFuZEV2ZW50KGFic3RyYWN0RXZlbnQpIC8vIGFkZCBpbmRpdmlkdWFsIGV4cGFuZGVkIGV2ZW50cyB0byB0aGUgY2FjaGVcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWNyZW1lbnRQZW5kaW5nU291cmNlQ250KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHJlamVjdEV2ZW50U291cmNlKHNvdXJjZSkge1xuXHRcdHZhciB3YXNQZW5kaW5nID0gc291cmNlLl9zdGF0dXMgPT09ICdwZW5kaW5nJztcblxuXHRcdHNvdXJjZS5fc3RhdHVzID0gJ3JlamVjdGVkJztcblxuXHRcdGlmICh3YXNQZW5kaW5nKSB7XG5cdFx0XHRkZWNyZW1lbnRQZW5kaW5nU291cmNlQ250KCk7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBkZWNyZW1lbnRQZW5kaW5nU291cmNlQ250KCkge1xuXHRcdHBlbmRpbmdTb3VyY2VDbnQtLTtcblx0XHRpZiAoIXBlbmRpbmdTb3VyY2VDbnQpIHtcblx0XHRcdHJlcG9ydEV2ZW50Q2hhbmdlKGNhY2hlKTsgLy8gdXBkYXRlcyBwcnVuZWRDYWNoZVxuXHRcdFx0dC50cmlnZ2VyKCdldmVudHNSZWNlaXZlZCcsIHBydW5lZENhY2hlKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIF9mZXRjaEV2ZW50U291cmNlKHNvdXJjZSwgY2FsbGJhY2spIHtcblx0XHR2YXIgaTtcblx0XHR2YXIgZmV0Y2hlcnMgPSBGQy5zb3VyY2VGZXRjaGVycztcblx0XHR2YXIgcmVzO1xuXG5cdFx0Zm9yIChpPTA7IGk8ZmV0Y2hlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHJlcyA9IGZldGNoZXJzW2ldLmNhbGwoXG5cdFx0XHRcdHQsIC8vIHRoaXMsIHRoZSBDYWxlbmRhciBvYmplY3Rcblx0XHRcdFx0c291cmNlLFxuXHRcdFx0XHRyYW5nZVN0YXJ0LmNsb25lKCksXG5cdFx0XHRcdHJhbmdlRW5kLmNsb25lKCksXG5cdFx0XHRcdHQub3B0KCd0aW1lem9uZScpLFxuXHRcdFx0XHRjYWxsYmFja1xuXHRcdFx0KTtcblxuXHRcdFx0aWYgKHJlcyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHQvLyB0aGUgZmV0Y2hlciBpcyBpbiBjaGFyZ2UuIG1hZGUgaXRzIG93biBhc3luYyByZXF1ZXN0XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHR5cGVvZiByZXMgPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Ly8gdGhlIGZldGNoZXIgcmV0dXJuZWQgYSBuZXcgc291cmNlLiBwcm9jZXNzIGl0XG5cdFx0XHRcdF9mZXRjaEV2ZW50U291cmNlKHJlcywgY2FsbGJhY2spO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGV2ZW50cyA9IHNvdXJjZS5ldmVudHM7XG5cdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0aWYgKCQuaXNGdW5jdGlvbihldmVudHMpKSB7XG5cdFx0XHRcdHQucHVzaExvYWRpbmcoKTtcblx0XHRcdFx0ZXZlbnRzLmNhbGwoXG5cdFx0XHRcdFx0dCwgLy8gdGhpcywgdGhlIENhbGVuZGFyIG9iamVjdFxuXHRcdFx0XHRcdHJhbmdlU3RhcnQuY2xvbmUoKSxcblx0XHRcdFx0XHRyYW5nZUVuZC5jbG9uZSgpLFxuXHRcdFx0XHRcdHQub3B0KCd0aW1lem9uZScpLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soZXZlbnRzKTtcblx0XHRcdFx0XHRcdHQucG9wTG9hZGluZygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCQuaXNBcnJheShldmVudHMpKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGV2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH1cblx0XHR9ZWxzZXtcblx0XHRcdHZhciB1cmwgPSBzb3VyY2UudXJsO1xuXHRcdFx0aWYgKHVybCkge1xuXHRcdFx0XHR2YXIgc3VjY2VzcyA9IHNvdXJjZS5zdWNjZXNzO1xuXHRcdFx0XHR2YXIgZXJyb3IgPSBzb3VyY2UuZXJyb3I7XG5cdFx0XHRcdHZhciBjb21wbGV0ZSA9IHNvdXJjZS5jb21wbGV0ZTtcblxuXHRcdFx0XHQvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgJC5hamF4IGRhdGEgZnJvbSB0aGUgb3B0aW9uc1xuXHRcdFx0XHR2YXIgY3VzdG9tRGF0YTtcblx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbihzb3VyY2UuZGF0YSkpIHtcblx0XHRcdFx0XHQvLyBzdXBwbGllZCBhcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGtleS92YWx1ZSBvYmplY3Rcblx0XHRcdFx0XHRjdXN0b21EYXRhID0gc291cmNlLmRhdGEoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBzdXBwbGllZCBhcyBhIHN0cmFpZ2h0IGtleS92YWx1ZSBvYmplY3Rcblx0XHRcdFx0XHRjdXN0b21EYXRhID0gc291cmNlLmRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB1c2UgYSBjb3B5IG9mIHRoZSBjdXN0b20gZGF0YSBzbyB3ZSBjYW4gbW9kaWZ5IHRoZSBwYXJhbWV0ZXJzXG5cdFx0XHRcdC8vIGFuZCBub3QgYWZmZWN0IHRoZSBwYXNzZWQtaW4gb2JqZWN0LlxuXHRcdFx0XHR2YXIgZGF0YSA9ICQuZXh0ZW5kKHt9LCBjdXN0b21EYXRhIHx8IHt9KTtcblxuXHRcdFx0XHR2YXIgc3RhcnRQYXJhbSA9IGZpcnN0RGVmaW5lZChzb3VyY2Uuc3RhcnRQYXJhbSwgdC5vcHQoJ3N0YXJ0UGFyYW0nKSk7XG5cdFx0XHRcdHZhciBlbmRQYXJhbSA9IGZpcnN0RGVmaW5lZChzb3VyY2UuZW5kUGFyYW0sIHQub3B0KCdlbmRQYXJhbScpKTtcblx0XHRcdFx0dmFyIHRpbWV6b25lUGFyYW0gPSBmaXJzdERlZmluZWQoc291cmNlLnRpbWV6b25lUGFyYW0sIHQub3B0KCd0aW1lem9uZVBhcmFtJykpO1xuXG5cdFx0XHRcdGlmIChzdGFydFBhcmFtKSB7XG5cdFx0XHRcdFx0ZGF0YVtzdGFydFBhcmFtXSA9IHJhbmdlU3RhcnQuZm9ybWF0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZFBhcmFtKSB7XG5cdFx0XHRcdFx0ZGF0YVtlbmRQYXJhbV0gPSByYW5nZUVuZC5mb3JtYXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodC5vcHQoJ3RpbWV6b25lJykgJiYgdC5vcHQoJ3RpbWV6b25lJykgIT0gJ2xvY2FsJykge1xuXHRcdFx0XHRcdGRhdGFbdGltZXpvbmVQYXJhbV0gPSB0Lm9wdCgndGltZXpvbmUnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHQucHVzaExvYWRpbmcoKTtcblx0XHRcdFx0JC5hamF4KCQuZXh0ZW5kKHt9LCBhamF4RGVmYXVsdHMsIHNvdXJjZSwge1xuXHRcdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0XHRcdFx0XHRldmVudHMgPSBldmVudHMgfHwgW107XG5cdFx0XHRcdFx0XHR2YXIgcmVzID0gYXBwbHlBbGwoc3VjY2VzcywgdGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdGlmICgkLmlzQXJyYXkocmVzKSkge1xuXHRcdFx0XHRcdFx0XHRldmVudHMgPSByZXM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYWxsYmFjayhldmVudHMpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZXJyb3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0YXBwbHlBbGwoZXJyb3IsIHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0YXBwbHlBbGwoY29tcGxldGUsIHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHR0LnBvcExvYWRpbmcoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblxuXHQvKiBTb3VyY2VzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdGZ1bmN0aW9uIGFkZEV2ZW50U291cmNlKHNvdXJjZUlucHV0KSB7XG5cdFx0dmFyIHNvdXJjZSA9IGJ1aWxkRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQpO1xuXHRcdGlmIChzb3VyY2UpIHtcblx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2UpO1xuXHRcdFx0ZmV0Y2hFdmVudFNvdXJjZXMoWyBzb3VyY2UgXSwgJ2FkZCcpOyAvLyB3aWxsIGV2ZW50dWFsbHkgY2FsbCByZXBvcnRFdmVudENoYW5nZVxuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gYnVpbGRFdmVudFNvdXJjZShzb3VyY2VJbnB1dCkgeyAvLyB3aWxsIHJldHVybiB1bmRlZmluZWQgaWYgaW52YWxpZCBzb3VyY2Vcblx0XHR2YXIgbm9ybWFsaXplcnMgPSBGQy5zb3VyY2VOb3JtYWxpemVycztcblx0XHR2YXIgc291cmNlO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKCQuaXNGdW5jdGlvbihzb3VyY2VJbnB1dCkgfHwgJC5pc0FycmF5KHNvdXJjZUlucHV0KSkge1xuXHRcdFx0c291cmNlID0geyBldmVudHM6IHNvdXJjZUlucHV0IH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VJbnB1dCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHNvdXJjZSA9IHsgdXJsOiBzb3VyY2VJbnB1dCB9O1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2Ygc291cmNlSW5wdXQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRzb3VyY2UgPSAkLmV4dGVuZCh7fSwgc291cmNlSW5wdXQpOyAvLyBzaGFsbG93IGNvcHlcblx0XHR9XG5cblx0XHRpZiAoc291cmNlKSB7XG5cblx0XHRcdC8vIFRPRE86IHJlcGVhdCBjb2RlLCBzYW1lIGNvZGUgZm9yIGV2ZW50IGNsYXNzTmFtZXNcblx0XHRcdGlmIChzb3VyY2UuY2xhc3NOYW1lKSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygc291cmNlLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRzb3VyY2UuY2xhc3NOYW1lID0gc291cmNlLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG90aGVyd2lzZSwgYXNzdW1lZCB0byBiZSBhbiBhcnJheVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNvdXJjZS5jbGFzc05hbWUgPSBbXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZm9yIGFycmF5IHNvdXJjZXMsIHdlIGNvbnZlcnQgdG8gc3RhbmRhcmQgRXZlbnQgT2JqZWN0cyB1cCBmcm9udFxuXHRcdFx0aWYgKCQuaXNBcnJheShzb3VyY2UuZXZlbnRzKSkge1xuXHRcdFx0XHRzb3VyY2Uub3JpZ0FycmF5ID0gc291cmNlLmV2ZW50czsgLy8gZm9yIHJlbW92ZUV2ZW50U291cmNlXG5cdFx0XHRcdHNvdXJjZS5ldmVudHMgPSAkLm1hcChzb3VyY2UuZXZlbnRzLCBmdW5jdGlvbihldmVudElucHV0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1aWxkRXZlbnRGcm9tSW5wdXQoZXZlbnRJbnB1dCwgc291cmNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoaT0wOyBpPG5vcm1hbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZXJzW2ldLmNhbGwodCwgc291cmNlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNvdXJjZTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHJlbW92ZUV2ZW50U291cmNlKG1hdGNoSW5wdXQpIHtcblx0XHRyZW1vdmVTcGVjaWZpY0V2ZW50U291cmNlcyhcblx0XHRcdGdldEV2ZW50U291cmNlc0J5TWF0Y2gobWF0Y2hJbnB1dClcblx0XHQpO1xuXHR9XG5cblxuXHQvLyBpZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHJlbW92ZXMgYWxsLlxuXHRmdW5jdGlvbiByZW1vdmVFdmVudFNvdXJjZXMobWF0Y2hJbnB1dHMpIHtcblx0XHRpZiAobWF0Y2hJbnB1dHMgPT0gbnVsbCkge1xuXHRcdFx0cmVtb3ZlU3BlY2lmaWNFdmVudFNvdXJjZXMoc291cmNlcywgdHJ1ZSk7IC8vIGlzQWxsPXRydWVcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZW1vdmVTcGVjaWZpY0V2ZW50U291cmNlcyhcblx0XHRcdFx0Z2V0RXZlbnRTb3VyY2VzQnlNYXRjaEFycmF5KG1hdGNoSW5wdXRzKVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHJlbW92ZVNwZWNpZmljRXZlbnRTb3VyY2VzKHRhcmdldFNvdXJjZXMsIGlzQWxsKSB7XG5cdFx0dmFyIGk7XG5cblx0XHQvLyBjYW5jZWwgcGVuZGluZyByZXF1ZXN0c1xuXHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRyZWplY3RFdmVudFNvdXJjZSh0YXJnZXRTb3VyY2VzW2ldKTtcblx0XHR9XG5cblx0XHRpZiAoaXNBbGwpIHsgLy8gYW4gb3B0aW1pemF0aW9uXG5cdFx0XHRzb3VyY2VzID0gW107XG5cdFx0XHRjYWNoZSA9IFtdO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIHJlbW92ZSBmcm9tIHBlcnNpc3RlZCBzb3VyY2UgbGlzdFxuXHRcdFx0c291cmNlcyA9ICQuZ3JlcChzb3VyY2VzLCBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldFNvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoc291cmNlID09PSB0YXJnZXRTb3VyY2VzW2ldKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIGV4Y2x1ZGVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7IC8vIGluY2x1ZGVcblx0XHRcdH0pO1xuXG5cdFx0XHRjYWNoZSA9IGV4Y2x1ZGVFdmVudHNCeVNvdXJjZXMoY2FjaGUsIHRhcmdldFNvdXJjZXMpO1xuXHRcdH1cblxuXHRcdHJlcG9ydEV2ZW50Q2hhbmdlKCk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGdldEV2ZW50U291cmNlcygpIHtcblx0XHRyZXR1cm4gc291cmNlcy5zbGljZSgxKTsgLy8gcmV0dXJucyBhIHNoYWxsb3cgY29weSBvZiBzb3VyY2VzIHdpdGggc3RpY2t5U291cmNlIHJlbW92ZWRcblx0fVxuXG5cblx0ZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2VCeUlkKGlkKSB7XG5cdFx0cmV0dXJuICQuZ3JlcChzb3VyY2VzLCBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRcdHJldHVybiBzb3VyY2UuaWQgJiYgc291cmNlLmlkID09PSBpZDtcblx0XHR9KVswXTtcblx0fVxuXG5cblx0Ly8gbGlrZSBnZXRFdmVudFNvdXJjZXNCeU1hdGNoLCBidXQgYWNjZXB0cyBtdWx0cGxlIG1hdGNoIGNyaXRlcmlhIChsaWtlIG11bHRpcGxlIElEcylcblx0ZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2VzQnlNYXRjaEFycmF5KG1hdGNoSW5wdXRzKSB7XG5cblx0XHQvLyBjb2VyY2UgaW50byBhbiBhcnJheVxuXHRcdGlmICghbWF0Y2hJbnB1dHMpIHtcblx0XHRcdG1hdGNoSW5wdXRzID0gW107XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCEkLmlzQXJyYXkobWF0Y2hJbnB1dHMpKSB7XG5cdFx0XHRtYXRjaElucHV0cyA9IFsgbWF0Y2hJbnB1dHMgXTtcblx0XHR9XG5cblx0XHR2YXIgbWF0Y2hpbmdTb3VyY2VzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHQvLyByZXNvbHZlIHJhdyBpbnB1dHMgdG8gcmVhbCBldmVudCBzb3VyY2Ugb2JqZWN0c1xuXHRcdGZvciAoaSA9IDA7IGkgPCBtYXRjaElucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0bWF0Y2hpbmdTb3VyY2VzLnB1c2guYXBwbHkoIC8vIGFwcGVuZFxuXHRcdFx0XHRtYXRjaGluZ1NvdXJjZXMsXG5cdFx0XHRcdGdldEV2ZW50U291cmNlc0J5TWF0Y2gobWF0Y2hJbnB1dHNbaV0pXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGluZ1NvdXJjZXM7XG5cdH1cblxuXG5cdC8vIG1hdGNoSW5wdXQgY2FuIGVpdGhlciBieSBhIHJlYWwgZXZlbnQgc291cmNlIG9iamVjdCwgYW4gSUQsIG9yIHRoZSBmdW5jdGlvbi9VUkwgZm9yIHRoZSBzb3VyY2UuXG5cdC8vIHJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hpbmcgc291cmNlIG9iamVjdHMuXG5cdGZ1bmN0aW9uIGdldEV2ZW50U291cmNlc0J5TWF0Y2gobWF0Y2hJbnB1dCkge1xuXHRcdHZhciBpLCBzb3VyY2U7XG5cblx0XHQvLyBnaXZlbiBhbiBwcm9wZXIgZXZlbnQgc291cmNlIG9iamVjdFxuXHRcdGZvciAoaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzb3VyY2UgPSBzb3VyY2VzW2ldO1xuXHRcdFx0aWYgKHNvdXJjZSA9PT0gbWF0Y2hJbnB1dCkge1xuXHRcdFx0XHRyZXR1cm4gWyBzb3VyY2UgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBhbiBJRCBtYXRjaFxuXHRcdHNvdXJjZSA9IGdldEV2ZW50U291cmNlQnlJZChtYXRjaElucHV0KTtcblx0XHRpZiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gWyBzb3VyY2UgXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJC5ncmVwKHNvdXJjZXMsIGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuIGlzU291cmNlc0VxdWl2YWxlbnQobWF0Y2hJbnB1dCwgc291cmNlKTtcblx0XHR9KTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gaXNTb3VyY2VzRXF1aXZhbGVudChzb3VyY2UxLCBzb3VyY2UyKSB7XG5cdFx0cmV0dXJuIHNvdXJjZTEgJiYgc291cmNlMiAmJiBnZXRTb3VyY2VQcmltaXRpdmUoc291cmNlMSkgPT0gZ2V0U291cmNlUHJpbWl0aXZlKHNvdXJjZTIpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBnZXRTb3VyY2VQcmltaXRpdmUoc291cmNlKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdCh0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JykgPyAvLyBhIG5vcm1hbGl6ZWQgZXZlbnQgc291cmNlP1xuXHRcdFx0XHQoc291cmNlLm9yaWdBcnJheSB8fCBzb3VyY2UuZ29vZ2xlQ2FsZW5kYXJJZCB8fCBzb3VyY2UudXJsIHx8IHNvdXJjZS5ldmVudHMpIDogLy8gZ2V0IHRoZSBwcmltaXRpdmVcblx0XHRcdFx0bnVsbFxuXHRcdCkgfHxcblx0XHRzb3VyY2U7IC8vIHRoZSBnaXZlbiBhcmd1bWVudCAqaXMqIHRoZSBwcmltaXRpdmVcblx0fVxuXG5cblx0Ly8gdXRpbFxuXHQvLyByZXR1cm5zIGEgZmlsdGVyZWQgYXJyYXkgd2l0aG91dCBldmVudHMgdGhhdCBhcmUgcGFydCBvZiBhbnkgb2YgdGhlIGdpdmVuIHNvdXJjZXNcblx0ZnVuY3Rpb24gZXhjbHVkZUV2ZW50c0J5U291cmNlcyhzcGVjaWZpY0V2ZW50cywgc3BlY2lmaWNTb3VyY2VzKSB7XG5cdFx0cmV0dXJuICQuZ3JlcChzcGVjaWZpY0V2ZW50cywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY2lmaWNTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChldmVudC5zb3VyY2UgPT09IHNwZWNpZmljU291cmNlc1tpXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gZXhjbHVkZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTsgLy8ga2VlcFxuXHRcdH0pO1xuXHR9XG5cblxuXG5cdC8qIE1hbmlwdWxhdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBPbmx5IGV2ZXIgY2FsbGVkIGZyb20gdGhlIGV4dGVybmFsbHktZmFjaW5nIEFQSVxuXHRmdW5jdGlvbiB1cGRhdGVFdmVudChldmVudCkge1xuXHRcdHVwZGF0ZUV2ZW50cyhbIGV2ZW50IF0pO1xuXHR9XG5cblxuXHQvLyBPbmx5IGV2ZXIgY2FsbGVkIGZyb20gdGhlIGV4dGVybmFsbHktZmFjaW5nIEFQSVxuXHRmdW5jdGlvbiB1cGRhdGVFdmVudHMoZXZlbnRzKSB7XG5cdFx0dmFyIGksIGV2ZW50O1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZXZlbnQgPSBldmVudHNbaV07XG5cblx0XHRcdC8vIG1hc3NhZ2Ugc3RhcnQvZW5kIHZhbHVlcywgZXZlbiBpZiBkYXRlIHN0cmluZyB2YWx1ZXNcblx0XHRcdGV2ZW50LnN0YXJ0ID0gdC5tb21lbnQoZXZlbnQuc3RhcnQpO1xuXHRcdFx0aWYgKGV2ZW50LmVuZCkge1xuXHRcdFx0XHRldmVudC5lbmQgPSB0Lm1vbWVudChldmVudC5lbmQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGV2ZW50LmVuZCA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdG11dGF0ZUV2ZW50KGV2ZW50LCBnZXRNaXNjRXZlbnRQcm9wcyhldmVudCkpOyAvLyB3aWxsIGhhbmRsZSBzdGFydC9lbmQvYWxsRGF5IG5vcm1hbGl6YXRpb25cblx0XHR9XG5cblx0XHRyZXBvcnRFdmVudENoYW5nZSgpOyAvLyByZXBvcnRzIGV2ZW50IG1vZGlmaWNhdGlvbnMgKHNvIHdlIGNhbiByZWRyYXcpXG5cdH1cblxuXG5cdC8vIFJldHVybnMgYSBoYXNoIG9mIG1pc2MgZXZlbnQgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBjb3BpZWQgb3ZlciB0byByZWxhdGVkIGV2ZW50cy5cblx0ZnVuY3Rpb24gZ2V0TWlzY0V2ZW50UHJvcHMoZXZlbnQpIHtcblx0XHR2YXIgcHJvcHMgPSB7fTtcblxuXHRcdCQuZWFjaChldmVudCwgZnVuY3Rpb24obmFtZSwgdmFsKSB7XG5cdFx0XHRpZiAoaXNNaXNjRXZlbnRQcm9wTmFtZShuYW1lKSkge1xuXHRcdFx0XHRpZiAodmFsICE9PSB1bmRlZmluZWQgJiYgaXNBdG9taWModmFsKSkgeyAvLyBhIGRlZmluZWQgbm9uLW9iamVjdFxuXHRcdFx0XHRcdHByb3BzW25hbWVdID0gdmFsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gcHJvcHM7XG5cdH1cblxuXHQvLyBub24tZGF0ZS1yZWxhdGVkLCBub24taWQtcmVsYXRlZCwgbm9uLXNlY3JldFxuXHRmdW5jdGlvbiBpc01pc2NFdmVudFByb3BOYW1lKG5hbWUpIHtcblx0XHRyZXR1cm4gIS9eX3xeKGlkfGFsbERheXxzdGFydHxlbmQpJC8udGVzdChuYW1lKTtcblx0fVxuXG5cblx0Ly8gcmV0dXJucyB0aGUgZXhwYW5kZWQgZXZlbnRzIHRoYXQgd2VyZSBjcmVhdGVkXG5cdGZ1bmN0aW9uIHJlbmRlckV2ZW50KGV2ZW50SW5wdXQsIHN0aWNrKSB7XG5cdFx0cmV0dXJuIHJlbmRlckV2ZW50cyhbIGV2ZW50SW5wdXQgXSwgc3RpY2spO1xuXHR9XG5cblxuXHQvLyByZXR1cm5zIHRoZSBleHBhbmRlZCBldmVudHMgdGhhdCB3ZXJlIGNyZWF0ZWRcblx0ZnVuY3Rpb24gcmVuZGVyRXZlbnRzKGV2ZW50SW5wdXRzLCBzdGljaykge1xuXHRcdHZhciByZW5kZXJlZEV2ZW50cyA9IFtdO1xuXHRcdHZhciByZW5kZXJhYmxlRXZlbnRzO1xuXHRcdHZhciBhYnN0cmFjdEV2ZW50O1xuXHRcdHZhciBpLCBqLCBldmVudDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBldmVudElucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YWJzdHJhY3RFdmVudCA9IGJ1aWxkRXZlbnRGcm9tSW5wdXQoZXZlbnRJbnB1dHNbaV0pO1xuXG5cdFx0XHRpZiAoYWJzdHJhY3RFdmVudCkgeyAvLyBub3QgZmFsc2UgKGEgdmFsaWQgaW5wdXQpXG5cdFx0XHRcdHJlbmRlcmFibGVFdmVudHMgPSBleHBhbmRFdmVudChhYnN0cmFjdEV2ZW50KTtcblxuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgcmVuZGVyYWJsZUV2ZW50cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGV2ZW50ID0gcmVuZGVyYWJsZUV2ZW50c1tqXTtcblxuXHRcdFx0XHRcdGlmICghZXZlbnQuc291cmNlKSB7XG5cdFx0XHRcdFx0XHRpZiAoc3RpY2spIHtcblx0XHRcdFx0XHRcdFx0c3RpY2t5U291cmNlLmV2ZW50cy5wdXNoKGV2ZW50KTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc291cmNlID0gc3RpY2t5U291cmNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FjaGUucHVzaChldmVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVuZGVyZWRFdmVudHMgPSByZW5kZXJlZEV2ZW50cy5jb25jYXQocmVuZGVyYWJsZUV2ZW50cyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHJlbmRlcmVkRXZlbnRzLmxlbmd0aCkgeyAvLyBhbnkgbmV3IGV2ZW50cyByZW5kZXJlZD9cblx0XHRcdHJlcG9ydEV2ZW50Q2hhbmdlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlbmRlcmVkRXZlbnRzO1xuXHR9XG5cblxuXHRmdW5jdGlvbiByZW1vdmVFdmVudHMoZmlsdGVyKSB7XG5cdFx0dmFyIGV2ZW50SUQ7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoZmlsdGVyID09IG51bGwpIHsgLy8gbnVsbCBvciB1bmRlZmluZWQuIHJlbW92ZSBhbGwgZXZlbnRzXG5cdFx0XHRmaWx0ZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH07IC8vIHdpbGwgYWx3YXlzIG1hdGNoXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCEkLmlzRnVuY3Rpb24oZmlsdGVyKSkgeyAvLyBhbiBldmVudCBJRFxuXHRcdFx0ZXZlbnRJRCA9IGZpbHRlciArICcnO1xuXHRcdFx0ZmlsdGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0cmV0dXJuIGV2ZW50Ll9pZCA9PSBldmVudElEO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBQdXJnZSBldmVudChzKSBmcm9tIG91ciBsb2NhbCBjYWNoZVxuXHRcdGNhY2hlID0gJC5ncmVwKGNhY2hlLCBmaWx0ZXIsIHRydWUpOyAvLyBpbnZlcnNlPXRydWVcblxuXHRcdC8vIFJlbW92ZSBldmVudHMgZnJvbSBhcnJheSBzb3VyY2VzLlxuXHRcdC8vIFRoaXMgd29ya3MgYmVjYXVzZSB0aGV5IGhhdmUgYmVlbiBjb252ZXJ0ZWQgdG8gb2ZmaWNpYWwgRXZlbnQgT2JqZWN0cyB1cCBmcm9udC5cblx0XHQvLyAoYW5kIGFzIGEgcmVzdWx0LCBldmVudC5faWQgaGFzIGJlZW4gY2FsY3VsYXRlZCkuXG5cdFx0Zm9yIChpPTA7IGk8c291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKCQuaXNBcnJheShzb3VyY2VzW2ldLmV2ZW50cykpIHtcblx0XHRcdFx0c291cmNlc1tpXS5ldmVudHMgPSAkLmdyZXAoc291cmNlc1tpXS5ldmVudHMsIGZpbHRlciwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmVwb3J0RXZlbnRDaGFuZ2UoKTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gY2xpZW50RXZlbnRzKGZpbHRlcikge1xuXHRcdGlmICgkLmlzRnVuY3Rpb24oZmlsdGVyKSkge1xuXHRcdFx0cmV0dXJuICQuZ3JlcChjYWNoZSwgZmlsdGVyKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoZmlsdGVyICE9IG51bGwpIHsgLy8gbm90IG51bGwsIG5vdCB1bmRlZmluZWQuIGFuIGV2ZW50IElEXG5cdFx0XHRmaWx0ZXIgKz0gJyc7XG5cdFx0XHRyZXR1cm4gJC5ncmVwKGNhY2hlLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHJldHVybiBlLl9pZCA9PSBmaWx0ZXI7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlOyAvLyBlbHNlLCByZXR1cm4gYWxsXG5cdH1cblxuXG5cdC8vIE1ha2VzIHN1cmUgYWxsIGFycmF5IGV2ZW50IHNvdXJjZXMgaGF2ZSB0aGVpciBpbnRlcm5hbCBldmVudCBvYmplY3RzXG5cdC8vIGNvbnZlcnRlZCBvdmVyIHRvIHRoZSBDYWxlbmRhcidzIGN1cnJlbnQgdGltZXpvbmUuXG5cdHQucmV6b25lQXJyYXlFdmVudFNvdXJjZXMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaTtcblx0XHR2YXIgZXZlbnRzO1xuXHRcdHZhciBqO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGV2ZW50cyA9IHNvdXJjZXNbaV0uZXZlbnRzO1xuXHRcdFx0aWYgKCQuaXNBcnJheShldmVudHMpKSB7XG5cblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGV2ZW50cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdHJlem9uZUV2ZW50RGF0ZXMoZXZlbnRzW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiByZXpvbmVFdmVudERhdGVzKGV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RhcnQgPSB0Lm1vbWVudChldmVudC5zdGFydCk7XG5cdFx0aWYgKGV2ZW50LmVuZCkge1xuXHRcdFx0ZXZlbnQuZW5kID0gdC5tb21lbnQoZXZlbnQuZW5kKTtcblx0XHR9XG5cdFx0YmFja3VwRXZlbnREYXRlcyhldmVudCk7XG5cdH1cblxuXG5cdC8qIEV2ZW50IE5vcm1hbGl6YXRpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gR2l2ZW4gYSByYXcgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHByb3BlcnRpZXMsIHJldHVybnMgYW4gXCJhYnN0cmFjdFwiIEV2ZW50IG9iamVjdC5cblx0Ly8gQW4gXCJhYnN0cmFjdFwiIGV2ZW50IGlzIGFuIGV2ZW50IHRoYXQsIGlmIHJlY3VycmluZywgd2lsbCBub3QgaGF2ZSBiZWVuIGV4cGFuZGVkIHlldC5cblx0Ly8gV2lsbCByZXR1cm4gYGZhbHNlYCB3aGVuIGlucHV0IGlzIGludmFsaWQuXG5cdC8vIGBzb3VyY2VgIGlzIG9wdGlvbmFsXG5cdGZ1bmN0aW9uIGJ1aWxkRXZlbnRGcm9tSW5wdXQoaW5wdXQsIHNvdXJjZSkge1xuXHRcdHZhciBjYWxlbmRhckV2ZW50RGF0YVRyYW5zZm9ybSA9IHQub3B0KCdldmVudERhdGFUcmFuc2Zvcm0nKTtcblx0XHR2YXIgb3V0ID0ge307XG5cdFx0dmFyIHN0YXJ0LCBlbmQ7XG5cdFx0dmFyIGFsbERheTtcblxuXHRcdGlmIChjYWxlbmRhckV2ZW50RGF0YVRyYW5zZm9ybSkge1xuXHRcdFx0aW5wdXQgPSBjYWxlbmRhckV2ZW50RGF0YVRyYW5zZm9ybShpbnB1dCk7XG5cdFx0fVxuXHRcdGlmIChzb3VyY2UgJiYgc291cmNlLmV2ZW50RGF0YVRyYW5zZm9ybSkge1xuXHRcdFx0aW5wdXQgPSBzb3VyY2UuZXZlbnREYXRhVHJhbnNmb3JtKGlucHV0KTtcblx0XHR9XG5cblx0XHQvLyBDb3B5IGFsbCBwcm9wZXJ0aWVzIG92ZXIgdG8gdGhlIHJlc3VsdGluZyBvYmplY3QuXG5cdFx0Ly8gVGhlIHNwZWNpYWwtY2FzZSBwcm9wZXJ0aWVzIHdpbGwgYmUgY29waWVkIG92ZXIgYWZ0ZXJ3YXJkcy5cblx0XHQkLmV4dGVuZChvdXQsIGlucHV0KTtcblxuXHRcdGlmIChzb3VyY2UpIHtcblx0XHRcdG91dC5zb3VyY2UgPSBzb3VyY2U7XG5cdFx0fVxuXG5cdFx0b3V0Ll9pZCA9IGlucHV0Ll9pZCB8fCAoaW5wdXQuaWQgPT09IHVuZGVmaW5lZCA/ICdfZmMnICsgZXZlbnRHVUlEKysgOiBpbnB1dC5pZCArICcnKTtcblxuXHRcdGlmIChpbnB1dC5jbGFzc05hbWUpIHtcblx0XHRcdGlmICh0eXBlb2YgaW5wdXQuY2xhc3NOYW1lID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdG91dC5jbGFzc05hbWUgPSBpbnB1dC5jbGFzc05hbWUuc3BsaXQoL1xccysvKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgeyAvLyBhc3N1bWVkIHRvIGJlIGFuIGFycmF5XG5cdFx0XHRcdG91dC5jbGFzc05hbWUgPSBpbnB1dC5jbGFzc05hbWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0b3V0LmNsYXNzTmFtZSA9IFtdO1xuXHRcdH1cblxuXHRcdHN0YXJ0ID0gaW5wdXQuc3RhcnQgfHwgaW5wdXQuZGF0ZTsgLy8gXCJkYXRlXCIgaXMgYW4gYWxpYXMgZm9yIFwic3RhcnRcIlxuXHRcdGVuZCA9IGlucHV0LmVuZDtcblxuXHRcdC8vIHBhcnNlIGFzIGEgdGltZSAoRHVyYXRpb24pIGlmIGFwcGxpY2FibGVcblx0XHRpZiAoaXNUaW1lU3RyaW5nKHN0YXJ0KSkge1xuXHRcdFx0c3RhcnQgPSBtb21lbnQuZHVyYXRpb24oc3RhcnQpO1xuXHRcdH1cblx0XHRpZiAoaXNUaW1lU3RyaW5nKGVuZCkpIHtcblx0XHRcdGVuZCA9IG1vbWVudC5kdXJhdGlvbihlbmQpO1xuXHRcdH1cblxuXHRcdGlmIChpbnB1dC5kb3cgfHwgbW9tZW50LmlzRHVyYXRpb24oc3RhcnQpIHx8IG1vbWVudC5pc0R1cmF0aW9uKGVuZCkpIHtcblxuXHRcdFx0Ly8gdGhlIGV2ZW50IGlzIFwiYWJzdHJhY3RcIiAocmVjdXJyaW5nKSBzbyBkb24ndCBjYWxjdWxhdGUgZXhhY3Qgc3RhcnQvZW5kIGRhdGVzIGp1c3QgeWV0XG5cdFx0XHRvdXQuc3RhcnQgPSBzdGFydCA/IG1vbWVudC5kdXJhdGlvbihzdGFydCkgOiBudWxsOyAvLyB3aWxsIGJlIGEgRHVyYXRpb24gb3IgbnVsbFxuXHRcdFx0b3V0LmVuZCA9IGVuZCA/IG1vbWVudC5kdXJhdGlvbihlbmQpIDogbnVsbDsgLy8gd2lsbCBiZSBhIER1cmF0aW9uIG9yIG51bGxcblx0XHRcdG91dC5fcmVjdXJyaW5nID0gdHJ1ZTsgLy8gb3VyIGludGVybmFsIG1hcmtlclxuXHRcdH1cblx0XHRlbHNlIHtcblxuXHRcdFx0aWYgKHN0YXJ0KSB7XG5cdFx0XHRcdHN0YXJ0ID0gdC5tb21lbnQoc3RhcnQpO1xuXHRcdFx0XHRpZiAoIXN0YXJ0LmlzVmFsaWQoKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZW5kKSB7XG5cdFx0XHRcdGVuZCA9IHQubW9tZW50KGVuZCk7XG5cdFx0XHRcdGlmICghZW5kLmlzVmFsaWQoKSkge1xuXHRcdFx0XHRcdGVuZCA9IG51bGw7IC8vIGxldCBkZWZhdWx0cyB0YWtlIG92ZXJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRhbGxEYXkgPSBpbnB1dC5hbGxEYXk7XG5cdFx0XHRpZiAoYWxsRGF5ID09PSB1bmRlZmluZWQpIHsgLy8gc3RpbGwgdW5kZWZpbmVkPyBmYWxsYmFjayB0byBkZWZhdWx0XG5cdFx0XHRcdGFsbERheSA9IGZpcnN0RGVmaW5lZChcblx0XHRcdFx0XHRzb3VyY2UgPyBzb3VyY2UuYWxsRGF5RGVmYXVsdCA6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHR0Lm9wdCgnYWxsRGF5RGVmYXVsdCcpXG5cdFx0XHRcdCk7XG5cdFx0XHRcdC8vIHN0aWxsIHVuZGVmaW5lZD8gbm9ybWFsaXplRXZlbnREYXRlcyB3aWxsIGNhbGN1bGF0ZSBpdFxuXHRcdFx0fVxuXG5cdFx0XHRhc3NpZ25EYXRlc1RvRXZlbnQoc3RhcnQsIGVuZCwgYWxsRGF5LCBvdXQpO1xuXHRcdH1cblxuXHRcdHQubm9ybWFsaXplRXZlbnQob3V0KTsgLy8gaG9vayBmb3IgZXh0ZXJuYWwgdXNlLiBhIHByb3RvdHlwZSBtZXRob2RcblxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblx0dC5idWlsZEV2ZW50RnJvbUlucHV0ID0gYnVpbGRFdmVudEZyb21JbnB1dDtcblxuXG5cdC8vIE5vcm1hbGl6ZXMgYW5kIGFzc2lnbnMgdGhlIGdpdmVuIGRhdGVzIHRvIHRoZSBnaXZlbiBwYXJ0aWFsbHktZm9ybWVkIGV2ZW50IG9iamVjdC5cblx0Ly8gTk9URTogbXV0YXRlcyB0aGUgZ2l2ZW4gc3RhcnQvZW5kIG1vbWVudHMuIGRvZXMgbm90IG1ha2UgYSBjb3B5LlxuXHRmdW5jdGlvbiBhc3NpZ25EYXRlc1RvRXZlbnQoc3RhcnQsIGVuZCwgYWxsRGF5LCBldmVudCkge1xuXHRcdGV2ZW50LnN0YXJ0ID0gc3RhcnQ7XG5cdFx0ZXZlbnQuZW5kID0gZW5kO1xuXHRcdGV2ZW50LmFsbERheSA9IGFsbERheTtcblx0XHRub3JtYWxpemVFdmVudERhdGVzKGV2ZW50KTtcblx0XHRiYWNrdXBFdmVudERhdGVzKGV2ZW50KTtcblx0fVxuXG5cblx0Ly8gRW5zdXJlcyBwcm9wZXIgdmFsdWVzIGZvciBhbGxEYXkvc3RhcnQvZW5kLiBBY2NlcHRzIGFuIEV2ZW50IG9iamVjdCwgb3IgYSBwbGFpbiBvYmplY3Qgd2l0aCBldmVudC1pc2ggcHJvcGVydGllcy5cblx0Ly8gTk9URTogV2lsbCBtb2RpZnkgdGhlIGdpdmVuIG9iamVjdC5cblx0ZnVuY3Rpb24gbm9ybWFsaXplRXZlbnREYXRlcyhldmVudFByb3BzKSB7XG5cblx0XHRub3JtYWxpemVFdmVudFRpbWVzKGV2ZW50UHJvcHMpO1xuXG5cdFx0aWYgKGV2ZW50UHJvcHMuZW5kICYmICFldmVudFByb3BzLmVuZC5pc0FmdGVyKGV2ZW50UHJvcHMuc3RhcnQpKSB7XG5cdFx0XHRldmVudFByb3BzLmVuZCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKCFldmVudFByb3BzLmVuZCkge1xuXHRcdFx0aWYgKHQub3B0KCdmb3JjZUV2ZW50RHVyYXRpb24nKSkge1xuXHRcdFx0XHRldmVudFByb3BzLmVuZCA9IHQuZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50UHJvcHMuYWxsRGF5LCBldmVudFByb3BzLnN0YXJ0KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRldmVudFByb3BzLmVuZCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXHQvLyBFbnN1cmVzIHRoZSBhbGxEYXkgcHJvcGVydHkgZXhpc3RzIGFuZCB0aGUgdGltZWxpbmVzcyBvZiB0aGUgc3RhcnQvZW5kIGRhdGVzIGFyZSBjb25zaXN0ZW50XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50VGltZXMoZXZlbnRQcm9wcykge1xuXHRcdGlmIChldmVudFByb3BzLmFsbERheSA9PSBudWxsKSB7XG5cdFx0XHRldmVudFByb3BzLmFsbERheSA9ICEoZXZlbnRQcm9wcy5zdGFydC5oYXNUaW1lKCkgfHwgKGV2ZW50UHJvcHMuZW5kICYmIGV2ZW50UHJvcHMuZW5kLmhhc1RpbWUoKSkpO1xuXHRcdH1cblxuXHRcdGlmIChldmVudFByb3BzLmFsbERheSkge1xuXHRcdFx0ZXZlbnRQcm9wcy5zdGFydC5zdHJpcFRpbWUoKTtcblx0XHRcdGlmIChldmVudFByb3BzLmVuZCkge1xuXHRcdFx0XHQvLyBUT0RPOiBjb25zaWRlciBuZXh0RGF5VGhyZXNob2xkIGhlcmU/IElmIHNvLCB3aWxsIHJlcXVpcmUgYSBsb3Qgb2YgdGVzdGluZyBhbmQgYWRqdXN0bWVudFxuXHRcdFx0XHRldmVudFByb3BzLmVuZC5zdHJpcFRpbWUoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAoIWV2ZW50UHJvcHMuc3RhcnQuaGFzVGltZSgpKSB7XG5cdFx0XHRcdGV2ZW50UHJvcHMuc3RhcnQgPSB0LmFwcGx5VGltZXpvbmUoZXZlbnRQcm9wcy5zdGFydC50aW1lKDApKTsgLy8gd2lsbCBhc3NpZ24gYSAwMDowMCB0aW1lXG5cdFx0XHR9XG5cdFx0XHRpZiAoZXZlbnRQcm9wcy5lbmQgJiYgIWV2ZW50UHJvcHMuZW5kLmhhc1RpbWUoKSkge1xuXHRcdFx0XHRldmVudFByb3BzLmVuZCA9IHQuYXBwbHlUaW1lem9uZShldmVudFByb3BzLmVuZC50aW1lKDApKTsgLy8gd2lsbCBhc3NpZ24gYSAwMDowMCB0aW1lXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXHQvLyBJZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYSByZWN1cnJpbmcgZXZlbnQsIGJyZWFrIGl0IGRvd24gaW50byBhbiBhcnJheSBvZiBpbmRpdmlkdWFsIGluc3RhbmNlcy5cblx0Ly8gSWYgbm90IGEgcmVjdXJyaW5nIGV2ZW50LCByZXR1cm4gYW4gYXJyYXkgd2l0aCB0aGUgc2luZ2xlIG9yaWdpbmFsIGV2ZW50LlxuXHQvLyBJZiBnaXZlbiBhIGZhbHN5IGlucHV0IChwcm9iYWJseSBiZWNhdXNlIG9mIGEgZmFpbGVkIGJ1aWxkRXZlbnRGcm9tSW5wdXQgY2FsbCksIHJldHVybnMgYW4gZW1wdHkgYXJyYXkuXG5cdC8vIEhBQ0s6IGNhbiBvdmVycmlkZSB0aGUgcmVjdXJyaW5nIHdpbmRvdyBieSBwcm92aWRpbmcgY3VzdG9tIHJhbmdlU3RhcnQvcmFuZ2VFbmQgKGZvciBidXNpbmVzc0hvdXJzKS5cblx0ZnVuY3Rpb24gZXhwYW5kRXZlbnQoYWJzdHJhY3RFdmVudCwgX3JhbmdlU3RhcnQsIF9yYW5nZUVuZCkge1xuXHRcdHZhciBldmVudHMgPSBbXTtcblx0XHR2YXIgZG93SGFzaDtcblx0XHR2YXIgZG93O1xuXHRcdHZhciBpO1xuXHRcdHZhciBkYXRlO1xuXHRcdHZhciBzdGFydFRpbWUsIGVuZFRpbWU7XG5cdFx0dmFyIHN0YXJ0LCBlbmQ7XG5cdFx0dmFyIGV2ZW50O1xuXG5cdFx0X3JhbmdlU3RhcnQgPSBfcmFuZ2VTdGFydCB8fCByYW5nZVN0YXJ0O1xuXHRcdF9yYW5nZUVuZCA9IF9yYW5nZUVuZCB8fCByYW5nZUVuZDtcblxuXHRcdGlmIChhYnN0cmFjdEV2ZW50KSB7XG5cdFx0XHRpZiAoYWJzdHJhY3RFdmVudC5fcmVjdXJyaW5nKSB7XG5cblx0XHRcdFx0Ly8gbWFrZSBhIGJvb2xlYW4gaGFzaCBhcyB0byB3aGV0aGVyIHRoZSBldmVudCBvY2N1cnMgb24gZWFjaCBkYXktb2Ytd2Vla1xuXHRcdFx0XHRpZiAoKGRvdyA9IGFic3RyYWN0RXZlbnQuZG93KSkge1xuXHRcdFx0XHRcdGRvd0hhc2ggPSB7fTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZG93Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRkb3dIYXNoW2Rvd1tpXV0gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGl0ZXJhdGUgdGhyb3VnaCBldmVyeSBkYXkgaW4gdGhlIGN1cnJlbnQgcmFuZ2Vcblx0XHRcdFx0ZGF0ZSA9IF9yYW5nZVN0YXJ0LmNsb25lKCkuc3RyaXBUaW1lKCk7IC8vIGhvbGRzIHRoZSBkYXRlIG9mIHRoZSBjdXJyZW50IGRheVxuXHRcdFx0XHR3aGlsZSAoZGF0ZS5pc0JlZm9yZShfcmFuZ2VFbmQpKSB7XG5cblx0XHRcdFx0XHRpZiAoIWRvd0hhc2ggfHwgZG93SGFzaFtkYXRlLmRheSgpXSkgeyAvLyBpZiBldmVyeWRheSwgb3IgdGhpcyBwYXJ0aWN1bGFyIGRheS1vZi13ZWVrXG5cblx0XHRcdFx0XHRcdHN0YXJ0VGltZSA9IGFic3RyYWN0RXZlbnQuc3RhcnQ7IC8vIHRoZSBzdG9yZWQgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzIGFyZSB0aW1lcyAoRHVyYXRpb25zKVxuXHRcdFx0XHRcdFx0ZW5kVGltZSA9IGFic3RyYWN0RXZlbnQuZW5kOyAvLyBcIlxuXHRcdFx0XHRcdFx0c3RhcnQgPSBkYXRlLmNsb25lKCk7XG5cdFx0XHRcdFx0XHRlbmQgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRpZiAoc3RhcnRUaW1lKSB7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0ID0gc3RhcnQudGltZShzdGFydFRpbWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGVuZFRpbWUpIHtcblx0XHRcdFx0XHRcdFx0ZW5kID0gZGF0ZS5jbG9uZSgpLnRpbWUoZW5kVGltZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGV2ZW50ID0gJC5leHRlbmQoe30sIGFic3RyYWN0RXZlbnQpOyAvLyBtYWtlIGEgY29weSBvZiB0aGUgb3JpZ2luYWxcblx0XHRcdFx0XHRcdGFzc2lnbkRhdGVzVG9FdmVudChcblx0XHRcdFx0XHRcdFx0c3RhcnQsIGVuZCxcblx0XHRcdFx0XHRcdFx0IXN0YXJ0VGltZSAmJiAhZW5kVGltZSwgLy8gYWxsRGF5P1xuXHRcdFx0XHRcdFx0XHRldmVudFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGV2ZW50cy5wdXNoKGV2ZW50KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkYXRlLmFkZCgxLCAnZGF5cycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZXZlbnRzLnB1c2goYWJzdHJhY3RFdmVudCk7IC8vIHJldHVybiB0aGUgb3JpZ2luYWwgZXZlbnQuIHdpbGwgYmUgYSBvbmUtaXRlbSBhcnJheVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH1cblx0dC5leHBhbmRFdmVudCA9IGV4cGFuZEV2ZW50O1xuXG5cblxuXHQvKiBFdmVudCBNb2RpZmljYXRpb24gTWF0aFxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBNb2RpZmllcyBhbiBldmVudCBhbmQgYWxsIHJlbGF0ZWQgZXZlbnRzIGJ5IGFwcGx5aW5nIHRoZSBnaXZlbiBwcm9wZXJ0aWVzLlxuXHQvLyBTcGVjaWFsIGRhdGUtZGlmZmluZyBsb2dpYyBpcyB1c2VkIGZvciBtYW5pcHVsYXRpb24gb2YgZGF0ZXMuXG5cdC8vIElmIGBwcm9wc2AgZG9lcyBub3QgY29udGFpbiBzdGFydC9lbmQgZGF0ZXMsIHRoZSB1cGRhdGVkIHZhbHVlcyBhcmUgYXNzdW1lZCB0byBiZSB0aGUgZXZlbnQncyBjdXJyZW50IHN0YXJ0L2VuZC5cblx0Ly8gQWxsIGRhdGUgY29tcGFyaXNvbnMgYXJlIGRvbmUgYWdhaW5zdCB0aGUgZXZlbnQncyBwcmlzdGluZSBfc3RhcnQgYW5kIF9lbmQgZGF0ZXMuXG5cdC8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggZGVsdGEgaW5mb3JtYXRpb24gYW5kIGEgZnVuY3Rpb24gdG8gdW5kbyBhbGwgb3BlcmF0aW9ucy5cblx0Ly8gRm9yIG1ha2luZyBjb21wdXRhdGlvbnMgaW4gYSBncmFudWxhcml0eSBncmVhdGVyIHRoYW4gZGF5L3RpbWUsIHNwZWNpZnkgbGFyZ2VVbml0LlxuXHQvLyBOT1RFOiBUaGUgZ2l2ZW4gYG5ld1Byb3BzYCBtaWdodCBiZSBtdXRhdGVkIGZvciBub3JtYWxpemF0aW9uIHB1cnBvc2VzLlxuXHRmdW5jdGlvbiBtdXRhdGVFdmVudChldmVudCwgbmV3UHJvcHMsIGxhcmdlVW5pdCkge1xuXHRcdHZhciBtaXNjUHJvcHMgPSB7fTtcblx0XHR2YXIgb2xkUHJvcHM7XG5cdFx0dmFyIGNsZWFyRW5kO1xuXHRcdHZhciBzdGFydERlbHRhO1xuXHRcdHZhciBlbmREZWx0YTtcblx0XHR2YXIgZHVyYXRpb25EZWx0YTtcblx0XHR2YXIgdW5kb0Z1bmM7XG5cblx0XHQvLyBkaWZmcyB0aGUgZGF0ZXMgaW4gdGhlIGFwcHJvcHJpYXRlIHdheSwgcmV0dXJuaW5nIGEgZHVyYXRpb25cblx0XHRmdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTEsIGRhdGUwKSB7IC8vIGRhdGUxIC0gZGF0ZTBcblx0XHRcdGlmIChsYXJnZVVuaXQpIHtcblx0XHRcdFx0cmV0dXJuIGRpZmZCeVVuaXQoZGF0ZTEsIGRhdGUwLCBsYXJnZVVuaXQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAobmV3UHJvcHMuYWxsRGF5KSB7XG5cdFx0XHRcdHJldHVybiBkaWZmRGF5KGRhdGUxLCBkYXRlMCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGRpZmZEYXlUaW1lKGRhdGUxLCBkYXRlMCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bmV3UHJvcHMgPSBuZXdQcm9wcyB8fCB7fTtcblxuXHRcdC8vIG5vcm1hbGl6ZSBuZXcgZGF0ZS1yZWxhdGVkIHByb3BlcnRpZXNcblx0XHRpZiAoIW5ld1Byb3BzLnN0YXJ0KSB7XG5cdFx0XHRuZXdQcm9wcy5zdGFydCA9IGV2ZW50LnN0YXJ0LmNsb25lKCk7XG5cdFx0fVxuXHRcdGlmIChuZXdQcm9wcy5lbmQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bmV3UHJvcHMuZW5kID0gZXZlbnQuZW5kID8gZXZlbnQuZW5kLmNsb25lKCkgOiBudWxsO1xuXHRcdH1cblx0XHRpZiAobmV3UHJvcHMuYWxsRGF5ID09IG51bGwpIHsgLy8gaXMgbnVsbCBvciB1bmRlZmluZWQ/XG5cdFx0XHRuZXdQcm9wcy5hbGxEYXkgPSBldmVudC5hbGxEYXk7XG5cdFx0fVxuXHRcdG5vcm1hbGl6ZUV2ZW50RGF0ZXMobmV3UHJvcHMpO1xuXG5cdFx0Ly8gY3JlYXRlIG5vcm1hbGl6ZWQgdmVyc2lvbnMgb2YgdGhlIG9yaWdpbmFsIHByb3BzIHRvIGNvbXBhcmUgYWdhaW5zdFxuXHRcdC8vIG5lZWQgYSByZWFsIGVuZCB2YWx1ZSwgZm9yIGRpZmZpbmdcblx0XHRvbGRQcm9wcyA9IHtcblx0XHRcdHN0YXJ0OiBldmVudC5fc3RhcnQuY2xvbmUoKSxcblx0XHRcdGVuZDogZXZlbnQuX2VuZCA/IGV2ZW50Ll9lbmQuY2xvbmUoKSA6IHQuZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50Ll9hbGxEYXksIGV2ZW50Ll9zdGFydCksXG5cdFx0XHRhbGxEYXk6IG5ld1Byb3BzLmFsbERheSAvLyBub3JtYWxpemUgdGhlIGRhdGVzIGluIHRoZSBzYW1lIHJlZ2FyZCBhcyB0aGUgbmV3IHByb3BlcnRpZXNcblx0XHR9O1xuXHRcdG5vcm1hbGl6ZUV2ZW50RGF0ZXMob2xkUHJvcHMpO1xuXG5cdFx0Ly8gbmVlZCB0byBjbGVhciB0aGUgZW5kIGRhdGUgaWYgZXhwbGljaXRseSBjaGFuZ2VkIHRvIG51bGxcblx0XHRjbGVhckVuZCA9IGV2ZW50Ll9lbmQgIT09IG51bGwgJiYgbmV3UHJvcHMuZW5kID09PSBudWxsO1xuXG5cdFx0Ly8gY29tcHV0ZSB0aGUgZGVsdGEgZm9yIG1vdmluZyB0aGUgc3RhcnQgZGF0ZVxuXHRcdHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMobmV3UHJvcHMuc3RhcnQsIG9sZFByb3BzLnN0YXJ0KTtcblxuXHRcdC8vIGNvbXB1dGUgdGhlIGRlbHRhIGZvciBtb3ZpbmcgdGhlIGVuZCBkYXRlXG5cdFx0aWYgKG5ld1Byb3BzLmVuZCkge1xuXHRcdFx0ZW5kRGVsdGEgPSBkaWZmRGF0ZXMobmV3UHJvcHMuZW5kLCBvbGRQcm9wcy5lbmQpO1xuXHRcdFx0ZHVyYXRpb25EZWx0YSA9IGVuZERlbHRhLnN1YnRyYWN0KHN0YXJ0RGVsdGEpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGR1cmF0aW9uRGVsdGEgPSBudWxsO1xuXHRcdH1cblxuXHRcdC8vIGdhdGhlciBhbGwgbm9uLWRhdGUtcmVsYXRlZCBwcm9wZXJ0aWVzXG5cdFx0JC5lYWNoKG5ld1Byb3BzLCBmdW5jdGlvbihuYW1lLCB2YWwpIHtcblx0XHRcdGlmIChpc01pc2NFdmVudFByb3BOYW1lKG5hbWUpKSB7XG5cdFx0XHRcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdG1pc2NQcm9wc1tuYW1lXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gYXBwbHkgdGhlIG9wZXJhdGlvbnMgdG8gdGhlIGV2ZW50IGFuZCBhbGwgcmVsYXRlZCBldmVudHNcblx0XHR1bmRvRnVuYyA9IG11dGF0ZUV2ZW50cyhcblx0XHRcdGNsaWVudEV2ZW50cyhldmVudC5faWQpLCAvLyBnZXQgZXZlbnRzIHdpdGggdGhpcyBJRFxuXHRcdFx0Y2xlYXJFbmQsXG5cdFx0XHRuZXdQcm9wcy5hbGxEYXksXG5cdFx0XHRzdGFydERlbHRhLFxuXHRcdFx0ZHVyYXRpb25EZWx0YSxcblx0XHRcdG1pc2NQcm9wc1xuXHRcdCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGF0ZURlbHRhOiBzdGFydERlbHRhLFxuXHRcdFx0ZHVyYXRpb25EZWx0YTogZHVyYXRpb25EZWx0YSxcblx0XHRcdHVuZG86IHVuZG9GdW5jXG5cdFx0fTtcblx0fVxuXG5cblx0Ly8gTW9kaWZpZXMgYW4gYXJyYXkgb2YgZXZlbnRzIGluIHRoZSBmb2xsb3dpbmcgd2F5cyAob3BlcmF0aW9ucyBhcmUgaW4gb3JkZXIpOlxuXHQvLyAtIGNsZWFyIHRoZSBldmVudCdzIGBlbmRgXG5cdC8vIC0gY29udmVydCB0aGUgZXZlbnQgdG8gYWxsRGF5XG5cdC8vIC0gYWRkIGBkYXRlRGVsdGFgIHRvIHRoZSBzdGFydCBhbmQgZW5kXG5cdC8vIC0gYWRkIGBkdXJhdGlvbkRlbHRhYCB0byB0aGUgZXZlbnQncyBkdXJhdGlvblxuXHQvLyAtIGFzc2lnbiBgbWlzY1Byb3BzYCB0byB0aGUgZXZlbnRcblx0Ly9cblx0Ly8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB0byB1bmRvIGFsbCB0aGUgb3BlcmF0aW9ucy5cblx0Ly9cblx0Ly8gVE9ETzogZG9uJ3QgdXNlIHNvIG1hbnkgY2xvc3VyZXMuIHBvc3NpYmxlIG1lbW9yeSBpc3N1ZXMgd2hlbiBsb3RzIG9mIGV2ZW50cyB3aXRoIHNhbWUgSUQuXG5cdC8vXG5cdGZ1bmN0aW9uIG11dGF0ZUV2ZW50cyhldmVudHMsIGNsZWFyRW5kLCBhbGxEYXksIGRhdGVEZWx0YSwgZHVyYXRpb25EZWx0YSwgbWlzY1Byb3BzKSB7XG5cdFx0dmFyIGlzQW1iaWdUaW1lem9uZSA9IHQuZ2V0SXNBbWJpZ1RpbWV6b25lKCk7XG5cdFx0dmFyIHVuZG9GdW5jdGlvbnMgPSBbXTtcblxuXHRcdC8vIG5vcm1hbGl6ZSB6ZXJvLWxlbmd0aCBkZWx0YXMgdG8gYmUgbnVsbFxuXHRcdGlmIChkYXRlRGVsdGEgJiYgIWRhdGVEZWx0YS52YWx1ZU9mKCkpIHsgZGF0ZURlbHRhID0gbnVsbDsgfVxuXHRcdGlmIChkdXJhdGlvbkRlbHRhICYmICFkdXJhdGlvbkRlbHRhLnZhbHVlT2YoKSkgeyBkdXJhdGlvbkRlbHRhID0gbnVsbDsgfVxuXG5cdFx0JC5lYWNoKGV2ZW50cywgZnVuY3Rpb24oaSwgZXZlbnQpIHtcblx0XHRcdHZhciBvbGRQcm9wcztcblx0XHRcdHZhciBuZXdQcm9wcztcblxuXHRcdFx0Ly8gYnVpbGQgYW4gb2JqZWN0IGhvbGRpbmcgYWxsIHRoZSBvbGQgdmFsdWVzLCBib3RoIGRhdGUtcmVsYXRlZCBhbmQgbWlzYy5cblx0XHRcdC8vIGZvciB0aGUgdW5kbyBmdW5jdGlvbi5cblx0XHRcdG9sZFByb3BzID0ge1xuXHRcdFx0XHRzdGFydDogZXZlbnQuc3RhcnQuY2xvbmUoKSxcblx0XHRcdFx0ZW5kOiBldmVudC5lbmQgPyBldmVudC5lbmQuY2xvbmUoKSA6IG51bGwsXG5cdFx0XHRcdGFsbERheTogZXZlbnQuYWxsRGF5XG5cdFx0XHR9O1xuXHRcdFx0JC5lYWNoKG1pc2NQcm9wcywgZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRvbGRQcm9wc1tuYW1lXSA9IGV2ZW50W25hbWVdO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIG5ldyBkYXRlLXJlbGF0ZWQgcHJvcGVydGllcy4gd29yayBvZmYgdGhlIG9yaWdpbmFsIGRhdGUgc25hcHNob3QuXG5cdFx0XHQvLyBvayB0byB1c2UgcmVmZXJlbmNlcyBiZWNhdXNlIHRoZXkgd2lsbCBiZSB0aHJvd24gYXdheSB3aGVuIGJhY2t1cEV2ZW50RGF0ZXMgaXMgY2FsbGVkLlxuXHRcdFx0bmV3UHJvcHMgPSB7XG5cdFx0XHRcdHN0YXJ0OiBldmVudC5fc3RhcnQsXG5cdFx0XHRcdGVuZDogZXZlbnQuX2VuZCxcblx0XHRcdFx0YWxsRGF5OiBhbGxEYXkgLy8gbm9ybWFsaXplIHRoZSBkYXRlcyBpbiB0aGUgc2FtZSByZWdhcmQgYXMgdGhlIG5ldyBwcm9wZXJ0aWVzXG5cdFx0XHR9O1xuXHRcdFx0bm9ybWFsaXplRXZlbnREYXRlcyhuZXdQcm9wcyk7IC8vIG1hc3NhZ2VzIHN0YXJ0L2VuZC9hbGxEYXlcblxuXHRcdFx0Ly8gc3RyaXAgb3IgZW5zdXJlIHRoZSBlbmQgZGF0ZVxuXHRcdFx0aWYgKGNsZWFyRW5kKSB7XG5cdFx0XHRcdG5ld1Byb3BzLmVuZCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChkdXJhdGlvbkRlbHRhICYmICFuZXdQcm9wcy5lbmQpIHsgLy8gdGhlIGR1cmF0aW9uIHRyYW5zbGF0aW9uIHJlcXVpcmVzIGFuIGVuZCBkYXRlXG5cdFx0XHRcdG5ld1Byb3BzLmVuZCA9IHQuZ2V0RGVmYXVsdEV2ZW50RW5kKG5ld1Byb3BzLmFsbERheSwgbmV3UHJvcHMuc3RhcnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0ZURlbHRhKSB7XG5cdFx0XHRcdG5ld1Byb3BzLnN0YXJ0LmFkZChkYXRlRGVsdGEpO1xuXHRcdFx0XHRpZiAobmV3UHJvcHMuZW5kKSB7XG5cdFx0XHRcdFx0bmV3UHJvcHMuZW5kLmFkZChkYXRlRGVsdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkdXJhdGlvbkRlbHRhKSB7XG5cdFx0XHRcdG5ld1Byb3BzLmVuZC5hZGQoZHVyYXRpb25EZWx0YSk7IC8vIGVuZCBhbHJlYWR5IGVuc3VyZWQgYWJvdmVcblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgdGhlIGRhdGVzIGhhdmUgY2hhbmdlZCwgYW5kIHdlIGtub3cgaXQgaXMgaW1wb3NzaWJsZSB0byByZWNvbXB1dGUgdGhlXG5cdFx0XHQvLyB0aW1lem9uZSBvZmZzZXRzLCBzdHJpcCB0aGUgem9uZS5cblx0XHRcdGlmIChcblx0XHRcdFx0aXNBbWJpZ1RpbWV6b25lICYmXG5cdFx0XHRcdCFuZXdQcm9wcy5hbGxEYXkgJiZcblx0XHRcdFx0KGRhdGVEZWx0YSB8fCBkdXJhdGlvbkRlbHRhKVxuXHRcdFx0KSB7XG5cdFx0XHRcdG5ld1Byb3BzLnN0YXJ0LnN0cmlwWm9uZSgpO1xuXHRcdFx0XHRpZiAobmV3UHJvcHMuZW5kKSB7XG5cdFx0XHRcdFx0bmV3UHJvcHMuZW5kLnN0cmlwWm9uZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCQuZXh0ZW5kKGV2ZW50LCBtaXNjUHJvcHMsIG5ld1Byb3BzKTsgLy8gY29weSBvdmVyIG1pc2MgcHJvcHMsIHRoZW4gZGF0ZS1yZWxhdGVkIHByb3BzXG5cdFx0XHRiYWNrdXBFdmVudERhdGVzKGV2ZW50KTsgLy8gcmVnZW5lcmF0ZSBpbnRlcm5hbCBfc3RhcnQvX2VuZC9fYWxsRGF5XG5cblx0XHRcdHVuZG9GdW5jdGlvbnMucHVzaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JC5leHRlbmQoZXZlbnQsIG9sZFByb3BzKTtcblx0XHRcdFx0YmFja3VwRXZlbnREYXRlcyhldmVudCk7IC8vIHJlZ2VuZXJhdGUgaW50ZXJuYWwgX3N0YXJ0L19lbmQvX2FsbERheVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHVuZG9GdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dW5kb0Z1bmN0aW9uc1tpXSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxufVxuXG5cbi8vIHJldHVybnMgYW4gdW5kbyBmdW5jdGlvblxuQ2FsZW5kYXIucHJvdG90eXBlLm11dGF0ZVNlZyA9IGZ1bmN0aW9uKHNlZywgbmV3UHJvcHMpIHtcblx0cmV0dXJuIHRoaXMubXV0YXRlRXZlbnQoc2VnLmV2ZW50LCBuZXdQcm9wcyk7XG59O1xuXG5cbi8vIGhvb2sgZm9yIGV4dGVybmFsIGxpYnMgdG8gbWFuaXB1bGF0ZSBldmVudCBwcm9wZXJ0aWVzIHVwb24gY3JlYXRpb24uXG4vLyBzaG91bGQgbWFuaXB1bGF0ZSB0aGUgZXZlbnQgaW4tcGxhY2UuXG5DYWxlbmRhci5wcm90b3R5cGUubm9ybWFsaXplRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xufTtcblxuXG4vLyBEb2VzIHRoZSBnaXZlbiBzcGFuIChzdGFydCwgZW5kLCBhbmQgb3RoZXIgbG9jYXRpb24gaW5mb3JtYXRpb24pXG4vLyBmdWxseSBjb250YWluIHRoZSBvdGhlcj9cbkNhbGVuZGFyLnByb3RvdHlwZS5zcGFuQ29udGFpbnNTcGFuID0gZnVuY3Rpb24ob3V0ZXJTcGFuLCBpbm5lclNwYW4pIHtcblx0dmFyIGV2ZW50U3RhcnQgPSBvdXRlclNwYW4uc3RhcnQuY2xvbmUoKS5zdHJpcFpvbmUoKTtcblx0dmFyIGV2ZW50RW5kID0gdGhpcy5nZXRFdmVudEVuZChvdXRlclNwYW4pLnN0cmlwWm9uZSgpO1xuXG5cdHJldHVybiBpbm5lclNwYW4uc3RhcnQgPj0gZXZlbnRTdGFydCAmJiBpbm5lclNwYW4uZW5kIDw9IGV2ZW50RW5kO1xufTtcblxuXG4vLyBSZXR1cm5zIGEgbGlzdCBvZiBldmVudHMgdGhhdCB0aGUgZ2l2ZW4gZXZlbnQgc2hvdWxkIGJlIGNvbXBhcmVkIGFnYWluc3Qgd2hlbiBiZWluZyBjb25zaWRlcmVkIGZvciBhIG1vdmUgdG9cbi8vIHRoZSBzcGVjaWZpZWQgc3Bhbi4gQXR0YWNoZWQgdG8gdGhlIENhbGVuZGFyJ3MgcHJvdG90eXBlIGJlY2F1c2UgRXZlbnRNYW5hZ2VyIGlzIGEgbWl4aW4gZm9yIGEgQ2FsZW5kYXIuXG5DYWxlbmRhci5wcm90b3R5cGUuZ2V0UGVlckV2ZW50cyA9IGZ1bmN0aW9uKHNwYW4sIGV2ZW50KSB7XG5cdHZhciBjYWNoZSA9IHRoaXMuZ2V0RXZlbnRDYWNoZSgpO1xuXHR2YXIgcGVlckV2ZW50cyA9IFtdO1xuXHR2YXIgaSwgb3RoZXJFdmVudDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgY2FjaGUubGVuZ3RoOyBpKyspIHtcblx0XHRvdGhlckV2ZW50ID0gY2FjaGVbaV07XG5cdFx0aWYgKFxuXHRcdFx0IWV2ZW50IHx8XG5cdFx0XHRldmVudC5faWQgIT09IG90aGVyRXZlbnQuX2lkIC8vIGRvbid0IGNvbXBhcmUgdGhlIGV2ZW50IHRvIGl0c2VsZiBvciBvdGhlciByZWxhdGVkIFtyZXBlYXRpbmddIGV2ZW50c1xuXHRcdCkge1xuXHRcdFx0cGVlckV2ZW50cy5wdXNoKG90aGVyRXZlbnQpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwZWVyRXZlbnRzO1xufTtcblxuXG4vLyB1cGRhdGVzIHRoZSBcImJhY2t1cFwiIHByb3BlcnRpZXMsIHdoaWNoIGFyZSBwcmVzZXJ2ZWQgaW4gb3JkZXIgdG8gY29tcHV0ZSBkaWZmcyBsYXRlciBvbi5cbmZ1bmN0aW9uIGJhY2t1cEV2ZW50RGF0ZXMoZXZlbnQpIHtcblx0ZXZlbnQuX2FsbERheSA9IGV2ZW50LmFsbERheTtcblx0ZXZlbnQuX3N0YXJ0ID0gZXZlbnQuc3RhcnQuY2xvbmUoKTtcblx0ZXZlbnQuX2VuZCA9IGV2ZW50LmVuZCA/IGV2ZW50LmVuZC5jbG9uZSgpIDogbnVsbDtcbn1cblxuXG4vKiBPdmVybGFwcGluZyAvIENvbnN0cmFpbmluZ1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbi8vIERldGVybWluZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGNhbiBiZSByZWxvY2F0ZWQgdG8gdGhlIGdpdmVuIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIHdpdGggb3RoZXIgbWlzYyBkYXRhKVxuQ2FsZW5kYXIucHJvdG90eXBlLmlzRXZlbnRTcGFuQWxsb3dlZCA9IGZ1bmN0aW9uKHNwYW4sIGV2ZW50KSB7XG5cdHZhciBzb3VyY2UgPSBldmVudC5zb3VyY2UgfHwge307XG5cdHZhciBldmVudEFsbG93RnVuYyA9IHRoaXMub3B0KCdldmVudEFsbG93Jyk7XG5cblx0dmFyIGNvbnN0cmFpbnQgPSBmaXJzdERlZmluZWQoXG5cdFx0ZXZlbnQuY29uc3RyYWludCxcblx0XHRzb3VyY2UuY29uc3RyYWludCxcblx0XHR0aGlzLm9wdCgnZXZlbnRDb25zdHJhaW50Jylcblx0KTtcblxuXHR2YXIgb3ZlcmxhcCA9IGZpcnN0RGVmaW5lZChcblx0XHRldmVudC5vdmVybGFwLFxuXHRcdHNvdXJjZS5vdmVybGFwLFxuXHRcdHRoaXMub3B0KCdldmVudE92ZXJsYXAnKVxuXHQpO1xuXG5cdHJldHVybiB0aGlzLmlzU3BhbkFsbG93ZWQoc3BhbiwgY29uc3RyYWludCwgb3ZlcmxhcCwgZXZlbnQpICYmXG5cdFx0KCFldmVudEFsbG93RnVuYyB8fCBldmVudEFsbG93RnVuYyhzcGFuLCBldmVudCkgIT09IGZhbHNlKTtcbn07XG5cblxuLy8gRGV0ZXJtaW5lcyBpZiBhbiBleHRlcm5hbCBldmVudCBjYW4gYmUgcmVsb2NhdGVkIHRvIHRoZSBnaXZlbiBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCB3aXRoIG90aGVyIG1pc2MgZGF0YSlcbkNhbGVuZGFyLnByb3RvdHlwZS5pc0V4dGVybmFsU3BhbkFsbG93ZWQgPSBmdW5jdGlvbihldmVudFNwYW4sIGV2ZW50TG9jYXRpb24sIGV2ZW50UHJvcHMpIHtcblx0dmFyIGV2ZW50SW5wdXQ7XG5cdHZhciBldmVudDtcblxuXHQvLyBub3RlOiB2ZXJ5IHNpbWlsYXIgbG9naWMgaXMgaW4gVmlldydzIHJlcG9ydEV4dGVybmFsRHJvcFxuXHRpZiAoZXZlbnRQcm9wcykge1xuXHRcdGV2ZW50SW5wdXQgPSAkLmV4dGVuZCh7fSwgZXZlbnRQcm9wcywgZXZlbnRMb2NhdGlvbik7XG5cdFx0ZXZlbnQgPSB0aGlzLmV4cGFuZEV2ZW50KFxuXHRcdFx0dGhpcy5idWlsZEV2ZW50RnJvbUlucHV0KGV2ZW50SW5wdXQpXG5cdFx0KVswXTtcblx0fVxuXG5cdGlmIChldmVudCkge1xuXHRcdHJldHVybiB0aGlzLmlzRXZlbnRTcGFuQWxsb3dlZChldmVudFNwYW4sIGV2ZW50KTtcblx0fVxuXHRlbHNlIHsgLy8gdHJlYXQgaXQgYXMgYSBzZWxlY3Rpb25cblxuXHRcdHJldHVybiB0aGlzLmlzU2VsZWN0aW9uU3BhbkFsbG93ZWQoZXZlbnRTcGFuKTtcblx0fVxufTtcblxuXG4vLyBEZXRlcm1pbmVzIHRoZSBnaXZlbiBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCB3aXRoIG90aGVyIG1pc2MgZGF0YSkgY2FuIGJlIHNlbGVjdGVkLlxuQ2FsZW5kYXIucHJvdG90eXBlLmlzU2VsZWN0aW9uU3BhbkFsbG93ZWQgPSBmdW5jdGlvbihzcGFuKSB7XG5cdHZhciBzZWxlY3RBbGxvd0Z1bmMgPSB0aGlzLm9wdCgnc2VsZWN0QWxsb3cnKTtcblxuXHRyZXR1cm4gdGhpcy5pc1NwYW5BbGxvd2VkKHNwYW4sIHRoaXMub3B0KCdzZWxlY3RDb25zdHJhaW50JyksIHRoaXMub3B0KCdzZWxlY3RPdmVybGFwJykpICYmXG5cdFx0KCFzZWxlY3RBbGxvd0Z1bmMgfHwgc2VsZWN0QWxsb3dGdW5jKHNwYW4pICE9PSBmYWxzZSk7XG59O1xuXG5cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3BhbiAoY2F1c2VkIGJ5IGFuIGV2ZW50IGRyb3AvcmVzaXplIG9yIGEgc2VsZWN0aW9uKSBpcyBhbGxvd2VkIHRvIGV4aXN0XG4vLyBhY2NvcmRpbmcgdG8gdGhlIGNvbnN0cmFpbnQvb3ZlcmxhcCBzZXR0aW5ncy5cbi8vIGBldmVudGAgaXMgbm90IHJlcXVpcmVkIGlmIGNoZWNraW5nIGEgc2VsZWN0aW9uLlxuQ2FsZW5kYXIucHJvdG90eXBlLmlzU3BhbkFsbG93ZWQgPSBmdW5jdGlvbihzcGFuLCBjb25zdHJhaW50LCBvdmVybGFwLCBldmVudCkge1xuXHR2YXIgY29uc3RyYWludEV2ZW50cztcblx0dmFyIGFueUNvbnRhaW5tZW50O1xuXHR2YXIgcGVlckV2ZW50cztcblx0dmFyIGksIHBlZXJFdmVudDtcblx0dmFyIHBlZXJPdmVybGFwO1xuXG5cdC8vIHRoZSByYW5nZSBtdXN0IGJlIGZ1bGx5IGNvbnRhaW5lZCBieSBhdCBsZWFzdCBvbmUgb2YgcHJvZHVjZWQgY29uc3RyYWludCBldmVudHNcblx0aWYgKGNvbnN0cmFpbnQgIT0gbnVsbCkge1xuXG5cdFx0Ly8gbm90IHRyZWF0ZWQgYXMgYW4gZXZlbnQhIGludGVybWVkaWF0ZSBkYXRhIHN0cnVjdHVyZVxuXHRcdC8vIFRPRE86IHVzZSByYW5nZXMgaW4gdGhlIGZ1dHVyZVxuXHRcdGNvbnN0cmFpbnRFdmVudHMgPSB0aGlzLmNvbnN0cmFpbnRUb0V2ZW50cyhjb25zdHJhaW50KTtcblx0XHRpZiAoY29uc3RyYWludEV2ZW50cykgeyAvLyBub3QgaW52YWxpZFxuXG5cdFx0XHRhbnlDb250YWlubWVudCA9IGZhbHNlO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGNvbnN0cmFpbnRFdmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHRoaXMuc3BhbkNvbnRhaW5zU3Bhbihjb25zdHJhaW50RXZlbnRzW2ldLCBzcGFuKSkge1xuXHRcdFx0XHRcdGFueUNvbnRhaW5tZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWFueUNvbnRhaW5tZW50KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwZWVyRXZlbnRzID0gdGhpcy5nZXRQZWVyRXZlbnRzKHNwYW4sIGV2ZW50KTtcblxuXHRmb3IgKGkgPSAwOyBpIDwgcGVlckV2ZW50cy5sZW5ndGg7IGkrKykgIHtcblx0XHRwZWVyRXZlbnQgPSBwZWVyRXZlbnRzW2ldO1xuXG5cdFx0Ly8gdGhlcmUgbmVlZHMgdG8gYmUgYW4gYWN0dWFsIGludGVyc2VjdGlvbiBiZWZvcmUgZGlzYWxsb3dpbmcgYW55dGhpbmdcblx0XHRpZiAodGhpcy5ldmVudEludGVyc2VjdHNSYW5nZShwZWVyRXZlbnQsIHNwYW4pKSB7XG5cblx0XHRcdC8vIGV2YWx1YXRlIG92ZXJsYXAgZm9yIHRoZSBnaXZlbiByYW5nZSBhbmQgc2hvcnQtY2lyY3VpdCBpZiBuZWNlc3Nhcnlcblx0XHRcdGlmIChvdmVybGFwID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiB0aGUgZXZlbnQncyBvdmVybGFwIGlzIGEgdGVzdCBmdW5jdGlvbiwgcGFzcyB0aGUgcGVlciBldmVudCBpbiBxdWVzdGlvbiBhcyB0aGUgZmlyc3QgcGFyYW1cblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBvdmVybGFwID09PSAnZnVuY3Rpb24nICYmICFvdmVybGFwKHBlZXJFdmVudCwgZXZlbnQpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgd2UgYXJlIGNvbXB1dGluZyBpZiB0aGUgZ2l2ZW4gcmFuZ2UgaXMgYWxsb3dhYmxlIGZvciBhbiBldmVudCwgY29uc2lkZXIgdGhlIG90aGVyIGV2ZW50J3Ncblx0XHRcdC8vIEV2ZW50T2JqZWN0LXNwZWNpZmljIG9yIFNvdXJjZS1zcGVjaWZpYyBgb3ZlcmxhcGAgcHJvcGVydHlcblx0XHRcdGlmIChldmVudCkge1xuXHRcdFx0XHRwZWVyT3ZlcmxhcCA9IGZpcnN0RGVmaW5lZChcblx0XHRcdFx0XHRwZWVyRXZlbnQub3ZlcmxhcCxcblx0XHRcdFx0XHQocGVlckV2ZW50LnNvdXJjZSB8fCB7fSkub3ZlcmxhcFxuXHRcdFx0XHRcdC8vIHdlIGFscmVhZHkgY29uc2lkZXJlZCB0aGUgZ2xvYmFsIGBldmVudE92ZXJsYXBgXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGlmIChwZWVyT3ZlcmxhcCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgdGhlIHBlZXIgZXZlbnQncyBvdmVybGFwIGlzIGEgdGVzdCBmdW5jdGlvbiwgcGFzcyB0aGUgc3ViamVjdCBldmVudCBhcyB0aGUgZmlyc3QgcGFyYW1cblx0XHRcdFx0aWYgKHR5cGVvZiBwZWVyT3ZlcmxhcCA9PT0gJ2Z1bmN0aW9uJyAmJiAhcGVlck92ZXJsYXAoZXZlbnQsIHBlZXJFdmVudCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cblxuLy8gR2l2ZW4gYW4gZXZlbnQgaW5wdXQgZnJvbSB0aGUgQVBJLCBwcm9kdWNlcyBhbiBhcnJheSBvZiBldmVudCBvYmplY3RzLiBQb3NzaWJsZSBldmVudCBpbnB1dHM6XG4vLyAnYnVzaW5lc3NIb3Vycydcbi8vIEFuIGV2ZW50IElEIChudW1iZXIgb3Igc3RyaW5nKVxuLy8gQW4gb2JqZWN0IHdpdGggc3BlY2lmaWMgc3RhcnQvZW5kIGRhdGVzIG9yIGEgcmVjdXJyaW5nIGV2ZW50IChsaWtlIHdoYXQgYnVzaW5lc3NIb3VycyBhY2NlcHRzKVxuQ2FsZW5kYXIucHJvdG90eXBlLmNvbnN0cmFpbnRUb0V2ZW50cyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRJbnB1dCkge1xuXG5cdGlmIChjb25zdHJhaW50SW5wdXQgPT09ICdidXNpbmVzc0hvdXJzJykge1xuXHRcdHJldHVybiB0aGlzLmdldEN1cnJlbnRCdXNpbmVzc0hvdXJFdmVudHMoKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgY29uc3RyYWludElucHV0ID09PSAnb2JqZWN0Jykge1xuXHRcdGlmIChjb25zdHJhaW50SW5wdXQuc3RhcnQgIT0gbnVsbCkgeyAvLyBuZWVkcyB0byBiZSBldmVudC1saWtlIGlucHV0XG5cdFx0XHRyZXR1cm4gdGhpcy5leHBhbmRFdmVudCh0aGlzLmJ1aWxkRXZlbnRGcm9tSW5wdXQoY29uc3RyYWludElucHV0KSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7IC8vIGludmFsaWRcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5jbGllbnRFdmVudHMoY29uc3RyYWludElucHV0KTsgLy8gcHJvYmFibHkgYW4gSURcbn07XG5cblxuLy8gRG9lcyB0aGUgZXZlbnQncyBkYXRlIHJhbmdlIGludGVyc2VjdCB3aXRoIHRoZSBnaXZlbiByYW5nZT9cbi8vIHN0YXJ0L2VuZCBhbHJlYWR5IGFzc3VtZWQgdG8gaGF2ZSBzdHJpcHBlZCB6b25lcyA6KFxuQ2FsZW5kYXIucHJvdG90eXBlLmV2ZW50SW50ZXJzZWN0c1JhbmdlID0gZnVuY3Rpb24oZXZlbnQsIHJhbmdlKSB7XG5cdHZhciBldmVudFN0YXJ0ID0gZXZlbnQuc3RhcnQuY2xvbmUoKS5zdHJpcFpvbmUoKTtcblx0dmFyIGV2ZW50RW5kID0gdGhpcy5nZXRFdmVudEVuZChldmVudCkuc3RyaXBab25lKCk7XG5cblx0cmV0dXJuIHJhbmdlLnN0YXJ0IDwgZXZlbnRFbmQgJiYgcmFuZ2UuZW5kID4gZXZlbnRTdGFydDtcbn07XG5cblxuLyogQnVzaW5lc3MgSG91cnNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxudmFyIEJVU0lORVNTX0hPVVJfRVZFTlRfREVGQVVMVFMgPSB7XG5cdGlkOiAnX2ZjQnVzaW5lc3NIb3VycycsIC8vIHdpbGwgcmVsYXRlIGV2ZW50cyBmcm9tIGRpZmZlcmVudCBjYWxscyB0byBleHBhbmRFdmVudFxuXHRzdGFydDogJzA5OjAwJyxcblx0ZW5kOiAnMTc6MDAnLFxuXHRkb3c6IFsgMSwgMiwgMywgNCwgNSBdLCAvLyBtb25kYXkgLSBmcmlkYXlcblx0cmVuZGVyaW5nOiAnaW52ZXJzZS1iYWNrZ3JvdW5kJ1xuXHQvLyBjbGFzc05hbWVzIGFyZSBkZWZpbmVkIGluIGJ1c2luZXNzSG91cnNTZWdDbGFzc2VzXG59O1xuXG4vLyBSZXR1cm4gZXZlbnRzIG9iamVjdHMgZm9yIGJ1c2luZXNzIGhvdXJzIHdpdGhpbiB0aGUgY3VycmVudCB2aWV3LlxuLy8gQWJ1c2Ugb2Ygb3VyIGV2ZW50IHN5c3RlbSA6KFxuQ2FsZW5kYXIucHJvdG90eXBlLmdldEN1cnJlbnRCdXNpbmVzc0hvdXJFdmVudHMgPSBmdW5jdGlvbih3aG9sZURheSkge1xuXHRyZXR1cm4gdGhpcy5jb21wdXRlQnVzaW5lc3NIb3VyRXZlbnRzKHdob2xlRGF5LCB0aGlzLm9wdCgnYnVzaW5lc3NIb3VycycpKTtcbn07XG5cbi8vIEdpdmVuIGEgcmF3IGlucHV0IHZhbHVlIGZyb20gb3B0aW9ucywgcmV0dXJuIGV2ZW50cyBvYmplY3RzIGZvciBidXNpbmVzcyBob3VycyB3aXRoaW4gdGhlIGN1cnJlbnQgdmlldy5cbkNhbGVuZGFyLnByb3RvdHlwZS5jb21wdXRlQnVzaW5lc3NIb3VyRXZlbnRzID0gZnVuY3Rpb24od2hvbGVEYXksIGlucHV0KSB7XG5cdGlmIChpbnB1dCA9PT0gdHJ1ZSkge1xuXHRcdHJldHVybiB0aGlzLmV4cGFuZEJ1c2luZXNzSG91ckV2ZW50cyh3aG9sZURheSwgWyB7fSBdKTtcblx0fVxuXHRlbHNlIGlmICgkLmlzUGxhaW5PYmplY3QoaW5wdXQpKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kQnVzaW5lc3NIb3VyRXZlbnRzKHdob2xlRGF5LCBbIGlucHV0IF0pO1xuXHR9XG5cdGVsc2UgaWYgKCQuaXNBcnJheShpbnB1dCkpIHtcblx0XHRyZXR1cm4gdGhpcy5leHBhbmRCdXNpbmVzc0hvdXJFdmVudHMod2hvbGVEYXksIGlucHV0LCB0cnVlKTtcblx0fVxuXHRlbHNlIHtcblx0XHRyZXR1cm4gW107XG5cdH1cbn07XG5cbi8vIGlucHV0cyBleHBlY3RlZCB0byBiZSBhbiBhcnJheSBvZiBvYmplY3RzLlxuLy8gaWYgaWdub3JlTm9Eb3cgaXMgdHJ1ZSwgd2lsbCBpZ25vcmUgZW50cmllcyB0aGF0IGRvbid0IHNwZWNpZnkgYSBkYXktb2Ytd2VlayAoZG93KSBrZXkuXG5DYWxlbmRhci5wcm90b3R5cGUuZXhwYW5kQnVzaW5lc3NIb3VyRXZlbnRzID0gZnVuY3Rpb24od2hvbGVEYXksIGlucHV0cywgaWdub3JlTm9Eb3cpIHtcblx0dmFyIHZpZXcgPSB0aGlzLmdldFZpZXcoKTtcblx0dmFyIGV2ZW50cyA9IFtdO1xuXHR2YXIgaSwgaW5wdXQ7XG5cblx0Zm9yIChpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdGlucHV0ID0gaW5wdXRzW2ldO1xuXG5cdFx0aWYgKGlnbm9yZU5vRG93ICYmICFpbnB1dC5kb3cpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdC8vIGdpdmUgZGVmYXVsdHMuIHdpbGwgbWFrZSBhIGNvcHlcblx0XHRpbnB1dCA9ICQuZXh0ZW5kKHt9LCBCVVNJTkVTU19IT1VSX0VWRU5UX0RFRkFVTFRTLCBpbnB1dCk7XG5cblx0XHQvLyBpZiBhIHdob2xlLWRheSBzZXJpZXMgaXMgcmVxdWVzdGVkLCBjbGVhciB0aGUgc3RhcnQvZW5kIHRpbWVzXG5cdFx0aWYgKHdob2xlRGF5KSB7XG5cdFx0XHRpbnB1dC5zdGFydCA9IG51bGw7XG5cdFx0XHRpbnB1dC5lbmQgPSBudWxsO1xuXHRcdH1cblxuXHRcdGV2ZW50cy5wdXNoLmFwcGx5KGV2ZW50cywgLy8gYXBwZW5kXG5cdFx0XHR0aGlzLmV4cGFuZEV2ZW50KFxuXHRcdFx0XHR0aGlzLmJ1aWxkRXZlbnRGcm9tSW5wdXQoaW5wdXQpLFxuXHRcdFx0XHR2aWV3LmFjdGl2ZVJhbmdlLnN0YXJ0LFxuXHRcdFx0XHR2aWV3LmFjdGl2ZVJhbmdlLmVuZFxuXHRcdFx0KVxuXHRcdCk7XG5cdH1cblxuXHRyZXR1cm4gZXZlbnRzO1xufTtcblxuOztcblxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZm9yIHRoZSBcImJhc2ljXCIgdmlld3MsIGFzIHdlbGwgYXMgbW9udGggdmlldy4gUmVuZGVycyBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjZWxscy5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gSXQgaXMgYSBtYW5hZ2VyIGZvciBhIERheUdyaWQgc3ViY29tcG9uZW50LCB3aGljaCBkb2VzIG1vc3Qgb2YgdGhlIGhlYXZ5IGxpZnRpbmcuXG4vLyBJdCBpcyByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgd2lkdGgvaGVpZ2h0LlxuXG52YXIgQmFzaWNWaWV3ID0gRkMuQmFzaWNWaWV3ID0gVmlldy5leHRlbmQoe1xuXG5cdHNjcm9sbGVyOiBudWxsLFxuXG5cdGRheUdyaWRDbGFzczogRGF5R3JpZCwgLy8gY2xhc3MgdGhlIGRheUdyaWQgd2lsbCBiZSBpbnN0YW50aWF0ZWQgZnJvbSAob3ZlcnJpZGFibGUgYnkgc3ViY2xhc3Nlcylcblx0ZGF5R3JpZDogbnVsbCwgLy8gdGhlIG1haW4gc3ViY29tcG9uZW50IHRoYXQgZG9lcyBtb3N0IG9mIHRoZSBoZWF2eSBsaWZ0aW5nXG5cblx0ZGF5TnVtYmVyc1Zpc2libGU6IGZhbHNlLCAvLyBkaXNwbGF5IGRheSBudW1iZXJzIG9uIGVhY2ggZGF5IGNlbGw/XG5cdGNvbFdlZWtOdW1iZXJzVmlzaWJsZTogZmFsc2UsIC8vIGRpc3BsYXkgd2VlayBudW1iZXJzIGFsb25nIHRoZSBzaWRlP1xuXHRjZWxsV2Vla051bWJlcnNWaXNpYmxlOiBmYWxzZSwgLy8gZGlzcGxheSB3ZWVrIG51bWJlcnMgaW4gZGF5IGNlbGw/XG5cblx0d2Vla051bWJlcldpZHRoOiBudWxsLCAvLyB3aWR0aCBvZiBhbGwgdGhlIHdlZWstbnVtYmVyIGNlbGxzIHJ1bm5pbmcgZG93biB0aGUgc2lkZVxuXG5cdGhlYWRDb250YWluZXJFbDogbnVsbCwgLy8gZGl2IHRoYXQgaG9sZCdzIHRoZSBkYXlHcmlkJ3MgcmVuZGVyZWQgZGF0ZSBoZWFkZXJcblx0aGVhZFJvd0VsOiBudWxsLCAvLyB0aGUgZmFrZSByb3cgZWxlbWVudCBvZiB0aGUgZGF5LW9mLXdlZWsgaGVhZGVyXG5cblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQgPSB0aGlzLmluc3RhbnRpYXRlRGF5R3JpZCgpO1xuXG5cdFx0dGhpcy5zY3JvbGxlciA9IG5ldyBTY3JvbGxlcih7XG5cdFx0XHRvdmVyZmxvd1g6ICdoaWRkZW4nLFxuXHRcdFx0b3ZlcmZsb3dZOiAnYXV0bydcblx0XHR9KTtcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgRGF5R3JpZCBvYmplY3QgdGhpcyB2aWV3IG5lZWRzLiBEcmF3cyBmcm9tIHRoaXMuZGF5R3JpZENsYXNzXG5cdGluc3RhbnRpYXRlRGF5R3JpZDogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gZ2VuZXJhdGUgYSBzdWJjbGFzcyBvbiB0aGUgZmx5IHdpdGggQmFzaWNWaWV3LXNwZWNpZmljIGJlaGF2aW9yXG5cdFx0Ly8gVE9ETzogY2FjaGUgdGhpcyBzdWJjbGFzc1xuXHRcdHZhciBzdWJjbGFzcyA9IHRoaXMuZGF5R3JpZENsYXNzLmV4dGVuZChiYXNpY0RheUdyaWRNZXRob2RzKTtcblxuXHRcdHJldHVybiBuZXcgc3ViY2xhc3ModGhpcyk7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuXG5cdGJ1aWxkUmVuZGVyUmFuZ2U6IGZ1bmN0aW9uKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCkge1xuXHRcdHZhciByZW5kZXJSYW5nZSA9IFZpZXcucHJvdG90eXBlLmJ1aWxkUmVuZGVyUmFuZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdC8vIHllYXIgYW5kIG1vbnRoIHZpZXdzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggd2Vla3MuIHRoaXMgaXMgYWxyZWFkeSBkb25lIGZvciB3ZWVrXG5cdFx0aWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChjdXJyZW50UmFuZ2VVbml0KSkge1xuXHRcdFx0cmVuZGVyUmFuZ2Uuc3RhcnQuc3RhcnRPZignd2VlaycpO1xuXG5cdFx0XHQvLyBtYWtlIGVuZC1vZi13ZWVrIGlmIG5vdCBhbHJlYWR5XG5cdFx0XHRpZiAocmVuZGVyUmFuZ2UuZW5kLndlZWtkYXkoKSkge1xuXHRcdFx0XHRyZW5kZXJSYW5nZS5lbmQuYWRkKDEsICd3ZWVrJykuc3RhcnRPZignd2VlaycpOyAvLyBleGNsdXNpdmVseSBtb3ZlIGJhY2t3YXJkc1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnRyaW1IaWRkZW5EYXlzKHJlbmRlclJhbmdlKTtcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIHZpZXcgaW50byBgdGhpcy5lbGAsIHdoaWNoIHNob3VsZCBhbHJlYWR5IGJlIGFzc2lnbmVkXG5cdHJlbmRlckRhdGVzOiBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMuZGF5R3JpZC5icmVha09uV2Vla3MgPSAveWVhcnxtb250aHx3ZWVrLy50ZXN0KHRoaXMuY3VycmVudFJhbmdlVW5pdCk7IC8vIGRvIGJlZm9yZSBHcmlkOjpzZXRSYW5nZVxuXHRcdHRoaXMuZGF5R3JpZC5zZXRSYW5nZSh0aGlzLnJlbmRlclJhbmdlKTtcblxuXHRcdHRoaXMuZGF5TnVtYmVyc1Zpc2libGUgPSB0aGlzLmRheUdyaWQucm93Q250ID4gMTsgLy8gVE9ETzogbWFrZSBncmlkIHJlc3BvbnNpYmxlXG5cdFx0aWYgKHRoaXMub3B0KCd3ZWVrTnVtYmVycycpKSB7XG5cdFx0XHRpZiAodGhpcy5vcHQoJ3dlZWtOdW1iZXJzV2l0aGluRGF5cycpKSB7XG5cdFx0XHRcdHRoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSA9IHRydWU7XG5cdFx0XHRcdHRoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlID0gdHJ1ZTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHRoaXMuZGF5R3JpZC5udW1iZXJzVmlzaWJsZSA9IHRoaXMuZGF5TnVtYmVyc1Zpc2libGUgfHxcblx0XHRcdHRoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSB8fCB0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZTtcblxuXHRcdHRoaXMuZWwuYWRkQ2xhc3MoJ2ZjLWJhc2ljLXZpZXcnKS5odG1sKHRoaXMucmVuZGVyU2tlbGV0b25IdG1sKCkpO1xuXHRcdHRoaXMucmVuZGVySGVhZCgpO1xuXG5cdFx0dGhpcy5zY3JvbGxlci5yZW5kZXIoKTtcblx0XHR2YXIgZGF5R3JpZENvbnRhaW5lckVsID0gdGhpcy5zY3JvbGxlci5lbC5hZGRDbGFzcygnZmMtZGF5LWdyaWQtY29udGFpbmVyJyk7XG5cdFx0dmFyIGRheUdyaWRFbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1kYXktZ3JpZFwiIC8+JykuYXBwZW5kVG8oZGF5R3JpZENvbnRhaW5lckVsKTtcblx0XHR0aGlzLmVsLmZpbmQoJy5mYy1ib2R5ID4gdHIgPiB0ZCcpLmFwcGVuZChkYXlHcmlkQ29udGFpbmVyRWwpO1xuXG5cdFx0dGhpcy5kYXlHcmlkLnNldEVsZW1lbnQoZGF5R3JpZEVsKTtcblx0XHR0aGlzLmRheUdyaWQucmVuZGVyRGF0ZXModGhpcy5oYXNSaWdpZFJvd3MoKSk7XG5cdH0sXG5cblxuXHQvLyByZW5kZXIgdGhlIGRheS1vZi13ZWVrIGhlYWRlcnNcblx0cmVuZGVySGVhZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oZWFkQ29udGFpbmVyRWwgPVxuXHRcdFx0dGhpcy5lbC5maW5kKCcuZmMtaGVhZC1jb250YWluZXInKVxuXHRcdFx0XHQuaHRtbCh0aGlzLmRheUdyaWQucmVuZGVySGVhZEh0bWwoKSk7XG5cdFx0dGhpcy5oZWFkUm93RWwgPSB0aGlzLmhlYWRDb250YWluZXJFbC5maW5kKCcuZmMtcm93Jyk7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZpZXcuIFNpbmNlIHdlIGhhdmVuJ3Qgc2VwYXJhdGVkIHNrZWxldG9uIHJlbmRlcmluZyBmcm9tIGRhdGUgcmVuZGVyaW5nLFxuXHQvLyBhbHdheXMgY29tcGxldGVseSBraWxsIHRoZSBkYXlHcmlkJ3MgcmVuZGVyaW5nLlxuXHR1bnJlbmRlckRhdGVzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJEYXRlcygpO1xuXHRcdHRoaXMuZGF5R3JpZC5yZW1vdmVFbGVtZW50KCk7XG5cdFx0dGhpcy5zY3JvbGxlci5kZXN0cm95KCk7XG5cdH0sXG5cblxuXHRyZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQucmVuZGVyQnVzaW5lc3NIb3VycygpO1xuXHR9LFxuXG5cblx0dW5yZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cdH0sXG5cblxuXHQvLyBCdWlsZHMgdGhlIEhUTUwgc2tlbGV0b24gZm9yIHRoZSB2aWV3LlxuXHQvLyBUaGUgZGF5LWdyaWQgY29tcG9uZW50IHdpbGwgcmVuZGVyIGluc2lkZSBvZiBhIGNvbnRhaW5lciBkZWZpbmVkIGJ5IHRoaXMgSFRNTC5cblx0cmVuZGVyU2tlbGV0b25IdG1sOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0Jzx0YWJsZT4nICtcblx0XHRcdFx0Jzx0aGVhZCBjbGFzcz1cImZjLWhlYWRcIj4nICtcblx0XHRcdFx0XHQnPHRyPicgK1xuXHRcdFx0XHRcdFx0Jzx0ZCBjbGFzcz1cImZjLWhlYWQtY29udGFpbmVyICcgKyB0aGlzLndpZGdldEhlYWRlckNsYXNzICsgJ1wiPjwvdGQ+JyArXG5cdFx0XHRcdFx0JzwvdHI+JyArXG5cdFx0XHRcdCc8L3RoZWFkPicgK1xuXHRcdFx0XHQnPHRib2R5IGNsYXNzPVwiZmMtYm9keVwiPicgK1xuXHRcdFx0XHRcdCc8dHI+JyArXG5cdFx0XHRcdFx0XHQnPHRkIGNsYXNzPVwiJyArIHRoaXMud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiPjwvdGQ+JyArXG5cdFx0XHRcdFx0JzwvdHI+JyArXG5cdFx0XHRcdCc8L3Rib2R5PicgK1xuXHRcdFx0JzwvdGFibGU+Jztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyBhbiBIVE1MIGF0dHJpYnV0ZSBzdHJpbmcgZm9yIHNldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSB3ZWVrIG51bWJlciBjb2x1bW4sIGlmIGl0IGlzIGtub3duXG5cdHdlZWtOdW1iZXJTdHlsZUF0dHI6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLndlZWtOdW1iZXJXaWR0aCAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuICdzdHlsZT1cIndpZHRoOicgKyB0aGlzLndlZWtOdW1iZXJXaWR0aCArICdweFwiJztcblx0XHR9XG5cdFx0cmV0dXJuICcnO1xuXHR9LFxuXG5cblx0Ly8gRGV0ZXJtaW5lcyB3aGV0aGVyIGVhY2ggcm93IHNob3VsZCBoYXZlIGEgY29uc3RhbnQgaGVpZ2h0XG5cdGhhc1JpZ2lkUm93czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGV2ZW50TGltaXQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdCcpO1xuXHRcdHJldHVybiBldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ICE9PSAnbnVtYmVyJztcblx0fSxcblxuXG5cdC8qIERpbWVuc2lvbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlZnJlc2hlcyB0aGUgaG9yaXpvbnRhbCBkaW1lbnNpb25zIG9mIHRoZSB2aWV3XG5cdHVwZGF0ZVdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcblx0XHRcdC8vIE1ha2Ugc3VyZSBhbGwgd2VlayBudW1iZXIgY2VsbHMgcnVubmluZyBkb3duIHRoZSBzaWRlIGhhdmUgdGhlIHNhbWUgd2lkdGguXG5cdFx0XHQvLyBSZWNvcmQgdGhlIHdpZHRoIGZvciBjZWxscyBjcmVhdGVkIGxhdGVyLlxuXHRcdFx0dGhpcy53ZWVrTnVtYmVyV2lkdGggPSBtYXRjaENlbGxXaWR0aHMoXG5cdFx0XHRcdHRoaXMuZWwuZmluZCgnLmZjLXdlZWstbnVtYmVyJylcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQWRqdXN0cyB0aGUgdmVydGljYWwgZGltZW5zaW9ucyBvZiB0aGUgdmlldyB0byB0aGUgc3BlY2lmaWVkIHZhbHVlc1xuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKHRvdGFsSGVpZ2h0LCBpc0F1dG8pIHtcblx0XHR2YXIgZXZlbnRMaW1pdCA9IHRoaXMub3B0KCdldmVudExpbWl0Jyk7XG5cdFx0dmFyIHNjcm9sbGVySGVpZ2h0O1xuXHRcdHZhciBzY3JvbGxiYXJXaWR0aHM7XG5cblx0XHQvLyByZXNldCBhbGwgaGVpZ2h0cyB0byBiZSBuYXR1cmFsXG5cdFx0dGhpcy5zY3JvbGxlci5jbGVhcigpO1xuXHRcdHVuY29tcGVuc2F0ZVNjcm9sbCh0aGlzLmhlYWRSb3dFbCk7XG5cblx0XHR0aGlzLmRheUdyaWQucmVtb3ZlU2VnUG9wb3ZlcigpOyAvLyBraWxsIHRoZSBcIm1vcmVcIiBwb3BvdmVyIGlmIGRpc3BsYXllZFxuXG5cdFx0Ly8gaXMgdGhlIGV2ZW50IGxpbWl0IGEgY29uc3RhbnQgbGV2ZWwgbnVtYmVyP1xuXHRcdGlmIChldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ID09PSAnbnVtYmVyJykge1xuXHRcdFx0dGhpcy5kYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTsgLy8gbGltaXQgdGhlIGxldmVscyBmaXJzdCBzbyB0aGUgaGVpZ2h0IGNhbiByZWRpc3RyaWJ1dGUgYWZ0ZXJcblx0XHR9XG5cblx0XHQvLyBkaXN0cmlidXRlIHRoZSBoZWlnaHQgdG8gdGhlIHJvd3Ncblx0XHQvLyAodG90YWxIZWlnaHQgaXMgYSBcInJlY29tbWVuZGVkXCIgdmFsdWUgaWYgaXNBdXRvKVxuXHRcdHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xuXHRcdHRoaXMuc2V0R3JpZEhlaWdodChzY3JvbGxlckhlaWdodCwgaXNBdXRvKTtcblxuXHRcdC8vIGlzIHRoZSBldmVudCBsaW1pdCBkeW5hbWljYWxseSBjYWxjdWxhdGVkP1xuXHRcdGlmIChldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ICE9PSAnbnVtYmVyJykge1xuXHRcdFx0dGhpcy5kYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTsgLy8gbGltaXQgdGhlIGxldmVscyBhZnRlciB0aGUgZ3JpZCdzIHJvdyBoZWlnaHRzIGhhdmUgYmVlbiBzZXRcblx0XHR9XG5cblx0XHRpZiAoIWlzQXV0bykgeyAvLyBzaG91bGQgd2UgZm9yY2UgZGltZW5zaW9ucyBvZiB0aGUgc2Nyb2xsIGNvbnRhaW5lcj9cblxuXHRcdFx0dGhpcy5zY3JvbGxlci5zZXRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQpO1xuXHRcdFx0c2Nyb2xsYmFyV2lkdGhzID0gdGhpcy5zY3JvbGxlci5nZXRTY3JvbGxiYXJXaWR0aHMoKTtcblxuXHRcdFx0aWYgKHNjcm9sbGJhcldpZHRocy5sZWZ0IHx8IHNjcm9sbGJhcldpZHRocy5yaWdodCkgeyAvLyB1c2luZyBzY3JvbGxiYXJzP1xuXG5cdFx0XHRcdGNvbXBlbnNhdGVTY3JvbGwodGhpcy5oZWFkUm93RWwsIHNjcm9sbGJhcldpZHRocyk7XG5cblx0XHRcdFx0Ly8gZG9pbmcgdGhlIHNjcm9sbGJhciBjb21wZW5zYXRpb24gbWlnaHQgaGF2ZSBjcmVhdGVkIHRleHQgb3ZlcmZsb3cgd2hpY2ggY3JlYXRlZCBtb3JlIGhlaWdodC4gcmVkb1xuXHRcdFx0XHRzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcblx0XHRcdFx0dGhpcy5zY3JvbGxlci5zZXRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBndWFyYW50ZWVzIHRoZSBzYW1lIHNjcm9sbGJhciB3aWR0aHNcblx0XHRcdHRoaXMuc2Nyb2xsZXIubG9ja092ZXJmbG93KHNjcm9sbGJhcldpZHRocyk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gZ2l2ZW4gYSBkZXNpcmVkIHRvdGFsIGhlaWdodCBvZiB0aGUgdmlldywgcmV0dXJucyB3aGF0IHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbGVyIHNob3VsZCBiZVxuXHRjb21wdXRlU2Nyb2xsZXJIZWlnaHQ6IGZ1bmN0aW9uKHRvdGFsSGVpZ2h0KSB7XG5cdFx0cmV0dXJuIHRvdGFsSGVpZ2h0IC1cblx0XHRcdHN1YnRyYWN0SW5uZXJFbEhlaWdodCh0aGlzLmVsLCB0aGlzLnNjcm9sbGVyLmVsKTsgLy8gZXZlcnl0aGluZyB0aGF0J3MgTk9UIHRoZSBzY3JvbGxlclxuXHR9LFxuXG5cblx0Ly8gU2V0cyB0aGUgaGVpZ2h0IG9mIGp1c3QgdGhlIERheUdyaWQgY29tcG9uZW50IGluIHRoaXMgdmlld1xuXHRzZXRHcmlkSGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQsIGlzQXV0bykge1xuXHRcdGlmIChpc0F1dG8pIHtcblx0XHRcdHVuZGlzdHJpYnV0ZUhlaWdodCh0aGlzLmRheUdyaWQucm93RWxzKTsgLy8gbGV0IHRoZSByb3dzIGJlIHRoZWlyIG5hdHVyYWwgaGVpZ2h0IHdpdGggbm8gZXhwYW5kaW5nXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZGlzdHJpYnV0ZUhlaWdodCh0aGlzLmRheUdyaWQucm93RWxzLCBoZWlnaHQsIHRydWUpOyAvLyB0cnVlID0gY29tcGVuc2F0ZSBmb3IgaGVpZ2h0LWhvZ2dpbmcgcm93c1xuXHRcdH1cblx0fSxcblxuXG5cdC8qIFNjcm9sbFxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Y29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4geyB0b3A6IDAgfTtcblx0fSxcblxuXG5cdHF1ZXJ5RGF0ZVNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHsgdG9wOiB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbFRvcCgpIH07XG5cdH0sXG5cblxuXHRhcHBseURhdGVTY3JvbGw6IGZ1bmN0aW9uKHNjcm9sbCkge1xuXHRcdGlmIChzY3JvbGwudG9wICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2Nyb2xsZXIuc2V0U2Nyb2xsVG9wKHNjcm9sbC50b3ApO1xuXHRcdH1cblx0fSxcblxuXG5cdC8qIEhpdCBBcmVhc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQvLyBmb3J3YXJkIGFsbCBoaXQtcmVsYXRlZCBtZXRob2QgY2FsbHMgdG8gZGF5R3JpZFxuXG5cblx0aGl0c05lZWRlZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kYXlHcmlkLmhpdHNOZWVkZWQoKTtcblx0fSxcblxuXG5cdGhpdHNOb3ROZWVkZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5R3JpZC5oaXRzTm90TmVlZGVkKCk7XG5cdH0sXG5cblxuXHRwcmVwYXJlSGl0czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnByZXBhcmVIaXRzKCk7XG5cdH0sXG5cblxuXHRyZWxlYXNlSGl0czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnJlbGVhc2VIaXRzKCk7XG5cdH0sXG5cblxuXHRxdWVyeUhpdDogZnVuY3Rpb24obGVmdCwgdG9wKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF5R3JpZC5xdWVyeUhpdChsZWZ0LCB0b3ApO1xuXHR9LFxuXG5cblx0Z2V0SGl0U3BhbjogZnVuY3Rpb24oaGl0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF5R3JpZC5nZXRIaXRTcGFuKGhpdCk7XG5cdH0sXG5cblxuXHRnZXRIaXRFbDogZnVuY3Rpb24oaGl0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF5R3JpZC5nZXRIaXRFbChoaXQpO1xuXHR9LFxuXG5cblx0LyogRXZlbnRzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBnaXZlbiBldmVudHMgb250byB0aGUgdmlldyBhbmQgcG9wdWxhdGVzIHRoZSBzZWdtZW50cyBhcnJheVxuXHRyZW5kZXJFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdHRoaXMuZGF5R3JpZC5yZW5kZXJFdmVudHMoZXZlbnRzKTtcblxuXHRcdHRoaXMudXBkYXRlSGVpZ2h0KCk7IC8vIG11c3QgY29tcGVuc2F0ZSBmb3IgZXZlbnRzIHRoYXQgb3ZlcmZsb3cgdGhlIHJvd1xuXHR9LFxuXG5cblx0Ly8gUmV0cmlldmVzIGFsbCBzZWdtZW50IG9iamVjdHMgdGhhdCBhcmUgcmVuZGVyZWQgaW4gdGhlIHZpZXdcblx0Z2V0RXZlbnRTZWdzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXlHcmlkLmdldEV2ZW50U2VncygpO1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFsbCBldmVudCBlbGVtZW50cyBhbmQgY2xlYXJzIGludGVybmFsIHNlZ21lbnQgZGF0YVxuXHR1bnJlbmRlckV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnVucmVuZGVyRXZlbnRzKCk7XG5cblx0XHQvLyB3ZSBET04nVCBuZWVkIHRvIGNhbGwgdXBkYXRlSGVpZ2h0KCkgYmVjYXVzZVxuXHRcdC8vIGEgcmVuZGVyRXZlbnRzKCkgY2FsbCBhbHdheXMgaGFwcGVucyBhZnRlciB0aGlzLCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgY2FsbCB1cGRhdGVIZWlnaHQoKVxuXHR9LFxuXG5cblx0LyogRHJhZ2dpbmcgKGZvciBib3RoIGV2ZW50cyBhbmQgZXh0ZXJuYWwgZWxlbWVudHMpXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBBIHJldHVybmVkIHZhbHVlIG9mIGB0cnVlYCBzaWduYWxzIHRoYXQgYSBtb2NrIFwiaGVscGVyXCIgZXZlbnQgaGFzIGJlZW4gcmVuZGVyZWQuXG5cdHJlbmRlckRyYWc6IGZ1bmN0aW9uKGRyb3BMb2NhdGlvbiwgc2VnKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF5R3JpZC5yZW5kZXJEcmFnKGRyb3BMb2NhdGlvbiwgc2VnKTtcblx0fSxcblxuXG5cdHVucmVuZGVyRHJhZzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnVucmVuZGVyRHJhZygpO1xuXHR9LFxuXG5cblx0LyogU2VsZWN0aW9uXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYSBzZWxlY3Rpb25cblx0cmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnJlbmRlclNlbGVjdGlvbihzcGFuKTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9ucyBvZiBhIHNlbGVjdGlvblxuXHR1bnJlbmRlclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnVucmVuZGVyU2VsZWN0aW9uKCk7XG5cdH1cblxufSk7XG5cblxuLy8gTWV0aG9kcyB0aGF0IHdpbGwgY3VzdG9taXplIHRoZSByZW5kZXJpbmcgYmVoYXZpb3Igb2YgdGhlIEJhc2ljVmlldydzIGRheUdyaWRcbnZhciBiYXNpY0RheUdyaWRNZXRob2RzID0ge1xuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgdGhlIGRheS1vZiB3ZWVrIGhlYWRlciBjZWxsc1xuXHRyZW5kZXJIZWFkSW50cm9IdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdGlmICh2aWV3LmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xuXHRcdFx0cmV0dXJuICcnICtcblx0XHRcdFx0Jzx0aCBjbGFzcz1cImZjLXdlZWstbnVtYmVyICcgKyB2aWV3LndpZGdldEhlYWRlckNsYXNzICsgJ1wiICcgKyB2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+JyArXG5cdFx0XHRcdFx0JzxzcGFuPicgKyAvLyBuZWVkZWQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xuXHRcdFx0XHRcdFx0aHRtbEVzY2FwZSh2aWV3Lm9wdCgnd2Vla051bWJlclRpdGxlJykpICtcblx0XHRcdFx0XHQnPC9zcGFuPicgK1xuXHRcdFx0XHQnPC90aD4nO1xuXHRcdH1cblxuXHRcdHJldHVybiAnJztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IHdpbGwgZ28gYmVmb3JlIGNvbnRlbnQtc2tlbGV0b24gY2VsbHMgdGhhdCBkaXNwbGF5IHRoZSBkYXkvd2VlayBudW1iZXJzXG5cdHJlbmRlck51bWJlckludHJvSHRtbDogZnVuY3Rpb24ocm93KSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIHdlZWtTdGFydCA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCAwKTtcblxuXHRcdGlmICh2aWV3LmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xuXHRcdFx0cmV0dXJuICcnICtcblx0XHRcdFx0Jzx0ZCBjbGFzcz1cImZjLXdlZWstbnVtYmVyXCIgJyArIHZpZXcud2Vla051bWJlclN0eWxlQXR0cigpICsgJz4nICtcblx0XHRcdFx0XHR2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoIC8vIGFzaWRlIGZyb20gbGluaywgaW1wb3J0YW50IGZvciBtYXRjaENlbGxXaWR0aHNcblx0XHRcdFx0XHRcdHsgZGF0ZTogd2Vla1N0YXJ0LCB0eXBlOiAnd2VlaycsIGZvcmNlT2ZmOiB0aGlzLmNvbENudCA9PT0gMSB9LFxuXHRcdFx0XHRcdFx0d2Vla1N0YXJ0LmZvcm1hdCgndycpIC8vIGlubmVyIEhUTUxcblx0XHRcdFx0XHQpICtcblx0XHRcdFx0JzwvdGQ+Jztcblx0XHR9XG5cblx0XHRyZXR1cm4gJyc7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSB0aGUgZGF5IGJnIGNlbGxzIGZvciBlYWNoIGRheS1yb3dcblx0cmVuZGVyQmdJbnRyb0h0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0aWYgKHZpZXcuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XG5cdFx0XHRyZXR1cm4gJzx0ZCBjbGFzcz1cImZjLXdlZWstbnVtYmVyICcgKyB2aWV3LndpZGdldENvbnRlbnRDbGFzcyArICdcIiAnICtcblx0XHRcdFx0dmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPjwvdGQ+Jztcblx0XHR9XG5cblx0XHRyZXR1cm4gJyc7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSBldmVyeSBvdGhlciB0eXBlIG9mIHJvdyBnZW5lcmF0ZWQgYnkgRGF5R3JpZC5cblx0Ly8gQWZmZWN0cyBoZWxwZXItc2tlbGV0b24gYW5kIGhpZ2hsaWdodC1za2VsZXRvbiByb3dzLlxuXHRyZW5kZXJJbnRyb0h0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0aWYgKHZpZXcuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XG5cdFx0XHRyZXR1cm4gJzx0ZCBjbGFzcz1cImZjLXdlZWstbnVtYmVyXCIgJyArIHZpZXcud2Vla051bWJlclN0eWxlQXR0cigpICsgJz48L3RkPic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cbn07XG5cbjs7XG5cbi8qIEEgbW9udGggdmlldyB3aXRoIGRheSBjZWxscyBydW5uaW5nIGluIHJvd3MgKG9uZS1wZXItd2VlaykgYW5kIGNvbHVtbnNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG52YXIgTW9udGhWaWV3ID0gRkMuTW9udGhWaWV3ID0gQmFzaWNWaWV3LmV4dGVuZCh7XG5cblxuXHQvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuXG5cdGJ1aWxkUmVuZGVyUmFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZW5kZXJSYW5nZSA9IEJhc2ljVmlldy5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHZhciByb3dDbnQ7XG5cblx0XHQvLyBlbnN1cmUgNiB3ZWVrc1xuXHRcdGlmICh0aGlzLmlzRml4ZWRXZWVrcygpKSB7XG5cdFx0XHRyb3dDbnQgPSBNYXRoLmNlaWwoIC8vIGNvdWxkIGJlIHBhcnRpYWwgd2Vla3MgZHVlIHRvIGhpZGRlbkRheXNcblx0XHRcdFx0cmVuZGVyUmFuZ2UuZW5kLmRpZmYocmVuZGVyUmFuZ2Uuc3RhcnQsICd3ZWVrcycsIHRydWUpIC8vIGRvbnRSb3VuZD10cnVlXG5cdFx0XHQpO1xuXHRcdFx0cmVuZGVyUmFuZ2UuZW5kLmFkZCg2IC0gcm93Q250LCAnd2Vla3MnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVuZGVyUmFuZ2U7XG5cdH0sXG5cblxuXHQvLyBPdmVycmlkZXMgdGhlIGRlZmF1bHQgQmFzaWNWaWV3IGJlaGF2aW9yIHRvIGhhdmUgc3BlY2lhbCBtdWx0aS13ZWVrIGF1dG8taGVpZ2h0IGxvZ2ljXG5cdHNldEdyaWRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCwgaXNBdXRvKSB7XG5cblx0XHQvLyBpZiBhdXRvLCBtYWtlIHRoZSBoZWlnaHQgb2YgZWFjaCByb3cgdGhlIGhlaWdodCB0aGF0IGl0IHdvdWxkIGJlIGlmIHRoZXJlIHdlcmUgNiB3ZWVrc1xuXHRcdGlmIChpc0F1dG8pIHtcblx0XHRcdGhlaWdodCAqPSB0aGlzLnJvd0NudCAvIDY7XG5cdFx0fVxuXG5cdFx0ZGlzdHJpYnV0ZUhlaWdodCh0aGlzLmRheUdyaWQucm93RWxzLCBoZWlnaHQsICFpc0F1dG8pOyAvLyBpZiBhdXRvLCBkb24ndCBjb21wZW5zYXRlIGZvciBoZWlnaHQtaG9nZ2luZyByb3dzXG5cdH0sXG5cblxuXHRpc0ZpeGVkV2Vla3M6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdCgnZml4ZWRXZWVrQ291bnQnKTtcblx0fVxuXG59KTtcblxuOztcblxuZmNWaWV3cy5iYXNpYyA9IHtcblx0J2NsYXNzJzogQmFzaWNWaWV3XG59O1xuXG5mY1ZpZXdzLmJhc2ljRGF5ID0ge1xuXHR0eXBlOiAnYmFzaWMnLFxuXHRkdXJhdGlvbjogeyBkYXlzOiAxIH1cbn07XG5cbmZjVmlld3MuYmFzaWNXZWVrID0ge1xuXHR0eXBlOiAnYmFzaWMnLFxuXHRkdXJhdGlvbjogeyB3ZWVrczogMSB9XG59O1xuXG5mY1ZpZXdzLm1vbnRoID0ge1xuXHQnY2xhc3MnOiBNb250aFZpZXcsXG5cdGR1cmF0aW9uOiB7IG1vbnRoczogMSB9LCAvLyBpbXBvcnRhbnQgZm9yIHByZXYvbmV4dFxuXHRkZWZhdWx0czoge1xuXHRcdGZpeGVkV2Vla0NvdW50OiB0cnVlXG5cdH1cbn07XG47O1xuXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgYWxsIGFnZW5kYS1yZWxhdGVkIHZpZXdzLiBEaXNwbGF5cyBvbmUgbW9yZSBjb2x1bW5zIHdpdGggdGltZSBzbG90cyBydW5uaW5nIHZlcnRpY2FsbHkuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIElzIGEgbWFuYWdlciBmb3IgdGhlIFRpbWVHcmlkIHN1YmNvbXBvbmVudCBhbmQgcG9zc2libHkgdGhlIERheUdyaWQgc3ViY29tcG9uZW50IChpZiBhbGxEYXlTbG90IGlzIG9uKS5cbi8vIFJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXG5cbnZhciBBZ2VuZGFWaWV3ID0gRkMuQWdlbmRhVmlldyA9IFZpZXcuZXh0ZW5kKHtcblxuXHRzY3JvbGxlcjogbnVsbCxcblxuXHR0aW1lR3JpZENsYXNzOiBUaW1lR3JpZCwgLy8gY2xhc3MgdXNlZCB0byBpbnN0YW50aWF0ZSB0aGUgdGltZUdyaWQuIHN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlXG5cdHRpbWVHcmlkOiBudWxsLCAvLyB0aGUgbWFpbiB0aW1lLWdyaWQgc3ViY29tcG9uZW50IG9mIHRoaXMgdmlld1xuXG5cdGRheUdyaWRDbGFzczogRGF5R3JpZCwgLy8gY2xhc3MgdXNlZCB0byBpbnN0YW50aWF0ZSB0aGUgZGF5R3JpZC4gc3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGVcblx0ZGF5R3JpZDogbnVsbCwgLy8gdGhlIFwiYWxsLWRheVwiIHN1YmNvbXBvbmVudC4gaWYgYWxsLWRheSBpcyB0dXJuZWQgb2ZmLCB0aGlzIHdpbGwgYmUgbnVsbFxuXG5cdGF4aXNXaWR0aDogbnVsbCwgLy8gdGhlIHdpZHRoIG9mIHRoZSB0aW1lIGF4aXMgcnVubmluZyBkb3duIHRoZSBzaWRlXG5cblx0aGVhZENvbnRhaW5lckVsOiBudWxsLCAvLyBkaXYgdGhhdCBob2xkJ3MgdGhlIHRpbWVHcmlkJ3MgcmVuZGVyZWQgZGF0ZSBoZWFkZXJcblx0bm9TY3JvbGxSb3dFbHM6IG51bGwsIC8vIHNldCBvZiBmYWtlIHJvdyBlbGVtZW50cyB0aGF0IG11c3QgY29tcGVuc2F0ZSB3aGVuIHNjcm9sbGVyIGhhcyBzY3JvbGxiYXJzXG5cblx0Ly8gd2hlbiB0aGUgdGltZS1ncmlkIGlzbid0IHRhbGwgZW5vdWdoIHRvIG9jY3VweSB0aGUgZ2l2ZW4gaGVpZ2h0LCB3ZSByZW5kZXIgYW4gPGhyPiB1bmRlcm5lYXRoXG5cdGJvdHRvbVJ1bGVFbDogbnVsbCxcblxuXHQvLyBpbmRpY2F0ZXMgdGhhdCBtaW5UaW1lL21heFRpbWUgYWZmZWN0cyByZW5kZXJpbmdcblx0dXNlc01pbk1heFRpbWU6IHRydWUsXG5cblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpbWVHcmlkID0gdGhpcy5pbnN0YW50aWF0ZVRpbWVHcmlkKCk7XG5cblx0XHRpZiAodGhpcy5vcHQoJ2FsbERheVNsb3QnKSkgeyAvLyBzaG91bGQgd2UgZGlzcGxheSB0aGUgXCJhbGwtZGF5XCIgYXJlYT9cblx0XHRcdHRoaXMuZGF5R3JpZCA9IHRoaXMuaW5zdGFudGlhdGVEYXlHcmlkKCk7IC8vIHRoZSBhbGwtZGF5IHN1YmNvbXBvbmVudCBvZiB0aGlzIHZpZXdcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbGVyID0gbmV3IFNjcm9sbGVyKHtcblx0XHRcdG92ZXJmbG93WDogJ2hpZGRlbicsXG5cdFx0XHRvdmVyZmxvd1k6ICdhdXRvJ1xuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gSW5zdGFudGlhdGVzIHRoZSBUaW1lR3JpZCBvYmplY3QgdGhpcyB2aWV3IG5lZWRzLiBEcmF3cyBmcm9tIHRoaXMudGltZUdyaWRDbGFzc1xuXHRpbnN0YW50aWF0ZVRpbWVHcmlkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3ViY2xhc3MgPSB0aGlzLnRpbWVHcmlkQ2xhc3MuZXh0ZW5kKGFnZW5kYVRpbWVHcmlkTWV0aG9kcyk7XG5cblx0XHRyZXR1cm4gbmV3IHN1YmNsYXNzKHRoaXMpO1xuXHR9LFxuXG5cblx0Ly8gSW5zdGFudGlhdGVzIHRoZSBEYXlHcmlkIG9iamVjdCB0aGlzIHZpZXcgbWlnaHQgbmVlZC4gRHJhd3MgZnJvbSB0aGlzLmRheUdyaWRDbGFzc1xuXHRpbnN0YW50aWF0ZURheUdyaWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdWJjbGFzcyA9IHRoaXMuZGF5R3JpZENsYXNzLmV4dGVuZChhZ2VuZGFEYXlHcmlkTWV0aG9kcyk7XG5cblx0XHRyZXR1cm4gbmV3IHN1YmNsYXNzKHRoaXMpO1xuXHR9LFxuXG5cblx0LyogUmVuZGVyaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIHRoZSB2aWV3IGludG8gYHRoaXMuZWxgLCB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGFzc2lnbmVkXG5cdHJlbmRlckRhdGVzOiBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMudGltZUdyaWQuc2V0UmFuZ2UodGhpcy5yZW5kZXJSYW5nZSk7XG5cblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQuc2V0UmFuZ2UodGhpcy5yZW5kZXJSYW5nZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbC5hZGRDbGFzcygnZmMtYWdlbmRhLXZpZXcnKS5odG1sKHRoaXMucmVuZGVyU2tlbGV0b25IdG1sKCkpO1xuXHRcdHRoaXMucmVuZGVySGVhZCgpO1xuXG5cdFx0dGhpcy5zY3JvbGxlci5yZW5kZXIoKTtcblx0XHR2YXIgdGltZUdyaWRXcmFwRWwgPSB0aGlzLnNjcm9sbGVyLmVsLmFkZENsYXNzKCdmYy10aW1lLWdyaWQtY29udGFpbmVyJyk7XG5cdFx0dmFyIHRpbWVHcmlkRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtdGltZS1ncmlkXCIgLz4nKS5hcHBlbmRUbyh0aW1lR3JpZFdyYXBFbCk7XG5cdFx0dGhpcy5lbC5maW5kKCcuZmMtYm9keSA+IHRyID4gdGQnKS5hcHBlbmQodGltZUdyaWRXcmFwRWwpO1xuXG5cdFx0dGhpcy50aW1lR3JpZC5zZXRFbGVtZW50KHRpbWVHcmlkRWwpO1xuXHRcdHRoaXMudGltZUdyaWQucmVuZGVyRGF0ZXMoKTtcblxuXHRcdC8vIHRoZSA8aHI+IHRoYXQgc29tZXRpbWVzIGRpc3BsYXlzIHVuZGVyIHRoZSB0aW1lLWdyaWRcblx0XHR0aGlzLmJvdHRvbVJ1bGVFbCA9ICQoJzxociBjbGFzcz1cImZjLWRpdmlkZXIgJyArIHRoaXMud2lkZ2V0SGVhZGVyQ2xhc3MgKyAnXCIvPicpXG5cdFx0XHQuYXBwZW5kVG8odGhpcy50aW1lR3JpZC5lbCk7IC8vIGluamVjdCBpdCBpbnRvIHRoZSB0aW1lLWdyaWRcblxuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5zZXRFbGVtZW50KHRoaXMuZWwuZmluZCgnLmZjLWRheS1ncmlkJykpO1xuXHRcdFx0dGhpcy5kYXlHcmlkLnJlbmRlckRhdGVzKCk7XG5cblx0XHRcdC8vIGhhdmUgdGhlIGRheS1ncmlkIGV4dGVuZCBpdCdzIGNvb3JkaW5hdGUgYXJlYSBvdmVyIHRoZSA8aHI+IGRpdmlkaW5nIHRoZSB0d28gZ3JpZHNcblx0XHRcdHRoaXMuZGF5R3JpZC5ib3R0b21Db29yZFBhZGRpbmcgPSB0aGlzLmRheUdyaWQuZWwubmV4dCgnaHInKS5vdXRlckhlaWdodCgpO1xuXHRcdH1cblxuXHRcdHRoaXMubm9TY3JvbGxSb3dFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1yb3c6bm90KC5mYy1zY3JvbGxlciAqKScpOyAvLyBmYWtlIHJvd3Mgbm90IHdpdGhpbiB0aGUgc2Nyb2xsZXJcblx0fSxcblxuXG5cdC8vIHJlbmRlciB0aGUgZGF5LW9mLXdlZWsgaGVhZGVyc1xuXHRyZW5kZXJIZWFkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhlYWRDb250YWluZXJFbCA9XG5cdFx0XHR0aGlzLmVsLmZpbmQoJy5mYy1oZWFkLWNvbnRhaW5lcicpXG5cdFx0XHRcdC5odG1sKHRoaXMudGltZUdyaWQucmVuZGVySGVhZEh0bWwoKSk7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZpZXcuIFNpbmNlIHdlIGhhdmVuJ3Qgc2VwYXJhdGVkIHNrZWxldG9uIHJlbmRlcmluZyBmcm9tIGRhdGUgcmVuZGVyaW5nLFxuXHQvLyBhbHdheXMgY29tcGxldGVseSBraWxsIGVhY2ggZ3JpZCdzIHJlbmRlcmluZy5cblx0dW5yZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC51bnJlbmRlckRhdGVzKCk7XG5cdFx0dGhpcy50aW1lR3JpZC5yZW1vdmVFbGVtZW50KCk7XG5cblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJEYXRlcygpO1xuXHRcdFx0dGhpcy5kYXlHcmlkLnJlbW92ZUVsZW1lbnQoKTtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTtcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyB0aGUgSFRNTCBza2VsZXRvbiBmb3IgdGhlIHZpZXcuXG5cdC8vIFRoZSBkYXktZ3JpZCBhbmQgdGltZS1ncmlkIGNvbXBvbmVudHMgd2lsbCByZW5kZXIgaW5zaWRlIGNvbnRhaW5lcnMgZGVmaW5lZCBieSB0aGlzIEhUTUwuXG5cdHJlbmRlclNrZWxldG9uSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICcnICtcblx0XHRcdCc8dGFibGU+JyArXG5cdFx0XHRcdCc8dGhlYWQgY2xhc3M9XCJmYy1oZWFkXCI+JyArXG5cdFx0XHRcdFx0Jzx0cj4nICtcblx0XHRcdFx0XHRcdCc8dGQgY2xhc3M9XCJmYy1oZWFkLWNvbnRhaW5lciAnICsgdGhpcy53aWRnZXRIZWFkZXJDbGFzcyArICdcIj48L3RkPicgK1xuXHRcdFx0XHRcdCc8L3RyPicgK1xuXHRcdFx0XHQnPC90aGVhZD4nICtcblx0XHRcdFx0Jzx0Ym9keSBjbGFzcz1cImZjLWJvZHlcIj4nICtcblx0XHRcdFx0XHQnPHRyPicgK1xuXHRcdFx0XHRcdFx0Jzx0ZCBjbGFzcz1cIicgKyB0aGlzLndpZGdldENvbnRlbnRDbGFzcyArICdcIj4nICtcblx0XHRcdFx0XHRcdFx0KHRoaXMuZGF5R3JpZCA/XG5cdFx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1kYXktZ3JpZFwiLz4nICtcblx0XHRcdFx0XHRcdFx0XHQnPGhyIGNsYXNzPVwiZmMtZGl2aWRlciAnICsgdGhpcy53aWRnZXRIZWFkZXJDbGFzcyArICdcIi8+JyA6XG5cdFx0XHRcdFx0XHRcdFx0Jydcblx0XHRcdFx0XHRcdFx0XHQpICtcblx0XHRcdFx0XHRcdCc8L3RkPicgK1xuXHRcdFx0XHRcdCc8L3RyPicgK1xuXHRcdFx0XHQnPC90Ym9keT4nICtcblx0XHRcdCc8L3RhYmxlPic7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgYW4gSFRNTCBhdHRyaWJ1dGUgc3RyaW5nIGZvciBzZXR0aW5nIHRoZSB3aWR0aCBvZiB0aGUgYXhpcywgaWYgaXQgaXMga25vd25cblx0YXhpc1N0eWxlQXR0cjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuYXhpc1dpZHRoICE9PSBudWxsKSB7XG5cdFx0XHQgcmV0dXJuICdzdHlsZT1cIndpZHRoOicgKyB0aGlzLmF4aXNXaWR0aCArICdweFwiJztcblx0XHR9XG5cdFx0cmV0dXJuICcnO1xuXHR9LFxuXG5cblx0LyogQnVzaW5lc3MgSG91cnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGltZUdyaWQucmVuZGVyQnVzaW5lc3NIb3VycygpO1xuXG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnJlbmRlckJ1c2luZXNzSG91cnMoKTtcblx0XHR9XG5cdH0sXG5cblxuXHR1bnJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGltZUdyaWQudW5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0LyogTm93IEluZGljYXRvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Z2V0Tm93SW5kaWNhdG9yVW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudGltZUdyaWQuZ2V0Tm93SW5kaWNhdG9yVW5pdCgpO1xuXHR9LFxuXG5cblx0cmVuZGVyTm93SW5kaWNhdG9yOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dGhpcy50aW1lR3JpZC5yZW5kZXJOb3dJbmRpY2F0b3IoZGF0ZSk7XG5cdH0sXG5cblxuXHR1bnJlbmRlck5vd0luZGljYXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC51bnJlbmRlck5vd0luZGljYXRvcigpO1xuXHR9LFxuXG5cblx0LyogRGltZW5zaW9uc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0dXBkYXRlU2l6ZTogZnVuY3Rpb24oaXNSZXNpemUpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnVwZGF0ZVNpemUoaXNSZXNpemUpO1xuXG5cdFx0Vmlldy5wcm90b3R5cGUudXBkYXRlU2l6ZS5jYWxsKHRoaXMsIGlzUmVzaXplKTsgLy8gY2FsbCB0aGUgc3VwZXItbWV0aG9kXG5cdH0sXG5cblxuXHQvLyBSZWZyZXNoZXMgdGhlIGhvcml6b250YWwgZGltZW5zaW9ucyBvZiB0aGUgdmlld1xuXHR1cGRhdGVXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gbWFrZSBhbGwgYXhpcyBjZWxscyBsaW5lIHVwLCBhbmQgcmVjb3JkIHRoZSB3aWR0aCBzbyBuZXdseSBjcmVhdGVkIGF4aXMgY2VsbHMgd2lsbCBoYXZlIGl0XG5cdFx0dGhpcy5heGlzV2lkdGggPSBtYXRjaENlbGxXaWR0aHModGhpcy5lbC5maW5kKCcuZmMtYXhpcycpKTtcblx0fSxcblxuXG5cdC8vIEFkanVzdHMgdGhlIHZlcnRpY2FsIGRpbWVuc2lvbnMgb2YgdGhlIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZXNcblx0c2V0SGVpZ2h0OiBmdW5jdGlvbih0b3RhbEhlaWdodCwgaXNBdXRvKSB7XG5cdFx0dmFyIGV2ZW50TGltaXQ7XG5cdFx0dmFyIHNjcm9sbGVySGVpZ2h0O1xuXHRcdHZhciBzY3JvbGxiYXJXaWR0aHM7XG5cblx0XHQvLyByZXNldCBhbGwgZGltZW5zaW9ucyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBzdGF0ZVxuXHRcdHRoaXMuYm90dG9tUnVsZUVsLmhpZGUoKTsgLy8gLnNob3coKSB3aWxsIGJlIGNhbGxlZCBsYXRlciBpZiB0aGlzIDxocj4gaXMgbmVjZXNzYXJ5XG5cdFx0dGhpcy5zY3JvbGxlci5jbGVhcigpOyAvLyBzZXRzIGhlaWdodCB0byAnYXV0bycgYW5kIGNsZWFycyBvdmVyZmxvd1xuXHRcdHVuY29tcGVuc2F0ZVNjcm9sbCh0aGlzLm5vU2Nyb2xsUm93RWxzKTtcblxuXHRcdC8vIGxpbWl0IG51bWJlciBvZiBldmVudHMgaW4gdGhlIGFsbC1kYXkgYXJlYVxuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5yZW1vdmVTZWdQb3BvdmVyKCk7IC8vIGtpbGwgdGhlIFwibW9yZVwiIHBvcG92ZXIgaWYgZGlzcGxheWVkXG5cblx0XHRcdGV2ZW50TGltaXQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdCcpO1xuXHRcdFx0aWYgKGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGV2ZW50TGltaXQgPSBBR0VOREFfQUxMX0RBWV9FVkVOVF9MSU1JVDsgLy8gbWFrZSBzdXJlIFwiYXV0b1wiIGdvZXMgdG8gYSByZWFsIG51bWJlclxuXHRcdFx0fVxuXHRcdFx0aWYgKGV2ZW50TGltaXQpIHtcblx0XHRcdFx0dGhpcy5kYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWlzQXV0bykgeyAvLyBzaG91bGQgd2UgZm9yY2UgZGltZW5zaW9ucyBvZiB0aGUgc2Nyb2xsIGNvbnRhaW5lcj9cblxuXHRcdFx0c2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XG5cdFx0XHR0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XG5cdFx0XHRzY3JvbGxiYXJXaWR0aHMgPSB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbGJhcldpZHRocygpO1xuXG5cdFx0XHRpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQgfHwgc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7IC8vIHVzaW5nIHNjcm9sbGJhcnM/XG5cblx0XHRcdFx0Ly8gbWFrZSB0aGUgYWxsLWRheSBhbmQgaGVhZGVyIHJvd3MgbGluZXMgdXBcblx0XHRcdFx0Y29tcGVuc2F0ZVNjcm9sbCh0aGlzLm5vU2Nyb2xsUm93RWxzLCBzY3JvbGxiYXJXaWR0aHMpO1xuXG5cdFx0XHRcdC8vIHRoZSBzY3JvbGxiYXIgY29tcGVuc2F0aW9uIG1pZ2h0IGhhdmUgY2hhbmdlZCB0ZXh0IGZsb3csIHdoaWNoIG1pZ2h0IGFmZmVjdCBoZWlnaHQsIHNvIHJlY2FsY3VsYXRlXG5cdFx0XHRcdC8vIGFuZCByZWFwcGx5IHRoZSBkZXNpcmVkIGhlaWdodCB0byB0aGUgc2Nyb2xsZXIuXG5cdFx0XHRcdHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xuXHRcdFx0XHR0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGd1YXJhbnRlZXMgdGhlIHNhbWUgc2Nyb2xsYmFyIHdpZHRoc1xuXHRcdFx0dGhpcy5zY3JvbGxlci5sb2NrT3ZlcmZsb3coc2Nyb2xsYmFyV2lkdGhzKTtcblxuXHRcdFx0Ly8gaWYgdGhlcmUncyBhbnkgc3BhY2UgYmVsb3cgdGhlIHNsYXRzLCBzaG93IHRoZSBob3Jpem9udGFsIHJ1bGUuXG5cdFx0XHQvLyB0aGlzIHdvbid0IGNhdXNlIGFueSBuZXcgb3ZlcmZsb3csIGJlY2F1c2UgbG9ja092ZXJmbG93IGFscmVhZHkgY2FsbGVkLlxuXHRcdFx0aWYgKHRoaXMudGltZUdyaWQuZ2V0VG90YWxTbGF0SGVpZ2h0KCkgPCBzY3JvbGxlckhlaWdodCkge1xuXHRcdFx0XHR0aGlzLmJvdHRvbVJ1bGVFbC5zaG93KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gZ2l2ZW4gYSBkZXNpcmVkIHRvdGFsIGhlaWdodCBvZiB0aGUgdmlldywgcmV0dXJucyB3aGF0IHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbGVyIHNob3VsZCBiZVxuXHRjb21wdXRlU2Nyb2xsZXJIZWlnaHQ6IGZ1bmN0aW9uKHRvdGFsSGVpZ2h0KSB7XG5cdFx0cmV0dXJuIHRvdGFsSGVpZ2h0IC1cblx0XHRcdHN1YnRyYWN0SW5uZXJFbEhlaWdodCh0aGlzLmVsLCB0aGlzLnNjcm9sbGVyLmVsKTsgLy8gZXZlcnl0aGluZyB0aGF0J3MgTk9UIHRoZSBzY3JvbGxlclxuXHR9LFxuXG5cblx0LyogU2Nyb2xsXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBDb21wdXRlcyB0aGUgaW5pdGlhbCBwcmUtY29uZmlndXJlZCBzY3JvbGwgc3RhdGUgcHJpb3IgdG8gYWxsb3dpbmcgdGhlIHVzZXIgdG8gY2hhbmdlIGl0XG5cdGNvbXB1dGVJbml0aWFsRGF0ZVNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjcm9sbFRpbWUgPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ3Njcm9sbFRpbWUnKSk7XG5cdFx0dmFyIHRvcCA9IHRoaXMudGltZUdyaWQuY29tcHV0ZVRpbWVUb3Aoc2Nyb2xsVGltZSk7XG5cblx0XHQvLyB6b29tIGNhbiBnaXZlIHdlaXJkIGZsb2F0aW5nLXBvaW50IHZhbHVlcy4gcmF0aGVyIHNjcm9sbCBhIGxpdHRsZSBiaXQgZnVydGhlclxuXHRcdHRvcCA9IE1hdGguY2VpbCh0b3ApO1xuXG5cdFx0aWYgKHRvcCkge1xuXHRcdFx0dG9wKys7IC8vIHRvIG92ZXJjb21lIHRvcCBib3JkZXIgdGhhdCBzbG90cyBiZXlvbmQgdGhlIGZpcnN0IGhhdmUuIGxvb2tzIGJldHRlclxuXHRcdH1cblxuXHRcdHJldHVybiB7IHRvcDogdG9wIH07XG5cdH0sXG5cblxuXHRxdWVyeURhdGVTY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7IHRvcDogdGhpcy5zY3JvbGxlci5nZXRTY3JvbGxUb3AoKSB9O1xuXHR9LFxuXG5cblx0YXBwbHlEYXRlU2Nyb2xsOiBmdW5jdGlvbihzY3JvbGwpIHtcblx0XHRpZiAoc2Nyb2xsLnRvcCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGVyLnNldFNjcm9sbFRvcChzY3JvbGwudG9wKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBIaXQgQXJlYXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0Ly8gZm9yd2FyZCBhbGwgaGl0LXJlbGF0ZWQgbWV0aG9kIGNhbGxzIHRvIHRoZSBncmlkcyAoZGF5R3JpZCBtaWdodCBub3QgYmUgZGVmaW5lZClcblxuXG5cdGhpdHNOZWVkZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGltZUdyaWQuaGl0c05lZWRlZCgpO1xuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5oaXRzTmVlZGVkKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0aGl0c05vdE5lZWRlZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC5oaXRzTm90TmVlZGVkKCk7XG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLmhpdHNOb3ROZWVkZWQoKTtcblx0XHR9XG5cdH0sXG5cblxuXHRwcmVwYXJlSGl0czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC5wcmVwYXJlSGl0cygpO1xuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5wcmVwYXJlSGl0cygpO1xuXHRcdH1cblx0fSxcblxuXG5cdHJlbGVhc2VIaXRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnJlbGVhc2VIaXRzKCk7XG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnJlbGVhc2VIaXRzKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0cXVlcnlIaXQ6IGZ1bmN0aW9uKGxlZnQsIHRvcCkge1xuXHRcdHZhciBoaXQgPSB0aGlzLnRpbWVHcmlkLnF1ZXJ5SGl0KGxlZnQsIHRvcCk7XG5cblx0XHRpZiAoIWhpdCAmJiB0aGlzLmRheUdyaWQpIHtcblx0XHRcdGhpdCA9IHRoaXMuZGF5R3JpZC5xdWVyeUhpdChsZWZ0LCB0b3ApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoaXQ7XG5cdH0sXG5cblxuXHRnZXRIaXRTcGFuOiBmdW5jdGlvbihoaXQpIHtcblx0XHQvLyBUT0RPOiBoaXQuY29tcG9uZW50IGlzIHNldCBhcyBhIGhhY2sgdG8gaWRlbnRpZnkgd2hlcmUgdGhlIGhpdCBjYW1lIGZyb21cblx0XHRyZXR1cm4gaGl0LmNvbXBvbmVudC5nZXRIaXRTcGFuKGhpdCk7XG5cdH0sXG5cblxuXHRnZXRIaXRFbDogZnVuY3Rpb24oaGl0KSB7XG5cdFx0Ly8gVE9ETzogaGl0LmNvbXBvbmVudCBpcyBzZXQgYXMgYSBoYWNrIHRvIGlkZW50aWZ5IHdoZXJlIHRoZSBoaXQgY2FtZSBmcm9tXG5cdFx0cmV0dXJuIGhpdC5jb21wb25lbnQuZ2V0SGl0RWwoaGl0KTtcblx0fSxcblxuXG5cdC8qIEV2ZW50c1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBldmVudHMgb250byB0aGUgdmlldyBhbmQgcG9wdWxhdGVzIHRoZSBWaWV3J3Mgc2VnbWVudCBhcnJheVxuXHRyZW5kZXJFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdHZhciBkYXlFdmVudHMgPSBbXTtcblx0XHR2YXIgdGltZWRFdmVudHMgPSBbXTtcblx0XHR2YXIgZGF5U2VncyA9IFtdO1xuXHRcdHZhciB0aW1lZFNlZ3M7XG5cdFx0dmFyIGk7XG5cblx0XHQvLyBzZXBhcmF0ZSB0aGUgZXZlbnRzIGludG8gYWxsLWRheSBhbmQgdGltZWRcblx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoZXZlbnRzW2ldLmFsbERheSkge1xuXHRcdFx0XHRkYXlFdmVudHMucHVzaChldmVudHNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRpbWVkRXZlbnRzLnB1c2goZXZlbnRzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyByZW5kZXIgdGhlIGV2ZW50cyBpbiB0aGUgc3ViY29tcG9uZW50c1xuXHRcdHRpbWVkU2VncyA9IHRoaXMudGltZUdyaWQucmVuZGVyRXZlbnRzKHRpbWVkRXZlbnRzKTtcblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHRkYXlTZWdzID0gdGhpcy5kYXlHcmlkLnJlbmRlckV2ZW50cyhkYXlFdmVudHMpO1xuXHRcdH1cblxuXHRcdC8vIHRoZSBhbGwtZGF5IGFyZWEgaXMgZmxleGlibGUgYW5kIG1pZ2h0IGhhdmUgYSBsb3Qgb2YgZXZlbnRzLCBzbyBzaGlmdCB0aGUgaGVpZ2h0XG5cdFx0dGhpcy51cGRhdGVIZWlnaHQoKTtcblx0fSxcblxuXG5cdC8vIFJldHJpZXZlcyBhbGwgc2VnbWVudCBvYmplY3RzIHRoYXQgYXJlIHJlbmRlcmVkIGluIHRoZSB2aWV3XG5cdGdldEV2ZW50U2VnczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudGltZUdyaWQuZ2V0RXZlbnRTZWdzKCkuY29uY2F0KFxuXHRcdFx0dGhpcy5kYXlHcmlkID8gdGhpcy5kYXlHcmlkLmdldEV2ZW50U2VncygpIDogW11cblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFsbCBldmVudCBlbGVtZW50cyBhbmQgY2xlYXJzIGludGVybmFsIHNlZ21lbnQgZGF0YVxuXHR1bnJlbmRlckV2ZW50czogZnVuY3Rpb24oKSB7XG5cblx0XHQvLyB1bnJlbmRlciB0aGUgZXZlbnRzIGluIHRoZSBzdWJjb21wb25lbnRzXG5cdFx0dGhpcy50aW1lR3JpZC51bnJlbmRlckV2ZW50cygpO1xuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC51bnJlbmRlckV2ZW50cygpO1xuXHRcdH1cblxuXHRcdC8vIHdlIERPTidUIG5lZWQgdG8gY2FsbCB1cGRhdGVIZWlnaHQoKSBiZWNhdXNlXG5cdFx0Ly8gYSByZW5kZXJFdmVudHMoKSBjYWxsIGFsd2F5cyBoYXBwZW5zIGFmdGVyIHRoaXMsIHdoaWNoIHdpbGwgZXZlbnR1YWxseSBjYWxsIHVwZGF0ZUhlaWdodCgpXG5cdH0sXG5cblxuXHQvKiBEcmFnZ2luZyAoZm9yIGV2ZW50cyBhbmQgZXh0ZXJuYWwgZWxlbWVudHMpXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBBIHJldHVybmVkIHZhbHVlIG9mIGB0cnVlYCBzaWduYWxzIHRoYXQgYSBtb2NrIFwiaGVscGVyXCIgZXZlbnQgaGFzIGJlZW4gcmVuZGVyZWQuXG5cdHJlbmRlckRyYWc6IGZ1bmN0aW9uKGRyb3BMb2NhdGlvbiwgc2VnKSB7XG5cdFx0aWYgKGRyb3BMb2NhdGlvbi5zdGFydC5oYXNUaW1lKCkpIHtcblx0XHRcdHJldHVybiB0aGlzLnRpbWVHcmlkLnJlbmRlckRyYWcoZHJvcExvY2F0aW9uLCBzZWcpO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHJldHVybiB0aGlzLmRheUdyaWQucmVuZGVyRHJhZyhkcm9wTG9jYXRpb24sIHNlZyk7XG5cdFx0fVxuXHR9LFxuXG5cblx0dW5yZW5kZXJEcmFnOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnVucmVuZGVyRHJhZygpO1xuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC51bnJlbmRlckRyYWcoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBTZWxlY3Rpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvblxuXHRyZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHRpZiAoc3Bhbi5zdGFydC5oYXNUaW1lKCkgfHwgc3Bhbi5lbmQuaGFzVGltZSgpKSB7XG5cdFx0XHR0aGlzLnRpbWVHcmlkLnJlbmRlclNlbGVjdGlvbihzcGFuKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQucmVuZGVyU2VsZWN0aW9uKHNwYW4pO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9ucyBvZiBhIHNlbGVjdGlvblxuXHR1bnJlbmRlclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC51bnJlbmRlclNlbGVjdGlvbigpO1xuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC51bnJlbmRlclNlbGVjdGlvbigpO1xuXHRcdH1cblx0fVxuXG59KTtcblxuXG4vLyBNZXRob2RzIHRoYXQgd2lsbCBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBiZWhhdmlvciBvZiB0aGUgQWdlbmRhVmlldydzIHRpbWVHcmlkXG4vLyBUT0RPOiBtb3ZlIGludG8gVGltZUdyaWRcbnZhciBhZ2VuZGFUaW1lR3JpZE1ldGhvZHMgPSB7XG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCB3aWxsIGdvIGJlZm9yZSB0aGUgZGF5LW9mIHdlZWsgaGVhZGVyIGNlbGxzXG5cdHJlbmRlckhlYWRJbnRyb0h0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciB3ZWVrVGV4dDtcblxuXHRcdGlmICh2aWV3Lm9wdCgnd2Vla051bWJlcnMnKSkge1xuXHRcdFx0d2Vla1RleHQgPSB0aGlzLnN0YXJ0LmZvcm1hdCh2aWV3Lm9wdCgnc21hbGxXZWVrRm9ybWF0JykpO1xuXG5cdFx0XHRyZXR1cm4gJycgK1xuXHRcdFx0XHQnPHRoIGNsYXNzPVwiZmMtYXhpcyBmYy13ZWVrLW51bWJlciAnICsgdmlldy53aWRnZXRIZWFkZXJDbGFzcyArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPicgK1xuXHRcdFx0XHRcdHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbCggLy8gYXNpZGUgZnJvbSBsaW5rLCBpbXBvcnRhbnQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xuXHRcdFx0XHRcdFx0eyBkYXRlOiB0aGlzLnN0YXJ0LCB0eXBlOiAnd2VlaycsIGZvcmNlT2ZmOiB0aGlzLmNvbENudCA+IDEgfSxcblx0XHRcdFx0XHRcdGh0bWxFc2NhcGUod2Vla1RleHQpIC8vIGlubmVyIEhUTUxcblx0XHRcdFx0XHQpICtcblx0XHRcdFx0JzwvdGg+Jztcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gJzx0aCBjbGFzcz1cImZjLWF4aXMgJyArIHZpZXcud2lkZ2V0SGVhZGVyQ2xhc3MgKyAnXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz48L3RoPic7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgdGhlIGJnIG9mIHRoZSBUaW1lR3JpZCBzbG90IGFyZWEuIExvbmcgdmVydGljYWwgY29sdW1uLlxuXHRyZW5kZXJCZ0ludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRyZXR1cm4gJzx0ZCBjbGFzcz1cImZjLWF4aXMgJyArIHZpZXcud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgYWxsIG90aGVyIHR5cGVzIG9mIGNlbGxzLlxuXHQvLyBBZmZlY3RzIGNvbnRlbnQtc2tlbGV0b24sIGhlbHBlci1za2VsZXRvbiwgaGlnaGxpZ2h0LXNrZWxldG9uIGZvciBib3RoIHRoZSB0aW1lLWdyaWQgYW5kIGRheS1ncmlkLlxuXHRyZW5kZXJJbnRyb0h0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0cmV0dXJuICc8dGQgY2xhc3M9XCJmYy1heGlzXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz48L3RkPic7XG5cdH1cblxufTtcblxuXG4vLyBNZXRob2RzIHRoYXQgd2lsbCBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBiZWhhdmlvciBvZiB0aGUgQWdlbmRhVmlldydzIGRheUdyaWRcbnZhciBhZ2VuZGFEYXlHcmlkTWV0aG9kcyA9IHtcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIHRoZSBhbGwtZGF5IGNlbGxzXG5cdHJlbmRlckJnSW50cm9IdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdHJldHVybiAnJyArXG5cdFx0XHQnPHRkIGNsYXNzPVwiZmMtYXhpcyAnICsgdmlldy53aWRnZXRDb250ZW50Q2xhc3MgKyAnXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz4nICtcblx0XHRcdFx0JzxzcGFuPicgKyAvLyBuZWVkZWQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xuXHRcdFx0XHRcdHZpZXcuZ2V0QWxsRGF5SHRtbCgpICtcblx0XHRcdFx0Jzwvc3Bhbj4nICtcblx0XHRcdCc8L3RkPic7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSBhbGwgb3RoZXIgdHlwZXMgb2YgY2VsbHMuXG5cdC8vIEFmZmVjdHMgY29udGVudC1za2VsZXRvbiwgaGVscGVyLXNrZWxldG9uLCBoaWdobGlnaHQtc2tlbGV0b24gZm9yIGJvdGggdGhlIHRpbWUtZ3JpZCBhbmQgZGF5LWdyaWQuXG5cdHJlbmRlckludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRyZXR1cm4gJzx0ZCBjbGFzcz1cImZjLWF4aXNcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGQ+Jztcblx0fVxuXG59O1xuXG47O1xuXG52YXIgQUdFTkRBX0FMTF9EQVlfRVZFTlRfTElNSVQgPSA1O1xuXG4vLyBwb3RlbnRpYWwgbmljZSB2YWx1ZXMgZm9yIHRoZSBzbG90LWR1cmF0aW9uIGFuZCBpbnRlcnZhbC1kdXJhdGlvblxuLy8gZnJvbSBsYXJnZXN0IHRvIHNtYWxsZXN0XG52YXIgQUdFTkRBX1NUT0NLX1NVQl9EVVJBVElPTlMgPSBbXG5cdHsgaG91cnM6IDEgfSxcblx0eyBtaW51dGVzOiAzMCB9LFxuXHR7IG1pbnV0ZXM6IDE1IH0sXG5cdHsgc2Vjb25kczogMzAgfSxcblx0eyBzZWNvbmRzOiAxNSB9XG5dO1xuXG5mY1ZpZXdzLmFnZW5kYSA9IHtcblx0J2NsYXNzJzogQWdlbmRhVmlldyxcblx0ZGVmYXVsdHM6IHtcblx0XHRhbGxEYXlTbG90OiB0cnVlLFxuXHRcdHNsb3REdXJhdGlvbjogJzAwOjMwOjAwJyxcblx0XHRzbG90RXZlbnRPdmVybGFwOiB0cnVlIC8vIGEgYmFkIG5hbWUuIGNvbmZ1c2VkIHdpdGggb3ZlcmxhcC9jb25zdHJhaW50IHN5c3RlbVxuXHR9XG59O1xuXG5mY1ZpZXdzLmFnZW5kYURheSA9IHtcblx0dHlwZTogJ2FnZW5kYScsXG5cdGR1cmF0aW9uOiB7IGRheXM6IDEgfVxufTtcblxuZmNWaWV3cy5hZ2VuZGFXZWVrID0ge1xuXHR0eXBlOiAnYWdlbmRhJyxcblx0ZHVyYXRpb246IHsgd2Vla3M6IDEgfVxufTtcbjs7XG5cbi8qXG5SZXNwb25zaWJsZSBmb3IgdGhlIHNjcm9sbGVyLCBhbmQgZm9yd2FyZGluZyBldmVudC1yZWxhdGVkIGFjdGlvbnMgaW50byB0aGUgXCJncmlkXCJcbiovXG52YXIgTGlzdFZpZXcgPSBWaWV3LmV4dGVuZCh7XG5cblx0Z3JpZDogbnVsbCxcblx0c2Nyb2xsZXI6IG51bGwsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5ncmlkID0gbmV3IExpc3RWaWV3R3JpZCh0aGlzKTtcblx0XHR0aGlzLnNjcm9sbGVyID0gbmV3IFNjcm9sbGVyKHtcblx0XHRcdG92ZXJmbG93WDogJ2hpZGRlbicsXG5cdFx0XHRvdmVyZmxvd1k6ICdhdXRvJ1xuXHRcdH0pO1xuXHR9LFxuXG5cdHJlbmRlclNrZWxldG9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsLmFkZENsYXNzKFxuXHRcdFx0J2ZjLWxpc3QtdmlldyAnICtcblx0XHRcdHRoaXMud2lkZ2V0Q29udGVudENsYXNzXG5cdFx0KTtcblxuXHRcdHRoaXMuc2Nyb2xsZXIucmVuZGVyKCk7XG5cdFx0dGhpcy5zY3JvbGxlci5lbC5hcHBlbmRUbyh0aGlzLmVsKTtcblxuXHRcdHRoaXMuZ3JpZC5zZXRFbGVtZW50KHRoaXMuc2Nyb2xsZXIuc2Nyb2xsRWwpO1xuXHR9LFxuXG5cdHVucmVuZGVyU2tlbGV0b246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpOyAvLyB3aWxsIHJlbW92ZSB0aGUgR3JpZCB0b29cblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKHRvdGFsSGVpZ2h0LCBpc0F1dG8pIHtcblx0XHR0aGlzLnNjcm9sbGVyLnNldEhlaWdodCh0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCkpO1xuXHR9LFxuXG5cdGNvbXB1dGVTY3JvbGxlckhlaWdodDogZnVuY3Rpb24odG90YWxIZWlnaHQpIHtcblx0XHRyZXR1cm4gdG90YWxIZWlnaHQgLVxuXHRcdFx0c3VidHJhY3RJbm5lckVsSGVpZ2h0KHRoaXMuZWwsIHRoaXMuc2Nyb2xsZXIuZWwpOyAvLyBldmVyeXRoaW5nIHRoYXQncyBOT1QgdGhlIHNjcm9sbGVyXG5cdH0sXG5cblx0cmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZ3JpZC5zZXRSYW5nZSh0aGlzLnJlbmRlclJhbmdlKTsgLy8gbmVlZHMgdG8gcHJvY2VzcyByYW5nZS1yZWxhdGVkIG9wdGlvbnNcblx0fSxcblxuXHRyZW5kZXJFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdHRoaXMuZ3JpZC5yZW5kZXJFdmVudHMoZXZlbnRzKTtcblx0fSxcblxuXHR1bnJlbmRlckV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5ncmlkLnVucmVuZGVyRXZlbnRzKCk7XG5cdH0sXG5cblx0aXNFdmVudFJlc2l6YWJsZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aXNFdmVudERyYWdnYWJsZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxufSk7XG5cbi8qXG5SZXNwb25zaWJsZSBmb3IgZXZlbnQgcmVuZGVyaW5nIGFuZCB1c2VyLWludGVyYWN0aW9uLlxuSXRzIFwiZWxcIiBpcyB0aGUgaW5uZXItY29udGVudCBvZiB0aGUgYWJvdmUgdmlldydzIHNjcm9sbGVyLlxuKi9cbnZhciBMaXN0Vmlld0dyaWQgPSBHcmlkLmV4dGVuZCh7XG5cblx0c2VnU2VsZWN0b3I6ICcuZmMtbGlzdC1pdGVtJywgLy8gd2hpY2ggZWxlbWVudHMgYWNjZXB0IGV2ZW50IGFjdGlvbnNcblx0aGFzRGF5SW50ZXJhY3Rpb25zOiBmYWxzZSwgLy8gbm8gZGF5IHNlbGVjdGlvbiBvciBkYXkgY2xpY2tpbmdcblxuXHQvLyBzbGljZXMgYnkgZGF5XG5cdHNwYW5Ub1NlZ3M6IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgZGF5U3RhcnQgPSB2aWV3LnJlbmRlclJhbmdlLnN0YXJ0LmNsb25lKCkudGltZSgwKTsgLy8gdGltZWQsIHNvIHNlZ3MgZ2V0IHRpbWVzIVxuXHRcdHZhciBkYXlJbmRleCA9IDA7XG5cdFx0dmFyIHNlZztcblx0XHR2YXIgc2VncyA9IFtdO1xuXG5cdFx0d2hpbGUgKGRheVN0YXJ0IDwgdmlldy5yZW5kZXJSYW5nZS5lbmQpIHtcblxuXHRcdFx0c2VnID0gaW50ZXJzZWN0UmFuZ2VzKHNwYW4sIHtcblx0XHRcdFx0c3RhcnQ6IGRheVN0YXJ0LFxuXHRcdFx0XHRlbmQ6IGRheVN0YXJ0LmNsb25lKCkuYWRkKDEsICdkYXknKVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChzZWcpIHtcblx0XHRcdFx0c2VnLmRheUluZGV4ID0gZGF5SW5kZXg7XG5cdFx0XHRcdHNlZ3MucHVzaChzZWcpO1xuXHRcdFx0fVxuXG5cdFx0XHRkYXlTdGFydC5hZGQoMSwgJ2RheScpO1xuXHRcdFx0ZGF5SW5kZXgrKztcblxuXHRcdFx0Ly8gZGV0ZWN0IHdoZW4gc3BhbiB3b24ndCBnbyBmdWxseSBpbnRvIHRoZSBuZXh0IGRheSxcblx0XHRcdC8vIGFuZCBtdXRhdGUgdGhlIGxhdGVzdCBzZWcgdG8gdGhlIGJlIHRoZSBlbmQuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHNlZyAmJiAhc2VnLmlzRW5kICYmIHNwYW4uZW5kLmhhc1RpbWUoKSAmJlxuXHRcdFx0XHRzcGFuLmVuZCA8IGRheVN0YXJ0LmNsb25lKCkuYWRkKHRoaXMudmlldy5uZXh0RGF5VGhyZXNob2xkKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHNlZy5lbmQgPSBzcGFuLmVuZC5jbG9uZSgpO1xuXHRcdFx0XHRzZWcuaXNFbmQgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXHQvLyBsaWtlIFwiNDowMGFtXCJcblx0Y29tcHV0ZUV2ZW50VGltZUZvcm1hdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudmlldy5vcHQoJ21lZGl1bVRpbWVGb3JtYXQnKTtcblx0fSxcblxuXHQvLyBmb3IgZXZlbnRzIHdpdGggYSB1cmwsIHRoZSB3aG9sZSA8dHI+IHNob3VsZCBiZSBjbGlja2FibGUsXG5cdC8vIGJ1dCBpdCdzIGltcG9zc2libGUgdG8gd3JhcCB3aXRoIGFuIDxhPiB0YWcuIHNpbXVsYXRlIHRoaXMuXG5cdGhhbmRsZVNlZ0NsaWNrOiBmdW5jdGlvbihzZWcsIGV2KSB7XG5cdFx0dmFyIHVybDtcblxuXHRcdEdyaWQucHJvdG90eXBlLmhhbmRsZVNlZ0NsaWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIHN1cGVyLiBtaWdodCBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvblxuXG5cdFx0Ly8gbm90IGNsaWNraW5nIG9uIG9yIHdpdGhpbiBhbiA8YT4gd2l0aCBhbiBocmVmXG5cdFx0aWYgKCEkKGV2LnRhcmdldCkuY2xvc2VzdCgnYVtocmVmXScpLmxlbmd0aCkge1xuXHRcdFx0dXJsID0gc2VnLmV2ZW50LnVybDtcblx0XHRcdGlmICh1cmwgJiYgIWV2LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7IC8vIGpzRXZlbnQgbm90IGNhbmNlbGxlZCBpbiBoYW5kbGVyXG5cdFx0XHRcdHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsOyAvLyBzaW11bGF0ZSBsaW5rIGNsaWNrXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHJldHVybnMgbGlzdCBvZiBmb3JlZ3JvdW5kIHNlZ3MgdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkXG5cdHJlbmRlckZnU2VnczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHNlZ3MgPSB0aGlzLnJlbmRlckZnU2VnRWxzKHNlZ3MpOyAvLyBtaWdodCBmaWx0ZXIgYXdheSBoaWRkZW4gZXZlbnRzXG5cblx0XHRpZiAoIXNlZ3MubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLnJlbmRlckVtcHR5TWVzc2FnZSgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMucmVuZGVyU2VnTGlzdChzZWdzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXHRyZW5kZXJFbXB0eU1lc3NhZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWwuaHRtbChcblx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtbGlzdC1lbXB0eS13cmFwMlwiPicgKyAvLyBUT0RPOiB0cnkgbGVzcyB3cmFwc1xuXHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1saXN0LWVtcHR5LXdyYXAxXCI+JyArXG5cdFx0XHQnPGRpdiBjbGFzcz1cImZjLWxpc3QtZW1wdHlcIj4nICtcblx0XHRcdFx0aHRtbEVzY2FwZSh0aGlzLnZpZXcub3B0KCdub0V2ZW50c01lc3NhZ2UnKSkgK1xuXHRcdFx0JzwvZGl2PicgK1xuXHRcdFx0JzwvZGl2PicgK1xuXHRcdFx0JzwvZGl2Pidcblx0XHQpO1xuXHR9LFxuXG5cdC8vIHJlbmRlciB0aGUgZXZlbnQgc2VnbWVudHMgaW4gdGhlIHZpZXdcblx0cmVuZGVyU2VnTGlzdDogZnVuY3Rpb24oYWxsU2Vncykge1xuXHRcdHZhciBzZWdzQnlEYXkgPSB0aGlzLmdyb3VwU2Vnc0J5RGF5KGFsbFNlZ3MpOyAvLyBzcGFyc2UgYXJyYXlcblx0XHR2YXIgZGF5SW5kZXg7XG5cdFx0dmFyIGRheVNlZ3M7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIHRhYmxlRWwgPSAkKCc8dGFibGUgY2xhc3M9XCJmYy1saXN0LXRhYmxlXCI+PHRib2R5Lz48L3RhYmxlPicpO1xuXHRcdHZhciB0Ym9keUVsID0gdGFibGVFbC5maW5kKCd0Ym9keScpO1xuXG5cdFx0Zm9yIChkYXlJbmRleCA9IDA7IGRheUluZGV4IDwgc2Vnc0J5RGF5Lmxlbmd0aDsgZGF5SW5kZXgrKykge1xuXHRcdFx0ZGF5U2VncyA9IHNlZ3NCeURheVtkYXlJbmRleF07XG5cdFx0XHRpZiAoZGF5U2VncykgeyAvLyBzcGFyc2UgYXJyYXksIHNvIG1pZ2h0IGJlIHVuZGVmaW5lZFxuXG5cdFx0XHRcdC8vIGFwcGVuZCBhIGRheSBoZWFkZXJcblx0XHRcdFx0dGJvZHlFbC5hcHBlbmQodGhpcy5kYXlIZWFkZXJIdG1sKFxuXHRcdFx0XHRcdHRoaXMudmlldy5yZW5kZXJSYW5nZS5zdGFydC5jbG9uZSgpLmFkZChkYXlJbmRleCwgJ2RheXMnKVxuXHRcdFx0XHQpKTtcblxuXHRcdFx0XHR0aGlzLnNvcnRFdmVudFNlZ3MoZGF5U2Vncyk7XG5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRheVNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR0Ym9keUVsLmFwcGVuZChkYXlTZWdzW2ldLmVsKTsgLy8gYXBwZW5kIGV2ZW50IHJvd1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbC5lbXB0eSgpLmFwcGVuZCh0YWJsZUVsKTtcblx0fSxcblxuXHQvLyBSZXR1cm5zIGEgc3BhcnNlIGFycmF5IG9mIGFycmF5cywgc2VncyBncm91cGVkIGJ5IHRoZWlyIGRheUluZGV4XG5cdGdyb3VwU2Vnc0J5RGF5OiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dmFyIHNlZ3NCeURheSA9IFtdOyAvLyBzcGFyc2UgYXJyYXlcblx0XHR2YXIgaSwgc2VnO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZyA9IHNlZ3NbaV07XG5cdFx0XHQoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gfHwgKHNlZ3NCeURheVtzZWcuZGF5SW5kZXhdID0gW10pKVxuXHRcdFx0XHQucHVzaChzZWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzQnlEYXk7XG5cdH0sXG5cblx0Ly8gZ2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgZGF5IGhlYWRlcnMgdGhhdCBsaXZlIGFtb25nc3QgdGhlIGV2ZW50IHJvd3Ncblx0ZGF5SGVhZGVySHRtbDogZnVuY3Rpb24oZGF5RGF0ZSkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBtYWluRm9ybWF0ID0gdmlldy5vcHQoJ2xpc3REYXlGb3JtYXQnKTtcblx0XHR2YXIgYWx0Rm9ybWF0ID0gdmlldy5vcHQoJ2xpc3REYXlBbHRGb3JtYXQnKTtcblxuXHRcdHJldHVybiAnPHRyIGNsYXNzPVwiZmMtbGlzdC1oZWFkaW5nXCIgZGF0YS1kYXRlPVwiJyArIGRheURhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykgKyAnXCI+JyArXG5cdFx0XHQnPHRkIGNsYXNzPVwiJyArIHZpZXcud2lkZ2V0SGVhZGVyQ2xhc3MgKyAnXCIgY29sc3Bhbj1cIjNcIj4nICtcblx0XHRcdFx0KG1haW5Gb3JtYXQgP1xuXHRcdFx0XHRcdHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbChcblx0XHRcdFx0XHRcdGRheURhdGUsXG5cdFx0XHRcdFx0XHR7ICdjbGFzcyc6ICdmYy1saXN0LWhlYWRpbmctbWFpbicgfSxcblx0XHRcdFx0XHRcdGh0bWxFc2NhcGUoZGF5RGF0ZS5mb3JtYXQobWFpbkZvcm1hdCkpIC8vIGlubmVyIEhUTUxcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQnJykgK1xuXHRcdFx0XHQoYWx0Rm9ybWF0ID9cblx0XHRcdFx0XHR2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoXG5cdFx0XHRcdFx0XHRkYXlEYXRlLFxuXHRcdFx0XHRcdFx0eyAnY2xhc3MnOiAnZmMtbGlzdC1oZWFkaW5nLWFsdCcgfSxcblx0XHRcdFx0XHRcdGh0bWxFc2NhcGUoZGF5RGF0ZS5mb3JtYXQoYWx0Rm9ybWF0KSkgLy8gaW5uZXIgSFRNTFxuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdCcnKSArXG5cdFx0XHQnPC90ZD4nICtcblx0XHQnPC90cj4nO1xuXHR9LFxuXG5cdC8vIGdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgYSBzaW5nbGUgZXZlbnQgcm93XG5cdGZnU2VnSHRtbDogZnVuY3Rpb24oc2VnKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGNsYXNzZXMgPSBbICdmYy1saXN0LWl0ZW0nIF0uY29uY2F0KHRoaXMuZ2V0U2VnQ3VzdG9tQ2xhc3NlcyhzZWcpKTtcblx0XHR2YXIgYmdDb2xvciA9IHRoaXMuZ2V0U2VnQmFja2dyb3VuZENvbG9yKHNlZyk7XG5cdFx0dmFyIGV2ZW50ID0gc2VnLmV2ZW50O1xuXHRcdHZhciB1cmwgPSBldmVudC51cmw7XG5cdFx0dmFyIHRpbWVIdG1sO1xuXG5cdFx0aWYgKGV2ZW50LmFsbERheSkge1xuXHRcdFx0dGltZUh0bWwgPSB2aWV3LmdldEFsbERheUh0bWwoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodmlldy5pc011bHRpRGF5RXZlbnQoZXZlbnQpKSB7IC8vIGlmIHRoZSBldmVudCBhcHBlYXJzIHRvIHNwYW4gbW9yZSB0aGFuIG9uZSBkYXlcblx0XHRcdGlmIChzZWcuaXNTdGFydCB8fCBzZWcuaXNFbmQpIHsgLy8gb3V0ZXIgc2VnbWVudCB0aGF0IHByb2JhYmx5IGxhc3RzIHBhcnQgb2YgdGhlIGRheVxuXHRcdFx0XHR0aW1lSHRtbCA9IGh0bWxFc2NhcGUodGhpcy5nZXRFdmVudFRpbWVUZXh0KHNlZykpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IC8vIGlubmVyIHNlZ21lbnQgdGhhdCBsYXN0cyB0aGUgd2hvbGUgZGF5XG5cdFx0XHRcdHRpbWVIdG1sID0gdmlldy5nZXRBbGxEYXlIdG1sKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gRGlzcGxheSB0aGUgbm9ybWFsIHRpbWUgdGV4dCBmb3IgdGhlICpldmVudCdzKiB0aW1lc1xuXHRcdFx0dGltZUh0bWwgPSBodG1sRXNjYXBlKHRoaXMuZ2V0RXZlbnRUaW1lVGV4dChldmVudCkpO1xuXHRcdH1cblxuXHRcdGlmICh1cmwpIHtcblx0XHRcdGNsYXNzZXMucHVzaCgnZmMtaGFzLXVybCcpO1xuXHRcdH1cblxuXHRcdHJldHVybiAnPHRyIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiPicgK1xuXHRcdFx0KHRoaXMuZGlzcGxheUV2ZW50VGltZSA/XG5cdFx0XHRcdCc8dGQgY2xhc3M9XCJmYy1saXN0LWl0ZW0tdGltZSAnICsgdmlldy53aWRnZXRDb250ZW50Q2xhc3MgKyAnXCI+JyArXG5cdFx0XHRcdFx0KHRpbWVIdG1sIHx8ICcnKSArXG5cdFx0XHRcdCc8L3RkPicgOlxuXHRcdFx0XHQnJykgK1xuXHRcdFx0Jzx0ZCBjbGFzcz1cImZjLWxpc3QtaXRlbS1tYXJrZXIgJyArIHZpZXcud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJmYy1ldmVudC1kb3RcIicgK1xuXHRcdFx0XHQoYmdDb2xvciA/XG5cdFx0XHRcdFx0JyBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGJnQ29sb3IgKyAnXCInIDpcblx0XHRcdFx0XHQnJykgK1xuXHRcdFx0XHQnPjwvc3Bhbj4nICtcblx0XHRcdCc8L3RkPicgK1xuXHRcdFx0Jzx0ZCBjbGFzcz1cImZjLWxpc3QtaXRlbS10aXRsZSAnICsgdmlldy53aWRnZXRDb250ZW50Q2xhc3MgKyAnXCI+JyArXG5cdFx0XHRcdCc8YScgKyAodXJsID8gJyBocmVmPVwiJyArIGh0bWxFc2NhcGUodXJsKSArICdcIicgOiAnJykgKyAnPicgK1xuXHRcdFx0XHRcdGh0bWxFc2NhcGUoc2VnLmV2ZW50LnRpdGxlIHx8ICcnKSArXG5cdFx0XHRcdCc8L2E+JyArXG5cdFx0XHQnPC90ZD4nICtcblx0XHQnPC90cj4nO1xuXHR9XG5cbn0pO1xuXG47O1xuXG5mY1ZpZXdzLmxpc3QgPSB7XG5cdCdjbGFzcyc6IExpc3RWaWV3LFxuXHRidXR0b25UZXh0S2V5OiAnbGlzdCcsIC8vIHdoYXQgdG8gbG9va3VwIGluIGxvY2FsZSBmaWxlc1xuXHRkZWZhdWx0czoge1xuXHRcdGJ1dHRvblRleHQ6ICdsaXN0JywgLy8gdGV4dCB0byBkaXNwbGF5IGZvciBFbmdsaXNoXG5cdFx0bGlzdERheUZvcm1hdDogJ0xMJywgLy8gbGlrZSBcIkphbnVhcnkgMSwgMjAxNlwiXG5cdFx0bm9FdmVudHNNZXNzYWdlOiAnTm8gZXZlbnRzIHRvIGRpc3BsYXknXG5cdH1cbn07XG5cbmZjVmlld3MubGlzdERheSA9IHtcblx0dHlwZTogJ2xpc3QnLFxuXHRkdXJhdGlvbjogeyBkYXlzOiAxIH0sXG5cdGRlZmF1bHRzOiB7XG5cdFx0bGlzdERheUZvcm1hdDogJ2RkZGQnIC8vIGRheS1vZi13ZWVrIGlzIGFsbCB3ZSBuZWVkLiBmdWxsIGRhdGUgaXMgcHJvYmFibHkgaW4gaGVhZGVyXG5cdH1cbn07XG5cbmZjVmlld3MubGlzdFdlZWsgPSB7XG5cdHR5cGU6ICdsaXN0Jyxcblx0ZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcblx0ZGVmYXVsdHM6IHtcblx0XHRsaXN0RGF5Rm9ybWF0OiAnZGRkZCcsIC8vIGRheS1vZi13ZWVrIGlzIG1vcmUgaW1wb3J0YW50XG5cdFx0bGlzdERheUFsdEZvcm1hdDogJ0xMJ1xuXHR9XG59O1xuXG5mY1ZpZXdzLmxpc3RNb250aCA9IHtcblx0dHlwZTogJ2xpc3QnLFxuXHRkdXJhdGlvbjogeyBtb250aDogMSB9LFxuXHRkZWZhdWx0czoge1xuXHRcdGxpc3REYXlBbHRGb3JtYXQ6ICdkZGRkJyAvLyBkYXktb2Ytd2VlayBpcyBuaWNlLXRvLWhhdmVcblx0fVxufTtcblxuZmNWaWV3cy5saXN0WWVhciA9IHtcblx0dHlwZTogJ2xpc3QnLFxuXHRkdXJhdGlvbjogeyB5ZWFyOiAxIH0sXG5cdGRlZmF1bHRzOiB7XG5cdFx0bGlzdERheUFsdEZvcm1hdDogJ2RkZGQnIC8vIGRheS1vZi13ZWVrIGlzIG5pY2UtdG8taGF2ZVxuXHR9XG59O1xuXG47O1xuXHJcbnJldHVybiBGQzsgLy8gZXhwb3J0IGZvciBOb2RlL0NvbW1vbkpTXHJcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mdWxsY2FsZW5kYXIvZGlzdC9mdWxsY2FsZW5kYXIuanNcbi8vIG1vZHVsZSBpZCA9IDU4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDE4MyJdLCJzb3VyY2VSb290IjoiIn0=